/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(4);
	module.exports = __webpack_require__(6);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(3))

/***/ },
/* 2 */
/***/ function(module, exports) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	module.exports = function(src) {
		if (typeof execScript === "function")
			execScript(src);
		else
			eval.call(null, src);
	}

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/*! jQuery v2.2.4 | (c) jQuery Foundation | jquery.org/license */\n!function (a, b) {\n  \"object\" == (typeof module === \"undefined\" ? \"undefined\" : _typeof(module)) && \"object\" == _typeof(module.exports) ? module.exports = a.document ? b(a, !0) : function (a) {\n    if (!a.document) throw new Error(\"jQuery requires a window with a document\");return b(a);\n  } : b(a);\n}(\"undefined\" != typeof window ? window : undefined, function (a, b) {\n  var c = [],\n      d = a.document,\n      e = c.slice,\n      f = c.concat,\n      g = c.push,\n      h = c.indexOf,\n      i = {},\n      j = i.toString,\n      k = i.hasOwnProperty,\n      l = {},\n      m = \"2.2.4\",\n      n = function n(a, b) {\n    return new n.fn.init(a, b);\n  },\n      o = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n      p = /^-ms-/,\n      q = /-([\\da-z])/gi,\n      r = function r(a, b) {\n    return b.toUpperCase();\n  };n.fn = n.prototype = { jquery: m, constructor: n, selector: \"\", length: 0, toArray: function toArray() {\n      return e.call(this);\n    }, get: function get(a) {\n      return null != a ? 0 > a ? this[a + this.length] : this[a] : e.call(this);\n    }, pushStack: function pushStack(a) {\n      var b = n.merge(this.constructor(), a);return b.prevObject = this, b.context = this.context, b;\n    }, each: function each(a) {\n      return n.each(this, a);\n    }, map: function map(a) {\n      return this.pushStack(n.map(this, function (b, c) {\n        return a.call(b, c, b);\n      }));\n    }, slice: function slice() {\n      return this.pushStack(e.apply(this, arguments));\n    }, first: function first() {\n      return this.eq(0);\n    }, last: function last() {\n      return this.eq(-1);\n    }, eq: function eq(a) {\n      var b = this.length,\n          c = +a + (0 > a ? b : 0);return this.pushStack(c >= 0 && b > c ? [this[c]] : []);\n    }, end: function end() {\n      return this.prevObject || this.constructor();\n    }, push: g, sort: c.sort, splice: c.splice }, n.extend = n.fn.extend = function () {\n    var a,\n        b,\n        c,\n        d,\n        e,\n        f,\n        g = arguments[0] || {},\n        h = 1,\n        i = arguments.length,\n        j = !1;for (\"boolean\" == typeof g && (j = g, g = arguments[h] || {}, h++), \"object\" == (typeof g === \"undefined\" ? \"undefined\" : _typeof(g)) || n.isFunction(g) || (g = {}), h === i && (g = this, h--); i > h; h++) {\n      if (null != (a = arguments[h])) for (b in a) {\n        c = g[b], d = a[b], g !== d && (j && d && (n.isPlainObject(d) || (e = n.isArray(d))) ? (e ? (e = !1, f = c && n.isArray(c) ? c : []) : f = c && n.isPlainObject(c) ? c : {}, g[b] = n.extend(j, f, d)) : void 0 !== d && (g[b] = d));\n      }\n    }return g;\n  }, n.extend({ expando: \"jQuery\" + (m + Math.random()).replace(/\\D/g, \"\"), isReady: !0, error: function error(a) {\n      throw new Error(a);\n    }, noop: function noop() {}, isFunction: function isFunction(a) {\n      return \"function\" === n.type(a);\n    }, isArray: Array.isArray, isWindow: function isWindow(a) {\n      return null != a && a === a.window;\n    }, isNumeric: function isNumeric(a) {\n      var b = a && a.toString();return !n.isArray(a) && b - parseFloat(b) + 1 >= 0;\n    }, isPlainObject: function isPlainObject(a) {\n      var b;if (\"object\" !== n.type(a) || a.nodeType || n.isWindow(a)) return !1;if (a.constructor && !k.call(a, \"constructor\") && !k.call(a.constructor.prototype || {}, \"isPrototypeOf\")) return !1;for (b in a) {}return void 0 === b || k.call(a, b);\n    }, isEmptyObject: function isEmptyObject(a) {\n      var b;for (b in a) {\n        return !1;\n      }return !0;\n    }, type: function type(a) {\n      return null == a ? a + \"\" : \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) || \"function\" == typeof a ? i[j.call(a)] || \"object\" : typeof a === \"undefined\" ? \"undefined\" : _typeof(a);\n    }, globalEval: function globalEval(a) {\n      var b,\n          c = eval;a = n.trim(a), a && (1 === a.indexOf(\"use strict\") ? (b = d.createElement(\"script\"), b.text = a, d.head.appendChild(b).parentNode.removeChild(b)) : c(a));\n    }, camelCase: function camelCase(a) {\n      return a.replace(p, \"ms-\").replace(q, r);\n    }, nodeName: function nodeName(a, b) {\n      return a.nodeName && a.nodeName.toLowerCase() === b.toLowerCase();\n    }, each: function each(a, b) {\n      var c,\n          d = 0;if (s(a)) {\n        for (c = a.length; c > d; d++) {\n          if (b.call(a[d], d, a[d]) === !1) break;\n        }\n      } else for (d in a) {\n        if (b.call(a[d], d, a[d]) === !1) break;\n      }return a;\n    }, trim: function trim(a) {\n      return null == a ? \"\" : (a + \"\").replace(o, \"\");\n    }, makeArray: function makeArray(a, b) {\n      var c = b || [];return null != a && (s(Object(a)) ? n.merge(c, \"string\" == typeof a ? [a] : a) : g.call(c, a)), c;\n    }, inArray: function inArray(a, b, c) {\n      return null == b ? -1 : h.call(b, a, c);\n    }, merge: function merge(a, b) {\n      for (var c = +b.length, d = 0, e = a.length; c > d; d++) {\n        a[e++] = b[d];\n      }return a.length = e, a;\n    }, grep: function grep(a, b, c) {\n      for (var d, e = [], f = 0, g = a.length, h = !c; g > f; f++) {\n        d = !b(a[f], f), d !== h && e.push(a[f]);\n      }return e;\n    }, map: function map(a, b, c) {\n      var d,\n          e,\n          g = 0,\n          h = [];if (s(a)) for (d = a.length; d > g; g++) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      } else for (g in a) {\n        e = b(a[g], g, c), null != e && h.push(e);\n      }return f.apply([], h);\n    }, guid: 1, proxy: function proxy(a, b) {\n      var c, d, f;return \"string\" == typeof b && (c = a[b], b = a, a = c), n.isFunction(a) ? (d = e.call(arguments, 2), f = function f() {\n        return a.apply(b || this, d.concat(e.call(arguments)));\n      }, f.guid = a.guid = a.guid || n.guid++, f) : void 0;\n    }, now: Date.now, support: l }), \"function\" == typeof Symbol && (n.fn[Symbol.iterator] = c[Symbol.iterator]), n.each(\"Boolean Number String Function Array Date RegExp Object Error Symbol\".split(\" \"), function (a, b) {\n    i[\"[object \" + b + \"]\"] = b.toLowerCase();\n  });function s(a) {\n    var b = !!a && \"length\" in a && a.length,\n        c = n.type(a);return \"function\" === c || n.isWindow(a) ? !1 : \"array\" === c || 0 === b || \"number\" == typeof b && b > 0 && b - 1 in a;\n  }var t = function (a) {\n    var b,\n        c,\n        d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l,\n        m,\n        n,\n        o,\n        p,\n        q,\n        r,\n        s,\n        t,\n        u = \"sizzle\" + 1 * new Date(),\n        v = a.document,\n        w = 0,\n        x = 0,\n        y = ga(),\n        z = ga(),\n        A = ga(),\n        B = function B(a, b) {\n      return a === b && (l = !0), 0;\n    },\n        C = 1 << 31,\n        D = {}.hasOwnProperty,\n        E = [],\n        F = E.pop,\n        G = E.push,\n        H = E.push,\n        I = E.slice,\n        J = function J(a, b) {\n      for (var c = 0, d = a.length; d > c; c++) {\n        if (a[c] === b) return c;\n      }return -1;\n    },\n        K = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n        L = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n        M = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n        N = \"\\\\[\" + L + \"*(\" + M + \")(?:\" + L + \"*([*^$|!~]?=)\" + L + \"*(?:'((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\"|(\" + M + \"))|)\" + L + \"*\\\\]\",\n        O = \":(\" + M + \")(?:\\\\((('((?:\\\\\\\\.|[^\\\\\\\\'])*)'|\\\"((?:\\\\\\\\.|[^\\\\\\\\\\\"])*)\\\")|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + N + \")*)|.*)\\\\)|)\",\n        P = new RegExp(L + \"+\", \"g\"),\n        Q = new RegExp(\"^\" + L + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + L + \"+$\", \"g\"),\n        R = new RegExp(\"^\" + L + \"*,\" + L + \"*\"),\n        S = new RegExp(\"^\" + L + \"*([>+~]|\" + L + \")\" + L + \"*\"),\n        T = new RegExp(\"=\" + L + \"*([^\\\\]'\\\"]*?)\" + L + \"*\\\\]\", \"g\"),\n        U = new RegExp(O),\n        V = new RegExp(\"^\" + M + \"$\"),\n        W = { ID: new RegExp(\"^#(\" + M + \")\"), CLASS: new RegExp(\"^\\\\.(\" + M + \")\"), TAG: new RegExp(\"^(\" + M + \"|[*])\"), ATTR: new RegExp(\"^\" + N), PSEUDO: new RegExp(\"^\" + O), CHILD: new RegExp(\"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + L + \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + L + \"*(?:([+-]|)\" + L + \"*(\\\\d+)|))\" + L + \"*\\\\)|)\", \"i\"), bool: new RegExp(\"^(?:\" + K + \")$\", \"i\"), needsContext: new RegExp(\"^\" + L + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" + L + \"*((?:-\\\\d)?\\\\d*)\" + L + \"*\\\\)|)(?=[^-]|$)\", \"i\") },\n        X = /^(?:input|select|textarea|button)$/i,\n        Y = /^h\\d$/i,\n        Z = /^[^{]+\\{\\s*\\[native \\w/,\n        $ = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n        _ = /[+~]/,\n        aa = /'|\\\\/g,\n        ba = new RegExp(\"\\\\\\\\([\\\\da-f]{1,6}\" + L + \"?|(\" + L + \")|.)\", \"ig\"),\n        ca = function ca(a, b, c) {\n      var d = \"0x\" + b - 65536;return d !== d || c ? b : 0 > d ? String.fromCharCode(d + 65536) : String.fromCharCode(d >> 10 | 55296, 1023 & d | 56320);\n    },\n        da = function da() {\n      m();\n    };try {\n      H.apply(E = I.call(v.childNodes), v.childNodes), E[v.childNodes.length].nodeType;\n    } catch (ea) {\n      H = { apply: E.length ? function (a, b) {\n          G.apply(a, I.call(b));\n        } : function (a, b) {\n          var c = a.length,\n              d = 0;while (a[c++] = b[d++]) {}a.length = c - 1;\n        } };\n    }function fa(a, b, d, e) {\n      var f,\n          h,\n          j,\n          k,\n          l,\n          o,\n          r,\n          s,\n          w = b && b.ownerDocument,\n          x = b ? b.nodeType : 9;if (d = d || [], \"string\" != typeof a || !a || 1 !== x && 9 !== x && 11 !== x) return d;if (!e && ((b ? b.ownerDocument || b : v) !== n && m(b), b = b || n, p)) {\n        if (11 !== x && (o = $.exec(a))) if (f = o[1]) {\n          if (9 === x) {\n            if (!(j = b.getElementById(f))) return d;if (j.id === f) return d.push(j), d;\n          } else if (w && (j = w.getElementById(f)) && t(b, j) && j.id === f) return d.push(j), d;\n        } else {\n          if (o[2]) return H.apply(d, b.getElementsByTagName(a)), d;if ((f = o[3]) && c.getElementsByClassName && b.getElementsByClassName) return H.apply(d, b.getElementsByClassName(f)), d;\n        }if (c.qsa && !A[a + \" \"] && (!q || !q.test(a))) {\n          if (1 !== x) w = b, s = a;else if (\"object\" !== b.nodeName.toLowerCase()) {\n            (k = b.getAttribute(\"id\")) ? k = k.replace(aa, \"\\\\$&\") : b.setAttribute(\"id\", k = u), r = g(a), h = r.length, l = V.test(k) ? \"#\" + k : \"[id='\" + k + \"']\";while (h--) {\n              r[h] = l + \" \" + qa(r[h]);\n            }s = r.join(\",\"), w = _.test(a) && oa(b.parentNode) || b;\n          }if (s) try {\n            return H.apply(d, w.querySelectorAll(s)), d;\n          } catch (y) {} finally {\n            k === u && b.removeAttribute(\"id\");\n          }\n        }\n      }return i(a.replace(Q, \"$1\"), b, d, e);\n    }function ga() {\n      var a = [];function b(c, e) {\n        return a.push(c + \" \") > d.cacheLength && delete b[a.shift()], b[c + \" \"] = e;\n      }return b;\n    }function ha(a) {\n      return a[u] = !0, a;\n    }function ia(a) {\n      var b = n.createElement(\"div\");try {\n        return !!a(b);\n      } catch (c) {\n        return !1;\n      } finally {\n        b.parentNode && b.parentNode.removeChild(b), b = null;\n      }\n    }function ja(a, b) {\n      var c = a.split(\"|\"),\n          e = c.length;while (e--) {\n        d.attrHandle[c[e]] = b;\n      }\n    }function ka(a, b) {\n      var c = b && a,\n          d = c && 1 === a.nodeType && 1 === b.nodeType && (~b.sourceIndex || C) - (~a.sourceIndex || C);if (d) return d;if (c) while (c = c.nextSibling) {\n        if (c === b) return -1;\n      }return a ? 1 : -1;\n    }function la(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return \"input\" === c && b.type === a;\n      };\n    }function ma(a) {\n      return function (b) {\n        var c = b.nodeName.toLowerCase();return (\"input\" === c || \"button\" === c) && b.type === a;\n      };\n    }function na(a) {\n      return ha(function (b) {\n        return b = +b, ha(function (c, d) {\n          var e,\n              f = a([], c.length, b),\n              g = f.length;while (g--) {\n            c[e = f[g]] && (c[e] = !(d[e] = c[e]));\n          }\n        });\n      });\n    }function oa(a) {\n      return a && \"undefined\" != typeof a.getElementsByTagName && a;\n    }c = fa.support = {}, f = fa.isXML = function (a) {\n      var b = a && (a.ownerDocument || a).documentElement;return b ? \"HTML\" !== b.nodeName : !1;\n    }, m = fa.setDocument = function (a) {\n      var b,\n          e,\n          g = a ? a.ownerDocument || a : v;return g !== n && 9 === g.nodeType && g.documentElement ? (n = g, o = n.documentElement, p = !f(n), (e = n.defaultView) && e.top !== e && (e.addEventListener ? e.addEventListener(\"unload\", da, !1) : e.attachEvent && e.attachEvent(\"onunload\", da)), c.attributes = ia(function (a) {\n        return a.className = \"i\", !a.getAttribute(\"className\");\n      }), c.getElementsByTagName = ia(function (a) {\n        return a.appendChild(n.createComment(\"\")), !a.getElementsByTagName(\"*\").length;\n      }), c.getElementsByClassName = Z.test(n.getElementsByClassName), c.getById = ia(function (a) {\n        return o.appendChild(a).id = u, !n.getElementsByName || !n.getElementsByName(u).length;\n      }), c.getById ? (d.find.ID = function (a, b) {\n        if (\"undefined\" != typeof b.getElementById && p) {\n          var c = b.getElementById(a);return c ? [c] : [];\n        }\n      }, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          return a.getAttribute(\"id\") === b;\n        };\n      }) : (delete d.find.ID, d.filter.ID = function (a) {\n        var b = a.replace(ba, ca);return function (a) {\n          var c = \"undefined\" != typeof a.getAttributeNode && a.getAttributeNode(\"id\");return c && c.value === b;\n        };\n      }), d.find.TAG = c.getElementsByTagName ? function (a, b) {\n        return \"undefined\" != typeof b.getElementsByTagName ? b.getElementsByTagName(a) : c.qsa ? b.querySelectorAll(a) : void 0;\n      } : function (a, b) {\n        var c,\n            d = [],\n            e = 0,\n            f = b.getElementsByTagName(a);if (\"*\" === a) {\n          while (c = f[e++]) {\n            1 === c.nodeType && d.push(c);\n          }return d;\n        }return f;\n      }, d.find.CLASS = c.getElementsByClassName && function (a, b) {\n        return \"undefined\" != typeof b.getElementsByClassName && p ? b.getElementsByClassName(a) : void 0;\n      }, r = [], q = [], (c.qsa = Z.test(n.querySelectorAll)) && (ia(function (a) {\n        o.appendChild(a).innerHTML = \"<a id='\" + u + \"'></a><select id='\" + u + \"-\\r\\\\' msallowcapture=''><option selected=''></option></select>\", a.querySelectorAll(\"[msallowcapture^='']\").length && q.push(\"[*^$]=\" + L + \"*(?:''|\\\"\\\")\"), a.querySelectorAll(\"[selected]\").length || q.push(\"\\\\[\" + L + \"*(?:value|\" + K + \")\"), a.querySelectorAll(\"[id~=\" + u + \"-]\").length || q.push(\"~=\"), a.querySelectorAll(\":checked\").length || q.push(\":checked\"), a.querySelectorAll(\"a#\" + u + \"+*\").length || q.push(\".#.+[+~]\");\n      }), ia(function (a) {\n        var b = n.createElement(\"input\");b.setAttribute(\"type\", \"hidden\"), a.appendChild(b).setAttribute(\"name\", \"D\"), a.querySelectorAll(\"[name=d]\").length && q.push(\"name\" + L + \"*[*^$|!~]?=\"), a.querySelectorAll(\":enabled\").length || q.push(\":enabled\", \":disabled\"), a.querySelectorAll(\"*,:x\"), q.push(\",.*:\");\n      })), (c.matchesSelector = Z.test(s = o.matches || o.webkitMatchesSelector || o.mozMatchesSelector || o.oMatchesSelector || o.msMatchesSelector)) && ia(function (a) {\n        c.disconnectedMatch = s.call(a, \"div\"), s.call(a, \"[s!='']:x\"), r.push(\"!=\", O);\n      }), q = q.length && new RegExp(q.join(\"|\")), r = r.length && new RegExp(r.join(\"|\")), b = Z.test(o.compareDocumentPosition), t = b || Z.test(o.contains) ? function (a, b) {\n        var c = 9 === a.nodeType ? a.documentElement : a,\n            d = b && b.parentNode;return a === d || !(!d || 1 !== d.nodeType || !(c.contains ? c.contains(d) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(d)));\n      } : function (a, b) {\n        if (b) while (b = b.parentNode) {\n          if (b === a) return !0;\n        }return !1;\n      }, B = b ? function (a, b) {\n        if (a === b) return l = !0, 0;var d = !a.compareDocumentPosition - !b.compareDocumentPosition;return d ? d : (d = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & d || !c.sortDetached && b.compareDocumentPosition(a) === d ? a === n || a.ownerDocument === v && t(v, a) ? -1 : b === n || b.ownerDocument === v && t(v, b) ? 1 : k ? J(k, a) - J(k, b) : 0 : 4 & d ? -1 : 1);\n      } : function (a, b) {\n        if (a === b) return l = !0, 0;var c,\n            d = 0,\n            e = a.parentNode,\n            f = b.parentNode,\n            g = [a],\n            h = [b];if (!e || !f) return a === n ? -1 : b === n ? 1 : e ? -1 : f ? 1 : k ? J(k, a) - J(k, b) : 0;if (e === f) return ka(a, b);c = a;while (c = c.parentNode) {\n          g.unshift(c);\n        }c = b;while (c = c.parentNode) {\n          h.unshift(c);\n        }while (g[d] === h[d]) {\n          d++;\n        }return d ? ka(g[d], h[d]) : g[d] === v ? -1 : h[d] === v ? 1 : 0;\n      }, n) : n;\n    }, fa.matches = function (a, b) {\n      return fa(a, null, null, b);\n    }, fa.matchesSelector = function (a, b) {\n      if ((a.ownerDocument || a) !== n && m(a), b = b.replace(T, \"='$1']\"), c.matchesSelector && p && !A[b + \" \"] && (!r || !r.test(b)) && (!q || !q.test(b))) try {\n        var d = s.call(a, b);if (d || c.disconnectedMatch || a.document && 11 !== a.document.nodeType) return d;\n      } catch (e) {}return fa(b, n, null, [a]).length > 0;\n    }, fa.contains = function (a, b) {\n      return (a.ownerDocument || a) !== n && m(a), t(a, b);\n    }, fa.attr = function (a, b) {\n      (a.ownerDocument || a) !== n && m(a);var e = d.attrHandle[b.toLowerCase()],\n          f = e && D.call(d.attrHandle, b.toLowerCase()) ? e(a, b, !p) : void 0;return void 0 !== f ? f : c.attributes || !p ? a.getAttribute(b) : (f = a.getAttributeNode(b)) && f.specified ? f.value : null;\n    }, fa.error = function (a) {\n      throw new Error(\"Syntax error, unrecognized expression: \" + a);\n    }, fa.uniqueSort = function (a) {\n      var b,\n          d = [],\n          e = 0,\n          f = 0;if (l = !c.detectDuplicates, k = !c.sortStable && a.slice(0), a.sort(B), l) {\n        while (b = a[f++]) {\n          b === a[f] && (e = d.push(f));\n        }while (e--) {\n          a.splice(d[e], 1);\n        }\n      }return k = null, a;\n    }, e = fa.getText = function (a) {\n      var b,\n          c = \"\",\n          d = 0,\n          f = a.nodeType;if (f) {\n        if (1 === f || 9 === f || 11 === f) {\n          if (\"string\" == typeof a.textContent) return a.textContent;for (a = a.firstChild; a; a = a.nextSibling) {\n            c += e(a);\n          }\n        } else if (3 === f || 4 === f) return a.nodeValue;\n      } else while (b = a[d++]) {\n        c += e(b);\n      }return c;\n    }, d = fa.selectors = { cacheLength: 50, createPseudo: ha, match: W, attrHandle: {}, find: {}, relative: { \">\": { dir: \"parentNode\", first: !0 }, \" \": { dir: \"parentNode\" }, \"+\": { dir: \"previousSibling\", first: !0 }, \"~\": { dir: \"previousSibling\" } }, preFilter: { ATTR: function ATTR(a) {\n          return a[1] = a[1].replace(ba, ca), a[3] = (a[3] || a[4] || a[5] || \"\").replace(ba, ca), \"~=\" === a[2] && (a[3] = \" \" + a[3] + \" \"), a.slice(0, 4);\n        }, CHILD: function CHILD(a) {\n          return a[1] = a[1].toLowerCase(), \"nth\" === a[1].slice(0, 3) ? (a[3] || fa.error(a[0]), a[4] = +(a[4] ? a[5] + (a[6] || 1) : 2 * (\"even\" === a[3] || \"odd\" === a[3])), a[5] = +(a[7] + a[8] || \"odd\" === a[3])) : a[3] && fa.error(a[0]), a;\n        }, PSEUDO: function PSEUDO(a) {\n          var b,\n              c = !a[6] && a[2];return W.CHILD.test(a[0]) ? null : (a[3] ? a[2] = a[4] || a[5] || \"\" : c && U.test(c) && (b = g(c, !0)) && (b = c.indexOf(\")\", c.length - b) - c.length) && (a[0] = a[0].slice(0, b), a[2] = c.slice(0, b)), a.slice(0, 3));\n        } }, filter: { TAG: function TAG(a) {\n          var b = a.replace(ba, ca).toLowerCase();return \"*\" === a ? function () {\n            return !0;\n          } : function (a) {\n            return a.nodeName && a.nodeName.toLowerCase() === b;\n          };\n        }, CLASS: function CLASS(a) {\n          var b = y[a + \" \"];return b || (b = new RegExp(\"(^|\" + L + \")\" + a + \"(\" + L + \"|$)\")) && y(a, function (a) {\n            return b.test(\"string\" == typeof a.className && a.className || \"undefined\" != typeof a.getAttribute && a.getAttribute(\"class\") || \"\");\n          });\n        }, ATTR: function ATTR(a, b, c) {\n          return function (d) {\n            var e = fa.attr(d, a);return null == e ? \"!=\" === b : b ? (e += \"\", \"=\" === b ? e === c : \"!=\" === b ? e !== c : \"^=\" === b ? c && 0 === e.indexOf(c) : \"*=\" === b ? c && e.indexOf(c) > -1 : \"$=\" === b ? c && e.slice(-c.length) === c : \"~=\" === b ? (\" \" + e.replace(P, \" \") + \" \").indexOf(c) > -1 : \"|=\" === b ? e === c || e.slice(0, c.length + 1) === c + \"-\" : !1) : !0;\n          };\n        }, CHILD: function CHILD(a, b, c, d, e) {\n          var f = \"nth\" !== a.slice(0, 3),\n              g = \"last\" !== a.slice(-4),\n              h = \"of-type\" === b;return 1 === d && 0 === e ? function (a) {\n            return !!a.parentNode;\n          } : function (b, c, i) {\n            var j,\n                k,\n                l,\n                m,\n                n,\n                o,\n                p = f !== g ? \"nextSibling\" : \"previousSibling\",\n                q = b.parentNode,\n                r = h && b.nodeName.toLowerCase(),\n                s = !i && !h,\n                t = !1;if (q) {\n              if (f) {\n                while (p) {\n                  m = b;while (m = m[p]) {\n                    if (h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) return !1;\n                  }o = p = \"only\" === a && !o && \"nextSibling\";\n                }return !0;\n              }if (o = [g ? q.firstChild : q.lastChild], g && s) {\n                m = q, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n && j[2], m = n && q.childNodes[n];while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                  if (1 === m.nodeType && ++t && m === b) {\n                    k[a] = [w, n, t];break;\n                  }\n                }\n              } else if (s && (m = b, l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), j = k[a] || [], n = j[0] === w && j[1], t = n), t === !1) while (m = ++n && m && m[p] || (t = n = 0) || o.pop()) {\n                if ((h ? m.nodeName.toLowerCase() === r : 1 === m.nodeType) && ++t && (s && (l = m[u] || (m[u] = {}), k = l[m.uniqueID] || (l[m.uniqueID] = {}), k[a] = [w, t]), m === b)) break;\n              }return t -= e, t === d || t % d === 0 && t / d >= 0;\n            }\n          };\n        }, PSEUDO: function PSEUDO(a, b) {\n          var c,\n              e = d.pseudos[a] || d.setFilters[a.toLowerCase()] || fa.error(\"unsupported pseudo: \" + a);return e[u] ? e(b) : e.length > 1 ? (c = [a, a, \"\", b], d.setFilters.hasOwnProperty(a.toLowerCase()) ? ha(function (a, c) {\n            var d,\n                f = e(a, b),\n                g = f.length;while (g--) {\n              d = J(a, f[g]), a[d] = !(c[d] = f[g]);\n            }\n          }) : function (a) {\n            return e(a, 0, c);\n          }) : e;\n        } }, pseudos: { not: ha(function (a) {\n          var b = [],\n              c = [],\n              d = h(a.replace(Q, \"$1\"));return d[u] ? ha(function (a, b, c, e) {\n            var f,\n                g = d(a, null, e, []),\n                h = a.length;while (h--) {\n              (f = g[h]) && (a[h] = !(b[h] = f));\n            }\n          }) : function (a, e, f) {\n            return b[0] = a, d(b, null, f, c), b[0] = null, !c.pop();\n          };\n        }), has: ha(function (a) {\n          return function (b) {\n            return fa(a, b).length > 0;\n          };\n        }), contains: ha(function (a) {\n          return a = a.replace(ba, ca), function (b) {\n            return (b.textContent || b.innerText || e(b)).indexOf(a) > -1;\n          };\n        }), lang: ha(function (a) {\n          return V.test(a || \"\") || fa.error(\"unsupported lang: \" + a), a = a.replace(ba, ca).toLowerCase(), function (b) {\n            var c;do {\n              if (c = p ? b.lang : b.getAttribute(\"xml:lang\") || b.getAttribute(\"lang\")) return c = c.toLowerCase(), c === a || 0 === c.indexOf(a + \"-\");\n            } while ((b = b.parentNode) && 1 === b.nodeType);return !1;\n          };\n        }), target: function target(b) {\n          var c = a.location && a.location.hash;return c && c.slice(1) === b.id;\n        }, root: function root(a) {\n          return a === o;\n        }, focus: function focus(a) {\n          return a === n.activeElement && (!n.hasFocus || n.hasFocus()) && !!(a.type || a.href || ~a.tabIndex);\n        }, enabled: function enabled(a) {\n          return a.disabled === !1;\n        }, disabled: function disabled(a) {\n          return a.disabled === !0;\n        }, checked: function checked(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && !!a.checked || \"option\" === b && !!a.selected;\n        }, selected: function selected(a) {\n          return a.parentNode && a.parentNode.selectedIndex, a.selected === !0;\n        }, empty: function empty(a) {\n          for (a = a.firstChild; a; a = a.nextSibling) {\n            if (a.nodeType < 6) return !1;\n          }return !0;\n        }, parent: function parent(a) {\n          return !d.pseudos.empty(a);\n        }, header: function header(a) {\n          return Y.test(a.nodeName);\n        }, input: function input(a) {\n          return X.test(a.nodeName);\n        }, button: function button(a) {\n          var b = a.nodeName.toLowerCase();return \"input\" === b && \"button\" === a.type || \"button\" === b;\n        }, text: function text(a) {\n          var b;return \"input\" === a.nodeName.toLowerCase() && \"text\" === a.type && (null == (b = a.getAttribute(\"type\")) || \"text\" === b.toLowerCase());\n        }, first: na(function () {\n          return [0];\n        }), last: na(function (a, b) {\n          return [b - 1];\n        }), eq: na(function (a, b, c) {\n          return [0 > c ? c + b : c];\n        }), even: na(function (a, b) {\n          for (var c = 0; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), odd: na(function (a, b) {\n          for (var c = 1; b > c; c += 2) {\n            a.push(c);\n          }return a;\n        }), lt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; --d >= 0;) {\n            a.push(d);\n          }return a;\n        }), gt: na(function (a, b, c) {\n          for (var d = 0 > c ? c + b : c; ++d < b;) {\n            a.push(d);\n          }return a;\n        }) } }, d.pseudos.nth = d.pseudos.eq;for (b in { radio: !0, checkbox: !0, file: !0, password: !0, image: !0 }) {\n      d.pseudos[b] = la(b);\n    }for (b in { submit: !0, reset: !0 }) {\n      d.pseudos[b] = ma(b);\n    }function pa() {}pa.prototype = d.filters = d.pseudos, d.setFilters = new pa(), g = fa.tokenize = function (a, b) {\n      var c,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = z[a + \" \"];if (k) return b ? 0 : k.slice(0);h = a, i = [], j = d.preFilter;while (h) {\n        c && !(e = R.exec(h)) || (e && (h = h.slice(e[0].length) || h), i.push(f = [])), c = !1, (e = S.exec(h)) && (c = e.shift(), f.push({ value: c, type: e[0].replace(Q, \" \") }), h = h.slice(c.length));for (g in d.filter) {\n          !(e = W[g].exec(h)) || j[g] && !(e = j[g](e)) || (c = e.shift(), f.push({ value: c, type: g, matches: e }), h = h.slice(c.length));\n        }if (!c) break;\n      }return b ? h.length : h ? fa.error(a) : z(a, i).slice(0);\n    };function qa(a) {\n      for (var b = 0, c = a.length, d = \"\"; c > b; b++) {\n        d += a[b].value;\n      }return d;\n    }function ra(a, b, c) {\n      var d = b.dir,\n          e = c && \"parentNode\" === d,\n          f = x++;return b.first ? function (b, c, f) {\n        while (b = b[d]) {\n          if (1 === b.nodeType || e) return a(b, c, f);\n        }\n      } : function (b, c, g) {\n        var h,\n            i,\n            j,\n            k = [w, f];if (g) {\n          while (b = b[d]) {\n            if ((1 === b.nodeType || e) && a(b, c, g)) return !0;\n          }\n        } else while (b = b[d]) {\n          if (1 === b.nodeType || e) {\n            if (j = b[u] || (b[u] = {}), i = j[b.uniqueID] || (j[b.uniqueID] = {}), (h = i[d]) && h[0] === w && h[1] === f) return k[2] = h[2];if (i[d] = k, k[2] = a(b, c, g)) return !0;\n          }\n        }\n      };\n    }function sa(a) {\n      return a.length > 1 ? function (b, c, d) {\n        var e = a.length;while (e--) {\n          if (!a[e](b, c, d)) return !1;\n        }return !0;\n      } : a[0];\n    }function ta(a, b, c) {\n      for (var d = 0, e = b.length; e > d; d++) {\n        fa(a, b[d], c);\n      }return c;\n    }function ua(a, b, c, d, e) {\n      for (var f, g = [], h = 0, i = a.length, j = null != b; i > h; h++) {\n        (f = a[h]) && (c && !c(f, d, e) || (g.push(f), j && b.push(h)));\n      }return g;\n    }function va(a, b, c, d, e, f) {\n      return d && !d[u] && (d = va(d)), e && !e[u] && (e = va(e, f)), ha(function (f, g, h, i) {\n        var j,\n            k,\n            l,\n            m = [],\n            n = [],\n            o = g.length,\n            p = f || ta(b || \"*\", h.nodeType ? [h] : h, []),\n            q = !a || !f && b ? p : ua(p, m, a, h, i),\n            r = c ? e || (f ? a : o || d) ? [] : g : q;if (c && c(q, r, h, i), d) {\n          j = ua(r, n), d(j, [], h, i), k = j.length;while (k--) {\n            (l = j[k]) && (r[n[k]] = !(q[n[k]] = l));\n          }\n        }if (f) {\n          if (e || a) {\n            if (e) {\n              j = [], k = r.length;while (k--) {\n                (l = r[k]) && j.push(q[k] = l);\n              }e(null, r = [], j, i);\n            }k = r.length;while (k--) {\n              (l = r[k]) && (j = e ? J(f, l) : m[k]) > -1 && (f[j] = !(g[j] = l));\n            }\n          }\n        } else r = ua(r === g ? r.splice(o, r.length) : r), e ? e(null, g, r, i) : H.apply(g, r);\n      });\n    }function wa(a) {\n      for (var b, c, e, f = a.length, g = d.relative[a[0].type], h = g || d.relative[\" \"], i = g ? 1 : 0, k = ra(function (a) {\n        return a === b;\n      }, h, !0), l = ra(function (a) {\n        return J(b, a) > -1;\n      }, h, !0), m = [function (a, c, d) {\n        var e = !g && (d || c !== j) || ((b = c).nodeType ? k(a, c, d) : l(a, c, d));return b = null, e;\n      }]; f > i; i++) {\n        if (c = d.relative[a[i].type]) m = [ra(sa(m), c)];else {\n          if (c = d.filter[a[i].type].apply(null, a[i].matches), c[u]) {\n            for (e = ++i; f > e; e++) {\n              if (d.relative[a[e].type]) break;\n            }return va(i > 1 && sa(m), i > 1 && qa(a.slice(0, i - 1).concat({ value: \" \" === a[i - 2].type ? \"*\" : \"\" })).replace(Q, \"$1\"), c, e > i && wa(a.slice(i, e)), f > e && wa(a = a.slice(e)), f > e && qa(a));\n          }m.push(c);\n        }\n      }return sa(m);\n    }function xa(a, b) {\n      var c = b.length > 0,\n          e = a.length > 0,\n          f = function f(_f, g, h, i, k) {\n        var l,\n            o,\n            q,\n            r = 0,\n            s = \"0\",\n            t = _f && [],\n            u = [],\n            v = j,\n            x = _f || e && d.find.TAG(\"*\", k),\n            y = w += null == v ? 1 : Math.random() || .1,\n            z = x.length;for (k && (j = g === n || g || k); s !== z && null != (l = x[s]); s++) {\n          if (e && l) {\n            o = 0, g || l.ownerDocument === n || (m(l), h = !p);while (q = a[o++]) {\n              if (q(l, g || n, h)) {\n                i.push(l);break;\n              }\n            }k && (w = y);\n          }c && ((l = !q && l) && r--, _f && t.push(l));\n        }if (r += s, c && s !== r) {\n          o = 0;while (q = b[o++]) {\n            q(t, u, g, h);\n          }if (_f) {\n            if (r > 0) while (s--) {\n              t[s] || u[s] || (u[s] = F.call(i));\n            }u = ua(u);\n          }H.apply(i, u), k && !_f && u.length > 0 && r + b.length > 1 && fa.uniqueSort(i);\n        }return k && (w = y, j = v), t;\n      };return c ? ha(f) : f;\n    }return h = fa.compile = function (a, b) {\n      var c,\n          d = [],\n          e = [],\n          f = A[a + \" \"];if (!f) {\n        b || (b = g(a)), c = b.length;while (c--) {\n          f = wa(b[c]), f[u] ? d.push(f) : e.push(f);\n        }f = A(a, xa(e, d)), f.selector = a;\n      }return f;\n    }, i = fa.select = function (a, b, e, f) {\n      var i,\n          j,\n          k,\n          l,\n          m,\n          n = \"function\" == typeof a && a,\n          o = !f && g(a = n.selector || a);if (e = e || [], 1 === o.length) {\n        if (j = o[0] = o[0].slice(0), j.length > 2 && \"ID\" === (k = j[0]).type && c.getById && 9 === b.nodeType && p && d.relative[j[1].type]) {\n          if (b = (d.find.ID(k.matches[0].replace(ba, ca), b) || [])[0], !b) return e;n && (b = b.parentNode), a = a.slice(j.shift().value.length);\n        }i = W.needsContext.test(a) ? 0 : j.length;while (i--) {\n          if (k = j[i], d.relative[l = k.type]) break;if ((m = d.find[l]) && (f = m(k.matches[0].replace(ba, ca), _.test(j[0].type) && oa(b.parentNode) || b))) {\n            if (j.splice(i, 1), a = f.length && qa(j), !a) return H.apply(e, f), e;break;\n          }\n        }\n      }return (n || h(a, o))(f, b, !p, e, !b || _.test(a) && oa(b.parentNode) || b), e;\n    }, c.sortStable = u.split(\"\").sort(B).join(\"\") === u, c.detectDuplicates = !!l, m(), c.sortDetached = ia(function (a) {\n      return 1 & a.compareDocumentPosition(n.createElement(\"div\"));\n    }), ia(function (a) {\n      return a.innerHTML = \"<a href='#'></a>\", \"#\" === a.firstChild.getAttribute(\"href\");\n    }) || ja(\"type|href|height|width\", function (a, b, c) {\n      return c ? void 0 : a.getAttribute(b, \"type\" === b.toLowerCase() ? 1 : 2);\n    }), c.attributes && ia(function (a) {\n      return a.innerHTML = \"<input/>\", a.firstChild.setAttribute(\"value\", \"\"), \"\" === a.firstChild.getAttribute(\"value\");\n    }) || ja(\"value\", function (a, b, c) {\n      return c || \"input\" !== a.nodeName.toLowerCase() ? void 0 : a.defaultValue;\n    }), ia(function (a) {\n      return null == a.getAttribute(\"disabled\");\n    }) || ja(K, function (a, b, c) {\n      var d;return c ? void 0 : a[b] === !0 ? b.toLowerCase() : (d = a.getAttributeNode(b)) && d.specified ? d.value : null;\n    }), fa;\n  }(a);n.find = t, n.expr = t.selectors, n.expr[\":\"] = n.expr.pseudos, n.uniqueSort = n.unique = t.uniqueSort, n.text = t.getText, n.isXMLDoc = t.isXML, n.contains = t.contains;var u = function u(a, b, c) {\n    var d = [],\n        e = void 0 !== c;while ((a = a[b]) && 9 !== a.nodeType) {\n      if (1 === a.nodeType) {\n        if (e && n(a).is(c)) break;d.push(a);\n      }\n    }return d;\n  },\n      v = function v(a, b) {\n    for (var c = []; a; a = a.nextSibling) {\n      1 === a.nodeType && a !== b && c.push(a);\n    }return c;\n  },\n      w = n.expr.match.needsContext,\n      x = /^<([\\w-]+)\\s*\\/?>(?:<\\/\\1>|)$/,\n      y = /^.[^:#\\[\\.,]*$/;function z(a, b, c) {\n    if (n.isFunction(b)) return n.grep(a, function (a, d) {\n      return !!b.call(a, d, a) !== c;\n    });if (b.nodeType) return n.grep(a, function (a) {\n      return a === b !== c;\n    });if (\"string\" == typeof b) {\n      if (y.test(b)) return n.filter(b, a, c);b = n.filter(b, a);\n    }return n.grep(a, function (a) {\n      return h.call(b, a) > -1 !== c;\n    });\n  }n.filter = function (a, b, c) {\n    var d = b[0];return c && (a = \":not(\" + a + \")\"), 1 === b.length && 1 === d.nodeType ? n.find.matchesSelector(d, a) ? [d] : [] : n.find.matches(a, n.grep(b, function (a) {\n      return 1 === a.nodeType;\n    }));\n  }, n.fn.extend({ find: function find(a) {\n      var b,\n          c = this.length,\n          d = [],\n          e = this;if (\"string\" != typeof a) return this.pushStack(n(a).filter(function () {\n        for (b = 0; c > b; b++) {\n          if (n.contains(e[b], this)) return !0;\n        }\n      }));for (b = 0; c > b; b++) {\n        n.find(a, e[b], d);\n      }return d = this.pushStack(c > 1 ? n.unique(d) : d), d.selector = this.selector ? this.selector + \" \" + a : a, d;\n    }, filter: function filter(a) {\n      return this.pushStack(z(this, a || [], !1));\n    }, not: function not(a) {\n      return this.pushStack(z(this, a || [], !0));\n    }, is: function is(a) {\n      return !!z(this, \"string\" == typeof a && w.test(a) ? n(a) : a || [], !1).length;\n    } });var A,\n      B = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n      C = n.fn.init = function (a, b, c) {\n    var e, f;if (!a) return this;if (c = c || A, \"string\" == typeof a) {\n      if (e = \"<\" === a[0] && \">\" === a[a.length - 1] && a.length >= 3 ? [null, a, null] : B.exec(a), !e || !e[1] && b) return !b || b.jquery ? (b || c).find(a) : this.constructor(b).find(a);if (e[1]) {\n        if (b = b instanceof n ? b[0] : b, n.merge(this, n.parseHTML(e[1], b && b.nodeType ? b.ownerDocument || b : d, !0)), x.test(e[1]) && n.isPlainObject(b)) for (e in b) {\n          n.isFunction(this[e]) ? this[e](b[e]) : this.attr(e, b[e]);\n        }return this;\n      }return f = d.getElementById(e[2]), f && f.parentNode && (this.length = 1, this[0] = f), this.context = d, this.selector = a, this;\n    }return a.nodeType ? (this.context = this[0] = a, this.length = 1, this) : n.isFunction(a) ? void 0 !== c.ready ? c.ready(a) : a(n) : (void 0 !== a.selector && (this.selector = a.selector, this.context = a.context), n.makeArray(a, this));\n  };C.prototype = n.fn, A = n(d);var D = /^(?:parents|prev(?:Until|All))/,\n      E = { children: !0, contents: !0, next: !0, prev: !0 };n.fn.extend({ has: function has(a) {\n      var b = n(a, this),\n          c = b.length;return this.filter(function () {\n        for (var a = 0; c > a; a++) {\n          if (n.contains(this, b[a])) return !0;\n        }\n      });\n    }, closest: function closest(a, b) {\n      for (var c, d = 0, e = this.length, f = [], g = w.test(a) || \"string\" != typeof a ? n(a, b || this.context) : 0; e > d; d++) {\n        for (c = this[d]; c && c !== b; c = c.parentNode) {\n          if (c.nodeType < 11 && (g ? g.index(c) > -1 : 1 === c.nodeType && n.find.matchesSelector(c, a))) {\n            f.push(c);break;\n          }\n        }\n      }return this.pushStack(f.length > 1 ? n.uniqueSort(f) : f);\n    }, index: function index(a) {\n      return a ? \"string\" == typeof a ? h.call(n(a), this[0]) : h.call(this, a.jquery ? a[0] : a) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1;\n    }, add: function add(a, b) {\n      return this.pushStack(n.uniqueSort(n.merge(this.get(), n(a, b))));\n    }, addBack: function addBack(a) {\n      return this.add(null == a ? this.prevObject : this.prevObject.filter(a));\n    } });function F(a, b) {\n    while ((a = a[b]) && 1 !== a.nodeType) {}return a;\n  }n.each({ parent: function parent(a) {\n      var b = a.parentNode;return b && 11 !== b.nodeType ? b : null;\n    }, parents: function parents(a) {\n      return u(a, \"parentNode\");\n    }, parentsUntil: function parentsUntil(a, b, c) {\n      return u(a, \"parentNode\", c);\n    }, next: function next(a) {\n      return F(a, \"nextSibling\");\n    }, prev: function prev(a) {\n      return F(a, \"previousSibling\");\n    }, nextAll: function nextAll(a) {\n      return u(a, \"nextSibling\");\n    }, prevAll: function prevAll(a) {\n      return u(a, \"previousSibling\");\n    }, nextUntil: function nextUntil(a, b, c) {\n      return u(a, \"nextSibling\", c);\n    }, prevUntil: function prevUntil(a, b, c) {\n      return u(a, \"previousSibling\", c);\n    }, siblings: function siblings(a) {\n      return v((a.parentNode || {}).firstChild, a);\n    }, children: function children(a) {\n      return v(a.firstChild);\n    }, contents: function contents(a) {\n      return a.contentDocument || n.merge([], a.childNodes);\n    } }, function (a, b) {\n    n.fn[a] = function (c, d) {\n      var e = n.map(this, b, c);return \"Until\" !== a.slice(-5) && (d = c), d && \"string\" == typeof d && (e = n.filter(d, e)), this.length > 1 && (E[a] || n.uniqueSort(e), D.test(a) && e.reverse()), this.pushStack(e);\n    };\n  });var G = /\\S+/g;function H(a) {\n    var b = {};return n.each(a.match(G) || [], function (a, c) {\n      b[c] = !0;\n    }), b;\n  }n.Callbacks = function (a) {\n    a = \"string\" == typeof a ? H(a) : n.extend({}, a);var b,\n        c,\n        d,\n        e,\n        f = [],\n        g = [],\n        h = -1,\n        i = function i() {\n      for (e = a.once, d = b = !0; g.length; h = -1) {\n        c = g.shift();while (++h < f.length) {\n          f[h].apply(c[0], c[1]) === !1 && a.stopOnFalse && (h = f.length, c = !1);\n        }\n      }a.memory || (c = !1), b = !1, e && (f = c ? [] : \"\");\n    },\n        j = { add: function add() {\n        return f && (c && !b && (h = f.length - 1, g.push(c)), function d(b) {\n          n.each(b, function (b, c) {\n            n.isFunction(c) ? a.unique && j.has(c) || f.push(c) : c && c.length && \"string\" !== n.type(c) && d(c);\n          });\n        }(arguments), c && !b && i()), this;\n      }, remove: function remove() {\n        return n.each(arguments, function (a, b) {\n          var c;while ((c = n.inArray(b, f, c)) > -1) {\n            f.splice(c, 1), h >= c && h--;\n          }\n        }), this;\n      }, has: function has(a) {\n        return a ? n.inArray(a, f) > -1 : f.length > 0;\n      }, empty: function empty() {\n        return f && (f = []), this;\n      }, disable: function disable() {\n        return e = g = [], f = c = \"\", this;\n      }, disabled: function disabled() {\n        return !f;\n      }, lock: function lock() {\n        return e = g = [], c || (f = c = \"\"), this;\n      }, locked: function locked() {\n        return !!e;\n      }, fireWith: function fireWith(a, c) {\n        return e || (c = c || [], c = [a, c.slice ? c.slice() : c], g.push(c), b || i()), this;\n      }, fire: function fire() {\n        return j.fireWith(this, arguments), this;\n      }, fired: function fired() {\n        return !!d;\n      } };return j;\n  }, n.extend({ Deferred: function Deferred(a) {\n      var b = [[\"resolve\", \"done\", n.Callbacks(\"once memory\"), \"resolved\"], [\"reject\", \"fail\", n.Callbacks(\"once memory\"), \"rejected\"], [\"notify\", \"progress\", n.Callbacks(\"memory\")]],\n          c = \"pending\",\n          d = { state: function state() {\n          return c;\n        }, always: function always() {\n          return e.done(arguments).fail(arguments), this;\n        }, then: function then() {\n          var a = arguments;return n.Deferred(function (c) {\n            n.each(b, function (b, f) {\n              var g = n.isFunction(a[b]) && a[b];e[f[1]](function () {\n                var a = g && g.apply(this, arguments);a && n.isFunction(a.promise) ? a.promise().progress(c.notify).done(c.resolve).fail(c.reject) : c[f[0] + \"With\"](this === d ? c.promise() : this, g ? [a] : arguments);\n              });\n            }), a = null;\n          }).promise();\n        }, promise: function promise(a) {\n          return null != a ? n.extend(a, d) : d;\n        } },\n          e = {};return d.pipe = d.then, n.each(b, function (a, f) {\n        var g = f[2],\n            h = f[3];d[f[1]] = g.add, h && g.add(function () {\n          c = h;\n        }, b[1 ^ a][2].disable, b[2][2].lock), e[f[0]] = function () {\n          return e[f[0] + \"With\"](this === e ? d : this, arguments), this;\n        }, e[f[0] + \"With\"] = g.fireWith;\n      }), d.promise(e), a && a.call(e, e), e;\n    }, when: function when(a) {\n      var b = 0,\n          c = e.call(arguments),\n          d = c.length,\n          f = 1 !== d || a && n.isFunction(a.promise) ? d : 0,\n          g = 1 === f ? a : n.Deferred(),\n          h = function h(a, b, c) {\n        return function (d) {\n          b[a] = this, c[a] = arguments.length > 1 ? e.call(arguments) : d, c === i ? g.notifyWith(b, c) : --f || g.resolveWith(b, c);\n        };\n      },\n          i,\n          j,\n          k;if (d > 1) for (i = new Array(d), j = new Array(d), k = new Array(d); d > b; b++) {\n        c[b] && n.isFunction(c[b].promise) ? c[b].promise().progress(h(b, j, i)).done(h(b, k, c)).fail(g.reject) : --f;\n      }return f || g.resolveWith(k, c), g.promise();\n    } });var I;n.fn.ready = function (a) {\n    return n.ready.promise().done(a), this;\n  }, n.extend({ isReady: !1, readyWait: 1, holdReady: function holdReady(a) {\n      a ? n.readyWait++ : n.ready(!0);\n    }, ready: function ready(a) {\n      (a === !0 ? --n.readyWait : n.isReady) || (n.isReady = !0, a !== !0 && --n.readyWait > 0 || (I.resolveWith(d, [n]), n.fn.triggerHandler && (n(d).triggerHandler(\"ready\"), n(d).off(\"ready\"))));\n    } });function J() {\n    d.removeEventListener(\"DOMContentLoaded\", J), a.removeEventListener(\"load\", J), n.ready();\n  }n.ready.promise = function (b) {\n    return I || (I = n.Deferred(), \"complete\" === d.readyState || \"loading\" !== d.readyState && !d.documentElement.doScroll ? a.setTimeout(n.ready) : (d.addEventListener(\"DOMContentLoaded\", J), a.addEventListener(\"load\", J))), I.promise(b);\n  }, n.ready.promise();var K = function K(a, b, c, d, e, f, g) {\n    var h = 0,\n        i = a.length,\n        j = null == c;if (\"object\" === n.type(c)) {\n      e = !0;for (h in c) {\n        K(a, b, h, c[h], !0, f, g);\n      }\n    } else if (void 0 !== d && (e = !0, n.isFunction(d) || (g = !0), j && (g ? (b.call(a, d), b = null) : (j = b, b = function b(a, _b, c) {\n      return j.call(n(a), c);\n    })), b)) for (; i > h; h++) {\n      b(a[h], c, g ? d : d.call(a[h], h, b(a[h], c)));\n    }return e ? a : j ? b.call(a) : i ? b(a[0], c) : f;\n  },\n      L = function L(a) {\n    return 1 === a.nodeType || 9 === a.nodeType || !+a.nodeType;\n  };function M() {\n    this.expando = n.expando + M.uid++;\n  }M.uid = 1, M.prototype = { register: function register(a, b) {\n      var c = b || {};return a.nodeType ? a[this.expando] = c : Object.defineProperty(a, this.expando, { value: c, writable: !0, configurable: !0 }), a[this.expando];\n    }, cache: function cache(a) {\n      if (!L(a)) return {};var b = a[this.expando];return b || (b = {}, L(a) && (a.nodeType ? a[this.expando] = b : Object.defineProperty(a, this.expando, { value: b, configurable: !0 }))), b;\n    }, set: function set(a, b, c) {\n      var d,\n          e = this.cache(a);if (\"string\" == typeof b) e[b] = c;else for (d in b) {\n        e[d] = b[d];\n      }return e;\n    }, get: function get(a, b) {\n      return void 0 === b ? this.cache(a) : a[this.expando] && a[this.expando][b];\n    }, access: function access(a, b, c) {\n      var d;return void 0 === b || b && \"string\" == typeof b && void 0 === c ? (d = this.get(a, b), void 0 !== d ? d : this.get(a, n.camelCase(b))) : (this.set(a, b, c), void 0 !== c ? c : b);\n    }, remove: function remove(a, b) {\n      var c,\n          d,\n          e,\n          f = a[this.expando];if (void 0 !== f) {\n        if (void 0 === b) this.register(a);else {\n          n.isArray(b) ? d = b.concat(b.map(n.camelCase)) : (e = n.camelCase(b), b in f ? d = [b, e] : (d = e, d = d in f ? [d] : d.match(G) || [])), c = d.length;while (c--) {\n            delete f[d[c]];\n          }\n        }(void 0 === b || n.isEmptyObject(f)) && (a.nodeType ? a[this.expando] = void 0 : delete a[this.expando]);\n      }\n    }, hasData: function hasData(a) {\n      var b = a[this.expando];return void 0 !== b && !n.isEmptyObject(b);\n    } };var N = new M(),\n      O = new M(),\n      P = /^(?:\\{[\\w\\W]*\\}|\\[[\\w\\W]*\\])$/,\n      Q = /[A-Z]/g;function R(a, b, c) {\n    var d;if (void 0 === c && 1 === a.nodeType) if (d = \"data-\" + b.replace(Q, \"-$&\").toLowerCase(), c = a.getAttribute(d), \"string\" == typeof c) {\n      try {\n        c = \"true\" === c ? !0 : \"false\" === c ? !1 : \"null\" === c ? null : +c + \"\" === c ? +c : P.test(c) ? n.parseJSON(c) : c;\n      } catch (e) {}O.set(a, b, c);\n    } else c = void 0;return c;\n  }n.extend({ hasData: function hasData(a) {\n      return O.hasData(a) || N.hasData(a);\n    }, data: function data(a, b, c) {\n      return O.access(a, b, c);\n    }, removeData: function removeData(a, b) {\n      O.remove(a, b);\n    }, _data: function _data(a, b, c) {\n      return N.access(a, b, c);\n    }, _removeData: function _removeData(a, b) {\n      N.remove(a, b);\n    } }), n.fn.extend({ data: function data(a, b) {\n      var c,\n          d,\n          e,\n          f = this[0],\n          g = f && f.attributes;if (void 0 === a) {\n        if (this.length && (e = O.get(f), 1 === f.nodeType && !N.get(f, \"hasDataAttrs\"))) {\n          c = g.length;while (c--) {\n            g[c] && (d = g[c].name, 0 === d.indexOf(\"data-\") && (d = n.camelCase(d.slice(5)), R(f, d, e[d])));\n          }N.set(f, \"hasDataAttrs\", !0);\n        }return e;\n      }return \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? this.each(function () {\n        O.set(this, a);\n      }) : K(this, function (b) {\n        var c, d;if (f && void 0 === b) {\n          if (c = O.get(f, a) || O.get(f, a.replace(Q, \"-$&\").toLowerCase()), void 0 !== c) return c;if (d = n.camelCase(a), c = O.get(f, d), void 0 !== c) return c;if (c = R(f, d, void 0), void 0 !== c) return c;\n        } else d = n.camelCase(a), this.each(function () {\n          var c = O.get(this, d);O.set(this, d, b), a.indexOf(\"-\") > -1 && void 0 !== c && O.set(this, a, b);\n        });\n      }, null, b, arguments.length > 1, null, !0);\n    }, removeData: function removeData(a) {\n      return this.each(function () {\n        O.remove(this, a);\n      });\n    } }), n.extend({ queue: function queue(a, b, c) {\n      var d;return a ? (b = (b || \"fx\") + \"queue\", d = N.get(a, b), c && (!d || n.isArray(c) ? d = N.access(a, b, n.makeArray(c)) : d.push(c)), d || []) : void 0;\n    }, dequeue: function dequeue(a, b) {\n      b = b || \"fx\";var c = n.queue(a, b),\n          d = c.length,\n          e = c.shift(),\n          f = n._queueHooks(a, b),\n          g = function g() {\n        n.dequeue(a, b);\n      };\"inprogress\" === e && (e = c.shift(), d--), e && (\"fx\" === b && c.unshift(\"inprogress\"), delete f.stop, e.call(a, g, f)), !d && f && f.empty.fire();\n    }, _queueHooks: function _queueHooks(a, b) {\n      var c = b + \"queueHooks\";return N.get(a, c) || N.access(a, c, { empty: n.Callbacks(\"once memory\").add(function () {\n          N.remove(a, [b + \"queue\", c]);\n        }) });\n    } }), n.fn.extend({ queue: function queue(a, b) {\n      var c = 2;return \"string\" != typeof a && (b = a, a = \"fx\", c--), arguments.length < c ? n.queue(this[0], a) : void 0 === b ? this : this.each(function () {\n        var c = n.queue(this, a, b);n._queueHooks(this, a), \"fx\" === a && \"inprogress\" !== c[0] && n.dequeue(this, a);\n      });\n    }, dequeue: function dequeue(a) {\n      return this.each(function () {\n        n.dequeue(this, a);\n      });\n    }, clearQueue: function clearQueue(a) {\n      return this.queue(a || \"fx\", []);\n    }, promise: function promise(a, b) {\n      var c,\n          d = 1,\n          e = n.Deferred(),\n          f = this,\n          g = this.length,\n          h = function h() {\n        --d || e.resolveWith(f, [f]);\n      };\"string\" != typeof a && (b = a, a = void 0), a = a || \"fx\";while (g--) {\n        c = N.get(f[g], a + \"queueHooks\"), c && c.empty && (d++, c.empty.add(h));\n      }return h(), e.promise(b);\n    } });var S = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n      T = new RegExp(\"^(?:([+-])=|)(\" + S + \")([a-z%]*)$\", \"i\"),\n      U = [\"Top\", \"Right\", \"Bottom\", \"Left\"],\n      V = function V(a, b) {\n    return a = b || a, \"none\" === n.css(a, \"display\") || !n.contains(a.ownerDocument, a);\n  };function W(a, b, c, d) {\n    var e,\n        f = 1,\n        g = 20,\n        h = d ? function () {\n      return d.cur();\n    } : function () {\n      return n.css(a, b, \"\");\n    },\n        i = h(),\n        j = c && c[3] || (n.cssNumber[b] ? \"\" : \"px\"),\n        k = (n.cssNumber[b] || \"px\" !== j && +i) && T.exec(n.css(a, b));if (k && k[3] !== j) {\n      j = j || k[3], c = c || [], k = +i || 1;do {\n        f = f || \".5\", k /= f, n.style(a, b, k + j);\n      } while (f !== (f = h() / i) && 1 !== f && --g);\n    }return c && (k = +k || +i || 0, e = c[1] ? k + (c[1] + 1) * c[2] : +c[2], d && (d.unit = j, d.start = k, d.end = e)), e;\n  }var X = /^(?:checkbox|radio)$/i,\n      Y = /<([\\w:-]+)/,\n      Z = /^$|\\/(?:java|ecma)script/i,\n      $ = { option: [1, \"<select multiple='multiple'>\", \"</select>\"], thead: [1, \"<table>\", \"</table>\"], col: [2, \"<table><colgroup>\", \"</colgroup></table>\"], tr: [2, \"<table><tbody>\", \"</tbody></table>\"], td: [3, \"<table><tbody><tr>\", \"</tr></tbody></table>\"], _default: [0, \"\", \"\"] };$.optgroup = $.option, $.tbody = $.tfoot = $.colgroup = $.caption = $.thead, $.th = $.td;function _(a, b) {\n    var c = \"undefined\" != typeof a.getElementsByTagName ? a.getElementsByTagName(b || \"*\") : \"undefined\" != typeof a.querySelectorAll ? a.querySelectorAll(b || \"*\") : [];return void 0 === b || b && n.nodeName(a, b) ? n.merge([a], c) : c;\n  }function aa(a, b) {\n    for (var c = 0, d = a.length; d > c; c++) {\n      N.set(a[c], \"globalEval\", !b || N.get(b[c], \"globalEval\"));\n    }\n  }var ba = /<|&#?\\w+;/;function ca(a, b, c, d, e) {\n    for (var f, g, h, i, j, k, l = b.createDocumentFragment(), m = [], o = 0, p = a.length; p > o; o++) {\n      if (f = a[o], f || 0 === f) if (\"object\" === n.type(f)) n.merge(m, f.nodeType ? [f] : f);else if (ba.test(f)) {\n        g = g || l.appendChild(b.createElement(\"div\")), h = (Y.exec(f) || [\"\", \"\"])[1].toLowerCase(), i = $[h] || $._default, g.innerHTML = i[1] + n.htmlPrefilter(f) + i[2], k = i[0];while (k--) {\n          g = g.lastChild;\n        }n.merge(m, g.childNodes), g = l.firstChild, g.textContent = \"\";\n      } else m.push(b.createTextNode(f));\n    }l.textContent = \"\", o = 0;while (f = m[o++]) {\n      if (d && n.inArray(f, d) > -1) e && e.push(f);else if (j = n.contains(f.ownerDocument, f), g = _(l.appendChild(f), \"script\"), j && aa(g), c) {\n        k = 0;while (f = g[k++]) {\n          Z.test(f.type || \"\") && c.push(f);\n        }\n      }\n    }return l;\n  }!function () {\n    var a = d.createDocumentFragment(),\n        b = a.appendChild(d.createElement(\"div\")),\n        c = d.createElement(\"input\");c.setAttribute(\"type\", \"radio\"), c.setAttribute(\"checked\", \"checked\"), c.setAttribute(\"name\", \"t\"), b.appendChild(c), l.checkClone = b.cloneNode(!0).cloneNode(!0).lastChild.checked, b.innerHTML = \"<textarea>x</textarea>\", l.noCloneChecked = !!b.cloneNode(!0).lastChild.defaultValue;\n  }();var da = /^key/,\n      ea = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,\n      fa = /^([^.]*)(?:\\.(.+)|)/;function ga() {\n    return !0;\n  }function ha() {\n    return !1;\n  }function ia() {\n    try {\n      return d.activeElement;\n    } catch (a) {}\n  }function ja(a, b, c, d, e, f) {\n    var g, h;if (\"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b))) {\n      \"string\" != typeof c && (d = d || c, c = void 0);for (h in b) {\n        ja(a, h, c, d, b[h], f);\n      }return a;\n    }if (null == d && null == e ? (e = c, d = c = void 0) : null == e && (\"string\" == typeof c ? (e = d, d = void 0) : (e = d, d = c, c = void 0)), e === !1) e = ha;else if (!e) return a;return 1 === f && (g = e, e = function e(a) {\n      return n().off(a), g.apply(this, arguments);\n    }, e.guid = g.guid || (g.guid = n.guid++)), a.each(function () {\n      n.event.add(this, b, e, d, c);\n    });\n  }n.event = { global: {}, add: function add(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.get(a);if (r) {\n        c.handler && (f = c, c = f.handler, e = f.selector), c.guid || (c.guid = n.guid++), (i = r.events) || (i = r.events = {}), (g = r.handle) || (g = r.handle = function (b) {\n          return \"undefined\" != typeof n && n.event.triggered !== b.type ? n.event.dispatch.apply(a, arguments) : void 0;\n        }), b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o && (l = n.event.special[o] || {}, o = (e ? l.delegateType : l.bindType) || o, l = n.event.special[o] || {}, k = n.extend({ type: o, origType: q, data: d, handler: c, guid: c.guid, selector: e, needsContext: e && n.expr.match.needsContext.test(e), namespace: p.join(\".\") }, f), (m = i[o]) || (m = i[o] = [], m.delegateCount = 0, l.setup && l.setup.call(a, d, p, g) !== !1 || a.addEventListener && a.addEventListener(o, g)), l.add && (l.add.call(a, k), k.handler.guid || (k.handler.guid = c.guid)), e ? m.splice(m.delegateCount++, 0, k) : m.push(k), n.event.global[o] = !0);\n        }\n      }\n    }, remove: function remove(a, b, c, d, e) {\n      var f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m,\n          o,\n          p,\n          q,\n          r = N.hasData(a) && N.get(a);if (r && (i = r.events)) {\n        b = (b || \"\").match(G) || [\"\"], j = b.length;while (j--) {\n          if (h = fa.exec(b[j]) || [], o = q = h[1], p = (h[2] || \"\").split(\".\").sort(), o) {\n            l = n.event.special[o] || {}, o = (d ? l.delegateType : l.bindType) || o, m = i[o] || [], h = h[2] && new RegExp(\"(^|\\\\.)\" + p.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\"), g = f = m.length;while (f--) {\n              k = m[f], !e && q !== k.origType || c && c.guid !== k.guid || h && !h.test(k.namespace) || d && d !== k.selector && (\"**\" !== d || !k.selector) || (m.splice(f, 1), k.selector && m.delegateCount--, l.remove && l.remove.call(a, k));\n            }g && !m.length && (l.teardown && l.teardown.call(a, p, r.handle) !== !1 || n.removeEvent(a, o, r.handle), delete i[o]);\n          } else for (o in i) {\n            n.event.remove(a, o + b[j], c, d, !0);\n          }\n        }n.isEmptyObject(i) && N.remove(a, \"handle events\");\n      }\n    }, dispatch: function dispatch(a) {\n      a = n.event.fix(a);var b,\n          c,\n          d,\n          f,\n          g,\n          h = [],\n          i = e.call(arguments),\n          j = (N.get(this, \"events\") || {})[a.type] || [],\n          k = n.event.special[a.type] || {};if (i[0] = a, a.delegateTarget = this, !k.preDispatch || k.preDispatch.call(this, a) !== !1) {\n        h = n.event.handlers.call(this, a, j), b = 0;while ((f = h[b++]) && !a.isPropagationStopped()) {\n          a.currentTarget = f.elem, c = 0;while ((g = f.handlers[c++]) && !a.isImmediatePropagationStopped()) {\n            a.rnamespace && !a.rnamespace.test(g.namespace) || (a.handleObj = g, a.data = g.data, d = ((n.event.special[g.origType] || {}).handle || g.handler).apply(f.elem, i), void 0 !== d && (a.result = d) === !1 && (a.preventDefault(), a.stopPropagation()));\n          }\n        }return k.postDispatch && k.postDispatch.call(this, a), a.result;\n      }\n    }, handlers: function handlers(a, b) {\n      var c,\n          d,\n          e,\n          f,\n          g = [],\n          h = b.delegateCount,\n          i = a.target;if (h && i.nodeType && (\"click\" !== a.type || isNaN(a.button) || a.button < 1)) for (; i !== this; i = i.parentNode || this) {\n        if (1 === i.nodeType && (i.disabled !== !0 || \"click\" !== a.type)) {\n          for (d = [], c = 0; h > c; c++) {\n            f = b[c], e = f.selector + \" \", void 0 === d[e] && (d[e] = f.needsContext ? n(e, this).index(i) > -1 : n.find(e, this, null, [i]).length), d[e] && d.push(f);\n          }d.length && g.push({ elem: i, handlers: d });\n        }\n      }return h < b.length && g.push({ elem: this, handlers: b.slice(h) }), g;\n    }, props: \"altKey bubbles cancelable ctrlKey currentTarget detail eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"), fixHooks: {}, keyHooks: { props: \"char charCode key keyCode\".split(\" \"), filter: function filter(a, b) {\n        return null == a.which && (a.which = null != b.charCode ? b.charCode : b.keyCode), a;\n      } }, mouseHooks: { props: \"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"), filter: function filter(a, b) {\n        var c,\n            e,\n            f,\n            g = b.button;return null == a.pageX && null != b.clientX && (c = a.target.ownerDocument || d, e = c.documentElement, f = c.body, a.pageX = b.clientX + (e && e.scrollLeft || f && f.scrollLeft || 0) - (e && e.clientLeft || f && f.clientLeft || 0), a.pageY = b.clientY + (e && e.scrollTop || f && f.scrollTop || 0) - (e && e.clientTop || f && f.clientTop || 0)), a.which || void 0 === g || (a.which = 1 & g ? 1 : 2 & g ? 3 : 4 & g ? 2 : 0), a;\n      } }, fix: function fix(a) {\n      if (a[n.expando]) return a;var b,\n          c,\n          e,\n          f = a.type,\n          g = a,\n          h = this.fixHooks[f];h || (this.fixHooks[f] = h = ea.test(f) ? this.mouseHooks : da.test(f) ? this.keyHooks : {}), e = h.props ? this.props.concat(h.props) : this.props, a = new n.Event(g), b = e.length;while (b--) {\n        c = e[b], a[c] = g[c];\n      }return a.target || (a.target = d), 3 === a.target.nodeType && (a.target = a.target.parentNode), h.filter ? h.filter(a, g) : a;\n    }, special: { load: { noBubble: !0 }, focus: { trigger: function trigger() {\n          return this !== ia() && this.focus ? (this.focus(), !1) : void 0;\n        }, delegateType: \"focusin\" }, blur: { trigger: function trigger() {\n          return this === ia() && this.blur ? (this.blur(), !1) : void 0;\n        }, delegateType: \"focusout\" }, click: { trigger: function trigger() {\n          return \"checkbox\" === this.type && this.click && n.nodeName(this, \"input\") ? (this.click(), !1) : void 0;\n        }, _default: function _default(a) {\n          return n.nodeName(a.target, \"a\");\n        } }, beforeunload: { postDispatch: function postDispatch(a) {\n          void 0 !== a.result && a.originalEvent && (a.originalEvent.returnValue = a.result);\n        } } } }, n.removeEvent = function (a, b, c) {\n    a.removeEventListener && a.removeEventListener(b, c);\n  }, n.Event = function (a, b) {\n    return this instanceof n.Event ? (a && a.type ? (this.originalEvent = a, this.type = a.type, this.isDefaultPrevented = a.defaultPrevented || void 0 === a.defaultPrevented && a.returnValue === !1 ? ga : ha) : this.type = a, b && n.extend(this, b), this.timeStamp = a && a.timeStamp || n.now(), void (this[n.expando] = !0)) : new n.Event(a, b);\n  }, n.Event.prototype = { constructor: n.Event, isDefaultPrevented: ha, isPropagationStopped: ha, isImmediatePropagationStopped: ha, isSimulated: !1, preventDefault: function preventDefault() {\n      var a = this.originalEvent;this.isDefaultPrevented = ga, a && !this.isSimulated && a.preventDefault();\n    }, stopPropagation: function stopPropagation() {\n      var a = this.originalEvent;this.isPropagationStopped = ga, a && !this.isSimulated && a.stopPropagation();\n    }, stopImmediatePropagation: function stopImmediatePropagation() {\n      var a = this.originalEvent;this.isImmediatePropagationStopped = ga, a && !this.isSimulated && a.stopImmediatePropagation(), this.stopPropagation();\n    } }, n.each({ mouseenter: \"mouseover\", mouseleave: \"mouseout\", pointerenter: \"pointerover\", pointerleave: \"pointerout\" }, function (a, b) {\n    n.event.special[a] = { delegateType: b, bindType: b, handle: function handle(a) {\n        var c,\n            d = this,\n            e = a.relatedTarget,\n            f = a.handleObj;return e && (e === d || n.contains(d, e)) || (a.type = f.origType, c = f.handler.apply(this, arguments), a.type = b), c;\n      } };\n  }), n.fn.extend({ on: function on(a, b, c, d) {\n      return ja(this, a, b, c, d);\n    }, one: function one(a, b, c, d) {\n      return ja(this, a, b, c, d, 1);\n    }, off: function off(a, b, c) {\n      var d, e;if (a && a.preventDefault && a.handleObj) return d = a.handleObj, n(a.delegateTarget).off(d.namespace ? d.origType + \".\" + d.namespace : d.origType, d.selector, d.handler), this;if (\"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a))) {\n        for (e in a) {\n          this.off(e, b, a[e]);\n        }return this;\n      }return b !== !1 && \"function\" != typeof b || (c = b, b = void 0), c === !1 && (c = ha), this.each(function () {\n        n.event.remove(this, a, c, b);\n      });\n    } });var ka = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:-]+)[^>]*)\\/>/gi,\n      la = /<script|<style|<link/i,\n      ma = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n      na = /^true\\/(.*)/,\n      oa = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g;function pa(a, b) {\n    return n.nodeName(a, \"table\") && n.nodeName(11 !== b.nodeType ? b : b.firstChild, \"tr\") ? a.getElementsByTagName(\"tbody\")[0] || a.appendChild(a.ownerDocument.createElement(\"tbody\")) : a;\n  }function qa(a) {\n    return a.type = (null !== a.getAttribute(\"type\")) + \"/\" + a.type, a;\n  }function ra(a) {\n    var b = na.exec(a.type);return b ? a.type = b[1] : a.removeAttribute(\"type\"), a;\n  }function sa(a, b) {\n    var c, d, e, f, g, h, i, j;if (1 === b.nodeType) {\n      if (N.hasData(a) && (f = N.access(a), g = N.set(b, f), j = f.events)) {\n        delete g.handle, g.events = {};for (e in j) {\n          for (c = 0, d = j[e].length; d > c; c++) {\n            n.event.add(b, e, j[e][c]);\n          }\n        }\n      }O.hasData(a) && (h = O.access(a), i = n.extend({}, h), O.set(b, i));\n    }\n  }function ta(a, b) {\n    var c = b.nodeName.toLowerCase();\"input\" === c && X.test(a.type) ? b.checked = a.checked : \"input\" !== c && \"textarea\" !== c || (b.defaultValue = a.defaultValue);\n  }function ua(a, b, c, d) {\n    b = f.apply([], b);var e,\n        g,\n        h,\n        i,\n        j,\n        k,\n        m = 0,\n        o = a.length,\n        p = o - 1,\n        q = b[0],\n        r = n.isFunction(q);if (r || o > 1 && \"string\" == typeof q && !l.checkClone && ma.test(q)) return a.each(function (e) {\n      var f = a.eq(e);r && (b[0] = q.call(this, e, f.html())), ua(f, b, c, d);\n    });if (o && (e = ca(b, a[0].ownerDocument, !1, a, d), g = e.firstChild, 1 === e.childNodes.length && (e = g), g || d)) {\n      for (h = n.map(_(e, \"script\"), qa), i = h.length; o > m; m++) {\n        j = e, m !== p && (j = n.clone(j, !0, !0), i && n.merge(h, _(j, \"script\"))), c.call(a[m], j, m);\n      }if (i) for (k = h[h.length - 1].ownerDocument, n.map(h, ra), m = 0; i > m; m++) {\n        j = h[m], Z.test(j.type || \"\") && !N.access(j, \"globalEval\") && n.contains(k, j) && (j.src ? n._evalUrl && n._evalUrl(j.src) : n.globalEval(j.textContent.replace(oa, \"\")));\n      }\n    }return a;\n  }function va(a, b, c) {\n    for (var d, e = b ? n.filter(b, a) : a, f = 0; null != (d = e[f]); f++) {\n      c || 1 !== d.nodeType || n.cleanData(_(d)), d.parentNode && (c && n.contains(d.ownerDocument, d) && aa(_(d, \"script\")), d.parentNode.removeChild(d));\n    }return a;\n  }n.extend({ htmlPrefilter: function htmlPrefilter(a) {\n      return a.replace(ka, \"<$1></$2>\");\n    }, clone: function clone(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h = a.cloneNode(!0),\n          i = n.contains(a.ownerDocument, a);if (!(l.noCloneChecked || 1 !== a.nodeType && 11 !== a.nodeType || n.isXMLDoc(a))) for (g = _(h), f = _(a), d = 0, e = f.length; e > d; d++) {\n        ta(f[d], g[d]);\n      }if (b) if (c) for (f = f || _(a), g = g || _(h), d = 0, e = f.length; e > d; d++) {\n        sa(f[d], g[d]);\n      } else sa(a, h);return g = _(h, \"script\"), g.length > 0 && aa(g, !i && _(a, \"script\")), h;\n    }, cleanData: function cleanData(a) {\n      for (var b, c, d, e = n.event.special, f = 0; void 0 !== (c = a[f]); f++) {\n        if (L(c)) {\n          if (b = c[N.expando]) {\n            if (b.events) for (d in b.events) {\n              e[d] ? n.event.remove(c, d) : n.removeEvent(c, d, b.handle);\n            }c[N.expando] = void 0;\n          }c[O.expando] && (c[O.expando] = void 0);\n        }\n      }\n    } }), n.fn.extend({ domManip: ua, detach: function detach(a) {\n      return va(this, a, !0);\n    }, remove: function remove(a) {\n      return va(this, a);\n    }, text: function text(a) {\n      return K(this, function (a) {\n        return void 0 === a ? n.text(this) : this.empty().each(function () {\n          1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = a);\n        });\n      }, null, a, arguments.length);\n    }, append: function append() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.appendChild(a);\n        }\n      });\n    }, prepend: function prepend() {\n      return ua(this, arguments, function (a) {\n        if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {\n          var b = pa(this, a);b.insertBefore(a, b.firstChild);\n        }\n      });\n    }, before: function before() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this);\n      });\n    }, after: function after() {\n      return ua(this, arguments, function (a) {\n        this.parentNode && this.parentNode.insertBefore(a, this.nextSibling);\n      });\n    }, empty: function empty() {\n      for (var a, b = 0; null != (a = this[b]); b++) {\n        1 === a.nodeType && (n.cleanData(_(a, !1)), a.textContent = \"\");\n      }return this;\n    }, clone: function clone(a, b) {\n      return a = null == a ? !1 : a, b = null == b ? a : b, this.map(function () {\n        return n.clone(this, a, b);\n      });\n    }, html: function html(a) {\n      return K(this, function (a) {\n        var b = this[0] || {},\n            c = 0,\n            d = this.length;if (void 0 === a && 1 === b.nodeType) return b.innerHTML;if (\"string\" == typeof a && !la.test(a) && !$[(Y.exec(a) || [\"\", \"\"])[1].toLowerCase()]) {\n          a = n.htmlPrefilter(a);try {\n            for (; d > c; c++) {\n              b = this[c] || {}, 1 === b.nodeType && (n.cleanData(_(b, !1)), b.innerHTML = a);\n            }b = 0;\n          } catch (e) {}\n        }b && this.empty().append(a);\n      }, null, a, arguments.length);\n    }, replaceWith: function replaceWith() {\n      var a = [];return ua(this, arguments, function (b) {\n        var c = this.parentNode;n.inArray(this, a) < 0 && (n.cleanData(_(this)), c && c.replaceChild(b, this));\n      }, a);\n    } }), n.each({ appendTo: \"append\", prependTo: \"prepend\", insertBefore: \"before\", insertAfter: \"after\", replaceAll: \"replaceWith\" }, function (a, b) {\n    n.fn[a] = function (a) {\n      for (var c, d = [], e = n(a), f = e.length - 1, h = 0; f >= h; h++) {\n        c = h === f ? this : this.clone(!0), n(e[h])[b](c), g.apply(d, c.get());\n      }return this.pushStack(d);\n    };\n  });var wa,\n      xa = { HTML: \"block\", BODY: \"block\" };function ya(a, b) {\n    var c = n(b.createElement(a)).appendTo(b.body),\n        d = n.css(c[0], \"display\");return c.detach(), d;\n  }function za(a) {\n    var b = d,\n        c = xa[a];return c || (c = ya(a, b), \"none\" !== c && c || (wa = (wa || n(\"<iframe frameborder='0' width='0' height='0'/>\")).appendTo(b.documentElement), b = wa[0].contentDocument, b.write(), b.close(), c = ya(a, b), wa.detach()), xa[a] = c), c;\n  }var Aa = /^margin/,\n      Ba = new RegExp(\"^(\" + S + \")(?!px)[a-z%]+$\", \"i\"),\n      Ca = function Ca(b) {\n    var c = b.ownerDocument.defaultView;return c && c.opener || (c = a), c.getComputedStyle(b);\n  },\n      Da = function Da(a, b, c, d) {\n    var e,\n        f,\n        g = {};for (f in b) {\n      g[f] = a.style[f], a.style[f] = b[f];\n    }e = c.apply(a, d || []);for (f in b) {\n      a.style[f] = g[f];\n    }return e;\n  },\n      Ea = d.documentElement;!function () {\n    var b,\n        c,\n        e,\n        f,\n        g = d.createElement(\"div\"),\n        h = d.createElement(\"div\");if (h.style) {\n      (function () {\n        var i = function i() {\n          h.style.cssText = \"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%\", h.innerHTML = \"\", Ea.appendChild(g);var d = a.getComputedStyle(h);b = \"1%\" !== d.top, f = \"2px\" === d.marginLeft, c = \"4px\" === d.width, h.style.marginRight = \"50%\", e = \"4px\" === d.marginRight, Ea.removeChild(g);\n        };\n\n        h.style.backgroundClip = \"content-box\", h.cloneNode(!0).style.backgroundClip = \"\", l.clearCloneStyle = \"content-box\" === h.style.backgroundClip, g.style.cssText = \"border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute\", g.appendChild(h);n.extend(l, { pixelPosition: function pixelPosition() {\n            return i(), b;\n          }, boxSizingReliable: function boxSizingReliable() {\n            return null == c && i(), c;\n          }, pixelMarginRight: function pixelMarginRight() {\n            return null == c && i(), e;\n          }, reliableMarginLeft: function reliableMarginLeft() {\n            return null == c && i(), f;\n          }, reliableMarginRight: function reliableMarginRight() {\n            var b,\n                c = h.appendChild(d.createElement(\"div\"));return c.style.cssText = h.style.cssText = \"-webkit-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0\", c.style.marginRight = c.style.width = \"0\", h.style.width = \"1px\", Ea.appendChild(g), b = !parseFloat(a.getComputedStyle(c).marginRight), Ea.removeChild(g), h.removeChild(c), b;\n          } });\n      })();\n    }\n  }();function Fa(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.style;return c = c || Ca(a), g = c ? c.getPropertyValue(b) || c[b] : void 0, \"\" !== g && void 0 !== g || n.contains(a.ownerDocument, a) || (g = n.style(a, b)), c && !l.pixelMarginRight() && Ba.test(g) && Aa.test(b) && (d = h.width, e = h.minWidth, f = h.maxWidth, h.minWidth = h.maxWidth = h.width = g, g = c.width, h.width = d, h.minWidth = e, h.maxWidth = f), void 0 !== g ? g + \"\" : g;\n  }function Ga(a, b) {\n    return { get: function get() {\n        return a() ? void delete this.get : (this.get = b).apply(this, arguments);\n      } };\n  }var Ha = /^(none|table(?!-c[ea]).+)/,\n      Ia = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n      Ja = { letterSpacing: \"0\", fontWeight: \"400\" },\n      Ka = [\"Webkit\", \"O\", \"Moz\", \"ms\"],\n      La = d.createElement(\"div\").style;function Ma(a) {\n    if (a in La) return a;var b = a[0].toUpperCase() + a.slice(1),\n        c = Ka.length;while (c--) {\n      if (a = Ka[c] + b, a in La) return a;\n    }\n  }function Na(a, b, c) {\n    var d = T.exec(b);return d ? Math.max(0, d[2] - (c || 0)) + (d[3] || \"px\") : b;\n  }function Oa(a, b, c, d, e) {\n    for (var f = c === (d ? \"border\" : \"content\") ? 4 : \"width\" === b ? 1 : 0, g = 0; 4 > f; f += 2) {\n      \"margin\" === c && (g += n.css(a, c + U[f], !0, e)), d ? (\"content\" === c && (g -= n.css(a, \"padding\" + U[f], !0, e)), \"margin\" !== c && (g -= n.css(a, \"border\" + U[f] + \"Width\", !0, e))) : (g += n.css(a, \"padding\" + U[f], !0, e), \"padding\" !== c && (g += n.css(a, \"border\" + U[f] + \"Width\", !0, e)));\n    }return g;\n  }function Pa(a, b, c) {\n    var d = !0,\n        e = \"width\" === b ? a.offsetWidth : a.offsetHeight,\n        f = Ca(a),\n        g = \"border-box\" === n.css(a, \"boxSizing\", !1, f);if (0 >= e || null == e) {\n      if (e = Fa(a, b, f), (0 > e || null == e) && (e = a.style[b]), Ba.test(e)) return e;d = g && (l.boxSizingReliable() || e === a.style[b]), e = parseFloat(e) || 0;\n    }return e + Oa(a, b, c || (g ? \"border\" : \"content\"), d, f) + \"px\";\n  }function Qa(a, b) {\n    for (var c, d, e, f = [], g = 0, h = a.length; h > g; g++) {\n      d = a[g], d.style && (f[g] = N.get(d, \"olddisplay\"), c = d.style.display, b ? (f[g] || \"none\" !== c || (d.style.display = \"\"), \"\" === d.style.display && V(d) && (f[g] = N.access(d, \"olddisplay\", za(d.nodeName)))) : (e = V(d), \"none\" === c && e || N.set(d, \"olddisplay\", e ? c : n.css(d, \"display\"))));\n    }for (g = 0; h > g; g++) {\n      d = a[g], d.style && (b && \"none\" !== d.style.display && \"\" !== d.style.display || (d.style.display = b ? f[g] || \"\" : \"none\"));\n    }return a;\n  }n.extend({ cssHooks: { opacity: { get: function get(a, b) {\n          if (b) {\n            var c = Fa(a, \"opacity\");return \"\" === c ? \"1\" : c;\n          }\n        } } }, cssNumber: { animationIterationCount: !0, columnCount: !0, fillOpacity: !0, flexGrow: !0, flexShrink: !0, fontWeight: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, widows: !0, zIndex: !0, zoom: !0 }, cssProps: { \"float\": \"cssFloat\" }, style: function style(a, b, c, d) {\n      if (a && 3 !== a.nodeType && 8 !== a.nodeType && a.style) {\n        var e,\n            f,\n            g,\n            h = n.camelCase(b),\n            i = a.style;return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], void 0 === c ? g && \"get\" in g && void 0 !== (e = g.get(a, !1, d)) ? e : i[b] : (f = typeof c === \"undefined\" ? \"undefined\" : _typeof(c), \"string\" === f && (e = T.exec(c)) && e[1] && (c = W(a, b, e), f = \"number\"), null != c && c === c && (\"number\" === f && (c += e && e[3] || (n.cssNumber[h] ? \"\" : \"px\")), l.clearCloneStyle || \"\" !== c || 0 !== b.indexOf(\"background\") || (i[b] = \"inherit\"), g && \"set\" in g && void 0 === (c = g.set(a, c, d)) || (i[b] = c)), void 0);\n      }\n    }, css: function css(a, b, c, d) {\n      var e,\n          f,\n          g,\n          h = n.camelCase(b);return b = n.cssProps[h] || (n.cssProps[h] = Ma(h) || h), g = n.cssHooks[b] || n.cssHooks[h], g && \"get\" in g && (e = g.get(a, !0, c)), void 0 === e && (e = Fa(a, b, d)), \"normal\" === e && b in Ja && (e = Ja[b]), \"\" === c || c ? (f = parseFloat(e), c === !0 || isFinite(f) ? f || 0 : e) : e;\n    } }), n.each([\"height\", \"width\"], function (a, b) {\n    n.cssHooks[b] = { get: function get(a, c, d) {\n        return c ? Ha.test(n.css(a, \"display\")) && 0 === a.offsetWidth ? Da(a, Ia, function () {\n          return Pa(a, b, d);\n        }) : Pa(a, b, d) : void 0;\n      }, set: function set(a, c, d) {\n        var e,\n            f = d && Ca(a),\n            g = d && Oa(a, b, d, \"border-box\" === n.css(a, \"boxSizing\", !1, f), f);return g && (e = T.exec(c)) && \"px\" !== (e[3] || \"px\") && (a.style[b] = c, c = n.css(a, b)), Na(a, c, g);\n      } };\n  }), n.cssHooks.marginLeft = Ga(l.reliableMarginLeft, function (a, b) {\n    return b ? (parseFloat(Fa(a, \"marginLeft\")) || a.getBoundingClientRect().left - Da(a, { marginLeft: 0 }, function () {\n      return a.getBoundingClientRect().left;\n    })) + \"px\" : void 0;\n  }), n.cssHooks.marginRight = Ga(l.reliableMarginRight, function (a, b) {\n    return b ? Da(a, { display: \"inline-block\" }, Fa, [a, \"marginRight\"]) : void 0;\n  }), n.each({ margin: \"\", padding: \"\", border: \"Width\" }, function (a, b) {\n    n.cssHooks[a + b] = { expand: function expand(c) {\n        for (var d = 0, e = {}, f = \"string\" == typeof c ? c.split(\" \") : [c]; 4 > d; d++) {\n          e[a + U[d] + b] = f[d] || f[d - 2] || f[0];\n        }return e;\n      } }, Aa.test(a) || (n.cssHooks[a + b].set = Na);\n  }), n.fn.extend({ css: function css(a, b) {\n      return K(this, function (a, b, c) {\n        var d,\n            e,\n            f = {},\n            g = 0;if (n.isArray(b)) {\n          for (d = Ca(a), e = b.length; e > g; g++) {\n            f[b[g]] = n.css(a, b[g], !1, d);\n          }return f;\n        }return void 0 !== c ? n.style(a, b, c) : n.css(a, b);\n      }, a, b, arguments.length > 1);\n    }, show: function show() {\n      return Qa(this, !0);\n    }, hide: function hide() {\n      return Qa(this);\n    }, toggle: function toggle(a) {\n      return \"boolean\" == typeof a ? a ? this.show() : this.hide() : this.each(function () {\n        V(this) ? n(this).show() : n(this).hide();\n      });\n    } });function Ra(a, b, c, d, e) {\n    return new Ra.prototype.init(a, b, c, d, e);\n  }n.Tween = Ra, Ra.prototype = { constructor: Ra, init: function init(a, b, c, d, e, f) {\n      this.elem = a, this.prop = c, this.easing = e || n.easing._default, this.options = b, this.start = this.now = this.cur(), this.end = d, this.unit = f || (n.cssNumber[c] ? \"\" : \"px\");\n    }, cur: function cur() {\n      var a = Ra.propHooks[this.prop];return a && a.get ? a.get(this) : Ra.propHooks._default.get(this);\n    }, run: function run(a) {\n      var b,\n          c = Ra.propHooks[this.prop];return this.options.duration ? this.pos = b = n.easing[this.easing](a, this.options.duration * a, 0, 1, this.options.duration) : this.pos = b = a, this.now = (this.end - this.start) * b + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), c && c.set ? c.set(this) : Ra.propHooks._default.set(this), this;\n    } }, Ra.prototype.init.prototype = Ra.prototype, Ra.propHooks = { _default: { get: function get(a) {\n        var b;return 1 !== a.elem.nodeType || null != a.elem[a.prop] && null == a.elem.style[a.prop] ? a.elem[a.prop] : (b = n.css(a.elem, a.prop, \"\"), b && \"auto\" !== b ? b : 0);\n      }, set: function set(a) {\n        n.fx.step[a.prop] ? n.fx.step[a.prop](a) : 1 !== a.elem.nodeType || null == a.elem.style[n.cssProps[a.prop]] && !n.cssHooks[a.prop] ? a.elem[a.prop] = a.now : n.style(a.elem, a.prop, a.now + a.unit);\n      } } }, Ra.propHooks.scrollTop = Ra.propHooks.scrollLeft = { set: function set(a) {\n      a.elem.nodeType && a.elem.parentNode && (a.elem[a.prop] = a.now);\n    } }, n.easing = { linear: function linear(a) {\n      return a;\n    }, swing: function swing(a) {\n      return .5 - Math.cos(a * Math.PI) / 2;\n    }, _default: \"swing\" }, n.fx = Ra.prototype.init, n.fx.step = {};var Sa,\n      Ta,\n      Ua = /^(?:toggle|show|hide)$/,\n      Va = /queueHooks$/;function Wa() {\n    return a.setTimeout(function () {\n      Sa = void 0;\n    }), Sa = n.now();\n  }function Xa(a, b) {\n    var c,\n        d = 0,\n        e = { height: a };for (b = b ? 1 : 0; 4 > d; d += 2 - b) {\n      c = U[d], e[\"margin\" + c] = e[\"padding\" + c] = a;\n    }return b && (e.opacity = e.width = a), e;\n  }function Ya(a, b, c) {\n    for (var d, e = (_a.tweeners[b] || []).concat(_a.tweeners[\"*\"]), f = 0, g = e.length; g > f; f++) {\n      if (d = e[f].call(c, b, a)) return d;\n    }\n  }function Za(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h,\n        i,\n        j,\n        k,\n        l = this,\n        m = {},\n        o = a.style,\n        p = a.nodeType && V(a),\n        q = N.get(a, \"fxshow\");c.queue || (h = n._queueHooks(a, \"fx\"), null == h.unqueued && (h.unqueued = 0, i = h.empty.fire, h.empty.fire = function () {\n      h.unqueued || i();\n    }), h.unqueued++, l.always(function () {\n      l.always(function () {\n        h.unqueued--, n.queue(a, \"fx\").length || h.empty.fire();\n      });\n    })), 1 === a.nodeType && (\"height\" in b || \"width\" in b) && (c.overflow = [o.overflow, o.overflowX, o.overflowY], j = n.css(a, \"display\"), k = \"none\" === j ? N.get(a, \"olddisplay\") || za(a.nodeName) : j, \"inline\" === k && \"none\" === n.css(a, \"float\") && (o.display = \"inline-block\")), c.overflow && (o.overflow = \"hidden\", l.always(function () {\n      o.overflow = c.overflow[0], o.overflowX = c.overflow[1], o.overflowY = c.overflow[2];\n    }));for (d in b) {\n      if (e = b[d], Ua.exec(e)) {\n        if (delete b[d], f = f || \"toggle\" === e, e === (p ? \"hide\" : \"show\")) {\n          if (\"show\" !== e || !q || void 0 === q[d]) continue;p = !0;\n        }m[d] = q && q[d] || n.style(a, d);\n      } else j = void 0;\n    }if (n.isEmptyObject(m)) \"inline\" === (\"none\" === j ? za(a.nodeName) : j) && (o.display = j);else {\n      q ? \"hidden\" in q && (p = q.hidden) : q = N.access(a, \"fxshow\", {}), f && (q.hidden = !p), p ? n(a).show() : l.done(function () {\n        n(a).hide();\n      }), l.done(function () {\n        var b;N.remove(a, \"fxshow\");for (b in m) {\n          n.style(a, b, m[b]);\n        }\n      });for (d in m) {\n        g = Ya(p ? q[d] : 0, d, l), d in q || (q[d] = g.start, p && (g.end = g.start, g.start = \"width\" === d || \"height\" === d ? 1 : 0));\n      }\n    }\n  }function $a(a, b) {\n    var c, d, e, f, g;for (c in a) {\n      if (d = n.camelCase(c), e = b[d], f = a[c], n.isArray(f) && (e = f[1], f = a[c] = f[0]), c !== d && (a[d] = f, delete a[c]), g = n.cssHooks[d], g && \"expand\" in g) {\n        f = g.expand(f), delete a[d];for (c in f) {\n          c in a || (a[c] = f[c], b[c] = e);\n        }\n      } else b[d] = e;\n    }\n  }function _a(a, b, c) {\n    var d,\n        e,\n        f = 0,\n        g = _a.prefilters.length,\n        h = n.Deferred().always(function () {\n      delete i.elem;\n    }),\n        i = function i() {\n      if (e) return !1;for (var b = Sa || Wa(), c = Math.max(0, j.startTime + j.duration - b), d = c / j.duration || 0, f = 1 - d, g = 0, i = j.tweens.length; i > g; g++) {\n        j.tweens[g].run(f);\n      }return h.notifyWith(a, [j, f, c]), 1 > f && i ? c : (h.resolveWith(a, [j]), !1);\n    },\n        j = h.promise({ elem: a, props: n.extend({}, b), opts: n.extend(!0, { specialEasing: {}, easing: n.easing._default }, c), originalProperties: b, originalOptions: c, startTime: Sa || Wa(), duration: c.duration, tweens: [], createTween: function createTween(b, c) {\n        var d = n.Tween(a, j.opts, b, c, j.opts.specialEasing[b] || j.opts.easing);return j.tweens.push(d), d;\n      }, stop: function stop(b) {\n        var c = 0,\n            d = b ? j.tweens.length : 0;if (e) return this;for (e = !0; d > c; c++) {\n          j.tweens[c].run(1);\n        }return b ? (h.notifyWith(a, [j, 1, 0]), h.resolveWith(a, [j, b])) : h.rejectWith(a, [j, b]), this;\n      } }),\n        k = j.props;for ($a(k, j.opts.specialEasing); g > f; f++) {\n      if (d = _a.prefilters[f].call(j, a, k, j.opts)) return n.isFunction(d.stop) && (n._queueHooks(j.elem, j.opts.queue).stop = n.proxy(d.stop, d)), d;\n    }return n.map(k, Ya, j), n.isFunction(j.opts.start) && j.opts.start.call(a, j), n.fx.timer(n.extend(i, { elem: a, anim: j, queue: j.opts.queue })), j.progress(j.opts.progress).done(j.opts.done, j.opts.complete).fail(j.opts.fail).always(j.opts.always);\n  }n.Animation = n.extend(_a, { tweeners: { \"*\": [function (a, b) {\n        var c = this.createTween(a, b);return W(c.elem, a, T.exec(b), c), c;\n      }] }, tweener: function tweener(a, b) {\n      n.isFunction(a) ? (b = a, a = [\"*\"]) : a = a.match(G);for (var c, d = 0, e = a.length; e > d; d++) {\n        c = a[d], _a.tweeners[c] = _a.tweeners[c] || [], _a.tweeners[c].unshift(b);\n      }\n    }, prefilters: [Za], prefilter: function prefilter(a, b) {\n      b ? _a.prefilters.unshift(a) : _a.prefilters.push(a);\n    } }), n.speed = function (a, b, c) {\n    var d = a && \"object\" == (typeof a === \"undefined\" ? \"undefined\" : _typeof(a)) ? n.extend({}, a) : { complete: c || !c && b || n.isFunction(a) && a, duration: a, easing: c && b || b && !n.isFunction(b) && b };return d.duration = n.fx.off ? 0 : \"number\" == typeof d.duration ? d.duration : d.duration in n.fx.speeds ? n.fx.speeds[d.duration] : n.fx.speeds._default, null != d.queue && d.queue !== !0 || (d.queue = \"fx\"), d.old = d.complete, d.complete = function () {\n      n.isFunction(d.old) && d.old.call(this), d.queue && n.dequeue(this, d.queue);\n    }, d;\n  }, n.fn.extend({ fadeTo: function fadeTo(a, b, c, d) {\n      return this.filter(V).css(\"opacity\", 0).show().end().animate({ opacity: b }, a, c, d);\n    }, animate: function animate(a, b, c, d) {\n      var e = n.isEmptyObject(a),\n          f = n.speed(b, c, d),\n          g = function g() {\n        var b = _a(this, n.extend({}, a), f);(e || N.get(this, \"finish\")) && b.stop(!0);\n      };return g.finish = g, e || f.queue === !1 ? this.each(g) : this.queue(f.queue, g);\n    }, stop: function stop(a, b, c) {\n      var d = function d(a) {\n        var b = a.stop;delete a.stop, b(c);\n      };return \"string\" != typeof a && (c = b, b = a, a = void 0), b && a !== !1 && this.queue(a || \"fx\", []), this.each(function () {\n        var b = !0,\n            e = null != a && a + \"queueHooks\",\n            f = n.timers,\n            g = N.get(this);if (e) g[e] && g[e].stop && d(g[e]);else for (e in g) {\n          g[e] && g[e].stop && Va.test(e) && d(g[e]);\n        }for (e = f.length; e--;) {\n          f[e].elem !== this || null != a && f[e].queue !== a || (f[e].anim.stop(c), b = !1, f.splice(e, 1));\n        }!b && c || n.dequeue(this, a);\n      });\n    }, finish: function finish(a) {\n      return a !== !1 && (a = a || \"fx\"), this.each(function () {\n        var b,\n            c = N.get(this),\n            d = c[a + \"queue\"],\n            e = c[a + \"queueHooks\"],\n            f = n.timers,\n            g = d ? d.length : 0;for (c.finish = !0, n.queue(this, a, []), e && e.stop && e.stop.call(this, !0), b = f.length; b--;) {\n          f[b].elem === this && f[b].queue === a && (f[b].anim.stop(!0), f.splice(b, 1));\n        }for (b = 0; g > b; b++) {\n          d[b] && d[b].finish && d[b].finish.call(this);\n        }delete c.finish;\n      });\n    } }), n.each([\"toggle\", \"show\", \"hide\"], function (a, b) {\n    var c = n.fn[b];n.fn[b] = function (a, d, e) {\n      return null == a || \"boolean\" == typeof a ? c.apply(this, arguments) : this.animate(Xa(b, !0), a, d, e);\n    };\n  }), n.each({ slideDown: Xa(\"show\"), slideUp: Xa(\"hide\"), slideToggle: Xa(\"toggle\"), fadeIn: { opacity: \"show\" }, fadeOut: { opacity: \"hide\" }, fadeToggle: { opacity: \"toggle\" } }, function (a, b) {\n    n.fn[a] = function (a, c, d) {\n      return this.animate(b, a, c, d);\n    };\n  }), n.timers = [], n.fx.tick = function () {\n    var a,\n        b = 0,\n        c = n.timers;for (Sa = n.now(); b < c.length; b++) {\n      a = c[b], a() || c[b] !== a || c.splice(b--, 1);\n    }c.length || n.fx.stop(), Sa = void 0;\n  }, n.fx.timer = function (a) {\n    n.timers.push(a), a() ? n.fx.start() : n.timers.pop();\n  }, n.fx.interval = 13, n.fx.start = function () {\n    Ta || (Ta = a.setInterval(n.fx.tick, n.fx.interval));\n  }, n.fx.stop = function () {\n    a.clearInterval(Ta), Ta = null;\n  }, n.fx.speeds = { slow: 600, fast: 200, _default: 400 }, n.fn.delay = function (b, c) {\n    return b = n.fx ? n.fx.speeds[b] || b : b, c = c || \"fx\", this.queue(c, function (c, d) {\n      var e = a.setTimeout(c, b);d.stop = function () {\n        a.clearTimeout(e);\n      };\n    });\n  }, function () {\n    var a = d.createElement(\"input\"),\n        b = d.createElement(\"select\"),\n        c = b.appendChild(d.createElement(\"option\"));a.type = \"checkbox\", l.checkOn = \"\" !== a.value, l.optSelected = c.selected, b.disabled = !0, l.optDisabled = !c.disabled, a = d.createElement(\"input\"), a.value = \"t\", a.type = \"radio\", l.radioValue = \"t\" === a.value;\n  }();var ab,\n      bb = n.expr.attrHandle;n.fn.extend({ attr: function attr(a, b) {\n      return K(this, n.attr, a, b, arguments.length > 1);\n    }, removeAttr: function removeAttr(a) {\n      return this.each(function () {\n        n.removeAttr(this, a);\n      });\n    } }), n.extend({ attr: function attr(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return \"undefined\" == typeof a.getAttribute ? n.prop(a, b, c) : (1 === f && n.isXMLDoc(a) || (b = b.toLowerCase(), e = n.attrHooks[b] || (n.expr.match.bool.test(b) ? ab : void 0)), void 0 !== c ? null === c ? void n.removeAttr(a, b) : e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : (a.setAttribute(b, c + \"\"), c) : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : (d = n.find.attr(a, b), null == d ? void 0 : d));\n    }, attrHooks: { type: { set: function set(a, b) {\n          if (!l.radioValue && \"radio\" === b && n.nodeName(a, \"input\")) {\n            var c = a.value;return a.setAttribute(\"type\", b), c && (a.value = c), b;\n          }\n        } } }, removeAttr: function removeAttr(a, b) {\n      var c,\n          d,\n          e = 0,\n          f = b && b.match(G);if (f && 1 === a.nodeType) while (c = f[e++]) {\n        d = n.propFix[c] || c, n.expr.match.bool.test(c) && (a[d] = !1), a.removeAttribute(c);\n      }\n    } }), ab = { set: function set(a, b, c) {\n      return b === !1 ? n.removeAttr(a, c) : a.setAttribute(c, c), c;\n    } }, n.each(n.expr.match.bool.source.match(/\\w+/g), function (a, b) {\n    var c = bb[b] || n.find.attr;bb[b] = function (a, b, d) {\n      var e, f;return d || (f = bb[b], bb[b] = e, e = null != c(a, b, d) ? b.toLowerCase() : null, bb[b] = f), e;\n    };\n  });var cb = /^(?:input|select|textarea|button)$/i,\n      db = /^(?:a|area)$/i;n.fn.extend({ prop: function prop(a, b) {\n      return K(this, n.prop, a, b, arguments.length > 1);\n    }, removeProp: function removeProp(a) {\n      return this.each(function () {\n        delete this[n.propFix[a] || a];\n      });\n    } }), n.extend({ prop: function prop(a, b, c) {\n      var d,\n          e,\n          f = a.nodeType;if (3 !== f && 8 !== f && 2 !== f) return 1 === f && n.isXMLDoc(a) || (b = n.propFix[b] || b, e = n.propHooks[b]), void 0 !== c ? e && \"set\" in e && void 0 !== (d = e.set(a, c, b)) ? d : a[b] = c : e && \"get\" in e && null !== (d = e.get(a, b)) ? d : a[b];\n    }, propHooks: { tabIndex: { get: function get(a) {\n          var b = n.find.attr(a, \"tabindex\");return b ? parseInt(b, 10) : cb.test(a.nodeName) || db.test(a.nodeName) && a.href ? 0 : -1;\n        } } }, propFix: { \"for\": \"htmlFor\", \"class\": \"className\" } }), l.optSelected || (n.propHooks.selected = { get: function get(a) {\n      var b = a.parentNode;return b && b.parentNode && b.parentNode.selectedIndex, null;\n    }, set: function set(a) {\n      var b = a.parentNode;b && (b.selectedIndex, b.parentNode && b.parentNode.selectedIndex);\n    } }), n.each([\"tabIndex\", \"readOnly\", \"maxLength\", \"cellSpacing\", \"cellPadding\", \"rowSpan\", \"colSpan\", \"useMap\", \"frameBorder\", \"contentEditable\"], function () {\n    n.propFix[this.toLowerCase()] = this;\n  });var eb = /[\\t\\r\\n\\f]/g;function fb(a) {\n    return a.getAttribute && a.getAttribute(\"class\") || \"\";\n  }n.fn.extend({ addClass: function addClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).addClass(a.call(this, b, fb(this)));\n      });if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              d.indexOf(\" \" + f + \" \") < 0 && (d += f + \" \");\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, removeClass: function removeClass(a) {\n      var b,\n          c,\n          d,\n          e,\n          f,\n          g,\n          h,\n          i = 0;if (n.isFunction(a)) return this.each(function (b) {\n        n(this).removeClass(a.call(this, b, fb(this)));\n      });if (!arguments.length) return this.attr(\"class\", \"\");if (\"string\" == typeof a && a) {\n        b = a.match(G) || [];while (c = this[i++]) {\n          if (e = fb(c), d = 1 === c.nodeType && (\" \" + e + \" \").replace(eb, \" \")) {\n            g = 0;while (f = b[g++]) {\n              while (d.indexOf(\" \" + f + \" \") > -1) {\n                d = d.replace(\" \" + f + \" \", \" \");\n              }\n            }h = n.trim(d), e !== h && c.setAttribute(\"class\", h);\n          }\n        }\n      }return this;\n    }, toggleClass: function toggleClass(a, b) {\n      var c = typeof a === \"undefined\" ? \"undefined\" : _typeof(a);return \"boolean\" == typeof b && \"string\" === c ? b ? this.addClass(a) : this.removeClass(a) : n.isFunction(a) ? this.each(function (c) {\n        n(this).toggleClass(a.call(this, c, fb(this), b), b);\n      }) : this.each(function () {\n        var b, d, e, f;if (\"string\" === c) {\n          d = 0, e = n(this), f = a.match(G) || [];while (b = f[d++]) {\n            e.hasClass(b) ? e.removeClass(b) : e.addClass(b);\n          }\n        } else void 0 !== a && \"boolean\" !== c || (b = fb(this), b && N.set(this, \"__className__\", b), this.setAttribute && this.setAttribute(\"class\", b || a === !1 ? \"\" : N.get(this, \"__className__\") || \"\"));\n      });\n    }, hasClass: function hasClass(a) {\n      var b,\n          c,\n          d = 0;b = \" \" + a + \" \";while (c = this[d++]) {\n        if (1 === c.nodeType && (\" \" + fb(c) + \" \").replace(eb, \" \").indexOf(b) > -1) return !0;\n      }return !1;\n    } });var gb = /\\r/g,\n      hb = /[\\x20\\t\\r\\n\\f]+/g;n.fn.extend({ val: function val(a) {\n      var b,\n          c,\n          d,\n          e = this[0];{\n        if (arguments.length) return d = n.isFunction(a), this.each(function (c) {\n          var e;1 === this.nodeType && (e = d ? a.call(this, c, n(this).val()) : a, null == e ? e = \"\" : \"number\" == typeof e ? e += \"\" : n.isArray(e) && (e = n.map(e, function (a) {\n            return null == a ? \"\" : a + \"\";\n          })), b = n.valHooks[this.type] || n.valHooks[this.nodeName.toLowerCase()], b && \"set\" in b && void 0 !== b.set(this, e, \"value\") || (this.value = e));\n        });if (e) return b = n.valHooks[e.type] || n.valHooks[e.nodeName.toLowerCase()], b && \"get\" in b && void 0 !== (c = b.get(e, \"value\")) ? c : (c = e.value, \"string\" == typeof c ? c.replace(gb, \"\") : null == c ? \"\" : c);\n      }\n    } }), n.extend({ valHooks: { option: { get: function get(a) {\n          var b = n.find.attr(a, \"value\");return null != b ? b : n.trim(n.text(a)).replace(hb, \" \");\n        } }, select: { get: function get(a) {\n          for (var b, c, d = a.options, e = a.selectedIndex, f = \"select-one\" === a.type || 0 > e, g = f ? null : [], h = f ? e + 1 : d.length, i = 0 > e ? h : f ? e : 0; h > i; i++) {\n            if (c = d[i], (c.selected || i === e) && (l.optDisabled ? !c.disabled : null === c.getAttribute(\"disabled\")) && (!c.parentNode.disabled || !n.nodeName(c.parentNode, \"optgroup\"))) {\n              if (b = n(c).val(), f) return b;g.push(b);\n            }\n          }return g;\n        }, set: function set(a, b) {\n          var c,\n              d,\n              e = a.options,\n              f = n.makeArray(b),\n              g = e.length;while (g--) {\n            d = e[g], (d.selected = n.inArray(n.valHooks.option.get(d), f) > -1) && (c = !0);\n          }return c || (a.selectedIndex = -1), f;\n        } } } }), n.each([\"radio\", \"checkbox\"], function () {\n    n.valHooks[this] = { set: function set(a, b) {\n        return n.isArray(b) ? a.checked = n.inArray(n(a).val(), b) > -1 : void 0;\n      } }, l.checkOn || (n.valHooks[this].get = function (a) {\n      return null === a.getAttribute(\"value\") ? \"on\" : a.value;\n    });\n  });var ib = /^(?:focusinfocus|focusoutblur)$/;n.extend(n.event, { trigger: function trigger(b, c, e, f) {\n      var g,\n          h,\n          i,\n          j,\n          l,\n          m,\n          o,\n          p = [e || d],\n          q = k.call(b, \"type\") ? b.type : b,\n          r = k.call(b, \"namespace\") ? b.namespace.split(\".\") : [];if (h = i = e = e || d, 3 !== e.nodeType && 8 !== e.nodeType && !ib.test(q + n.event.triggered) && (q.indexOf(\".\") > -1 && (r = q.split(\".\"), q = r.shift(), r.sort()), l = q.indexOf(\":\") < 0 && \"on\" + q, b = b[n.expando] ? b : new n.Event(q, \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && b), b.isTrigger = f ? 2 : 3, b.namespace = r.join(\".\"), b.rnamespace = b.namespace ? new RegExp(\"(^|\\\\.)\" + r.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\") : null, b.result = void 0, b.target || (b.target = e), c = null == c ? [b] : n.makeArray(c, [b]), o = n.event.special[q] || {}, f || !o.trigger || o.trigger.apply(e, c) !== !1)) {\n        if (!f && !o.noBubble && !n.isWindow(e)) {\n          for (j = o.delegateType || q, ib.test(j + q) || (h = h.parentNode); h; h = h.parentNode) {\n            p.push(h), i = h;\n          }i === (e.ownerDocument || d) && p.push(i.defaultView || i.parentWindow || a);\n        }g = 0;while ((h = p[g++]) && !b.isPropagationStopped()) {\n          b.type = g > 1 ? j : o.bindType || q, m = (N.get(h, \"events\") || {})[b.type] && N.get(h, \"handle\"), m && m.apply(h, c), m = l && h[l], m && m.apply && L(h) && (b.result = m.apply(h, c), b.result === !1 && b.preventDefault());\n        }return b.type = q, f || b.isDefaultPrevented() || o._default && o._default.apply(p.pop(), c) !== !1 || !L(e) || l && n.isFunction(e[q]) && !n.isWindow(e) && (i = e[l], i && (e[l] = null), n.event.triggered = q, e[q](), n.event.triggered = void 0, i && (e[l] = i)), b.result;\n      }\n    }, simulate: function simulate(a, b, c) {\n      var d = n.extend(new n.Event(), c, { type: a, isSimulated: !0 });n.event.trigger(d, null, b);\n    } }), n.fn.extend({ trigger: function trigger(a, b) {\n      return this.each(function () {\n        n.event.trigger(a, b, this);\n      });\n    }, triggerHandler: function triggerHandler(a, b) {\n      var c = this[0];return c ? n.event.trigger(a, b, c, !0) : void 0;\n    } }), n.each(\"blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu\".split(\" \"), function (a, b) {\n    n.fn[b] = function (a, c) {\n      return arguments.length > 0 ? this.on(b, null, a, c) : this.trigger(b);\n    };\n  }), n.fn.extend({ hover: function hover(a, b) {\n      return this.mouseenter(a).mouseleave(b || a);\n    } }), l.focusin = \"onfocusin\" in a, l.focusin || n.each({ focus: \"focusin\", blur: \"focusout\" }, function (a, b) {\n    var c = function c(a) {\n      n.event.simulate(b, a.target, n.event.fix(a));\n    };n.event.special[b] = { setup: function setup() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b);e || d.addEventListener(a, c, !0), N.access(d, b, (e || 0) + 1);\n      }, teardown: function teardown() {\n        var d = this.ownerDocument || this,\n            e = N.access(d, b) - 1;e ? N.access(d, b, e) : (d.removeEventListener(a, c, !0), N.remove(d, b));\n      } };\n  });var jb = a.location,\n      kb = n.now(),\n      lb = /\\?/;n.parseJSON = function (a) {\n    return JSON.parse(a + \"\");\n  }, n.parseXML = function (b) {\n    var c;if (!b || \"string\" != typeof b) return null;try {\n      c = new a.DOMParser().parseFromString(b, \"text/xml\");\n    } catch (d) {\n      c = void 0;\n    }return c && !c.getElementsByTagName(\"parsererror\").length || n.error(\"Invalid XML: \" + b), c;\n  };var mb = /#.*$/,\n      nb = /([?&])_=[^&]*/,\n      ob = /^(.*?):[ \\t]*([^\\r\\n]*)$/gm,\n      pb = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      qb = /^(?:GET|HEAD)$/,\n      rb = /^\\/\\//,\n      sb = {},\n      tb = {},\n      ub = \"*/\".concat(\"*\"),\n      vb = d.createElement(\"a\");vb.href = jb.href;function wb(a) {\n    return function (b, c) {\n      \"string\" != typeof b && (c = b, b = \"*\");var d,\n          e = 0,\n          f = b.toLowerCase().match(G) || [];if (n.isFunction(c)) while (d = f[e++]) {\n        \"+\" === d[0] ? (d = d.slice(1) || \"*\", (a[d] = a[d] || []).unshift(c)) : (a[d] = a[d] || []).push(c);\n      }\n    };\n  }function xb(a, b, c, d) {\n    var e = {},\n        f = a === tb;function g(h) {\n      var i;return e[h] = !0, n.each(a[h] || [], function (a, h) {\n        var j = h(b, c, d);return \"string\" != typeof j || f || e[j] ? f ? !(i = j) : void 0 : (b.dataTypes.unshift(j), g(j), !1);\n      }), i;\n    }return g(b.dataTypes[0]) || !e[\"*\"] && g(\"*\");\n  }function yb(a, b) {\n    var c,\n        d,\n        e = n.ajaxSettings.flatOptions || {};for (c in b) {\n      void 0 !== b[c] && ((e[c] ? a : d || (d = {}))[c] = b[c]);\n    }return d && n.extend(!0, a, d), a;\n  }function zb(a, b, c) {\n    var d,\n        e,\n        f,\n        g,\n        h = a.contents,\n        i = a.dataTypes;while (\"*\" === i[0]) {\n      i.shift(), void 0 === d && (d = a.mimeType || b.getResponseHeader(\"Content-Type\"));\n    }if (d) for (e in h) {\n      if (h[e] && h[e].test(d)) {\n        i.unshift(e);break;\n      }\n    }if (i[0] in c) f = i[0];else {\n      for (e in c) {\n        if (!i[0] || a.converters[e + \" \" + i[0]]) {\n          f = e;break;\n        }g || (g = e);\n      }f = f || g;\n    }return f ? (f !== i[0] && i.unshift(f), c[f]) : void 0;\n  }function Ab(a, b, c, d) {\n    var e,\n        f,\n        g,\n        h,\n        i,\n        j = {},\n        k = a.dataTypes.slice();if (k[1]) for (g in a.converters) {\n      j[g.toLowerCase()] = a.converters[g];\n    }f = k.shift();while (f) {\n      if (a.responseFields[f] && (c[a.responseFields[f]] = b), !i && d && a.dataFilter && (b = a.dataFilter(b, a.dataType)), i = f, f = k.shift()) if (\"*\" === f) f = i;else if (\"*\" !== i && i !== f) {\n        if (g = j[i + \" \" + f] || j[\"* \" + f], !g) for (e in j) {\n          if (h = e.split(\" \"), h[1] === f && (g = j[i + \" \" + h[0]] || j[\"* \" + h[0]])) {\n            g === !0 ? g = j[e] : j[e] !== !0 && (f = h[0], k.unshift(h[1]));break;\n          }\n        }if (g !== !0) if (g && a[\"throws\"]) b = g(b);else try {\n          b = g(b);\n        } catch (l) {\n          return { state: \"parsererror\", error: g ? l : \"No conversion from \" + i + \" to \" + f };\n        }\n      }\n    }return { state: \"success\", data: b };\n  }n.extend({ active: 0, lastModified: {}, etag: {}, ajaxSettings: { url: jb.href, type: \"GET\", isLocal: pb.test(jb.protocol), global: !0, processData: !0, async: !0, contentType: \"application/x-www-form-urlencoded; charset=UTF-8\", accepts: { \"*\": ub, text: \"text/plain\", html: \"text/html\", xml: \"application/xml, text/xml\", json: \"application/json, text/javascript\" }, contents: { xml: /\\bxml\\b/, html: /\\bhtml/, json: /\\bjson\\b/ }, responseFields: { xml: \"responseXML\", text: \"responseText\", json: \"responseJSON\" }, converters: { \"* text\": String, \"text html\": !0, \"text json\": n.parseJSON, \"text xml\": n.parseXML }, flatOptions: { url: !0, context: !0 } }, ajaxSetup: function ajaxSetup(a, b) {\n      return b ? yb(yb(a, n.ajaxSettings), b) : yb(n.ajaxSettings, a);\n    }, ajaxPrefilter: wb(sb), ajaxTransport: wb(tb), ajax: function ajax(b, c) {\n      \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (c = b, b = void 0), c = c || {};var e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k,\n          l,\n          m = n.ajaxSetup({}, c),\n          o = m.context || m,\n          p = m.context && (o.nodeType || o.jquery) ? n(o) : n.event,\n          q = n.Deferred(),\n          r = n.Callbacks(\"once memory\"),\n          s = m.statusCode || {},\n          t = {},\n          u = {},\n          v = 0,\n          w = \"canceled\",\n          x = { readyState: 0, getResponseHeader: function getResponseHeader(a) {\n          var b;if (2 === v) {\n            if (!h) {\n              h = {};while (b = ob.exec(g)) {\n                h[b[1].toLowerCase()] = b[2];\n              }\n            }b = h[a.toLowerCase()];\n          }return null == b ? null : b;\n        }, getAllResponseHeaders: function getAllResponseHeaders() {\n          return 2 === v ? g : null;\n        }, setRequestHeader: function setRequestHeader(a, b) {\n          var c = a.toLowerCase();return v || (a = u[c] = u[c] || a, t[a] = b), this;\n        }, overrideMimeType: function overrideMimeType(a) {\n          return v || (m.mimeType = a), this;\n        }, statusCode: function statusCode(a) {\n          var b;if (a) if (2 > v) for (b in a) {\n            s[b] = [s[b], a[b]];\n          } else x.always(a[x.status]);return this;\n        }, abort: function abort(a) {\n          var b = a || w;return e && e.abort(b), z(0, b), this;\n        } };if (q.promise(x).complete = r.add, x.success = x.done, x.error = x.fail, m.url = ((b || m.url || jb.href) + \"\").replace(mb, \"\").replace(rb, jb.protocol + \"//\"), m.type = c.method || c.type || m.method || m.type, m.dataTypes = n.trim(m.dataType || \"*\").toLowerCase().match(G) || [\"\"], null == m.crossDomain) {\n        j = d.createElement(\"a\");try {\n          j.href = m.url, j.href = j.href, m.crossDomain = vb.protocol + \"//\" + vb.host != j.protocol + \"//\" + j.host;\n        } catch (y) {\n          m.crossDomain = !0;\n        }\n      }if (m.data && m.processData && \"string\" != typeof m.data && (m.data = n.param(m.data, m.traditional)), xb(sb, m, c, x), 2 === v) return x;k = n.event && m.global, k && 0 === n.active++ && n.event.trigger(\"ajaxStart\"), m.type = m.type.toUpperCase(), m.hasContent = !qb.test(m.type), f = m.url, m.hasContent || (m.data && (f = m.url += (lb.test(f) ? \"&\" : \"?\") + m.data, delete m.data), m.cache === !1 && (m.url = nb.test(f) ? f.replace(nb, \"$1_=\" + kb++) : f + (lb.test(f) ? \"&\" : \"?\") + \"_=\" + kb++)), m.ifModified && (n.lastModified[f] && x.setRequestHeader(\"If-Modified-Since\", n.lastModified[f]), n.etag[f] && x.setRequestHeader(\"If-None-Match\", n.etag[f])), (m.data && m.hasContent && m.contentType !== !1 || c.contentType) && x.setRequestHeader(\"Content-Type\", m.contentType), x.setRequestHeader(\"Accept\", m.dataTypes[0] && m.accepts[m.dataTypes[0]] ? m.accepts[m.dataTypes[0]] + (\"*\" !== m.dataTypes[0] ? \", \" + ub + \"; q=0.01\" : \"\") : m.accepts[\"*\"]);for (l in m.headers) {\n        x.setRequestHeader(l, m.headers[l]);\n      }if (m.beforeSend && (m.beforeSend.call(o, x, m) === !1 || 2 === v)) return x.abort();w = \"abort\";for (l in { success: 1, error: 1, complete: 1 }) {\n        x[l](m[l]);\n      }if (e = xb(tb, m, c, x)) {\n        if (x.readyState = 1, k && p.trigger(\"ajaxSend\", [x, m]), 2 === v) return x;m.async && m.timeout > 0 && (i = a.setTimeout(function () {\n          x.abort(\"timeout\");\n        }, m.timeout));try {\n          v = 1, e.send(t, z);\n        } catch (y) {\n          if (!(2 > v)) throw y;z(-1, y);\n        }\n      } else z(-1, \"No Transport\");function z(b, c, d, h) {\n        var j,\n            l,\n            t,\n            u,\n            w,\n            y = c;2 !== v && (v = 2, i && a.clearTimeout(i), e = void 0, g = h || \"\", x.readyState = b > 0 ? 4 : 0, j = b >= 200 && 300 > b || 304 === b, d && (u = zb(m, x, d)), u = Ab(m, u, x, j), j ? (m.ifModified && (w = x.getResponseHeader(\"Last-Modified\"), w && (n.lastModified[f] = w), w = x.getResponseHeader(\"etag\"), w && (n.etag[f] = w)), 204 === b || \"HEAD\" === m.type ? y = \"nocontent\" : 304 === b ? y = \"notmodified\" : (y = u.state, l = u.data, t = u.error, j = !t)) : (t = y, !b && y || (y = \"error\", 0 > b && (b = 0))), x.status = b, x.statusText = (c || y) + \"\", j ? q.resolveWith(o, [l, y, x]) : q.rejectWith(o, [x, y, t]), x.statusCode(s), s = void 0, k && p.trigger(j ? \"ajaxSuccess\" : \"ajaxError\", [x, m, j ? l : t]), r.fireWith(o, [x, y]), k && (p.trigger(\"ajaxComplete\", [x, m]), --n.active || n.event.trigger(\"ajaxStop\")));\n      }return x;\n    }, getJSON: function getJSON(a, b, c) {\n      return n.get(a, b, c, \"json\");\n    }, getScript: function getScript(a, b) {\n      return n.get(a, void 0, b, \"script\");\n    } }), n.each([\"get\", \"post\"], function (a, b) {\n    n[b] = function (a, c, d, e) {\n      return n.isFunction(c) && (e = e || d, d = c, c = void 0), n.ajax(n.extend({ url: a, type: b, dataType: e, data: c, success: d }, n.isPlainObject(a) && a));\n    };\n  }), n._evalUrl = function (a) {\n    return n.ajax({ url: a, type: \"GET\", dataType: \"script\", async: !1, global: !1, \"throws\": !0 });\n  }, n.fn.extend({ wrapAll: function wrapAll(a) {\n      var b;return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapAll(a.call(this, b));\n      }) : (this[0] && (b = n(a, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && b.insertBefore(this[0]), b.map(function () {\n        var a = this;while (a.firstElementChild) {\n          a = a.firstElementChild;\n        }return a;\n      }).append(this)), this);\n    }, wrapInner: function wrapInner(a) {\n      return n.isFunction(a) ? this.each(function (b) {\n        n(this).wrapInner(a.call(this, b));\n      }) : this.each(function () {\n        var b = n(this),\n            c = b.contents();c.length ? c.wrapAll(a) : b.append(a);\n      });\n    }, wrap: function wrap(a) {\n      var b = n.isFunction(a);return this.each(function (c) {\n        n(this).wrapAll(b ? a.call(this, c) : a);\n      });\n    }, unwrap: function unwrap() {\n      return this.parent().each(function () {\n        n.nodeName(this, \"body\") || n(this).replaceWith(this.childNodes);\n      }).end();\n    } }), n.expr.filters.hidden = function (a) {\n    return !n.expr.filters.visible(a);\n  }, n.expr.filters.visible = function (a) {\n    return a.offsetWidth > 0 || a.offsetHeight > 0 || a.getClientRects().length > 0;\n  };var Bb = /%20/g,\n      Cb = /\\[\\]$/,\n      Db = /\\r?\\n/g,\n      Eb = /^(?:submit|button|image|reset|file)$/i,\n      Fb = /^(?:input|select|textarea|keygen)/i;function Gb(a, b, c, d) {\n    var e;if (n.isArray(b)) n.each(b, function (b, e) {\n      c || Cb.test(a) ? d(a, e) : Gb(a + \"[\" + (\"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && null != e ? b : \"\") + \"]\", e, c, d);\n    });else if (c || \"object\" !== n.type(b)) d(a, b);else for (e in b) {\n      Gb(a + \"[\" + e + \"]\", b[e], c, d);\n    }\n  }n.param = function (a, b) {\n    var c,\n        d = [],\n        e = function e(a, b) {\n      b = n.isFunction(b) ? b() : null == b ? \"\" : b, d[d.length] = encodeURIComponent(a) + \"=\" + encodeURIComponent(b);\n    };if (void 0 === b && (b = n.ajaxSettings && n.ajaxSettings.traditional), n.isArray(a) || a.jquery && !n.isPlainObject(a)) n.each(a, function () {\n      e(this.name, this.value);\n    });else for (c in a) {\n      Gb(c, a[c], b, e);\n    }return d.join(\"&\").replace(Bb, \"+\");\n  }, n.fn.extend({ serialize: function serialize() {\n      return n.param(this.serializeArray());\n    }, serializeArray: function serializeArray() {\n      return this.map(function () {\n        var a = n.prop(this, \"elements\");return a ? n.makeArray(a) : this;\n      }).filter(function () {\n        var a = this.type;return this.name && !n(this).is(\":disabled\") && Fb.test(this.nodeName) && !Eb.test(a) && (this.checked || !X.test(a));\n      }).map(function (a, b) {\n        var c = n(this).val();return null == c ? null : n.isArray(c) ? n.map(c, function (a) {\n          return { name: b.name, value: a.replace(Db, \"\\r\\n\") };\n        }) : { name: b.name, value: c.replace(Db, \"\\r\\n\") };\n      }).get();\n    } }), n.ajaxSettings.xhr = function () {\n    try {\n      return new a.XMLHttpRequest();\n    } catch (b) {}\n  };var Hb = { 0: 200, 1223: 204 },\n      Ib = n.ajaxSettings.xhr();l.cors = !!Ib && \"withCredentials\" in Ib, l.ajax = Ib = !!Ib, n.ajaxTransport(function (b) {\n    var _c, d;return l.cors || Ib && !b.crossDomain ? { send: function send(e, f) {\n        var g,\n            h = b.xhr();if (h.open(b.type, b.url, b.async, b.username, b.password), b.xhrFields) for (g in b.xhrFields) {\n          h[g] = b.xhrFields[g];\n        }b.mimeType && h.overrideMimeType && h.overrideMimeType(b.mimeType), b.crossDomain || e[\"X-Requested-With\"] || (e[\"X-Requested-With\"] = \"XMLHttpRequest\");for (g in e) {\n          h.setRequestHeader(g, e[g]);\n        }_c = function c(a) {\n          return function () {\n            _c && (_c = d = h.onload = h.onerror = h.onabort = h.onreadystatechange = null, \"abort\" === a ? h.abort() : \"error\" === a ? \"number\" != typeof h.status ? f(0, \"error\") : f(h.status, h.statusText) : f(Hb[h.status] || h.status, h.statusText, \"text\" !== (h.responseType || \"text\") || \"string\" != typeof h.responseText ? { binary: h.response } : { text: h.responseText }, h.getAllResponseHeaders()));\n          };\n        }, h.onload = _c(), d = h.onerror = _c(\"error\"), void 0 !== h.onabort ? h.onabort = d : h.onreadystatechange = function () {\n          4 === h.readyState && a.setTimeout(function () {\n            _c && d();\n          });\n        }, _c = _c(\"abort\");try {\n          h.send(b.hasContent && b.data || null);\n        } catch (i) {\n          if (_c) throw i;\n        }\n      }, abort: function abort() {\n        _c && _c();\n      } } : void 0;\n  }), n.ajaxSetup({ accepts: { script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\" }, contents: { script: /\\b(?:java|ecma)script\\b/ }, converters: { \"text script\": function textScript(a) {\n        return n.globalEval(a), a;\n      } } }), n.ajaxPrefilter(\"script\", function (a) {\n    void 0 === a.cache && (a.cache = !1), a.crossDomain && (a.type = \"GET\");\n  }), n.ajaxTransport(\"script\", function (a) {\n    if (a.crossDomain) {\n      var b, _c2;return { send: function send(e, f) {\n          b = n(\"<script>\").prop({ charset: a.scriptCharset, src: a.url }).on(\"load error\", _c2 = function c(a) {\n            b.remove(), _c2 = null, a && f(\"error\" === a.type ? 404 : 200, a.type);\n          }), d.head.appendChild(b[0]);\n        }, abort: function abort() {\n          _c2 && _c2();\n        } };\n    }\n  });var Jb = [],\n      Kb = /(=)\\?(?=&|$)|\\?\\?/;n.ajaxSetup({ jsonp: \"callback\", jsonpCallback: function jsonpCallback() {\n      var a = Jb.pop() || n.expando + \"_\" + kb++;return this[a] = !0, a;\n    } }), n.ajaxPrefilter(\"json jsonp\", function (b, c, d) {\n    var e,\n        f,\n        g,\n        h = b.jsonp !== !1 && (Kb.test(b.url) ? \"url\" : \"string\" == typeof b.data && 0 === (b.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") && Kb.test(b.data) && \"data\");return h || \"jsonp\" === b.dataTypes[0] ? (e = b.jsonpCallback = n.isFunction(b.jsonpCallback) ? b.jsonpCallback() : b.jsonpCallback, h ? b[h] = b[h].replace(Kb, \"$1\" + e) : b.jsonp !== !1 && (b.url += (lb.test(b.url) ? \"&\" : \"?\") + b.jsonp + \"=\" + e), b.converters[\"script json\"] = function () {\n      return g || n.error(e + \" was not called\"), g[0];\n    }, b.dataTypes[0] = \"json\", f = a[e], a[e] = function () {\n      g = arguments;\n    }, d.always(function () {\n      void 0 === f ? n(a).removeProp(e) : a[e] = f, b[e] && (b.jsonpCallback = c.jsonpCallback, Jb.push(e)), g && n.isFunction(f) && f(g[0]), g = f = void 0;\n    }), \"script\") : void 0;\n  }), n.parseHTML = function (a, b, c) {\n    if (!a || \"string\" != typeof a) return null;\"boolean\" == typeof b && (c = b, b = !1), b = b || d;var e = x.exec(a),\n        f = !c && [];return e ? [b.createElement(e[1])] : (e = ca([a], b, f), f && f.length && n(f).remove(), n.merge([], e.childNodes));\n  };var Lb = n.fn.load;n.fn.load = function (a, b, c) {\n    if (\"string\" != typeof a && Lb) return Lb.apply(this, arguments);var d,\n        e,\n        f,\n        g = this,\n        h = a.indexOf(\" \");return h > -1 && (d = n.trim(a.slice(h)), a = a.slice(0, h)), n.isFunction(b) ? (c = b, b = void 0) : b && \"object\" == (typeof b === \"undefined\" ? \"undefined\" : _typeof(b)) && (e = \"POST\"), g.length > 0 && n.ajax({ url: a, type: e || \"GET\", dataType: \"html\", data: b }).done(function (a) {\n      f = arguments, g.html(d ? n(\"<div>\").append(n.parseHTML(a)).find(d) : a);\n    }).always(c && function (a, b) {\n      g.each(function () {\n        c.apply(this, f || [a.responseText, b, a]);\n      });\n    }), this;\n  }, n.each([\"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\"], function (a, b) {\n    n.fn[b] = function (a) {\n      return this.on(b, a);\n    };\n  }), n.expr.filters.animated = function (a) {\n    return n.grep(n.timers, function (b) {\n      return a === b.elem;\n    }).length;\n  };function Mb(a) {\n    return n.isWindow(a) ? a : 9 === a.nodeType && a.defaultView;\n  }n.offset = { setOffset: function setOffset(a, b, c) {\n      var d,\n          e,\n          f,\n          g,\n          h,\n          i,\n          j,\n          k = n.css(a, \"position\"),\n          l = n(a),\n          m = {};\"static\" === k && (a.style.position = \"relative\"), h = l.offset(), f = n.css(a, \"top\"), i = n.css(a, \"left\"), j = (\"absolute\" === k || \"fixed\" === k) && (f + i).indexOf(\"auto\") > -1, j ? (d = l.position(), g = d.top, e = d.left) : (g = parseFloat(f) || 0, e = parseFloat(i) || 0), n.isFunction(b) && (b = b.call(a, c, n.extend({}, h))), null != b.top && (m.top = b.top - h.top + g), null != b.left && (m.left = b.left - h.left + e), \"using\" in b ? b.using.call(a, m) : l.css(m);\n    } }, n.fn.extend({ offset: function offset(a) {\n      if (arguments.length) return void 0 === a ? this : this.each(function (b) {\n        n.offset.setOffset(this, a, b);\n      });var b,\n          c,\n          d = this[0],\n          e = { top: 0, left: 0 },\n          f = d && d.ownerDocument;if (f) return b = f.documentElement, n.contains(b, d) ? (e = d.getBoundingClientRect(), c = Mb(f), { top: e.top + c.pageYOffset - b.clientTop, left: e.left + c.pageXOffset - b.clientLeft }) : e;\n    }, position: function position() {\n      if (this[0]) {\n        var a,\n            b,\n            c = this[0],\n            d = { top: 0, left: 0 };return \"fixed\" === n.css(c, \"position\") ? b = c.getBoundingClientRect() : (a = this.offsetParent(), b = this.offset(), n.nodeName(a[0], \"html\") || (d = a.offset()), d.top += n.css(a[0], \"borderTopWidth\", !0), d.left += n.css(a[0], \"borderLeftWidth\", !0)), { top: b.top - d.top - n.css(c, \"marginTop\", !0), left: b.left - d.left - n.css(c, \"marginLeft\", !0) };\n      }\n    }, offsetParent: function offsetParent() {\n      return this.map(function () {\n        var a = this.offsetParent;while (a && \"static\" === n.css(a, \"position\")) {\n          a = a.offsetParent;\n        }return a || Ea;\n      });\n    } }), n.each({ scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\" }, function (a, b) {\n    var c = \"pageYOffset\" === b;n.fn[a] = function (d) {\n      return K(this, function (a, d, e) {\n        var f = Mb(a);return void 0 === e ? f ? f[b] : a[d] : void (f ? f.scrollTo(c ? f.pageXOffset : e, c ? e : f.pageYOffset) : a[d] = e);\n      }, a, d, arguments.length);\n    };\n  }), n.each([\"top\", \"left\"], function (a, b) {\n    n.cssHooks[b] = Ga(l.pixelPosition, function (a, c) {\n      return c ? (c = Fa(a, b), Ba.test(c) ? n(a).position()[b] + \"px\" : c) : void 0;\n    });\n  }), n.each({ Height: \"height\", Width: \"width\" }, function (a, b) {\n    n.each({ padding: \"inner\" + a, content: b, \"\": \"outer\" + a }, function (c, d) {\n      n.fn[d] = function (d, e) {\n        var f = arguments.length && (c || \"boolean\" != typeof d),\n            g = c || (d === !0 || e === !0 ? \"margin\" : \"border\");return K(this, function (b, c, d) {\n          var e;return n.isWindow(b) ? b.document.documentElement[\"client\" + a] : 9 === b.nodeType ? (e = b.documentElement, Math.max(b.body[\"scroll\" + a], e[\"scroll\" + a], b.body[\"offset\" + a], e[\"offset\" + a], e[\"client\" + a])) : void 0 === d ? n.css(b, c, g) : n.style(b, c, d, g);\n        }, b, f ? d : void 0, f, null);\n      };\n    });\n  }), n.fn.extend({ bind: function bind(a, b, c) {\n      return this.on(a, null, b, c);\n    }, unbind: function unbind(a, b) {\n      return this.off(a, null, b);\n    }, delegate: function delegate(a, b, c, d) {\n      return this.on(b, a, c, d);\n    }, undelegate: function undelegate(a, b, c) {\n      return 1 === arguments.length ? this.off(a, \"**\") : this.off(b, a || \"**\", c);\n    }, size: function size() {\n      return this.length;\n    } }), n.fn.andSelf = n.fn.addBack, \"function\" == typeof define && define.amd && define(\"jquery\", [], function () {\n    return n;\n  });var Nb = a.jQuery,\n      Ob = a.$;return n.noConflict = function (b) {\n    return a.$ === n && (a.$ = Ob), b && a.jQuery === n && (a.jQuery = Nb), n;\n  }, b || (a.jQuery = a.$ = n), n;\n});"

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(2)(__webpack_require__(5))

/***/ },
/* 5 */
/***/ function(module, exports) {

	module.exports = "\"use strict\";\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nfunction _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}function _classCallCheck(t, e) {\n  if (!(t instanceof e)) throw new TypeError(\"Cannot call a class as a function\");\n}!function (t) {\n  \"use strict\";\n  function e(t) {\n    if (void 0 === Function.prototype.name) {\n      var e = /function\\s([^(]{1,})\\(/,\n          i = e.exec(t.toString());return i && i.length > 1 ? i[1].trim() : \"\";\n    }return void 0 === t.prototype ? t.constructor.name : t.prototype.constructor.name;\n  }function i(t) {\n    return !!/true/.test(t) || !/false/.test(t) && (isNaN(1 * t) ? t : parseFloat(t));\n  }function n(t) {\n    return t.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n  }var s = \"6.2.4\",\n      o = { version: s, _plugins: {}, _uuids: [], rtl: function rtl() {\n      return \"rtl\" === t(\"html\").attr(\"dir\");\n    }, plugin: function plugin(t, i) {\n      var s = i || e(t),\n          o = n(s);this._plugins[o] = this[s] = t;\n    }, registerPlugin: function registerPlugin(t, i) {\n      var s = i ? n(i) : e(t.constructor).toLowerCase();t.uuid = this.GetYoDigits(6, s), t.$element.attr(\"data-\" + s) || t.$element.attr(\"data-\" + s, t.uuid), t.$element.data(\"zfPlugin\") || t.$element.data(\"zfPlugin\", t), t.$element.trigger(\"init.zf.\" + s), this._uuids.push(t.uuid);\n    }, unregisterPlugin: function unregisterPlugin(t) {\n      var i = n(e(t.$element.data(\"zfPlugin\").constructor));this._uuids.splice(this._uuids.indexOf(t.uuid), 1), t.$element.removeAttr(\"data-\" + i).removeData(\"zfPlugin\").trigger(\"destroyed.zf.\" + i);for (var s in t) {\n        t[s] = null;\n      }\n    }, reInit: function reInit(e) {\n      var i = e instanceof t;try {\n        if (i) e.each(function () {\n          t(this).data(\"zfPlugin\")._init();\n        });else {\n          var s = typeof e === \"undefined\" ? \"undefined\" : _typeof(e),\n              o = this,\n              a = { object: function object(e) {\n              e.forEach(function (e) {\n                e = n(e), t(\"[data-\" + e + \"]\").foundation(\"_init\");\n              });\n            }, string: function string() {\n              e = n(e), t(\"[data-\" + e + \"]\").foundation(\"_init\");\n            }, undefined: function undefined() {\n              this.object(Object.keys(o._plugins));\n            } };a[s](e);\n        }\n      } catch (r) {\n        console.error(r);\n      } finally {\n        return e;\n      }\n    }, GetYoDigits: function GetYoDigits(t, e) {\n      return t = t || 6, Math.round(Math.pow(36, t + 1) - Math.random() * Math.pow(36, t)).toString(36).slice(1) + (e ? \"-\" + e : \"\");\n    }, reflow: function reflow(e, n) {\n      \"undefined\" == typeof n ? n = Object.keys(this._plugins) : \"string\" == typeof n && (n = [n]);var s = this;t.each(n, function (n, o) {\n        var a = s._plugins[o],\n            r = t(e).find(\"[data-\" + o + \"]\").addBack(\"[data-\" + o + \"]\");r.each(function () {\n          var e = t(this),\n              n = {};if (e.data(\"zfPlugin\")) return void console.warn(\"Tried to initialize \" + o + \" on an element that already has a Foundation plugin.\");if (e.attr(\"data-options\")) {\n            e.attr(\"data-options\").split(\";\").forEach(function (t, e) {\n              var s = t.split(\":\").map(function (t) {\n                return t.trim();\n              });s[0] && (n[s[0]] = i(s[1]));\n            });\n          }try {\n            e.data(\"zfPlugin\", new a(t(this), n));\n          } catch (s) {\n            console.error(s);\n          } finally {\n            return;\n          }\n        });\n      });\n    }, getFnName: e, transitionend: function transitionend(t) {\n      var e,\n          i = { transition: \"transitionend\", WebkitTransition: \"webkitTransitionEnd\", MozTransition: \"transitionend\", OTransition: \"otransitionend\" },\n          n = document.createElement(\"div\");for (var s in i) {\n        \"undefined\" != typeof n.style[s] && (e = i[s]);\n      }return e ? e : (e = setTimeout(function () {\n        t.triggerHandler(\"transitionend\", [t]);\n      }, 1), \"transitionend\");\n    } };o.util = { throttle: function throttle(t, e) {\n      var i = null;return function () {\n        var n = this,\n            s = arguments;null === i && (i = setTimeout(function () {\n          t.apply(n, s), i = null;\n        }, e));\n      };\n    } };var a = function a(i) {\n    var n = typeof i === \"undefined\" ? \"undefined\" : _typeof(i),\n        s = t(\"meta.foundation-mq\"),\n        a = t(\".no-js\");if (s.length || t('<meta class=\"foundation-mq\">').appendTo(document.head), a.length && a.removeClass(\"no-js\"), \"undefined\" === n) o.MediaQuery._init(), o.reflow(this);else {\n      if (\"string\" !== n) throw new TypeError(\"We're sorry, \" + n + \" is not a valid parameter. You must use a string representing the method you wish to invoke.\");var r = Array.prototype.slice.call(arguments, 1),\n          l = this.data(\"zfPlugin\");if (void 0 === l || void 0 === l[i]) throw new ReferenceError(\"We're sorry, '\" + i + \"' is not an available method for \" + (l ? e(l) : \"this element\") + \".\");1 === this.length ? l[i].apply(l, r) : this.each(function (e, n) {\n        l[i].apply(t(n).data(\"zfPlugin\"), r);\n      });\n    }return this;\n  };window.Foundation = o, t.fn.foundation = a, function () {\n    Date.now && window.Date.now || (window.Date.now = Date.now = function () {\n      return new Date().getTime();\n    });for (var t = [\"webkit\", \"moz\"], e = 0; e < t.length && !window.requestAnimationFrame; ++e) {\n      var i = t[e];window.requestAnimationFrame = window[i + \"RequestAnimationFrame\"], window.cancelAnimationFrame = window[i + \"CancelAnimationFrame\"] || window[i + \"CancelRequestAnimationFrame\"];\n    }if (/iP(ad|hone|od).*OS 6/.test(window.navigator.userAgent) || !window.requestAnimationFrame || !window.cancelAnimationFrame) {\n      var n = 0;window.requestAnimationFrame = function (t) {\n        var e = Date.now(),\n            i = Math.max(n + 16, e);return setTimeout(function () {\n          t(n = i);\n        }, i - e);\n      }, window.cancelAnimationFrame = clearTimeout;\n    }window.performance && window.performance.now || (window.performance = { start: Date.now(), now: function now() {\n        return Date.now() - this.start;\n      } });\n  }(), Function.prototype.bind || (Function.prototype.bind = function (t) {\n    if (\"function\" != typeof this) throw new TypeError(\"Function.prototype.bind - what is trying to be bound is not callable\");var e = Array.prototype.slice.call(arguments, 1),\n        i = this,\n        n = function n() {},\n        s = function s() {\n      return i.apply(this instanceof n ? this : t, e.concat(Array.prototype.slice.call(arguments)));\n    };return this.prototype && (n.prototype = this.prototype), s.prototype = new n(), s;\n  });\n}(jQuery), !function (t) {\n  function e(t, e, n, s) {\n    var o,\n        a,\n        r,\n        l,\n        u = i(t);if (e) {\n      var d = i(e);a = u.offset.top + u.height <= d.height + d.offset.top, o = u.offset.top >= d.offset.top, r = u.offset.left >= d.offset.left, l = u.offset.left + u.width <= d.width + d.offset.left;\n    } else a = u.offset.top + u.height <= u.windowDims.height + u.windowDims.offset.top, o = u.offset.top >= u.windowDims.offset.top, r = u.offset.left >= u.windowDims.offset.left, l = u.offset.left + u.width <= u.windowDims.width;var h = [a, o, r, l];return n ? r === l == !0 : s ? o === a == !0 : h.indexOf(!1) === -1;\n  }function i(t, e) {\n    if (t = t.length ? t[0] : t, t === window || t === document) throw new Error(\"I'm sorry, Dave. I'm afraid I can't do that.\");var i = t.getBoundingClientRect(),\n        n = t.parentNode.getBoundingClientRect(),\n        s = document.body.getBoundingClientRect(),\n        o = window.pageYOffset,\n        a = window.pageXOffset;return { width: i.width, height: i.height, offset: { top: i.top + o, left: i.left + a }, parentDims: { width: n.width, height: n.height, offset: { top: n.top + o, left: n.left + a } }, windowDims: { width: s.width, height: s.height, offset: { top: o, left: a } } };\n  }function n(t, e, n, s, o, a) {\n    var r = i(t),\n        l = e ? i(e) : null;switch (n) {case \"top\":\n        return { left: Foundation.rtl() ? l.offset.left - r.width + l.width : l.offset.left, top: l.offset.top - (r.height + s) };case \"left\":\n        return { left: l.offset.left - (r.width + o), top: l.offset.top };case \"right\":\n        return { left: l.offset.left + l.width + o, top: l.offset.top };case \"center top\":\n        return { left: l.offset.left + l.width / 2 - r.width / 2, top: l.offset.top - (r.height + s) };case \"center bottom\":\n        return { left: a ? o : l.offset.left + l.width / 2 - r.width / 2, top: l.offset.top + l.height + s };case \"center left\":\n        return { left: l.offset.left - (r.width + o), top: l.offset.top + l.height / 2 - r.height / 2 };case \"center right\":\n        return { left: l.offset.left + l.width + o + 1, top: l.offset.top + l.height / 2 - r.height / 2 };case \"center\":\n        return { left: r.windowDims.offset.left + r.windowDims.width / 2 - r.width / 2, top: r.windowDims.offset.top + r.windowDims.height / 2 - r.height / 2 };case \"reveal\":\n        return { left: (r.windowDims.width - r.width) / 2, top: r.windowDims.offset.top + s };case \"reveal full\":\n        return { left: r.windowDims.offset.left, top: r.windowDims.offset.top };case \"left bottom\":\n        return { left: l.offset.left, top: l.offset.top + l.height };case \"right bottom\":\n        return { left: l.offset.left + l.width + o - r.width, top: l.offset.top + l.height };default:\n        return { left: Foundation.rtl() ? l.offset.left - r.width + l.width : l.offset.left + o, top: l.offset.top + l.height + s };}\n  }Foundation.Box = { ImNotTouchingYou: e, GetDimensions: i, GetOffsets: n };\n}(jQuery), !function (t) {\n  function e(t) {\n    var e = {};for (var i in t) {\n      e[t[i]] = t[i];\n    }return e;\n  }var i = { 9: \"TAB\", 13: \"ENTER\", 27: \"ESCAPE\", 32: \"SPACE\", 37: \"ARROW_LEFT\", 38: \"ARROW_UP\", 39: \"ARROW_RIGHT\", 40: \"ARROW_DOWN\" },\n      n = {},\n      s = { keys: e(i), parseKey: function parseKey(t) {\n      var e = i[t.which || t.keyCode] || String.fromCharCode(t.which).toUpperCase();return t.shiftKey && (e = \"SHIFT_\" + e), t.ctrlKey && (e = \"CTRL_\" + e), t.altKey && (e = \"ALT_\" + e), e;\n    }, handleKey: function handleKey(e, i, s) {\n      var o,\n          a,\n          r,\n          l = n[i],\n          u = this.parseKey(e);if (!l) return console.warn(\"Component not defined!\");if (o = \"undefined\" == typeof l.ltr ? l : Foundation.rtl() ? t.extend({}, l.ltr, l.rtl) : t.extend({}, l.rtl, l.ltr), a = o[u], r = s[a], r && \"function\" == typeof r) {\n        var d = r.apply();(s.handled || \"function\" == typeof s.handled) && s.handled(d);\n      } else (s.unhandled || \"function\" == typeof s.unhandled) && s.unhandled();\n    }, findFocusable: function findFocusable(e) {\n      return e.find(\"a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), button:not([disabled]), iframe, object, embed, *[tabindex], *[contenteditable]\").filter(function () {\n        return !(!t(this).is(\":visible\") || t(this).attr(\"tabindex\") < 0);\n      });\n    }, register: function register(t, e) {\n      n[t] = e;\n    } };Foundation.Keyboard = s;\n}(jQuery), !function (t) {\n  function e(t) {\n    var e = {};return \"string\" != typeof t ? e : (t = t.trim().slice(1, -1)) ? e = t.split(\"&\").reduce(function (t, e) {\n      var i = e.replace(/\\+/g, \" \").split(\"=\"),\n          n = i[0],\n          s = i[1];return n = decodeURIComponent(n), s = void 0 === s ? null : decodeURIComponent(s), t.hasOwnProperty(n) ? Array.isArray(t[n]) ? t[n].push(s) : t[n] = [t[n], s] : t[n] = s, t;\n    }, {}) : e;\n  }var i = { queries: [], current: \"\", _init: function _init() {\n      var i,\n          n = this,\n          s = t(\".foundation-mq\").css(\"font-family\");i = e(s);for (var o in i) {\n        i.hasOwnProperty(o) && n.queries.push({ name: o, value: \"only screen and (min-width: \" + i[o] + \")\" });\n      }this.current = this._getCurrentSize(), this._watcher();\n    }, atLeast: function atLeast(t) {\n      var e = this.get(t);return !!e && window.matchMedia(e).matches;\n    }, get: function get(t) {\n      for (var e in this.queries) {\n        if (this.queries.hasOwnProperty(e)) {\n          var i = this.queries[e];if (t === i.name) return i.value;\n        }\n      }return null;\n    }, _getCurrentSize: function _getCurrentSize() {\n      for (var t, e = 0; e < this.queries.length; e++) {\n        var i = this.queries[e];window.matchMedia(i.value).matches && (t = i);\n      }return \"object\" == (typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) ? t.name : t;\n    }, _watcher: function _watcher() {\n      var e = this;t(window).on(\"resize.zf.mediaquery\", function () {\n        var i = e._getCurrentSize(),\n            n = e.current;i !== n && (e.current = i, t(window).trigger(\"changed.zf.mediaquery\", [i, n]));\n      });\n    } };Foundation.MediaQuery = i, window.matchMedia || (window.matchMedia = function () {\n    \"use strict\";\n    var t = window.styleMedia || window.media;if (!t) {\n      var e = document.createElement(\"style\"),\n          i = document.getElementsByTagName(\"script\")[0],\n          n = null;e.type = \"text/css\", e.id = \"matchmediajs-test\", i && i.parentNode && i.parentNode.insertBefore(e, i), n = \"getComputedStyle\" in window && window.getComputedStyle(e, null) || e.currentStyle, t = { matchMedium: function matchMedium(t) {\n          var i = \"@media \" + t + \"{ #matchmediajs-test { width: 1px; } }\";return e.styleSheet ? e.styleSheet.cssText = i : e.textContent = i, \"1px\" === n.width;\n        } };\n    }return function (e) {\n      return { matches: t.matchMedium(e || \"all\"), media: e || \"all\" };\n    };\n  }()), Foundation.MediaQuery = i;\n}(jQuery), !function (t) {\n  function e(t, e, i) {\n    function n(r) {\n      a || (a = window.performance.now()), o = r - a, i.apply(e), o < t ? s = window.requestAnimationFrame(n, e) : (window.cancelAnimationFrame(s), e.trigger(\"finished.zf.animate\", [e]).triggerHandler(\"finished.zf.animate\", [e]));\n    }var s,\n        o,\n        a = null;s = window.requestAnimationFrame(n);\n  }function i(e, i, o, a) {\n    function r() {\n      e || i.hide(), l(), a && a.apply(i);\n    }function l() {\n      i[0].style.transitionDuration = 0, i.removeClass(u + \" \" + d + \" \" + o);\n    }if (i = t(i).eq(0), i.length) {\n      var u = e ? n[0] : n[1],\n          d = e ? s[0] : s[1];l(), i.addClass(o).css(\"transition\", \"none\"), requestAnimationFrame(function () {\n        i.addClass(u), e && i.show();\n      }), requestAnimationFrame(function () {\n        i[0].offsetWidth, i.css(\"transition\", \"\").addClass(d);\n      }), i.one(Foundation.transitionend(i), r);\n    }\n  }var n = [\"mui-enter\", \"mui-leave\"],\n      s = [\"mui-enter-active\", \"mui-leave-active\"],\n      o = { animateIn: function animateIn(t, e, n) {\n      i(!0, t, e, n);\n    }, animateOut: function animateOut(t, e, n) {\n      i(!1, t, e, n);\n    } };Foundation.Move = e, Foundation.Motion = o;\n}(jQuery), !function (t) {\n  var e = { Feather: function Feather(e) {\n      var i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : \"zf\";e.attr(\"role\", \"menubar\");var n = e.find(\"li\").attr({ role: \"menuitem\" }),\n          s = \"is-\" + i + \"-submenu\",\n          o = s + \"-item\",\n          a = \"is-\" + i + \"-submenu-parent\";e.find(\"a:first\").attr(\"tabindex\", 0), n.each(function () {\n        var e = t(this),\n            i = e.children(\"ul\");i.length && (e.addClass(a).attr({ \"aria-haspopup\": !0, \"aria-expanded\": !1, \"aria-label\": e.children(\"a:first\").text() }), i.addClass(\"submenu \" + s).attr({ \"data-submenu\": \"\", \"aria-hidden\": !0, role: \"menu\" })), e.parent(\"[data-submenu]\").length && e.addClass(\"is-submenu-item \" + o);\n      });\n    }, Burn: function Burn(t, e) {\n      var i = (t.find(\"li\").removeAttr(\"tabindex\"), \"is-\" + e + \"-submenu\"),\n          n = i + \"-item\",\n          s = \"is-\" + e + \"-submenu-parent\";t.find(\">li, .menu, .menu > li\").removeClass(i + \" \" + n + \" \" + s + \" is-submenu-item submenu is-active\").removeAttr(\"data-submenu\").css(\"display\", \"\");\n    } };Foundation.Nest = e;\n}(jQuery), !function (t) {\n  function e(t, e, i) {\n    var n,\n        s,\n        o = this,\n        a = e.duration,\n        r = Object.keys(t.data())[0] || \"timer\",\n        l = -1;this.isPaused = !1, this.restart = function () {\n      l = -1, clearTimeout(s), this.start();\n    }, this.start = function () {\n      this.isPaused = !1, clearTimeout(s), l = l <= 0 ? a : l, t.data(\"paused\", !1), n = Date.now(), s = setTimeout(function () {\n        e.infinite && o.restart(), i && \"function\" == typeof i && i();\n      }, l), t.trigger(\"timerstart.zf.\" + r);\n    }, this.pause = function () {\n      this.isPaused = !0, clearTimeout(s), t.data(\"paused\", !0);var e = Date.now();l -= e - n, t.trigger(\"timerpaused.zf.\" + r);\n    };\n  }function i(e, i) {\n    function n() {\n      s--, 0 === s && i();\n    }var s = e.length;0 === s && i(), e.each(function () {\n      this.complete ? n() : \"undefined\" != typeof this.naturalWidth && this.naturalWidth > 0 ? n() : t(this).one(\"load\", function () {\n        n();\n      });\n    });\n  }Foundation.Timer = e, Foundation.onImagesLoaded = i;\n}(jQuery), function (t) {\n  function e() {\n    this.removeEventListener(\"touchmove\", i), this.removeEventListener(\"touchend\", e), u = !1;\n  }function i(i) {\n    if (t.spotSwipe.preventDefault && i.preventDefault(), u) {\n      var n,\n          s = i.touches[0].pageX,\n          a = (i.touches[0].pageY, o - s);l = new Date().getTime() - r, Math.abs(a) >= t.spotSwipe.moveThreshold && l <= t.spotSwipe.timeThreshold && (n = a > 0 ? \"left\" : \"right\"), n && (i.preventDefault(), e.call(this), t(this).trigger(\"swipe\", n).trigger(\"swipe\" + n));\n    }\n  }function n(t) {\n    1 == t.touches.length && (o = t.touches[0].pageX, a = t.touches[0].pageY, u = !0, r = new Date().getTime(), this.addEventListener(\"touchmove\", i, !1), this.addEventListener(\"touchend\", e, !1));\n  }function s() {\n    this.addEventListener && this.addEventListener(\"touchstart\", n, !1);\n  }t.spotSwipe = { version: \"1.0.0\", enabled: \"ontouchstart\" in document.documentElement, preventDefault: !1, moveThreshold: 75, timeThreshold: 200 };var o,\n      a,\n      r,\n      l,\n      u = !1;t.event.special.swipe = { setup: s }, t.each([\"left\", \"up\", \"down\", \"right\"], function () {\n    t.event.special[\"swipe\" + this] = { setup: function setup() {\n        t(this).on(\"swipe\", t.noop);\n      } };\n  });\n}(jQuery), !function (t) {\n  t.fn.addTouch = function () {\n    this.each(function (i, n) {\n      t(n).bind(\"touchstart touchmove touchend touchcancel\", function () {\n        e(event);\n      });\n    });var e = function e(t) {\n      var e,\n          i = t.changedTouches,\n          n = i[0],\n          s = { touchstart: \"mousedown\", touchmove: \"mousemove\", touchend: \"mouseup\" },\n          o = s[t.type];\"MouseEvent\" in window && \"function\" == typeof window.MouseEvent ? e = new window.MouseEvent(o, { bubbles: !0, cancelable: !0, screenX: n.screenX, screenY: n.screenY, clientX: n.clientX, clientY: n.clientY }) : (e = document.createEvent(\"MouseEvent\"), e.initMouseEvent(o, !0, !0, window, 1, n.screenX, n.screenY, n.clientX, n.clientY, !1, !1, !1, !1, 0, null)), n.target.dispatchEvent(e);\n    };\n  };\n}(jQuery), !function (t) {\n  function e() {\n    o(), n(), s(), i();\n  }function i(e) {\n    var i = t(\"[data-yeti-box]\"),\n        n = [\"dropdown\", \"tooltip\", \"reveal\"];if (e && (\"string\" == typeof e ? n.push(e) : \"object\" == (typeof e === \"undefined\" ? \"undefined\" : _typeof(e)) && \"string\" == typeof e[0] ? n.concat(e) : console.error(\"Plugin names must be strings\")), i.length) {\n      var s = n.map(function (t) {\n        return \"closeme.zf.\" + t;\n      }).join(\" \");t(window).off(s).on(s, function (e, i) {\n        var n = e.namespace.split(\".\")[0],\n            s = t(\"[data-\" + n + \"]\").not('[data-yeti-box=\"' + i + '\"]');s.each(function () {\n          var e = t(this);e.triggerHandler(\"close.zf.trigger\", [e]);\n        });\n      });\n    }\n  }function n(e) {\n    var i = void 0,\n        n = t(\"[data-resize]\");n.length && t(window).off(\"resize.zf.trigger\").on(\"resize.zf.trigger\", function (s) {\n      i && clearTimeout(i), i = setTimeout(function () {\n        a || n.each(function () {\n          t(this).triggerHandler(\"resizeme.zf.trigger\");\n        }), n.attr(\"data-events\", \"resize\");\n      }, e || 10);\n    });\n  }function s(e) {\n    var i = void 0,\n        n = t(\"[data-scroll]\");n.length && t(window).off(\"scroll.zf.trigger\").on(\"scroll.zf.trigger\", function (s) {\n      i && clearTimeout(i), i = setTimeout(function () {\n        a || n.each(function () {\n          t(this).triggerHandler(\"scrollme.zf.trigger\");\n        }), n.attr(\"data-events\", \"scroll\");\n      }, e || 10);\n    });\n  }function o() {\n    if (!a) return !1;var e = document.querySelectorAll(\"[data-resize], [data-scroll], [data-mutate]\"),\n        i = function i(e) {\n      var i = t(e[0].target);switch (i.attr(\"data-events\")) {case \"resize\":\n          i.triggerHandler(\"resizeme.zf.trigger\", [i]);break;case \"scroll\":\n          i.triggerHandler(\"scrollme.zf.trigger\", [i, window.pageYOffset]);break;default:\n          return !1;}\n    };if (e.length) for (var n = 0; n <= e.length - 1; n++) {\n      var s = new a(i);s.observe(e[n], { attributes: !0, childList: !1, characterData: !1, subtree: !1, attributeFilter: [\"data-events\"] });\n    }\n  }var a = function () {\n    for (var t = [\"WebKit\", \"Moz\", \"O\", \"Ms\", \"\"], e = 0; e < t.length; e++) {\n      if (t[e] + \"MutationObserver\" in window) return window[t[e] + \"MutationObserver\"];\n    }return !1;\n  }(),\n      r = function r(e, i) {\n    e.data(i).split(\" \").forEach(function (n) {\n      t(\"#\" + n)[\"close\" === i ? \"trigger\" : \"triggerHandler\"](i + \".zf.trigger\", [e]);\n    });\n  };t(document).on(\"click.zf.trigger\", \"[data-open]\", function () {\n    r(t(this), \"open\");\n  }), t(document).on(\"click.zf.trigger\", \"[data-close]\", function () {\n    var e = t(this).data(\"close\");e ? r(t(this), \"close\") : t(this).trigger(\"close.zf.trigger\");\n  }), t(document).on(\"click.zf.trigger\", \"[data-toggle]\", function () {\n    r(t(this), \"toggle\");\n  }), t(document).on(\"close.zf.trigger\", \"[data-closable]\", function (e) {\n    e.stopPropagation();var i = t(this).data(\"closable\");\"\" !== i ? Foundation.Motion.animateOut(t(this), i, function () {\n      t(this).trigger(\"closed.zf\");\n    }) : t(this).fadeOut().trigger(\"closed.zf\");\n  }), t(document).on(\"focus.zf.trigger blur.zf.trigger\", \"[data-toggle-focus]\", function () {\n    var e = t(this).data(\"toggle-focus\");t(\"#\" + e).triggerHandler(\"toggle.zf.trigger\", [t(this)]);\n  }), t(window).on(\"load\", function () {\n    e();\n  }), Foundation.IHearYou = e;\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i) {\n      var n = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};_classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Abide\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this.$inputs = this.$element.find(\"input, textarea, select\"), this._events();\n      } }, { key: \"_events\", value: function value() {\n        var e = this;this.$element.off(\".abide\").on(\"reset.zf.abide\", function () {\n          e.resetForm();\n        }).on(\"submit.zf.abide\", function () {\n          return e.validateForm();\n        }), \"fieldChange\" === this.options.validateOn && this.$inputs.off(\"change.zf.abide\").on(\"change.zf.abide\", function (i) {\n          e.validateInput(t(i.target));\n        }), this.options.liveValidate && this.$inputs.off(\"input.zf.abide\").on(\"input.zf.abide\", function (i) {\n          e.validateInput(t(i.target));\n        });\n      } }, { key: \"_reflow\", value: function value() {\n        this._init();\n      } }, { key: \"requiredCheck\", value: function value(t) {\n        if (!t.attr(\"required\")) return !0;var e = !0;switch (t[0].type) {case \"checkbox\":\n            e = t[0].checked;break;case \"select\":case \"select-one\":case \"select-multiple\":\n            var i = t.find(\"option:selected\");i.length && i.val() || (e = !1);break;default:\n            t.val() && t.val().length || (e = !1);}return e;\n      } }, { key: \"findFormError\", value: function value(t) {\n        var e = t.siblings(this.options.formErrorSelector);return e.length || (e = t.parent().find(this.options.formErrorSelector)), e;\n      } }, { key: \"findLabel\", value: function value(t) {\n        var e = t[0].id,\n            i = this.$element.find('label[for=\"' + e + '\"]');return i.length ? i : t.closest(\"label\");\n      } }, { key: \"findRadioLabels\", value: function value(e) {\n        var i = this,\n            n = e.map(function (e, n) {\n          var s = n.id,\n              o = i.$element.find('label[for=\"' + s + '\"]');return o.length || (o = t(n).closest(\"label\")), o[0];\n        });return t(n);\n      } }, { key: \"addErrorClasses\", value: function value(t) {\n        var e = this.findLabel(t),\n            i = this.findFormError(t);e.length && e.addClass(this.options.labelErrorClass), i.length && i.addClass(this.options.formErrorClass), t.addClass(this.options.inputErrorClass).attr(\"data-invalid\", \"\");\n      } }, { key: \"removeRadioErrorClasses\", value: function value(t) {\n        var e = this.$element.find(':radio[name=\"' + t + '\"]'),\n            i = this.findRadioLabels(e),\n            n = this.findFormError(e);i.length && i.removeClass(this.options.labelErrorClass), n.length && n.removeClass(this.options.formErrorClass), e.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");\n      } }, { key: \"removeErrorClasses\", value: function value(t) {\n        if (\"radio\" == t[0].type) return this.removeRadioErrorClasses(t.attr(\"name\"));var e = this.findLabel(t),\n            i = this.findFormError(t);e.length && e.removeClass(this.options.labelErrorClass), i.length && i.removeClass(this.options.formErrorClass), t.removeClass(this.options.inputErrorClass).removeAttr(\"data-invalid\");\n      } }, { key: \"validateInput\", value: function value(t) {\n        var e = this.requiredCheck(t),\n            i = !1,\n            n = !0,\n            s = t.attr(\"data-validator\"),\n            o = !0;if (t.is(\"[data-abide-ignore]\") || t.is('[type=\"hidden\"]')) return !0;switch (t[0].type) {case \"radio\":\n            i = this.validateRadio(t.attr(\"name\"));break;case \"checkbox\":\n            i = e;break;case \"select\":case \"select-one\":case \"select-multiple\":\n            i = e;break;default:\n            i = this.validateText(t);}s && (n = this.matchValidation(t, s, t.attr(\"required\"))), t.attr(\"data-equalto\") && (o = this.options.validators.equalTo(t));var a = [e, i, n, o].indexOf(!1) === -1,\n            r = (a ? \"valid\" : \"invalid\") + \".zf.abide\";return this[a ? \"removeErrorClasses\" : \"addErrorClasses\"](t), t.trigger(r, [t]), a;\n      } }, { key: \"validateForm\", value: function value() {\n        var e = [],\n            i = this;this.$inputs.each(function () {\n          e.push(i.validateInput(t(this)));\n        });var n = e.indexOf(!1) === -1;return this.$element.find(\"[data-abide-error]\").css(\"display\", n ? \"none\" : \"block\"), this.$element.trigger((n ? \"formvalid\" : \"forminvalid\") + \".zf.abide\", [this.$element]), n;\n      } }, { key: \"validateText\", value: function value(t, e) {\n        e = e || t.attr(\"pattern\") || t.attr(\"type\");var i = t.val(),\n            n = !1;return i.length ? n = this.options.patterns.hasOwnProperty(e) ? this.options.patterns[e].test(i) : e === t.attr(\"type\") || new RegExp(e).test(i) : t.prop(\"required\") || (n = !0), n;\n      } }, { key: \"validateRadio\", value: function value(e) {\n        var i = this.$element.find(':radio[name=\"' + e + '\"]'),\n            n = !1,\n            s = !1;return i.each(function (e, i) {\n          t(i).attr(\"required\") && (s = !0);\n        }), s || (n = !0), n || i.each(function (e, i) {\n          t(i).prop(\"checked\") && (n = !0);\n        }), n;\n      } }, { key: \"matchValidation\", value: function value(t, e, i) {\n        var n = this;i = !!i;var s = e.split(\" \").map(function (e) {\n          return n.options.validators[e](t, i, t.parent());\n        });return s.indexOf(!1) === -1;\n      } }, { key: \"resetForm\", value: function value() {\n        var e = this.$element,\n            i = this.options;t(\".\" + i.labelErrorClass, e).not(\"small\").removeClass(i.labelErrorClass), t(\".\" + i.inputErrorClass, e).not(\"small\").removeClass(i.inputErrorClass), t(i.formErrorSelector + \".\" + i.formErrorClass).removeClass(i.formErrorClass), e.find(\"[data-abide-error]\").css(\"display\", \"none\"), t(\":input\", e).not(\":button, :submit, :reset, :hidden, :radio, :checkbox, [data-abide-ignore]\").val(\"\").removeAttr(\"data-invalid\"), t(\":input:radio\", e).not(\"[data-abide-ignore]\").prop(\"checked\", !1).removeAttr(\"data-invalid\"), t(\":input:checkbox\", e).not(\"[data-abide-ignore]\").prop(\"checked\", !1).removeAttr(\"data-invalid\"), e.trigger(\"formreset.zf.abide\", [e]);\n      } }, { key: \"destroy\", value: function value() {\n        var e = this;this.$element.off(\".abide\").find(\"[data-abide-error]\").css(\"display\", \"none\"), this.$inputs.off(\".abide\").each(function () {\n          e.removeErrorClasses(t(this));\n        }), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { validateOn: \"fieldChange\", labelErrorClass: \"is-invalid-label\", inputErrorClass: \"is-invalid-input\", formErrorSelector: \".form-error\", formErrorClass: \"is-visible\", liveValidate: !1, patterns: { alpha: /^[a-zA-Z]+$/, alpha_numeric: /^[a-zA-Z0-9]+$/, integer: /^[-+]?\\d+$/, number: /^[-+]?\\d*(?:[\\.\\,]\\d+)?$/, card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\\d{3})\\d{11})$/, cvv: /^([0-9]){3,4}$/, email: /^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/, url: /^(https?|ftp|file|ssh):\\/\\/(((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-zA-Z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-zA-Z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/, domain: /^([a-zA-Z0-9]([a-zA-Z0-9\\-]{0,61}[a-zA-Z0-9])?\\.)+[a-zA-Z]{2,8}$/, datetime: /^([0-2][0-9]{3})\\-([0-1][0-9])\\-([0-3][0-9])T([0-5][0-9])\\:([0-5][0-9])\\:([0-5][0-9])(Z|([\\-\\+]([0-1][0-9])\\:00))$/, date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/, time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/, dateISO: /^\\d{4}[\\/\\-]\\d{1,2}[\\/\\-]\\d{1,2}$/, month_day_year: /^(0[1-9]|1[012])[- \\/.](0[1-9]|[12][0-9]|3[01])[- \\/.]\\d{4}$/, day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \\/.](0[1-9]|1[012])[- \\/.]\\d{4}$/, color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/ }, validators: { equalTo: function equalTo(e, i, n) {\n        return t(\"#\" + e.attr(\"data-equalto\")).val() === e.val();\n      } } }, Foundation.plugin(e, \"Abide\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Accordion\"), Foundation.Keyboard.register(\"Accordion\", { ENTER: \"toggle\", SPACE: \"toggle\", ARROW_DOWN: \"next\", ARROW_UP: \"previous\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this.$element.attr(\"role\", \"tablist\"), this.$tabs = this.$element.children(\"li, [data-accordion-item]\"), this.$tabs.each(function (e, i) {\n          var n = t(i),\n              s = n.children(\"[data-tab-content]\"),\n              o = s[0].id || Foundation.GetYoDigits(6, \"accordion\"),\n              a = i.id || o + \"-label\";n.find(\"a:first\").attr({ \"aria-controls\": o, role: \"tab\", id: a, \"aria-expanded\": !1, \"aria-selected\": !1 }), s.attr({ role: \"tabpanel\", \"aria-labelledby\": a, \"aria-hidden\": !0, id: o });\n        });var e = this.$element.find(\".is-active\").children(\"[data-tab-content]\");e.length && this.down(e, !0), this._events();\n      } }, { key: \"_events\", value: function value() {\n        var e = this;this.$tabs.each(function () {\n          var i = t(this),\n              n = i.children(\"[data-tab-content]\");n.length && i.children(\"a\").off(\"click.zf.accordion keydown.zf.accordion\").on(\"click.zf.accordion\", function (t) {\n            t.preventDefault(), e.toggle(n);\n          }).on(\"keydown.zf.accordion\", function (t) {\n            Foundation.Keyboard.handleKey(t, \"Accordion\", { toggle: function toggle() {\n                e.toggle(n);\n              }, next: function next() {\n                var t = i.next().find(\"a\").focus();e.options.multiExpand || t.trigger(\"click.zf.accordion\");\n              }, previous: function previous() {\n                var t = i.prev().find(\"a\").focus();e.options.multiExpand || t.trigger(\"click.zf.accordion\");\n              }, handled: function handled() {\n                t.preventDefault(), t.stopPropagation();\n              } });\n          });\n        });\n      } }, { key: \"toggle\", value: function value(t) {\n        t.parent().hasClass(\"is-active\") ? this.up(t) : this.down(t);\n      } }, { key: \"down\", value: function value(e, i) {\n        var n = this;if (e.attr(\"aria-hidden\", !1).parent(\"[data-tab-content]\").addBack().parent().addClass(\"is-active\"), !this.options.multiExpand && !i) {\n          var s = this.$element.children(\".is-active\").children(\"[data-tab-content]\");s.length && this.up(s.not(e));\n        }e.slideDown(this.options.slideSpeed, function () {\n          n.$element.trigger(\"down.zf.accordion\", [e]);\n        }), t(\"#\" + e.attr(\"aria-labelledby\")).attr({ \"aria-expanded\": !0, \"aria-selected\": !0 });\n      } }, { key: \"up\", value: function value(e) {\n        var i = e.parent().siblings(),\n            n = this;(this.options.allowAllClosed || i.hasClass(\"is-active\")) && e.parent().hasClass(\"is-active\") && (e.slideUp(n.options.slideSpeed, function () {\n          n.$element.trigger(\"up.zf.accordion\", [e]);\n        }), e.attr(\"aria-hidden\", !0).parent().removeClass(\"is-active\"), t(\"#\" + e.attr(\"aria-labelledby\")).attr({ \"aria-expanded\": !1, \"aria-selected\": !1 }));\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.find(\"[data-tab-content]\").stop(!0).slideUp(0).css(\"display\", \"\"), this.$element.find(\"a\").off(\".zf.accordion\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { slideSpeed: 250, multiExpand: !1, allowAllClosed: !1 }, Foundation.plugin(e, \"Accordion\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), Foundation.Nest.Feather(this.$element, \"accordion\"), this._init(), Foundation.registerPlugin(this, \"AccordionMenu\"), Foundation.Keyboard.register(\"AccordionMenu\", { ENTER: \"toggle\", SPACE: \"toggle\", ARROW_RIGHT: \"open\", ARROW_UP: \"up\", ARROW_DOWN: \"down\", ARROW_LEFT: \"close\", ESCAPE: \"closeAll\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this.$element.find(\"[data-submenu]\").not(\".is-active\").slideUp(0), this.$element.attr({ role: \"menu\", \"aria-multiselectable\": this.options.multiOpen }), this.$menuLinks = this.$element.find(\".is-accordion-submenu-parent\"), this.$menuLinks.each(function () {\n          var e = this.id || Foundation.GetYoDigits(6, \"acc-menu-link\"),\n              i = t(this),\n              n = i.children(\"[data-submenu]\"),\n              s = n[0].id || Foundation.GetYoDigits(6, \"acc-menu\"),\n              o = n.hasClass(\"is-active\");i.attr({ \"aria-controls\": s, \"aria-expanded\": o, role: \"menuitem\", id: e }), n.attr({ \"aria-labelledby\": e, \"aria-hidden\": !o, role: \"menu\", id: s });\n        });var e = this.$element.find(\".is-active\");if (e.length) {\n          var i = this;e.each(function () {\n            i.down(t(this));\n          });\n        }this._events();\n      } }, { key: \"_events\", value: function value() {\n        var e = this;this.$element.find(\"li\").each(function () {\n          var i = t(this).children(\"[data-submenu]\");i.length && t(this).children(\"a\").off(\"click.zf.accordionMenu\").on(\"click.zf.accordionMenu\", function (t) {\n            t.preventDefault(), e.toggle(i);\n          });\n        }).on(\"keydown.zf.accordionmenu\", function (i) {\n          var n,\n              s,\n              o = t(this),\n              a = o.parent(\"ul\").children(\"li\"),\n              r = o.children(\"[data-submenu]\");a.each(function (e) {\n            if (t(this).is(o)) return n = a.eq(Math.max(0, e - 1)).find(\"a\").first(), s = a.eq(Math.min(e + 1, a.length - 1)).find(\"a\").first(), t(this).children(\"[data-submenu]:visible\").length && (s = o.find(\"li:first-child\").find(\"a\").first()), t(this).is(\":first-child\") ? n = o.parents(\"li\").first().find(\"a\").first() : n.parents(\"li\").first().children(\"[data-submenu]:visible\").length && (n = n.parents(\"li\").find(\"li:last-child\").find(\"a\").first()), void (t(this).is(\":last-child\") && (s = o.parents(\"li\").first().next(\"li\").find(\"a\").first()));\n          }), Foundation.Keyboard.handleKey(i, \"AccordionMenu\", { open: function open() {\n              r.is(\":hidden\") && (e.down(r), r.find(\"li\").first().find(\"a\").first().focus());\n            }, close: function close() {\n              r.length && !r.is(\":hidden\") ? e.up(r) : o.parent(\"[data-submenu]\").length && (e.up(o.parent(\"[data-submenu]\")), o.parents(\"li\").first().find(\"a\").first().focus());\n            }, up: function up() {\n              return n.focus(), !0;\n            }, down: function down() {\n              return s.focus(), !0;\n            }, toggle: function toggle() {\n              o.children(\"[data-submenu]\").length && e.toggle(o.children(\"[data-submenu]\"));\n            }, closeAll: function closeAll() {\n              e.hideAll();\n            }, handled: function handled(t) {\n              t && i.preventDefault(), i.stopImmediatePropagation();\n            } });\n        });\n      } }, { key: \"hideAll\", value: function value() {\n        this.$element.find(\"[data-submenu]\").slideUp(this.options.slideSpeed);\n      } }, { key: \"toggle\", value: function value(t) {\n        t.is(\":animated\") || (t.is(\":hidden\") ? this.down(t) : this.up(t));\n      } }, { key: \"down\", value: function value(t) {\n        var e = this;this.options.multiOpen || this.up(this.$element.find(\".is-active\").not(t.parentsUntil(this.$element).add(t))), t.addClass(\"is-active\").attr({ \"aria-hidden\": !1 }).parent(\".is-accordion-submenu-parent\").attr({ \"aria-expanded\": !0 }), t.slideDown(e.options.slideSpeed, function () {\n          e.$element.trigger(\"down.zf.accordionMenu\", [t]);\n        });\n      } }, { key: \"up\", value: function value(t) {\n        var e = this;t.slideUp(e.options.slideSpeed, function () {\n          e.$element.trigger(\"up.zf.accordionMenu\", [t]);\n        });var i = t.find(\"[data-submenu]\").slideUp(0).addBack().attr(\"aria-hidden\", !0);i.parent(\".is-accordion-submenu-parent\").attr(\"aria-expanded\", !1);\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.find(\"[data-submenu]\").slideDown(0).css(\"display\", \"\"), this.$element.find(\"a\").off(\"click.zf.accordionMenu\"), Foundation.Nest.Burn(this.$element, \"accordion\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { slideSpeed: 250, multiOpen: !0 }, Foundation.plugin(e, \"AccordionMenu\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), Foundation.Nest.Feather(this.$element, \"drilldown\"), this._init(), Foundation.registerPlugin(this, \"Drilldown\"), Foundation.Keyboard.register(\"Drilldown\", { ENTER: \"open\", SPACE: \"open\", ARROW_RIGHT: \"next\", ARROW_UP: \"up\", ARROW_DOWN: \"down\", ARROW_LEFT: \"previous\", ESCAPE: \"close\", TAB: \"down\", SHIFT_TAB: \"up\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this.$submenuAnchors = this.$element.find(\"li.is-drilldown-submenu-parent\").children(\"a\"), this.$submenus = this.$submenuAnchors.parent(\"li\").children(\"[data-submenu]\"), this.$menuItems = this.$element.find(\"li\").not(\".js-drilldown-back\").attr(\"role\", \"menuitem\").find(\"a\"), this._prepareMenu(), this._keyboardEvents();\n      } }, { key: \"_prepareMenu\", value: function value() {\n        var e = this;this.$submenuAnchors.each(function () {\n          var i = t(this),\n              n = i.parent();e.options.parentLink && i.clone().prependTo(n.children(\"[data-submenu]\")).wrap('<li class=\"is-submenu-parent-item is-submenu-item is-drilldown-submenu-item\" role=\"menu-item\"></li>'), i.data(\"savedHref\", i.attr(\"href\")).removeAttr(\"href\").attr(\"tabindex\", 0), i.children(\"[data-submenu]\").attr({ \"aria-hidden\": !0, tabindex: 0, role: \"menu\" }), e._events(i);\n        }), this.$submenus.each(function () {\n          var i = t(this),\n              n = i.find(\".js-drilldown-back\");n.length || i.prepend(e.options.backButton), e._back(i);\n        }), this.$element.parent().hasClass(\"is-drilldown\") || (this.$wrapper = t(this.options.wrapper).addClass(\"is-drilldown\"), this.$wrapper = this.$element.wrap(this.$wrapper).parent().css(this._getMaxDims()));\n      } }, { key: \"_events\", value: function value(e) {\n        var i = this;e.off(\"click.zf.drilldown\").on(\"click.zf.drilldown\", function (n) {\n          if (t(n.target).parentsUntil(\"ul\", \"li\").hasClass(\"is-drilldown-submenu-parent\") && (n.stopImmediatePropagation(), n.preventDefault()), i._show(e.parent(\"li\")), i.options.closeOnClick) {\n            var s = t(\"body\");s.off(\".zf.drilldown\").on(\"click.zf.drilldown\", function (e) {\n              e.target === i.$element[0] || t.contains(i.$element[0], e.target) || (e.preventDefault(), i._hideAll(), s.off(\".zf.drilldown\"));\n            });\n          }\n        });\n      } }, { key: \"_keyboardEvents\", value: function value() {\n        var e = this;this.$menuItems.add(this.$element.find(\".js-drilldown-back > a\")).on(\"keydown.zf.drilldown\", function (i) {\n          var n,\n              s,\n              o = t(this),\n              a = o.parent(\"li\").parent(\"ul\").children(\"li\").children(\"a\");a.each(function (e) {\n            if (t(this).is(o)) return n = a.eq(Math.max(0, e - 1)), void (s = a.eq(Math.min(e + 1, a.length - 1)));\n          }), Foundation.Keyboard.handleKey(i, \"Drilldown\", { next: function next() {\n              if (o.is(e.$submenuAnchors)) return e._show(o.parent(\"li\")), o.parent(\"li\").one(Foundation.transitionend(o), function () {\n                o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();\n              }), !0;\n            }, previous: function previous() {\n              return e._hide(o.parent(\"li\").parent(\"ul\")), o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o), function () {\n                setTimeout(function () {\n                  o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();\n                }, 1);\n              }), !0;\n            }, up: function up() {\n              return n.focus(), !0;\n            }, down: function down() {\n              return s.focus(), !0;\n            }, close: function close() {\n              e._back();\n            }, open: function open() {\n              return o.is(e.$menuItems) ? o.is(e.$submenuAnchors) ? (e._show(o.parent(\"li\")), o.parent(\"li\").one(Foundation.transitionend(o), function () {\n                o.parent(\"li\").find(\"ul li a\").filter(e.$menuItems).first().focus();\n              }), !0) : void 0 : (e._hide(o.parent(\"li\").parent(\"ul\")), o.parent(\"li\").parent(\"ul\").one(Foundation.transitionend(o), function () {\n                setTimeout(function () {\n                  o.parent(\"li\").parent(\"ul\").parent(\"li\").children(\"a\").first().focus();\n                }, 1);\n              }), !0);\n            }, handled: function handled(t) {\n              t && i.preventDefault(), i.stopImmediatePropagation();\n            } });\n        });\n      } }, { key: \"_hideAll\", value: function value() {\n        var t = this.$element.find(\".is-drilldown-submenu.is-active\").addClass(\"is-closing\");t.one(Foundation.transitionend(t), function (e) {\n          t.removeClass(\"is-active is-closing\");\n        }), this.$element.trigger(\"closed.zf.drilldown\");\n      } }, { key: \"_back\", value: function value(t) {\n        var e = this;t.off(\"click.zf.drilldown\"), t.children(\".js-drilldown-back\").on(\"click.zf.drilldown\", function (i) {\n          i.stopImmediatePropagation(), e._hide(t);var n = t.parent(\"li\").parent(\"ul\").parent(\"li\");n.length && e._show(n);\n        });\n      } }, { key: \"_menuLinkEvents\", value: function value() {\n        var t = this;this.$menuItems.not(\".is-drilldown-submenu-parent\").off(\"click.zf.drilldown\").on(\"click.zf.drilldown\", function (e) {\n          setTimeout(function () {\n            t._hideAll();\n          }, 0);\n        });\n      } }, { key: \"_show\", value: function value(t) {\n        t.attr(\"aria-expanded\", !0), t.children(\"[data-submenu]\").addClass(\"is-active\").attr(\"aria-hidden\", !1), this.$element.trigger(\"open.zf.drilldown\", [t]);\n      } }, { key: \"_hide\", value: function value(t) {\n        t.parent(\"li\").attr(\"aria-expanded\", !1), t.attr(\"aria-hidden\", !0).addClass(\"is-closing\").one(Foundation.transitionend(t), function () {\n          t.removeClass(\"is-active is-closing\"), t.blur();\n        }), t.trigger(\"hide.zf.drilldown\", [t]);\n      } }, { key: \"_getMaxDims\", value: function value() {\n        var t = 0,\n            e = {};return this.$submenus.add(this.$element).each(function (e, i) {\n          var n = i.getBoundingClientRect().height;n > t && (t = n);\n        }), e[\"min-height\"] = t + \"px\", e[\"max-width\"] = this.$element[0].getBoundingClientRect().width + \"px\", e;\n      } }, { key: \"destroy\", value: function value() {\n        this._hideAll(), Foundation.Nest.Burn(this.$element, \"drilldown\"), this.$element.unwrap().find(\".js-drilldown-back, .is-submenu-parent-item\").remove().end().find(\".is-active, .is-closing, .is-drilldown-submenu\").removeClass(\"is-active is-closing is-drilldown-submenu\").end().find(\"[data-submenu]\").removeAttr(\"aria-hidden tabindex role\"), this.$submenuAnchors.each(function () {\n          t(this).off(\".zf.drilldown\");\n        }), this.$element.find(\"a\").each(function () {\n          var e = t(this);e.removeAttr(\"tabindex\"), e.data(\"savedHref\") && e.attr(\"href\", e.data(\"savedHref\")).removeData(\"savedHref\");\n        }), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { backButton: '<li class=\"js-drilldown-back\"><a tabindex=\"0\">Back</a></li>', wrapper: \"<div></div>\", parentLink: !1, closeOnClick: !1 }, Foundation.plugin(e, \"Drilldown\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Dropdown\"), Foundation.Keyboard.register(\"Dropdown\", { ENTER: \"open\", SPACE: \"open\", ESCAPE: \"close\", TAB: \"tab_forward\", SHIFT_TAB: \"tab_backward\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this.$element.attr(\"id\");this.$anchor = t(t('[data-toggle=\"' + e + '\"]').length ? '[data-toggle=\"' + e + '\"]' : '[data-open=\"' + e + '\"]'), this.$anchor.attr({ \"aria-controls\": e, \"data-is-focus\": !1, \"data-yeti-box\": e, \"aria-haspopup\": !0, \"aria-expanded\": !1 }), this.options.positionClass = this.getPositionClass(), this.counter = 4, this.usedPositions = [], this.$element.attr({ \"aria-hidden\": \"true\", \"data-yeti-box\": e, \"data-resize\": e, \"aria-labelledby\": this.$anchor[0].id || Foundation.GetYoDigits(6, \"dd-anchor\") }), this._events();\n      } }, { key: \"getPositionClass\", value: function value() {\n        var t = this.$element[0].className.match(/(top|left|right|bottom)/g);t = t ? t[0] : \"\";var e = /float-(\\S+)/.exec(this.$anchor[0].className);e = e ? e[1] : \"\";var i = e ? e + \" \" + t : t;return i;\n      } }, { key: \"_reposition\", value: function value(t) {\n        this.usedPositions.push(t ? t : \"bottom\"), !t && this.usedPositions.indexOf(\"top\") < 0 ? this.$element.addClass(\"top\") : \"top\" === t && this.usedPositions.indexOf(\"bottom\") < 0 ? this.$element.removeClass(t) : \"left\" === t && this.usedPositions.indexOf(\"right\") < 0 ? this.$element.removeClass(t).addClass(\"right\") : \"right\" === t && this.usedPositions.indexOf(\"left\") < 0 ? this.$element.removeClass(t).addClass(\"left\") : !t && this.usedPositions.indexOf(\"top\") > -1 && this.usedPositions.indexOf(\"left\") < 0 ? this.$element.addClass(\"left\") : \"top\" === t && this.usedPositions.indexOf(\"bottom\") > -1 && this.usedPositions.indexOf(\"left\") < 0 ? this.$element.removeClass(t).addClass(\"left\") : \"left\" === t && this.usedPositions.indexOf(\"right\") > -1 && this.usedPositions.indexOf(\"bottom\") < 0 ? this.$element.removeClass(t) : \"right\" === t && this.usedPositions.indexOf(\"left\") > -1 && this.usedPositions.indexOf(\"bottom\") < 0 ? this.$element.removeClass(t) : this.$element.removeClass(t), this.classChanged = !0, this.counter--;\n      } }, { key: \"_setPosition\", value: function value() {\n        if (\"false\" === this.$anchor.attr(\"aria-expanded\")) return !1;var t = this.getPositionClass(),\n            e = Foundation.Box.GetDimensions(this.$element),\n            i = (Foundation.Box.GetDimensions(this.$anchor), \"left\" === t ? \"left\" : \"right\" === t ? \"left\" : \"top\"),\n            n = \"top\" === i ? \"height\" : \"width\";\"height\" === n ? this.options.vOffset : this.options.hOffset;if (e.width >= e.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.$element)) return this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, \"center bottom\", this.options.vOffset, this.options.hOffset, !0)).css({ width: e.windowDims.width - 2 * this.options.hOffset, height: \"auto\" }), this.classChanged = !0, !1;for (this.$element.offset(Foundation.Box.GetOffsets(this.$element, this.$anchor, t, this.options.vOffset, this.options.hOffset)); !Foundation.Box.ImNotTouchingYou(this.$element, !1, !0) && this.counter;) {\n          this._reposition(t), this._setPosition();\n        }\n      } }, { key: \"_events\", value: function value() {\n        var e = this;this.$element.on({ \"open.zf.trigger\": this.open.bind(this), \"close.zf.trigger\": this.close.bind(this), \"toggle.zf.trigger\": this.toggle.bind(this), \"resizeme.zf.trigger\": this._setPosition.bind(this) }), this.options.hover && (this.$anchor.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\", function () {\n          t('body[data-whatinput=\"mouse\"]').is(\"*\") && (clearTimeout(e.timeout), e.timeout = setTimeout(function () {\n            e.open(), e.$anchor.data(\"hover\", !0);\n          }, e.options.hoverDelay));\n        }).on(\"mouseleave.zf.dropdown\", function () {\n          clearTimeout(e.timeout), e.timeout = setTimeout(function () {\n            e.close(), e.$anchor.data(\"hover\", !1);\n          }, e.options.hoverDelay);\n        }), this.options.hoverPane && this.$element.off(\"mouseenter.zf.dropdown mouseleave.zf.dropdown\").on(\"mouseenter.zf.dropdown\", function () {\n          clearTimeout(e.timeout);\n        }).on(\"mouseleave.zf.dropdown\", function () {\n          clearTimeout(e.timeout), e.timeout = setTimeout(function () {\n            e.close(), e.$anchor.data(\"hover\", !1);\n          }, e.options.hoverDelay);\n        })), this.$anchor.add(this.$element).on(\"keydown.zf.dropdown\", function (i) {\n          var n = t(this),\n              s = Foundation.Keyboard.findFocusable(e.$element);Foundation.Keyboard.handleKey(i, \"Dropdown\", { tab_forward: function tab_forward() {\n              e.$element.find(\":focus\").is(s.eq(-1)) && (e.options.trapFocus ? (s.eq(0).focus(), i.preventDefault()) : e.close());\n            }, tab_backward: function tab_backward() {\n              (e.$element.find(\":focus\").is(s.eq(0)) || e.$element.is(\":focus\")) && (e.options.trapFocus ? (s.eq(-1).focus(), i.preventDefault()) : e.close());\n            }, open: function open() {\n              n.is(e.$anchor) && (e.open(), e.$element.attr(\"tabindex\", -1).focus(), i.preventDefault());\n            }, close: function close() {\n              e.close(), e.$anchor.focus();\n            } });\n        });\n      } }, { key: \"_addBodyHandler\", value: function value() {\n        var e = t(document.body).not(this.$element),\n            i = this;e.off(\"click.zf.dropdown\").on(\"click.zf.dropdown\", function (t) {\n          i.$anchor.is(t.target) || i.$anchor.find(t.target).length || i.$element.find(t.target).length || (i.close(), e.off(\"click.zf.dropdown\"));\n        });\n      } }, { key: \"open\", value: function value() {\n        if (this.$element.trigger(\"closeme.zf.dropdown\", this.$element.attr(\"id\")), this.$anchor.addClass(\"hover\").attr({ \"aria-expanded\": !0 }), this._setPosition(), this.$element.addClass(\"is-open\").attr({ \"aria-hidden\": !1 }), this.options.autoFocus) {\n          var t = Foundation.Keyboard.findFocusable(this.$element);t.length && t.eq(0).focus();\n        }this.options.closeOnClick && this._addBodyHandler(), this.$element.trigger(\"show.zf.dropdown\", [this.$element]);\n      } }, { key: \"close\", value: function value() {\n        if (!this.$element.hasClass(\"is-open\")) return !1;if (this.$element.removeClass(\"is-open\").attr({ \"aria-hidden\": !0 }), this.$anchor.removeClass(\"hover\").attr(\"aria-expanded\", !1), this.classChanged) {\n          var t = this.getPositionClass();t && this.$element.removeClass(t), this.$element.addClass(this.options.positionClass).css({ height: \"\", width: \"\" }), this.classChanged = !1, this.counter = 4, this.usedPositions.length = 0;\n        }this.$element.trigger(\"hide.zf.dropdown\", [this.$element]);\n      } }, { key: \"toggle\", value: function value() {\n        if (this.$element.hasClass(\"is-open\")) {\n          if (this.$anchor.data(\"hover\")) return;this.close();\n        } else this.open();\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.off(\".zf.trigger\").hide(), this.$anchor.off(\".zf.dropdown\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { hoverDelay: 250, hover: !1, hoverPane: !1, vOffset: 1, hOffset: 1, positionClass: \"\", trapFocus: !1, autoFocus: !1, closeOnClick: !1 }, Foundation.plugin(e, \"Dropdown\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), Foundation.Nest.Feather(this.$element, \"dropdown\"), this._init(), Foundation.registerPlugin(this, \"DropdownMenu\"), Foundation.Keyboard.register(\"DropdownMenu\", { ENTER: \"open\", SPACE: \"open\", ARROW_RIGHT: \"next\", ARROW_UP: \"up\", ARROW_DOWN: \"down\", ARROW_LEFT: \"previous\", ESCAPE: \"close\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var t = this.$element.find(\"li.is-dropdown-submenu-parent\");this.$element.children(\".is-dropdown-submenu-parent\").children(\".is-dropdown-submenu\").addClass(\"first-sub\"), this.$menuItems = this.$element.find('[role=\"menuitem\"]'), this.$tabs = this.$element.children('[role=\"menuitem\"]'), this.$tabs.find(\"ul.is-dropdown-submenu\").addClass(this.options.verticalClass), this.$element.hasClass(this.options.rightClass) || \"right\" === this.options.alignment || Foundation.rtl() || this.$element.parents(\".top-bar-right\").is(\"*\") ? (this.options.alignment = \"right\", t.addClass(\"opens-left\")) : t.addClass(\"opens-right\"), this.changed = !1, this._events();\n      } }, { key: \"_isVertical\", value: function value() {\n        return \"block\" === this.$tabs.css(\"display\");\n      } }, { key: \"_events\", value: function value() {\n        var e = this,\n            i = \"ontouchstart\" in window || \"undefined\" != typeof window.ontouchstart,\n            n = \"is-dropdown-submenu-parent\",\n            s = function s(_s) {\n          var o = t(_s.target).parentsUntil(\"ul\", \".\" + n),\n              a = o.hasClass(n),\n              r = \"true\" === o.attr(\"data-is-click\"),\n              l = o.children(\".is-dropdown-submenu\");if (!a) return void (e.options.closeOnClickInside && e._hide(o));if (r) {\n            if (!e.options.closeOnClick || !e.options.clickOpen && !i || e.options.forceFollow && i) return;_s.stopImmediatePropagation(), _s.preventDefault(), e._hide(o);\n          } else _s.preventDefault(), _s.stopImmediatePropagation(), e._show(l), o.add(o.parentsUntil(e.$element, \".\" + n)).attr(\"data-is-click\", !0);\n        };(this.options.clickOpen || i) && this.$menuItems.on(\"click.zf.dropdownmenu touchstart.zf.dropdownmenu\", s), this.options.disableHover || this.$menuItems.on(\"mouseenter.zf.dropdownmenu\", function (i) {\n          var s = t(this),\n              o = s.hasClass(n);o && (clearTimeout(e.delay), e.delay = setTimeout(function () {\n            e._show(s.children(\".is-dropdown-submenu\"));\n          }, e.options.hoverDelay));\n        }).on(\"mouseleave.zf.dropdownmenu\", function (i) {\n          var s = t(this),\n              o = s.hasClass(n);if (o && e.options.autoclose) {\n            if (\"true\" === s.attr(\"data-is-click\") && e.options.clickOpen) return !1;clearTimeout(e.delay), e.delay = setTimeout(function () {\n              e._hide(s);\n            }, e.options.closingTime);\n          }\n        }), this.$menuItems.on(\"keydown.zf.dropdownmenu\", function (i) {\n          var n,\n              s,\n              o = t(i.target).parentsUntil(\"ul\", '[role=\"menuitem\"]'),\n              a = e.$tabs.index(o) > -1,\n              r = a ? e.$tabs : o.siblings(\"li\").add(o);r.each(function (e) {\n            if (t(this).is(o)) return n = r.eq(e - 1), void (s = r.eq(e + 1));\n          });var l = function l() {\n            o.is(\":last-child\") || (s.children(\"a:first\").focus(), i.preventDefault());\n          },\n              u = function u() {\n            n.children(\"a:first\").focus(), i.preventDefault();\n          },\n              d = function d() {\n            var t = o.children(\"ul.is-dropdown-submenu\");t.length && (e._show(t), o.find(\"li > a:first\").focus(), i.preventDefault());\n          },\n              h = function h() {\n            var t = o.parent(\"ul\").parent(\"li\");t.children(\"a:first\").focus(), e._hide(t), i.preventDefault();\n          },\n              c = { open: d, close: function close() {\n              e._hide(e.$element), e.$menuItems.find(\"a:first\").focus(), i.preventDefault();\n            }, handled: function handled() {\n              i.stopImmediatePropagation();\n            } };a ? e._isVertical() ? Foundation.rtl() ? t.extend(c, { down: l, up: u, next: h, previous: d }) : t.extend(c, { down: l, up: u, next: d, previous: h }) : Foundation.rtl() ? t.extend(c, { next: u, previous: l, down: d, up: h }) : t.extend(c, { next: l, previous: u, down: d, up: h }) : Foundation.rtl() ? t.extend(c, { next: h, previous: d, down: l, up: u }) : t.extend(c, { next: d, previous: h, down: l, up: u }), Foundation.Keyboard.handleKey(i, \"DropdownMenu\", c);\n        });\n      } }, { key: \"_addBodyHandler\", value: function value() {\n        var e = t(document.body),\n            i = this;e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\").on(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\", function (t) {\n          var n = i.$element.find(t.target);n.length || (i._hide(), e.off(\"mouseup.zf.dropdownmenu touchend.zf.dropdownmenu\"));\n        });\n      } }, { key: \"_show\", value: function value(e) {\n        var i = this.$tabs.index(this.$tabs.filter(function (i, n) {\n          return t(n).find(e).length > 0;\n        })),\n            n = e.parent(\"li.is-dropdown-submenu-parent\").siblings(\"li.is-dropdown-submenu-parent\");this._hide(n, i), e.css(\"visibility\", \"hidden\").addClass(\"js-dropdown-active\").attr({ \"aria-hidden\": !1 }).parent(\"li.is-dropdown-submenu-parent\").addClass(\"is-active\").attr({ \"aria-expanded\": !0 });var s = Foundation.Box.ImNotTouchingYou(e, null, !0);if (!s) {\n          var o = \"left\" === this.options.alignment ? \"-right\" : \"-left\",\n              a = e.parent(\".is-dropdown-submenu-parent\");a.removeClass(\"opens\" + o).addClass(\"opens-\" + this.options.alignment), s = Foundation.Box.ImNotTouchingYou(e, null, !0), s || a.removeClass(\"opens-\" + this.options.alignment).addClass(\"opens-inner\"), this.changed = !0;\n        }e.css(\"visibility\", \"\"), this.options.closeOnClick && this._addBodyHandler(), this.$element.trigger(\"show.zf.dropdownmenu\", [e]);\n      } }, { key: \"_hide\", value: function value(t, e) {\n        var i;i = t && t.length ? t : void 0 !== e ? this.$tabs.not(function (t, i) {\n          return t === e;\n        }) : this.$element;var n = i.hasClass(\"is-active\") || i.find(\".is-active\").length > 0;if (n) {\n          if (i.find(\"li.is-active\").add(i).attr({ \"aria-expanded\": !1, \"data-is-click\": !1 }).removeClass(\"is-active\"), i.find(\"ul.js-dropdown-active\").attr({ \"aria-hidden\": !0 }).removeClass(\"js-dropdown-active\"), this.changed || i.find(\"opens-inner\").length) {\n            var s = \"left\" === this.options.alignment ? \"right\" : \"left\";i.find(\"li.is-dropdown-submenu-parent\").add(i).removeClass(\"opens-inner opens-\" + this.options.alignment).addClass(\"opens-\" + s), this.changed = !1;\n          }this.$element.trigger(\"hide.zf.dropdownmenu\", [i]);\n        }\n      } }, { key: \"destroy\", value: function value() {\n        this.$menuItems.off(\".zf.dropdownmenu\").removeAttr(\"data-is-click\").removeClass(\"is-right-arrow is-left-arrow is-down-arrow opens-right opens-left opens-inner\"), t(document.body).off(\".zf.dropdownmenu\"), Foundation.Nest.Burn(this.$element, \"dropdown\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { disableHover: !1, autoclose: !0, hoverDelay: 50, clickOpen: !1, closingTime: 500, alignment: \"left\", closeOnClick: !0, closeOnClickInside: !0, verticalClass: \"vertical\", rightClass: \"align-right\", forceFollow: !0 }, Foundation.plugin(e, \"DropdownMenu\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Equalizer\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this.$element.attr(\"data-equalizer\") || \"\",\n            i = this.$element.find('[data-equalizer-watch=\"' + e + '\"]');this.$watched = i.length ? i : this.$element.find(\"[data-equalizer-watch]\"), this.$element.attr(\"data-resize\", e || Foundation.GetYoDigits(6, \"eq\")), this.hasNested = this.$element.find(\"[data-equalizer]\").length > 0, this.isNested = this.$element.parentsUntil(document.body, \"[data-equalizer]\").length > 0, this.isOn = !1, this._bindHandler = { onResizeMeBound: this._onResizeMe.bind(this), onPostEqualizedBound: this._onPostEqualized.bind(this) };var n,\n            s = this.$element.find(\"img\");this.options.equalizeOn ? (n = this._checkMQ(), t(window).on(\"changed.zf.mediaquery\", this._checkMQ.bind(this))) : this._events(), (void 0 !== n && n === !1 || void 0 === n) && (s.length ? Foundation.onImagesLoaded(s, this._reflow.bind(this)) : this._reflow());\n      } }, { key: \"_pauseEvents\", value: function value() {\n        this.isOn = !1, this.$element.off({ \".zf.equalizer\": this._bindHandler.onPostEqualizedBound, \"resizeme.zf.trigger\": this._bindHandler.onResizeMeBound });\n      } }, { key: \"_onResizeMe\", value: function value(t) {\n        this._reflow();\n      } }, { key: \"_onPostEqualized\", value: function value(t) {\n        t.target !== this.$element[0] && this._reflow();\n      } }, { key: \"_events\", value: function value() {\n        this._pauseEvents(), this.hasNested ? this.$element.on(\"postequalized.zf.equalizer\", this._bindHandler.onPostEqualizedBound) : this.$element.on(\"resizeme.zf.trigger\", this._bindHandler.onResizeMeBound), this.isOn = !0;\n      } }, { key: \"_checkMQ\", value: function value() {\n        var t = !Foundation.MediaQuery.atLeast(this.options.equalizeOn);return t ? this.isOn && (this._pauseEvents(), this.$watched.css(\"height\", \"auto\")) : this.isOn || this._events(), t;\n      } }, { key: \"_killswitch\", value: function value() {} }, { key: \"_reflow\", value: function value() {\n        return !this.options.equalizeOnStack && this._isStacked() ? (this.$watched.css(\"height\", \"auto\"), !1) : void (this.options.equalizeByRow ? this.getHeightsByRow(this.applyHeightByRow.bind(this)) : this.getHeights(this.applyHeight.bind(this)));\n      } }, { key: \"_isStacked\", value: function value() {\n        return this.$watched[0].getBoundingClientRect().top !== this.$watched[1].getBoundingClientRect().top;\n      } }, { key: \"getHeights\", value: function value(t) {\n        for (var e = [], i = 0, n = this.$watched.length; i < n; i++) {\n          this.$watched[i].style.height = \"auto\", e.push(this.$watched[i].offsetHeight);\n        }t(e);\n      } }, { key: \"getHeightsByRow\", value: function value(e) {\n        var i = this.$watched.length ? this.$watched.first().offset().top : 0,\n            n = [],\n            s = 0;n[s] = [];for (var o = 0, a = this.$watched.length; o < a; o++) {\n          this.$watched[o].style.height = \"auto\";var r = t(this.$watched[o]).offset().top;r != i && (s++, n[s] = [], i = r), n[s].push([this.$watched[o], this.$watched[o].offsetHeight]);\n        }for (var l = 0, u = n.length; l < u; l++) {\n          var d = t(n[l]).map(function () {\n            return this[1];\n          }).get(),\n              h = Math.max.apply(null, d);n[l].push(h);\n        }e(n);\n      } }, { key: \"applyHeight\", value: function value(t) {\n        var e = Math.max.apply(null, t);this.$element.trigger(\"preequalized.zf.equalizer\"), this.$watched.css(\"height\", e), this.$element.trigger(\"postequalized.zf.equalizer\");\n      } }, { key: \"applyHeightByRow\", value: function value(e) {\n        this.$element.trigger(\"preequalized.zf.equalizer\");for (var i = 0, n = e.length; i < n; i++) {\n          var s = e[i].length,\n              o = e[i][s - 1];if (s <= 2) t(e[i][0][0]).css({ height: \"auto\" });else {\n            this.$element.trigger(\"preequalizedrow.zf.equalizer\");for (var a = 0, r = s - 1; a < r; a++) {\n              t(e[i][a][0]).css({ height: o });\n            }this.$element.trigger(\"postequalizedrow.zf.equalizer\");\n          }\n        }this.$element.trigger(\"postequalized.zf.equalizer\");\n      } }, { key: \"destroy\", value: function value() {\n        this._pauseEvents(), this.$watched.css(\"height\", \"auto\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { equalizeOnStack: !1, equalizeByRow: !1, equalizeOn: \"\" }, Foundation.plugin(e, \"Equalizer\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, n), this.rules = [], this.currentPath = \"\", this._init(), this._events(), Foundation.registerPlugin(this, \"Interchange\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this._addBreakpoints(), this._generateRules(), this._reflow();\n      } }, { key: \"_events\", value: function value() {\n        t(window).on(\"resize.zf.interchange\", Foundation.util.throttle(this._reflow.bind(this), 50));\n      } }, { key: \"_reflow\", value: function value() {\n        var t;for (var e in this.rules) {\n          if (this.rules.hasOwnProperty(e)) {\n            var i = this.rules[e];window.matchMedia(i.query).matches && (t = i);\n          }\n        }t && this.replace(t.path);\n      } }, { key: \"_addBreakpoints\", value: function value() {\n        for (var t in Foundation.MediaQuery.queries) {\n          if (Foundation.MediaQuery.queries.hasOwnProperty(t)) {\n            var i = Foundation.MediaQuery.queries[t];e.SPECIAL_QUERIES[i.name] = i.value;\n          }\n        }\n      } }, { key: \"_generateRules\", value: function value(t) {\n        var i,\n            n = [];i = this.options.rules ? this.options.rules : this.$element.data(\"interchange\").match(/\\[.*?\\]/g);for (var s in i) {\n          if (i.hasOwnProperty(s)) {\n            var o = i[s].slice(1, -1).split(\", \"),\n                a = o.slice(0, -1).join(\"\"),\n                r = o[o.length - 1];e.SPECIAL_QUERIES[r] && (r = e.SPECIAL_QUERIES[r]), n.push({ path: a, query: r });\n          }\n        }this.rules = n;\n      } }, { key: \"replace\", value: function value(e) {\n        if (this.currentPath !== e) {\n          var i = this,\n              n = \"replaced.zf.interchange\";\"IMG\" === this.$element[0].nodeName ? this.$element.attr(\"src\", e).on(\"load\", function () {\n            i.currentPath = e;\n          }).trigger(n) : e.match(/\\.(gif|jpg|jpeg|png|svg|tiff)([?#].*)?/i) ? this.$element.css({ \"background-image\": \"url(\" + e + \")\" }).trigger(n) : t.get(e, function (s) {\n            i.$element.html(s).trigger(n), t(s).foundation(), i.currentPath = e;\n          });\n        }\n      } }, { key: \"destroy\", value: function value() {} }]), e;\n  }();e.defaults = { rules: null }, e.SPECIAL_QUERIES = { landscape: \"screen and (orientation: landscape)\", portrait: \"screen and (orientation: portrait)\", retina: \"only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx)\" }, Foundation.plugin(e, \"Interchange\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Magellan\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this.$element[0].id || Foundation.GetYoDigits(6, \"magellan\");this.$targets = t(\"[data-magellan-target]\"), this.$links = this.$element.find(\"a\"), this.$element.attr({ \"data-resize\": e, \"data-scroll\": e, id: e }), this.$active = t(), this.scrollPos = parseInt(window.pageYOffset, 10), this._events();\n      } }, { key: \"calcPoints\", value: function value() {\n        var e = this,\n            i = document.body,\n            n = document.documentElement;this.points = [], this.winHeight = Math.round(Math.max(window.innerHeight, n.clientHeight)), this.docHeight = Math.round(Math.max(i.scrollHeight, i.offsetHeight, n.clientHeight, n.scrollHeight, n.offsetHeight)), this.$targets.each(function () {\n          var i = t(this),\n              n = Math.round(i.offset().top - e.options.threshold);i.targetPoint = n, e.points.push(n);\n        });\n      } }, { key: \"_events\", value: function value() {\n        var e = this;t(\"html, body\"), { duration: e.options.animationDuration, easing: e.options.animationEasing };t(window).one(\"load\", function () {\n          e.options.deepLinking && location.hash && e.scrollToLoc(location.hash), e.calcPoints(), e._updateActive();\n        }), this.$element.on({ \"resizeme.zf.trigger\": this.reflow.bind(this), \"scrollme.zf.trigger\": this._updateActive.bind(this) }).on(\"click.zf.magellan\", 'a[href^=\"#\"]', function (t) {\n          t.preventDefault();var i = this.getAttribute(\"href\");e.scrollToLoc(i);\n        });\n      } }, { key: \"scrollToLoc\", value: function value(e) {\n        if (!t(e).length) return !1;var i = Math.round(t(e).offset().top - this.options.threshold / 2 - this.options.barOffset);t(\"html, body\").stop(!0).animate({ scrollTop: i }, this.options.animationDuration, this.options.animationEasing);\n      } }, { key: \"reflow\", value: function value() {\n        this.calcPoints(), this._updateActive();\n      } }, { key: \"_updateActive\", value: function value() {\n        var t,\n            e = parseInt(window.pageYOffset, 10);if (e + this.winHeight === this.docHeight) t = this.points.length - 1;else if (e < this.points[0]) t = 0;else {\n          var i = this.scrollPos < e,\n              n = this,\n              s = this.points.filter(function (t, s) {\n            return i ? t - n.options.barOffset <= e : t - n.options.barOffset - n.options.threshold <= e;\n          });t = s.length ? s.length - 1 : 0;\n        }if (this.$active.removeClass(this.options.activeClass), this.$active = this.$links.filter('[href=\"#' + this.$targets.eq(t).data(\"magellan-target\") + '\"]').addClass(this.options.activeClass), this.options.deepLinking) {\n          var o = this.$active[0].getAttribute(\"href\");window.history.pushState ? window.history.pushState(null, null, o) : window.location.hash = o;\n        }this.scrollPos = e, this.$element.trigger(\"update.zf.magellan\", [this.$active]);\n      } }, { key: \"destroy\", value: function value() {\n        if (this.$element.off(\".zf.trigger .zf.magellan\").find(\".\" + this.options.activeClass).removeClass(this.options.activeClass), this.options.deepLinking) {\n          var t = this.$active[0].getAttribute(\"href\");window.location.hash.replace(t, \"\");\n        }Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { animationDuration: 500, animationEasing: \"linear\", threshold: 50, activeClass: \"active\", deepLinking: !1, barOffset: 0 }, Foundation.plugin(e, \"Magellan\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this.$lastTrigger = t(), this.$triggers = t(), this._init(), this._events(), Foundation.registerPlugin(this, \"OffCanvas\"), Foundation.Keyboard.register(\"OffCanvas\", { ESCAPE: \"close\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this.$element.attr(\"id\");if (this.$element.attr(\"aria-hidden\", \"true\"), this.$triggers = t(document).find('[data-open=\"' + e + '\"], [data-close=\"' + e + '\"], [data-toggle=\"' + e + '\"]').attr(\"aria-expanded\", \"false\").attr(\"aria-controls\", e), this.options.closeOnClick) if (t(\".js-off-canvas-exit\").length) this.$exiter = t(\".js-off-canvas-exit\");else {\n          var i = document.createElement(\"div\");i.setAttribute(\"class\", \"js-off-canvas-exit\"), t(\"[data-off-canvas-content]\").append(i), this.$exiter = t(i);\n        }this.options.isRevealed = this.options.isRevealed || new RegExp(this.options.revealClass, \"g\").test(this.$element[0].className), this.options.isRevealed && (this.options.revealOn = this.options.revealOn || this.$element[0].className.match(/(reveal-for-medium|reveal-for-large)/g)[0].split(\"-\")[2], this._setMQChecker()), this.options.transitionTime || (this.options.transitionTime = 1e3 * parseFloat(window.getComputedStyle(t(\"[data-off-canvas-wrapper]\")[0]).transitionDuration));\n      } }, { key: \"_events\", value: function value() {\n        this.$element.off(\".zf.trigger .zf.offcanvas\").on({ \"open.zf.trigger\": this.open.bind(this), \"close.zf.trigger\": this.close.bind(this), \"toggle.zf.trigger\": this.toggle.bind(this), \"keydown.zf.offcanvas\": this._handleKeyboard.bind(this) }), this.options.closeOnClick && this.$exiter.length && this.$exiter.on({ \"click.zf.offcanvas\": this.close.bind(this) });\n      } }, { key: \"_setMQChecker\", value: function value() {\n        var e = this;t(window).on(\"changed.zf.mediaquery\", function () {\n          Foundation.MediaQuery.atLeast(e.options.revealOn) ? e.reveal(!0) : e.reveal(!1);\n        }).one(\"load.zf.offcanvas\", function () {\n          Foundation.MediaQuery.atLeast(e.options.revealOn) && e.reveal(!0);\n        });\n      } }, { key: \"reveal\", value: function value(t) {\n        var e = this.$element.find(\"[data-close]\");t ? (this.close(), this.isRevealed = !0, this.$element.off(\"open.zf.trigger toggle.zf.trigger\"), e.length && e.hide()) : (this.isRevealed = !1, this.$element.on({ \"open.zf.trigger\": this.open.bind(this), \"toggle.zf.trigger\": this.toggle.bind(this) }), e.length && e.show());\n      } }, { key: \"open\", value: function value(e, i) {\n        if (!this.$element.hasClass(\"is-open\") && !this.isRevealed) {\n          var n = this;t(document.body);this.options.forceTop && t(\"body\").scrollTop(0);var s = t(\"[data-off-canvas-wrapper]\");s.addClass(\"is-off-canvas-open is-open-\" + n.options.position), n.$element.addClass(\"is-open\"), this.$triggers.attr(\"aria-expanded\", \"true\"), this.$element.attr(\"aria-hidden\", \"false\").trigger(\"opened.zf.offcanvas\"), this.options.closeOnClick && this.$exiter.addClass(\"is-visible\"), i && (this.$lastTrigger = i), this.options.autoFocus && s.one(Foundation.transitionend(s), function () {\n            n.$element.hasClass(\"is-open\") && (n.$element.attr(\"tabindex\", \"-1\"), n.$element.focus());\n          }), this.options.trapFocus && s.one(Foundation.transitionend(s), function () {\n            n.$element.hasClass(\"is-open\") && (n.$element.attr(\"tabindex\", \"-1\"), n.trapFocus());\n          });\n        }\n      } }, { key: \"_trapFocus\", value: function value() {\n        var t = Foundation.Keyboard.findFocusable(this.$element),\n            e = t.eq(0),\n            i = t.eq(-1);t.off(\".zf.offcanvas\").on(\"keydown.zf.offcanvas\", function (t) {\n          var n = Foundation.Keyboard.parseKey(t);\"TAB\" === n && t.target === i[0] && (t.preventDefault(), e.focus()), \"SHIFT_TAB\" === n && t.target === e[0] && (t.preventDefault(), i.focus());\n        });\n      } }, { key: \"close\", value: function value(e) {\n        if (this.$element.hasClass(\"is-open\") && !this.isRevealed) {\n          var i = this;t(\"[data-off-canvas-wrapper]\").removeClass(\"is-off-canvas-open is-open-\" + i.options.position), i.$element.removeClass(\"is-open\"), this.$element.attr(\"aria-hidden\", \"true\").trigger(\"closed.zf.offcanvas\"), this.options.closeOnClick && this.$exiter.removeClass(\"is-visible\"), this.$triggers.attr(\"aria-expanded\", \"false\"), this.options.trapFocus && t(\"[data-off-canvas-content]\").removeAttr(\"tabindex\");\n        }\n      } }, { key: \"toggle\", value: function value(t, e) {\n        this.$element.hasClass(\"is-open\") ? this.close(t, e) : this.open(t, e);\n      } }, { key: \"_handleKeyboard\", value: function value(t) {\n        var e = this;Foundation.Keyboard.handleKey(t, \"OffCanvas\", { close: function close() {\n            return e.close(), e.$lastTrigger.focus(), !0;\n          }, handled: function handled() {\n            t.stopPropagation(), t.preventDefault();\n          } });\n      } }, { key: \"destroy\", value: function value() {\n        this.close(), this.$element.off(\".zf.trigger .zf.offcanvas\"), this.$exiter.off(\".zf.offcanvas\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { closeOnClick: !0, transitionTime: 0, position: \"left\", forceTop: !0, isRevealed: !1, revealOn: null, autoFocus: !0, revealClass: \"reveal-for-\", trapFocus: !1 }, Foundation.plugin(e, \"OffCanvas\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Orbit\"), Foundation.Keyboard.register(\"Orbit\", { ltr: { ARROW_RIGHT: \"next\", ARROW_LEFT: \"previous\" }, rtl: { ARROW_LEFT: \"next\", ARROW_RIGHT: \"previous\" } });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this.$wrapper = this.$element.find(\".\" + this.options.containerClass), this.$slides = this.$element.find(\".\" + this.options.slideClass);var t = this.$element.find(\"img\"),\n            e = this.$slides.filter(\".is-active\");e.length || this.$slides.eq(0).addClass(\"is-active\"), this.options.useMUI || this.$slides.addClass(\"no-motionui\"), t.length ? Foundation.onImagesLoaded(t, this._prepareForOrbit.bind(this)) : this._prepareForOrbit(), this.options.bullets && this._loadBullets(), this._events(), this.options.autoPlay && this.$slides.length > 1 && this.geoSync(), this.options.accessible && this.$wrapper.attr(\"tabindex\", 0);\n      } }, { key: \"_loadBullets\", value: function value() {\n        this.$bullets = this.$element.find(\".\" + this.options.boxOfBullets).find(\"button\");\n      } }, { key: \"geoSync\", value: function value() {\n        var t = this;this.timer = new Foundation.Timer(this.$element, { duration: this.options.timerDelay, infinite: !1 }, function () {\n          t.changeSlide(!0);\n        }), this.timer.start();\n      } }, { key: \"_prepareForOrbit\", value: function value() {\n        var t = this;this._setWrapperHeight(function (e) {\n          t._setSlideHeight(e);\n        });\n      } }, { key: \"_setWrapperHeight\", value: function value(e) {\n        var i,\n            n = 0,\n            s = 0;this.$slides.each(function () {\n          i = this.getBoundingClientRect().height, t(this).attr(\"data-slide\", s), s && t(this).css({ position: \"relative\", display: \"none\" }), n = i > n ? i : n, s++;\n        }), s === this.$slides.length && (this.$wrapper.css({ height: n }), e(n));\n      } }, { key: \"_setSlideHeight\", value: function value(e) {\n        this.$slides.each(function () {\n          t(this).css(\"max-height\", e);\n        });\n      } }, { key: \"_events\", value: function value() {\n        var e = this;if (this.$slides.length > 1) {\n          if (this.options.swipe && this.$slides.off(\"swipeleft.zf.orbit swiperight.zf.orbit\").on(\"swipeleft.zf.orbit\", function (t) {\n            t.preventDefault(), e.changeSlide(!0);\n          }).on(\"swiperight.zf.orbit\", function (t) {\n            t.preventDefault(), e.changeSlide(!1);\n          }), this.options.autoPlay && (this.$slides.on(\"click.zf.orbit\", function () {\n            e.$element.data(\"clickedOn\", !e.$element.data(\"clickedOn\")), e.timer[e.$element.data(\"clickedOn\") ? \"pause\" : \"start\"]();\n          }), this.options.pauseOnHover && this.$element.on(\"mouseenter.zf.orbit\", function () {\n            e.timer.pause();\n          }).on(\"mouseleave.zf.orbit\", function () {\n            e.$element.data(\"clickedOn\") || e.timer.start();\n          })), this.options.navButtons) {\n            var i = this.$element.find(\".\" + this.options.nextClass + \", .\" + this.options.prevClass);i.attr(\"tabindex\", 0).on(\"click.zf.orbit touchend.zf.orbit\", function (i) {\n              i.preventDefault(), e.changeSlide(t(this).hasClass(e.options.nextClass));\n            });\n          }this.options.bullets && this.$bullets.on(\"click.zf.orbit touchend.zf.orbit\", function () {\n            if (/is-active/g.test(this.className)) return !1;var i = t(this).data(\"slide\"),\n                n = i > e.$slides.filter(\".is-active\").data(\"slide\"),\n                s = e.$slides.eq(i);e.changeSlide(n, s, i);\n          }), this.options.accessible && this.$wrapper.add(this.$bullets).on(\"keydown.zf.orbit\", function (i) {\n            Foundation.Keyboard.handleKey(i, \"Orbit\", { next: function next() {\n                e.changeSlide(!0);\n              }, previous: function previous() {\n                e.changeSlide(!1);\n              }, handled: function handled() {\n                t(i.target).is(e.$bullets) && e.$bullets.filter(\".is-active\").focus();\n              } });\n          });\n        }\n      } }, { key: \"changeSlide\", value: function value(t, e, i) {\n        var n = this.$slides.filter(\".is-active\").eq(0);if (/mui/g.test(n[0].className)) return !1;var s,\n            o = this.$slides.first(),\n            a = this.$slides.last(),\n            r = t ? \"Right\" : \"Left\",\n            l = t ? \"Left\" : \"Right\",\n            u = this;s = e ? e : t ? this.options.infiniteWrap ? n.next(\".\" + this.options.slideClass).length ? n.next(\".\" + this.options.slideClass) : o : n.next(\".\" + this.options.slideClass) : this.options.infiniteWrap ? n.prev(\".\" + this.options.slideClass).length ? n.prev(\".\" + this.options.slideClass) : a : n.prev(\".\" + this.options.slideClass), s.length && (this.$element.trigger(\"beforeslidechange.zf.orbit\", [n, s]), this.options.bullets && (i = i || this.$slides.index(s), this._updateBullets(i)), this.options.useMUI ? (Foundation.Motion.animateIn(s.addClass(\"is-active\").css({ position: \"absolute\", top: 0 }), this.options[\"animInFrom\" + r], function () {\n          s.css({ position: \"relative\", display: \"block\" }).attr(\"aria-live\", \"polite\");\n        }), Foundation.Motion.animateOut(n.removeClass(\"is-active\"), this.options[\"animOutTo\" + l], function () {\n          n.removeAttr(\"aria-live\"), u.options.autoPlay && !u.timer.isPaused && u.timer.restart();\n        })) : (n.removeClass(\"is-active is-in\").removeAttr(\"aria-live\").hide(), s.addClass(\"is-active is-in\").attr(\"aria-live\", \"polite\").show(), this.options.autoPlay && !this.timer.isPaused && this.timer.restart()), this.$element.trigger(\"slidechange.zf.orbit\", [s]));\n      } }, { key: \"_updateBullets\", value: function value(t) {\n        var e = this.$element.find(\".\" + this.options.boxOfBullets).find(\".is-active\").removeClass(\"is-active\").blur(),\n            i = e.find(\"span:last\").detach();this.$bullets.eq(t).addClass(\"is-active\").append(i);\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.off(\".zf.orbit\").find(\"*\").off(\".zf.orbit\").end().hide(), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { bullets: !0, navButtons: !0, animInFromRight: \"slide-in-right\", animOutToRight: \"slide-out-right\", animInFromLeft: \"slide-in-left\", animOutToLeft: \"slide-out-left\", autoPlay: !0, timerDelay: 5e3, infiniteWrap: !0, swipe: !0, pauseOnHover: !0, accessible: !0, containerClass: \"orbit-container\", slideClass: \"orbit-slide\", boxOfBullets: \"orbit-bullets\", nextClass: \"orbit-next\", prevClass: \"orbit-previous\", useMUI: !0 }, Foundation.plugin(e, \"Orbit\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = t(i), this.rules = this.$element.data(\"responsive-menu\"), this.currentMq = null, this.currentPlugin = null, this._init(), this._events(), Foundation.registerPlugin(this, \"ResponsiveMenu\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        if (\"string\" == typeof this.rules) {\n          for (var e = {}, n = this.rules.split(\" \"), s = 0; s < n.length; s++) {\n            var o = n[s].split(\"-\"),\n                a = o.length > 1 ? o[0] : \"small\",\n                r = o.length > 1 ? o[1] : o[0];null !== i[r] && (e[a] = i[r]);\n          }this.rules = e;\n        }t.isEmptyObject(this.rules) || this._checkMediaQueries();\n      } }, { key: \"_events\", value: function value() {\n        var e = this;t(window).on(\"changed.zf.mediaquery\", function () {\n          e._checkMediaQueries();\n        });\n      } }, { key: \"_checkMediaQueries\", value: function value() {\n        var e,\n            n = this;t.each(this.rules, function (t) {\n          Foundation.MediaQuery.atLeast(t) && (e = t);\n        }), e && (this.currentPlugin instanceof this.rules[e].plugin || (t.each(i, function (t, e) {\n          n.$element.removeClass(e.cssClass);\n        }), this.$element.addClass(this.rules[e].cssClass), this.currentPlugin && this.currentPlugin.destroy(), this.currentPlugin = new this.rules[e].plugin(this.$element, {})));\n      } }, { key: \"destroy\", value: function value() {\n        this.currentPlugin.destroy(), t(window).off(\".zf.ResponsiveMenu\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = {};var i = { dropdown: { cssClass: \"dropdown\", plugin: Foundation._plugins[\"dropdown-menu\"] || null }, drilldown: { cssClass: \"drilldown\", plugin: Foundation._plugins.drilldown || null }, accordion: { cssClass: \"accordion-menu\", plugin: Foundation._plugins[\"accordion-menu\"] || null } };Foundation.plugin(e, \"ResponsiveMenu\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = t(i), this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), this._events(), Foundation.registerPlugin(this, \"ResponsiveToggle\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this.$element.data(\"responsive-toggle\");e || console.error(\"Your tab bar needs an ID of a Menu as the value of data-tab-bar.\"), this.$targetMenu = t(\"#\" + e), this.$toggler = this.$element.find(\"[data-toggle]\"), this._update();\n      } }, { key: \"_events\", value: function value() {\n        this._updateMqHandler = this._update.bind(this), t(window).on(\"changed.zf.mediaquery\", this._updateMqHandler), this.$toggler.on(\"click.zf.responsiveToggle\", this.toggleMenu.bind(this));\n      } }, { key: \"_update\", value: function value() {\n        Foundation.MediaQuery.atLeast(this.options.hideFor) ? (this.$element.hide(), this.$targetMenu.show()) : (this.$element.show(), this.$targetMenu.hide());\n      } }, { key: \"toggleMenu\", value: function value() {\n        Foundation.MediaQuery.atLeast(this.options.hideFor) || (this.$targetMenu.toggle(0), this.$element.trigger(\"toggled.zf.responsiveToggle\"));\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.off(\".zf.responsiveToggle\"), this.$toggler.off(\".zf.responsiveToggle\"), t(window).off(\"changed.zf.mediaquery\", this._updateMqHandler), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { hideFor: \"medium\" }, Foundation.plugin(e, \"ResponsiveToggle\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  function e() {\n    return (/iP(ad|hone|od).*OS/.test(window.navigator.userAgent)\n    );\n  }function i() {\n    return (/Android/.test(window.navigator.userAgent)\n    );\n  }function n() {\n    return e() || i();\n  }var s = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Reveal\"), Foundation.Keyboard.register(\"Reveal\", { ENTER: \"open\", SPACE: \"open\", ESCAPE: \"close\", TAB: \"tab_forward\", SHIFT_TAB: \"tab_backward\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        this.id = this.$element.attr(\"id\"), this.isActive = !1, this.cached = { mq: Foundation.MediaQuery.current }, this.isMobile = n(), this.$anchor = t(t('[data-open=\"' + this.id + '\"]').length ? '[data-open=\"' + this.id + '\"]' : '[data-toggle=\"' + this.id + '\"]'), this.$anchor.attr({ \"aria-controls\": this.id, \"aria-haspopup\": !0, tabindex: 0 }), (this.options.fullScreen || this.$element.hasClass(\"full\")) && (this.options.fullScreen = !0, this.options.overlay = !1), this.options.overlay && !this.$overlay && (this.$overlay = this._makeOverlay(this.id)), this.$element.attr({ role: \"dialog\", \"aria-hidden\": !0, \"data-yeti-box\": this.id, \"data-resize\": this.id }), this.$overlay ? this.$element.detach().appendTo(this.$overlay) : (this.$element.detach().appendTo(t(\"body\")), this.$element.addClass(\"without-overlay\")), this._events(), this.options.deepLink && window.location.hash === \"#\" + this.id && t(window).one(\"load.zf.reveal\", this.open.bind(this));\n      } }, { key: \"_makeOverlay\", value: function value(e) {\n        var i = t(\"<div></div>\").addClass(\"reveal-overlay\").appendTo(\"body\");return i;\n      } }, { key: \"_updatePosition\", value: function value() {\n        var e,\n            i,\n            n = this.$element.outerWidth(),\n            s = t(window).width(),\n            o = this.$element.outerHeight(),\n            a = t(window).height();e = \"auto\" === this.options.hOffset ? parseInt((s - n) / 2, 10) : parseInt(this.options.hOffset, 10), i = \"auto\" === this.options.vOffset ? o > a ? parseInt(Math.min(100, a / 10), 10) : parseInt((a - o) / 4, 10) : parseInt(this.options.vOffset, 10), this.$element.css({ top: i + \"px\" }), this.$overlay && \"auto\" === this.options.hOffset || (this.$element.css({ left: e + \"px\" }), this.$element.css({ margin: \"0px\" }));\n      } }, { key: \"_events\", value: function value() {\n        var e = this,\n            i = this;this.$element.on({ \"open.zf.trigger\": this.open.bind(this), \"close.zf.trigger\": function closeZfTrigger(n, s) {\n            if (n.target === i.$element[0] || t(n.target).parents(\"[data-closable]\")[0] === s) return e.close.apply(e);\n          }, \"toggle.zf.trigger\": this.toggle.bind(this), \"resizeme.zf.trigger\": function resizemeZfTrigger() {\n            i._updatePosition();\n          } }), this.$anchor.length && this.$anchor.on(\"keydown.zf.reveal\", function (t) {\n          13 !== t.which && 32 !== t.which || (t.stopPropagation(), t.preventDefault(), i.open());\n        }), this.options.closeOnClick && this.options.overlay && this.$overlay.off(\".zf.reveal\").on(\"click.zf.reveal\", function (e) {\n          e.target !== i.$element[0] && !t.contains(i.$element[0], e.target) && t.contains(document, e.target) && i.close();\n        }), this.options.deepLink && t(window).on(\"popstate.zf.reveal:\" + this.id, this._handleState.bind(this));\n      } }, { key: \"_handleState\", value: function value(t) {\n        window.location.hash !== \"#\" + this.id || this.isActive ? this.close() : this.open();\n      } }, { key: \"open\", value: function value() {\n        var e = this;if (this.options.deepLink) {\n          var i = \"#\" + this.id;window.history.pushState ? window.history.pushState(null, null, i) : window.location.hash = i;\n        }if (this.isActive = !0, this.$element.css({ visibility: \"hidden\" }).show().scrollTop(0), this.options.overlay && this.$overlay.css({ visibility: \"hidden\" }).show(), this._updatePosition(), this.$element.hide().css({ visibility: \"\" }), this.$overlay && (this.$overlay.css({ visibility: \"\" }).hide(), this.$element.hasClass(\"fast\") ? this.$overlay.addClass(\"fast\") : this.$element.hasClass(\"slow\") && this.$overlay.addClass(\"slow\")), this.options.multipleOpened || this.$element.trigger(\"closeme.zf.reveal\", this.id), this.options.animationIn) {\n          var n;!function () {\n            var t = function t() {\n              n.$element.attr({ \"aria-hidden\": !1, tabindex: -1 }).focus();\n            };n = e, e.options.overlay && Foundation.Motion.animateIn(e.$overlay, \"fade-in\"), Foundation.Motion.animateIn(e.$element, e.options.animationIn, function () {\n              e.focusableElements = Foundation.Keyboard.findFocusable(e.$element), t();\n            });\n          }();\n        } else this.options.overlay && this.$overlay.show(0), this.$element.show(this.options.showDelay);this.$element.attr({ \"aria-hidden\": !1, tabindex: -1 }).focus(), this.$element.trigger(\"open.zf.reveal\"), this.isMobile ? (this.originalScrollPos = window.pageYOffset, t(\"html, body\").addClass(\"is-reveal-open\")) : t(\"body\").addClass(\"is-reveal-open\"), setTimeout(function () {\n          e._extraHandlers();\n        }, 0);\n      } }, { key: \"_extraHandlers\", value: function value() {\n        var e = this;this.focusableElements = Foundation.Keyboard.findFocusable(this.$element), this.options.overlay || !this.options.closeOnClick || this.options.fullScreen || t(\"body\").on(\"click.zf.reveal\", function (i) {\n          i.target !== e.$element[0] && !t.contains(e.$element[0], i.target) && t.contains(document, i.target) && e.close();\n        }), this.options.closeOnEsc && t(window).on(\"keydown.zf.reveal\", function (t) {\n          Foundation.Keyboard.handleKey(t, \"Reveal\", { close: function close() {\n              e.options.closeOnEsc && (e.close(), e.$anchor.focus());\n            } });\n        }), this.$element.on(\"keydown.zf.reveal\", function (i) {\n          var n = t(this);Foundation.Keyboard.handleKey(i, \"Reveal\", { tab_forward: function tab_forward() {\n              return e.focusableElements = Foundation.Keyboard.findFocusable(e.$element), e.$element.find(\":focus\").is(e.focusableElements.eq(-1)) ? (e.focusableElements.eq(0).focus(), !0) : 0 === e.focusableElements.length || void 0;\n            }, tab_backward: function tab_backward() {\n              return e.focusableElements = Foundation.Keyboard.findFocusable(e.$element), e.$element.find(\":focus\").is(e.focusableElements.eq(0)) || e.$element.is(\":focus\") ? (e.focusableElements.eq(-1).focus(), !0) : 0 === e.focusableElements.length || void 0;\n            }, open: function open() {\n              e.$element.find(\":focus\").is(e.$element.find(\"[data-close]\")) ? setTimeout(function () {\n                e.$anchor.focus();\n              }, 1) : n.is(e.focusableElements) && e.open();\n            }, close: function close() {\n              e.options.closeOnEsc && (e.close(), e.$anchor.focus());\n            }, handled: function handled(t) {\n              t && i.preventDefault();\n            } });\n        });\n      } }, { key: \"close\", value: function value() {\n        function e() {\n          i.isMobile ? (t(\"html, body\").removeClass(\"is-reveal-open\"), i.originalScrollPos && (t(\"body\").scrollTop(i.originalScrollPos), i.originalScrollPos = null)) : t(\"body\").removeClass(\"is-reveal-open\"), i.$element.attr(\"aria-hidden\", !0), i.$element.trigger(\"closed.zf.reveal\");\n        }if (!this.isActive || !this.$element.is(\":visible\")) return !1;var i = this;this.options.animationOut ? (this.options.overlay ? Foundation.Motion.animateOut(this.$overlay, \"fade-out\", e) : e(), Foundation.Motion.animateOut(this.$element, this.options.animationOut)) : (this.options.overlay ? this.$overlay.hide(0, e) : e(), this.$element.hide(this.options.hideDelay)), this.options.closeOnEsc && t(window).off(\"keydown.zf.reveal\"), !this.options.overlay && this.options.closeOnClick && t(\"body\").off(\"click.zf.reveal\"), this.$element.off(\"keydown.zf.reveal\"), this.options.resetOnClose && this.$element.html(this.$element.html()), this.isActive = !1, i.options.deepLink && (window.history.replaceState ? window.history.replaceState(\"\", document.title, window.location.pathname) : window.location.hash = \"\");\n      } }, { key: \"toggle\", value: function value() {\n        this.isActive ? this.close() : this.open();\n      } }, { key: \"destroy\", value: function value() {\n        this.options.overlay && (this.$element.appendTo(t(\"body\")), this.$overlay.hide().off().remove()), this.$element.hide().off(), this.$anchor.off(\".zf\"), t(window).off(\".zf.reveal:\" + this.id), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();s.defaults = { animationIn: \"\", animationOut: \"\", showDelay: 0, hideDelay: 0, closeOnClick: !0, closeOnEsc: !0, multipleOpened: !1, vOffset: \"auto\", hOffset: \"auto\", fullScreen: !1, btmOffsetPct: 10, overlay: !0, resetOnClose: !1, deepLink: !1 }, Foundation.plugin(s, \"Reveal\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  function e(t, e) {\n    return t / e;\n  }function i(t, e, i, n) {\n    return Math.abs(t.position()[e] + t[n]() / 2 - i);\n  }var n = function () {\n    function n(e, i) {\n      _classCallCheck(this, n), this.$element = e, this.options = t.extend({}, n.defaults, this.$element.data(), i), this._init(), Foundation.registerPlugin(this, \"Slider\"), Foundation.Keyboard.register(\"Slider\", { ltr: { ARROW_RIGHT: \"increase\", ARROW_UP: \"increase\", ARROW_DOWN: \"decrease\", ARROW_LEFT: \"decrease\", SHIFT_ARROW_RIGHT: \"increase_fast\", SHIFT_ARROW_UP: \"increase_fast\", SHIFT_ARROW_DOWN: \"decrease_fast\", SHIFT_ARROW_LEFT: \"decrease_fast\" }, rtl: { ARROW_LEFT: \"increase\", ARROW_RIGHT: \"decrease\", SHIFT_ARROW_LEFT: \"increase_fast\", SHIFT_ARROW_RIGHT: \"decrease_fast\" } });\n    }return _createClass(n, [{ key: \"_init\", value: function value() {\n        this.inputs = this.$element.find(\"input\"), this.handles = this.$element.find(\"[data-slider-handle]\"), this.$handle = this.handles.eq(0), this.$input = this.inputs.length ? this.inputs.eq(0) : t(\"#\" + this.$handle.attr(\"aria-controls\")), this.$fill = this.$element.find(\"[data-slider-fill]\").css(this.options.vertical ? \"height\" : \"width\", 0);var e = !1,\n            i = this;(this.options.disabled || this.$element.hasClass(this.options.disabledClass)) && (this.options.disabled = !0, this.$element.addClass(this.options.disabledClass)), this.inputs.length || (this.inputs = t().add(this.$input), this.options.binding = !0), this._setInitAttr(0), this._events(this.$handle), this.handles[1] && (this.options.doubleSided = !0, this.$handle2 = this.handles.eq(1), this.$input2 = this.inputs.length > 1 ? this.inputs.eq(1) : t(\"#\" + this.$handle2.attr(\"aria-controls\")), this.inputs[1] || (this.inputs = this.inputs.add(this.$input2)), e = !0, this._setHandlePos(this.$handle, this.options.initialStart, !0, function () {\n          i._setHandlePos(i.$handle2, i.options.initialEnd, !0);\n        }), this._setInitAttr(1), this._events(this.$handle2)), e || this._setHandlePos(this.$handle, this.options.initialStart, !0);\n      } }, { key: \"_setHandlePos\", value: function value(t, i, n, s) {\n        if (!this.$element.hasClass(this.options.disabledClass)) {\n          i = parseFloat(i), i < this.options.start ? i = this.options.start : i > this.options.end && (i = this.options.end);var o = this.options.doubleSided;if (o) if (0 === this.handles.index(t)) {\n            var a = parseFloat(this.$handle2.attr(\"aria-valuenow\"));i = i >= a ? a - this.options.step : i;\n          } else {\n            var r = parseFloat(this.$handle.attr(\"aria-valuenow\"));i = i <= r ? r + this.options.step : i;\n          }this.options.vertical && !n && (i = this.options.end - i);var l = this,\n              u = this.options.vertical,\n              d = u ? \"height\" : \"width\",\n              h = u ? \"top\" : \"left\",\n              c = t[0].getBoundingClientRect()[d],\n              f = this.$element[0].getBoundingClientRect()[d],\n              p = e(i - this.options.start, this.options.end - this.options.start).toFixed(2),\n              m = (f - c) * p,\n              v = (100 * e(m, f)).toFixed(this.options.decimal);i = parseFloat(i.toFixed(this.options.decimal));var g = {};if (this._setValues(t, i), o) {\n            var w,\n                y = 0 === this.handles.index(t),\n                b = ~~(100 * e(c, f));if (y) g[h] = v + \"%\", w = parseFloat(this.$handle2[0].style[h]) - v + b, s && \"function\" == typeof s && s();else {\n              var $ = parseFloat(this.$handle[0].style[h]);w = v - (isNaN($) ? this.options.initialStart / ((this.options.end - this.options.start) / 100) : $) + b;\n            }g[\"min-\" + d] = w + \"%\";\n          }this.$element.one(\"finished.zf.animate\", function () {\n            l.$element.trigger(\"moved.zf.slider\", [t]);\n          });var C = this.$element.data(\"dragging\") ? 1e3 / 60 : this.options.moveTime;Foundation.Move(C, t, function () {\n            t.css(h, v + \"%\"), l.options.doubleSided ? l.$fill.css(g) : l.$fill.css(d, 100 * p + \"%\");\n          }), clearTimeout(l.timeout), l.timeout = setTimeout(function () {\n            l.$element.trigger(\"changed.zf.slider\", [t]);\n          }, l.options.changedDelay);\n        }\n      } }, { key: \"_setInitAttr\", value: function value(t) {\n        var e = this.inputs.eq(t).attr(\"id\") || Foundation.GetYoDigits(6, \"slider\");this.inputs.eq(t).attr({ id: e, max: this.options.end, min: this.options.start, step: this.options.step }), this.handles.eq(t).attr({ role: \"slider\", \"aria-controls\": e, \"aria-valuemax\": this.options.end, \"aria-valuemin\": this.options.start, \"aria-valuenow\": 0 === t ? this.options.initialStart : this.options.initialEnd, \"aria-orientation\": this.options.vertical ? \"vertical\" : \"horizontal\", tabindex: 0 });\n      } }, { key: \"_setValues\", value: function value(t, e) {\n        var i = this.options.doubleSided ? this.handles.index(t) : 0;this.inputs.eq(i).val(e), t.attr(\"aria-valuenow\", e);\n      } }, { key: \"_handleEvent\", value: function value(n, s, o) {\n        var a, r;if (o) a = this._adjustValue(null, o), r = !0;else {\n          n.preventDefault();var l = this,\n              u = this.options.vertical,\n              d = u ? \"height\" : \"width\",\n              h = u ? \"top\" : \"left\",\n              c = u ? n.pageY : n.pageX,\n              f = (this.$handle[0].getBoundingClientRect()[d] / 2, this.$element[0].getBoundingClientRect()[d]),\n              p = u ? t(window).scrollTop() : t(window).scrollLeft(),\n              m = this.$element.offset()[h];n.clientY === n.pageY && (c += p);var v,\n              g = c - m;v = g < 0 ? 0 : g > f ? f : g;var w = e(v, f);if (a = (this.options.end - this.options.start) * w + this.options.start, Foundation.rtl() && !this.options.vertical && (a = this.options.end - a), a = l._adjustValue(null, a), r = !1, !s) {\n            var y = i(this.$handle, h, v, d),\n                b = i(this.$handle2, h, v, d);s = y <= b ? this.$handle : this.$handle2;\n          }\n        }this._setHandlePos(s, a, r);\n      } }, { key: \"_adjustValue\", value: function value(t, e) {\n        var i,\n            n,\n            s,\n            o,\n            a = this.options.step,\n            r = parseFloat(a / 2);return i = t ? parseFloat(t.attr(\"aria-valuenow\")) : e, n = i % a, s = i - n, o = s + a, 0 === n ? i : i = i >= s + r ? o : s;\n      } }, { key: \"_events\", value: function value(e) {\n        var i,\n            n = this;if (this.inputs.off(\"change.zf.slider\").on(\"change.zf.slider\", function (e) {\n          var i = n.inputs.index(t(this));n._handleEvent(e, n.handles.eq(i), t(this).val());\n        }), this.options.clickSelect && this.$element.off(\"click.zf.slider\").on(\"click.zf.slider\", function (e) {\n          return !n.$element.data(\"dragging\") && void (t(e.target).is(\"[data-slider-handle]\") || (n.options.doubleSided ? n._handleEvent(e) : n._handleEvent(e, n.$handle)));\n        }), this.options.draggable) {\n          this.handles.addTouch();var s = t(\"body\");e.off(\"mousedown.zf.slider\").on(\"mousedown.zf.slider\", function (o) {\n            e.addClass(\"is-dragging\"), n.$fill.addClass(\"is-dragging\"), n.$element.data(\"dragging\", !0), i = t(o.currentTarget), s.on(\"mousemove.zf.slider\", function (t) {\n              t.preventDefault(), n._handleEvent(t, i);\n            }).on(\"mouseup.zf.slider\", function (t) {\n              n._handleEvent(t, i), e.removeClass(\"is-dragging\"), n.$fill.removeClass(\"is-dragging\"), n.$element.data(\"dragging\", !1), s.off(\"mousemove.zf.slider mouseup.zf.slider\");\n            });\n          }).on(\"selectstart.zf.slider touchmove.zf.slider\", function (t) {\n            t.preventDefault();\n          });\n        }e.off(\"keydown.zf.slider\").on(\"keydown.zf.slider\", function (e) {\n          var i,\n              s = t(this),\n              o = n.options.doubleSided ? n.handles.index(s) : 0,\n              a = parseFloat(n.inputs.eq(o).val());Foundation.Keyboard.handleKey(e, \"Slider\", { decrease: function decrease() {\n              i = a - n.options.step;\n            }, increase: function increase() {\n              i = a + n.options.step;\n            }, decrease_fast: function decrease_fast() {\n              i = a - 10 * n.options.step;\n            }, increase_fast: function increase_fast() {\n              i = a + 10 * n.options.step;\n            }, handled: function handled() {\n              e.preventDefault(), n._setHandlePos(s, i, !0);\n            } });\n        });\n      } }, { key: \"destroy\", value: function value() {\n        this.handles.off(\".zf.slider\"), this.inputs.off(\".zf.slider\"), this.$element.off(\".zf.slider\"), Foundation.unregisterPlugin(this);\n      } }]), n;\n  }();n.defaults = { start: 0, end: 100, step: 1, initialStart: 0, initialEnd: 100, binding: !1, clickSelect: !0, vertical: !1, draggable: !0, disabled: !1, doubleSided: !1, decimal: 2, moveTime: 200, disabledClass: \"disabled\", invertVertical: !1, changedDelay: 500 }, Foundation.plugin(n, \"Slider\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  function e(t) {\n    return parseInt(window.getComputedStyle(document.body, null).fontSize, 10) * t;\n  }var i = function () {\n    function i(e, n) {\n      _classCallCheck(this, i), this.$element = e, this.options = t.extend({}, i.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Sticky\");\n    }return _createClass(i, [{ key: \"_init\", value: function value() {\n        var e = this.$element.parent(\"[data-sticky-container]\"),\n            i = this.$element[0].id || Foundation.GetYoDigits(6, \"sticky\"),\n            n = this;e.length || (this.wasWrapped = !0), this.$container = e.length ? e : t(this.options.container).wrapInner(this.$element), this.$container.addClass(this.options.containerClass), this.$element.addClass(this.options.stickyClass).attr({ \"data-resize\": i }), this.scrollCount = this.options.checkEvery, this.isStuck = !1, t(window).one(\"load.zf.sticky\", function () {\n          n.containerHeight = \"none\" == n.$element.css(\"display\") ? 0 : n.$element[0].getBoundingClientRect().height, n.$container.css(\"height\", n.containerHeight), n.elemHeight = n.containerHeight, \"\" !== n.options.anchor ? n.$anchor = t(\"#\" + n.options.anchor) : n._parsePoints(), n._setSizes(function () {\n            n._calc(!1);\n          }), n._events(i.split(\"-\").reverse().join(\"-\"));\n        });\n      } }, { key: \"_parsePoints\", value: function value() {\n        for (var e = \"\" == this.options.topAnchor ? 1 : this.options.topAnchor, i = \"\" == this.options.btmAnchor ? document.documentElement.scrollHeight : this.options.btmAnchor, n = [e, i], s = {}, o = 0, a = n.length; o < a && n[o]; o++) {\n          var r;if (\"number\" == typeof n[o]) r = n[o];else {\n            var l = n[o].split(\":\"),\n                u = t(\"#\" + l[0]);r = u.offset().top, l[1] && \"bottom\" === l[1].toLowerCase() && (r += u[0].getBoundingClientRect().height);\n          }s[o] = r;\n        }this.points = s;\n      } }, { key: \"_events\", value: function value(e) {\n        var i = this,\n            n = this.scrollListener = \"scroll.zf.\" + e;this.isOn || (this.canStick && (this.isOn = !0, t(window).off(n).on(n, function (t) {\n          0 === i.scrollCount ? (i.scrollCount = i.options.checkEvery, i._setSizes(function () {\n            i._calc(!1, window.pageYOffset);\n          })) : (i.scrollCount--, i._calc(!1, window.pageYOffset));\n        })), this.$element.off(\"resizeme.zf.trigger\").on(\"resizeme.zf.trigger\", function (t, s) {\n          i._setSizes(function () {\n            i._calc(!1), i.canStick ? i.isOn || i._events(e) : i.isOn && i._pauseListeners(n);\n          });\n        }));\n      } }, { key: \"_pauseListeners\", value: function value(e) {\n        this.isOn = !1, t(window).off(e), this.$element.trigger(\"pause.zf.sticky\");\n      } }, { key: \"_calc\", value: function value(t, e) {\n        return t && this._setSizes(), this.canStick ? (e || (e = window.pageYOffset), void (e >= this.topPoint ? e <= this.bottomPoint ? this.isStuck || this._setSticky() : this.isStuck && this._removeSticky(!1) : this.isStuck && this._removeSticky(!0))) : (this.isStuck && this._removeSticky(!0), !1);\n      } }, { key: \"_setSticky\", value: function value() {\n        var t = this,\n            e = this.options.stickTo,\n            i = \"top\" === e ? \"marginTop\" : \"marginBottom\",\n            n = \"top\" === e ? \"bottom\" : \"top\",\n            s = {};s[i] = this.options[i] + \"em\", s[e] = 0, s[n] = \"auto\", s.left = this.$container.offset().left + parseInt(window.getComputedStyle(this.$container[0])[\"padding-left\"], 10), this.isStuck = !0, this.$element.removeClass(\"is-anchored is-at-\" + n).addClass(\"is-stuck is-at-\" + e).css(s).trigger(\"sticky.zf.stuckto:\" + e), this.$element.on(\"transitionend webkitTransitionEnd oTransitionEnd otransitionend MSTransitionEnd\", function () {\n          t._setSizes();\n        });\n      } }, { key: \"_removeSticky\", value: function value(t) {\n        var e = this.options.stickTo,\n            i = \"top\" === e,\n            n = {},\n            s = (this.points ? this.points[1] - this.points[0] : this.anchorHeight) - this.elemHeight,\n            o = i ? \"marginTop\" : \"marginBottom\",\n            a = t ? \"top\" : \"bottom\";n[o] = 0, n.bottom = \"auto\", t ? n.top = 0 : n.top = s, n.left = \"\", this.isStuck = !1, this.$element.removeClass(\"is-stuck is-at-\" + e).addClass(\"is-anchored is-at-\" + a).css(n).trigger(\"sticky.zf.unstuckfrom:\" + a);\n      } }, { key: \"_setSizes\", value: function value(t) {\n        this.canStick = Foundation.MediaQuery.atLeast(this.options.stickyOn), this.canStick || t && \"function\" == typeof t && t();var e = this.$container[0].getBoundingClientRect().width,\n            i = window.getComputedStyle(this.$container[0]),\n            n = parseInt(i[\"padding-right\"], 10);this.$anchor && this.$anchor.length ? this.anchorHeight = this.$anchor[0].getBoundingClientRect().height : this._parsePoints(), this.$element.css({ \"max-width\": e - n + \"px\" });var s = this.$element[0].getBoundingClientRect().height || this.containerHeight;if (\"none\" == this.$element.css(\"display\") && (s = 0), this.containerHeight = s, this.$container.css({ height: s }), this.elemHeight = s, this.isStuck) this.$element.css({ left: this.$container.offset().left + parseInt(i[\"padding-left\"], 10) });else if (this.$element.hasClass(\"is-at-bottom\")) {\n          var o = (this.points ? this.points[1] - this.$container.offset().top : this.anchorHeight) - this.elemHeight;this.$element.css(\"top\", o);\n        }this._setBreakPoints(s, function () {\n          t && \"function\" == typeof t && t();\n        });\n      } }, { key: \"_setBreakPoints\", value: function value(t, i) {\n        if (!this.canStick) {\n          if (!i || \"function\" != typeof i) return !1;i();\n        }var n = e(this.options.marginTop),\n            s = e(this.options.marginBottom),\n            o = this.points ? this.points[0] : this.$anchor.offset().top,\n            a = this.points ? this.points[1] : o + this.anchorHeight,\n            r = window.innerHeight;\n        \"top\" === this.options.stickTo ? (o -= n, a -= t + n) : \"bottom\" === this.options.stickTo && (o -= r - (t + s), a -= r - s), this.topPoint = o, this.bottomPoint = a, i && \"function\" == typeof i && i();\n      } }, { key: \"destroy\", value: function value() {\n        this._removeSticky(!0), this.$element.removeClass(this.options.stickyClass + \" is-anchored is-at-top\").css({ height: \"\", top: \"\", bottom: \"\", \"max-width\": \"\" }).off(\"resizeme.zf.trigger\"), this.$anchor && this.$anchor.length && this.$anchor.off(\"change.zf.sticky\"), t(window).off(this.scrollListener), this.wasWrapped ? this.$element.unwrap() : this.$container.removeClass(this.options.containerClass).css({ height: \"\" }), Foundation.unregisterPlugin(this);\n      } }]), i;\n  }();i.defaults = { container: \"<div data-sticky-container></div>\", stickTo: \"top\", anchor: \"\", topAnchor: \"\", btmAnchor: \"\", marginTop: 1, marginBottom: 1, stickyOn: \"medium\", stickyClass: \"sticky\", containerClass: \"sticky-container\", checkEvery: -1 }, Foundation.plugin(i, \"Sticky\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this._init(), Foundation.registerPlugin(this, \"Tabs\"), Foundation.Keyboard.register(\"Tabs\", { ENTER: \"open\", SPACE: \"open\", ARROW_RIGHT: \"next\", ARROW_UP: \"previous\", ARROW_DOWN: \"next\", ARROW_LEFT: \"previous\" });\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this;if (this.$tabTitles = this.$element.find(\".\" + this.options.linkClass), this.$tabContent = t('[data-tabs-content=\"' + this.$element[0].id + '\"]'), this.$tabTitles.each(function () {\n          var i = t(this),\n              n = i.find(\"a\"),\n              s = i.hasClass(\"is-active\"),\n              o = n[0].hash.slice(1),\n              a = n[0].id ? n[0].id : o + \"-label\",\n              r = t(\"#\" + o);i.attr({ role: \"presentation\" }), n.attr({ role: \"tab\", \"aria-controls\": o, \"aria-selected\": s, id: a }), r.attr({ role: \"tabpanel\", \"aria-hidden\": !s, \"aria-labelledby\": a }), s && e.options.autoFocus && n.focus();\n        }), this.options.matchHeight) {\n          var i = this.$tabContent.find(\"img\");i.length ? Foundation.onImagesLoaded(i, this._setHeight.bind(this)) : this._setHeight();\n        }this._events();\n      } }, { key: \"_events\", value: function value() {\n        this._addKeyHandler(), this._addClickHandler(), this._setHeightMqHandler = null, this.options.matchHeight && (this._setHeightMqHandler = this._setHeight.bind(this), t(window).on(\"changed.zf.mediaquery\", this._setHeightMqHandler));\n      } }, { key: \"_addClickHandler\", value: function value() {\n        var e = this;this.$element.off(\"click.zf.tabs\").on(\"click.zf.tabs\", \".\" + this.options.linkClass, function (i) {\n          i.preventDefault(), i.stopPropagation(), t(this).hasClass(\"is-active\") || e._handleTabChange(t(this));\n        });\n      } }, { key: \"_addKeyHandler\", value: function value() {\n        var e = this;e.$element.find(\"li:first-of-type\"), e.$element.find(\"li:last-of-type\");this.$tabTitles.off(\"keydown.zf.tabs\").on(\"keydown.zf.tabs\", function (i) {\n          if (9 !== i.which) {\n            var n,\n                s,\n                o = t(this),\n                a = o.parent(\"ul\").children(\"li\");a.each(function (i) {\n              if (t(this).is(o)) return void (e.options.wrapOnKeys ? (n = 0 === i ? a.last() : a.eq(i - 1), s = i === a.length - 1 ? a.first() : a.eq(i + 1)) : (n = a.eq(Math.max(0, i - 1)), s = a.eq(Math.min(i + 1, a.length - 1))));\n            }), Foundation.Keyboard.handleKey(i, \"Tabs\", { open: function open() {\n                o.find('[role=\"tab\"]').focus(), e._handleTabChange(o);\n              }, previous: function previous() {\n                n.find('[role=\"tab\"]').focus(), e._handleTabChange(n);\n              }, next: function next() {\n                s.find('[role=\"tab\"]').focus(), e._handleTabChange(s);\n              }, handled: function handled() {\n                i.stopPropagation(), i.preventDefault();\n              } });\n          }\n        });\n      } }, { key: \"_handleTabChange\", value: function value(e) {\n        var i = e.find('[role=\"tab\"]'),\n            n = i[0].hash,\n            s = this.$tabContent.find(n),\n            o = this.$element.find(\".\" + this.options.linkClass + \".is-active\").removeClass(\"is-active\").find('[role=\"tab\"]').attr({ \"aria-selected\": \"false\" });t(\"#\" + o.attr(\"aria-controls\")).removeClass(\"is-active\").attr({ \"aria-hidden\": \"true\" }), e.addClass(\"is-active\"), i.attr({ \"aria-selected\": \"true\" }), s.addClass(\"is-active\").attr({ \"aria-hidden\": \"false\" }), this.$element.trigger(\"change.zf.tabs\", [e]);\n      } }, { key: \"selectTab\", value: function value(t) {\n        var e;e = \"object\" == (typeof t === \"undefined\" ? \"undefined\" : _typeof(t)) ? t[0].id : t, e.indexOf(\"#\") < 0 && (e = \"#\" + e);var i = this.$tabTitles.find('[href=\"' + e + '\"]').parent(\".\" + this.options.linkClass);this._handleTabChange(i);\n      } }, { key: \"_setHeight\", value: function value() {\n        var e = 0;this.$tabContent.find(\".\" + this.options.panelClass).css(\"height\", \"\").each(function () {\n          var i = t(this),\n              n = i.hasClass(\"is-active\");n || i.css({ visibility: \"hidden\", display: \"block\" });var s = this.getBoundingClientRect().height;n || i.css({ visibility: \"\", display: \"\" }), e = s > e ? s : e;\n        }).css(\"height\", e + \"px\");\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.find(\".\" + this.options.linkClass).off(\".zf.tabs\").hide().end().find(\".\" + this.options.panelClass).hide(), this.options.matchHeight && null != this._setHeightMqHandler && t(window).off(\"changed.zf.mediaquery\", this._setHeightMqHandler), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { autoFocus: !1, wrapOnKeys: !0, matchHeight: !1, linkClass: \"tabs-title\", panelClass: \"tabs-panel\" }, Foundation.plugin(e, \"Tabs\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, i.data(), n), this.className = \"\", this._init(), this._events(), Foundation.registerPlugin(this, \"Toggler\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e;this.options.animate ? (e = this.options.animate.split(\" \"), this.animationIn = e[0], this.animationOut = e[1] || null) : (e = this.$element.data(\"toggler\"), this.className = \".\" === e[0] ? e.slice(1) : e);var i = this.$element[0].id;t('[data-open=\"' + i + '\"], [data-close=\"' + i + '\"], [data-toggle=\"' + i + '\"]').attr(\"aria-controls\", i), this.$element.attr(\"aria-expanded\", !this.$element.is(\":hidden\"));\n      } }, { key: \"_events\", value: function value() {\n        this.$element.off(\"toggle.zf.trigger\").on(\"toggle.zf.trigger\", this.toggle.bind(this));\n      } }, { key: \"toggle\", value: function value() {\n        this[this.options.animate ? \"_toggleAnimate\" : \"_toggleClass\"]();\n      } }, { key: \"_toggleClass\", value: function value() {\n        this.$element.toggleClass(this.className);var t = this.$element.hasClass(this.className);t ? this.$element.trigger(\"on.zf.toggler\") : this.$element.trigger(\"off.zf.toggler\"), this._updateARIA(t);\n      } }, { key: \"_toggleAnimate\", value: function value() {\n        var t = this;this.$element.is(\":hidden\") ? Foundation.Motion.animateIn(this.$element, this.animationIn, function () {\n          t._updateARIA(!0), this.trigger(\"on.zf.toggler\");\n        }) : Foundation.Motion.animateOut(this.$element, this.animationOut, function () {\n          t._updateARIA(!1), this.trigger(\"off.zf.toggler\");\n        });\n      } }, { key: \"_updateARIA\", value: function value(t) {\n        this.$element.attr(\"aria-expanded\", !!t);\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.off(\".zf.toggler\"), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { animate: !1 }, Foundation.plugin(e, \"Toggler\");\n}(jQuery);var _createClass = function () {\n  function t(t, e) {\n    for (var i = 0; i < e.length; i++) {\n      var n = e[i];n.enumerable = n.enumerable || !1, n.configurable = !0, \"value\" in n && (n.writable = !0), Object.defineProperty(t, n.key, n);\n    }\n  }return function (e, i, n) {\n    return i && t(e.prototype, i), n && t(e, n), e;\n  };\n}();!function (t) {\n  var e = function () {\n    function e(i, n) {\n      _classCallCheck(this, e), this.$element = i, this.options = t.extend({}, e.defaults, this.$element.data(), n), this.isActive = !1, this.isClick = !1, this._init(), Foundation.registerPlugin(this, \"Tooltip\");\n    }return _createClass(e, [{ key: \"_init\", value: function value() {\n        var e = this.$element.attr(\"aria-describedby\") || Foundation.GetYoDigits(6, \"tooltip\");this.options.positionClass = this.options.positionClass || this._getPositionClass(this.$element), this.options.tipText = this.options.tipText || this.$element.attr(\"title\"), this.template = this.options.template ? t(this.options.template) : this._buildTemplate(e), this.template.appendTo(document.body).text(this.options.tipText).hide(), this.$element.attr({ title: \"\", \"aria-describedby\": e, \"data-yeti-box\": e, \"data-toggle\": e, \"data-resize\": e }).addClass(this.options.triggerClass), this.usedPositions = [], this.counter = 4, this.classChanged = !1, this._events();\n      } }, { key: \"_getPositionClass\", value: function value(t) {\n        if (!t) return \"\";var e = t[0].className.match(/\\b(top|left|right)\\b/g);return e = e ? e[0] : \"\";\n      } }, { key: \"_buildTemplate\", value: function value(e) {\n        var i = (this.options.tooltipClass + \" \" + this.options.positionClass + \" \" + this.options.templateClasses).trim(),\n            n = t(\"<div></div>\").addClass(i).attr({ role: \"tooltip\", \"aria-hidden\": !0, \"data-is-active\": !1, \"data-is-focus\": !1, id: e });return n;\n      } }, { key: \"_reposition\", value: function value(t) {\n        this.usedPositions.push(t ? t : \"bottom\"), !t && this.usedPositions.indexOf(\"top\") < 0 ? this.template.addClass(\"top\") : \"top\" === t && this.usedPositions.indexOf(\"bottom\") < 0 ? this.template.removeClass(t) : \"left\" === t && this.usedPositions.indexOf(\"right\") < 0 ? this.template.removeClass(t).addClass(\"right\") : \"right\" === t && this.usedPositions.indexOf(\"left\") < 0 ? this.template.removeClass(t).addClass(\"left\") : !t && this.usedPositions.indexOf(\"top\") > -1 && this.usedPositions.indexOf(\"left\") < 0 ? this.template.addClass(\"left\") : \"top\" === t && this.usedPositions.indexOf(\"bottom\") > -1 && this.usedPositions.indexOf(\"left\") < 0 ? this.template.removeClass(t).addClass(\"left\") : \"left\" === t && this.usedPositions.indexOf(\"right\") > -1 && this.usedPositions.indexOf(\"bottom\") < 0 ? this.template.removeClass(t) : \"right\" === t && this.usedPositions.indexOf(\"left\") > -1 && this.usedPositions.indexOf(\"bottom\") < 0 ? this.template.removeClass(t) : this.template.removeClass(t), this.classChanged = !0, this.counter--;\n      } }, { key: \"_setPosition\", value: function value() {\n        var t = this._getPositionClass(this.template),\n            e = Foundation.Box.GetDimensions(this.template),\n            i = Foundation.Box.GetDimensions(this.$element),\n            n = \"left\" === t ? \"left\" : \"right\" === t ? \"left\" : \"top\",\n            s = \"top\" === n ? \"height\" : \"width\";\"height\" === s ? this.options.vOffset : this.options.hOffset;if (e.width >= e.windowDims.width || !this.counter && !Foundation.Box.ImNotTouchingYou(this.template)) return this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, \"center bottom\", this.options.vOffset, this.options.hOffset, !0)).css({ width: i.windowDims.width - 2 * this.options.hOffset, height: \"auto\" }), !1;for (this.template.offset(Foundation.Box.GetOffsets(this.template, this.$element, \"center \" + (t || \"bottom\"), this.options.vOffset, this.options.hOffset)); !Foundation.Box.ImNotTouchingYou(this.template) && this.counter;) {\n          this._reposition(t), this._setPosition();\n        }\n      } }, { key: \"show\", value: function value() {\n        if (\"all\" !== this.options.showOn && !Foundation.MediaQuery.atLeast(this.options.showOn)) return !1;var t = this;this.template.css(\"visibility\", \"hidden\").show(), this._setPosition(), this.$element.trigger(\"closeme.zf.tooltip\", this.template.attr(\"id\")), this.template.attr({ \"data-is-active\": !0, \"aria-hidden\": !1 }), t.isActive = !0, this.template.stop().hide().css(\"visibility\", \"\").fadeIn(this.options.fadeInDuration, function () {}), this.$element.trigger(\"show.zf.tooltip\");\n      } }, { key: \"hide\", value: function value() {\n        var t = this;this.template.stop().attr({ \"aria-hidden\": !0, \"data-is-active\": !1 }).fadeOut(this.options.fadeOutDuration, function () {\n          t.isActive = !1, t.isClick = !1, t.classChanged && (t.template.removeClass(t._getPositionClass(t.template)).addClass(t.options.positionClass), t.usedPositions = [], t.counter = 4, t.classChanged = !1);\n        }), this.$element.trigger(\"hide.zf.tooltip\");\n      } }, { key: \"_events\", value: function value() {\n        var t = this,\n            e = (this.template, !1);this.options.disableHover || this.$element.on(\"mouseenter.zf.tooltip\", function (e) {\n          t.isActive || (t.timeout = setTimeout(function () {\n            t.show();\n          }, t.options.hoverDelay));\n        }).on(\"mouseleave.zf.tooltip\", function (i) {\n          clearTimeout(t.timeout), (!e || t.isClick && !t.options.clickOpen) && t.hide();\n        }), this.options.clickOpen ? this.$element.on(\"mousedown.zf.tooltip\", function (e) {\n          e.stopImmediatePropagation(), t.isClick || (t.isClick = !0, !t.options.disableHover && t.$element.attr(\"tabindex\") || t.isActive || t.show());\n        }) : this.$element.on(\"mousedown.zf.tooltip\", function (e) {\n          e.stopImmediatePropagation(), t.isClick = !0;\n        }), this.options.disableForTouch || this.$element.on(\"tap.zf.tooltip touchend.zf.tooltip\", function (e) {\n          t.isActive ? t.hide() : t.show();\n        }), this.$element.on({ \"close.zf.trigger\": this.hide.bind(this) }), this.$element.on(\"focus.zf.tooltip\", function (i) {\n          return e = !0, t.isClick ? (t.options.clickOpen || (e = !1), !1) : void t.show();\n        }).on(\"focusout.zf.tooltip\", function (i) {\n          e = !1, t.isClick = !1, t.hide();\n        }).on(\"resizeme.zf.trigger\", function () {\n          t.isActive && t._setPosition();\n        });\n      } }, { key: \"toggle\", value: function value() {\n        this.isActive ? this.hide() : this.show();\n      } }, { key: \"destroy\", value: function value() {\n        this.$element.attr(\"title\", this.template.text()).off(\".zf.trigger .zf.tootip\").removeAttr(\"aria-describedby\").removeAttr(\"data-yeti-box\").removeAttr(\"data-toggle\").removeAttr(\"data-resize\"), this.template.remove(), Foundation.unregisterPlugin(this);\n      } }]), e;\n  }();e.defaults = { disableForTouch: !1, hoverDelay: 200, fadeInDuration: 150, fadeOutDuration: 150, disableHover: !1, templateClasses: \"\", tooltipClass: \"tooltip\", triggerClass: \"has-tip\", showOn: \"small\", template: \"\", tipText: \"\", touchCloseText: \"Tap to close.\", clickOpen: !0, positionClass: \"\", vOffset: 10, hOffset: 12 }, Foundation.plugin(e, \"Tooltip\");\n}(jQuery);"

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function($) {'use strict';
	
	//kada se koristi Webpack svaki file se ponaša indipendno te ga je potrebno importirati explicitno
	var React = __webpack_require__(8);
	var ReactDOM = __webpack_require__(165);
	
	var _require = __webpack_require__(166),
	    Route = _require.Route,
	    Router = _require.Router,
	    IndexRoute = _require.IndexRoute,
	    hashHistory = _require.hashHistory;
	
	//componente
	
	
	var Main = __webpack_require__(229);
	var Timer = __webpack_require__(231);
	var Countdown = __webpack_require__(232);
	
	//Load foundation
	__webpack_require__(235);
	$(document).foundation();
	
	//App css
	__webpack_require__(239);
	
	ReactDOM.render(React.createElement(
	    Router,
	    { history: hashHistory },
	    React.createElement(
	        Route,
	        { path: '/', component: Main },
	        React.createElement(Route, { path: 'countdown', component: Countdown }),
	        React.createElement(IndexRoute, { component: Timer })
	    )
	), document.getElementById('app'));
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(7)))

/***/ },
/* 7 */
/***/ function(module, exports) {

	module.exports = jQuery;

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(9);

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule React
	 */
	
	'use strict';
	
	var ReactDOM = __webpack_require__(10);
	var ReactDOMServer = __webpack_require__(155);
	var ReactIsomorphic = __webpack_require__(159);
	
	var assign = __webpack_require__(46);
	var deprecated = __webpack_require__(164);
	
	// `version` will be added here by ReactIsomorphic.
	var React = {};
	
	assign(React, ReactIsomorphic);
	
	assign(React, {
	  // ReactDOM
	  findDOMNode: deprecated('findDOMNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.findDOMNode),
	  render: deprecated('render', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.render),
	  unmountComponentAtNode: deprecated('unmountComponentAtNode', 'ReactDOM', 'react-dom', ReactDOM, ReactDOM.unmountComponentAtNode),
	
	  // ReactDOMServer
	  renderToString: deprecated('renderToString', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToString),
	  renderToStaticMarkup: deprecated('renderToStaticMarkup', 'ReactDOMServer', 'react-dom/server', ReactDOMServer, ReactDOMServer.renderToStaticMarkup)
	});
	
	React.__SECRET_DOM_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOM;
	React.__SECRET_DOM_SERVER_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactDOMServer;
	
	module.exports = React;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOM
	 */
	
	/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdates = __webpack_require__(61);
	var ReactVersion = __webpack_require__(153);
	
	var findDOMNode = __webpack_require__(98);
	var renderSubtreeIntoContainer = __webpack_require__(154);
	var warning = __webpack_require__(32);
	
	ReactDefaultInjection.inject();
	
	var render = ReactPerf.measure('React', 'render', ReactMount.render);
	
	var React = {
	  findDOMNode: findDOMNode,
	  render: render,
	  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
	  version: ReactVersion,
	
	  /* eslint-disable camelcase */
	  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
	  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
	};
	
	// Inject the runtime into a devtools global hook regardless of browser.
	// Allows for debugging when the hook is injected on the page.
	/* eslint-enable camelcase */
	if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
	  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
	    CurrentOwner: ReactCurrentOwner,
	    InstanceHandles: ReactInstanceHandles,
	    Mount: ReactMount,
	    Reconciler: ReactReconciler,
	    TextComponent: ReactDOMTextComponent
	  });
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var ExecutionEnvironment = __webpack_require__(16);
	  if (ExecutionEnvironment.canUseDOM && window.top === window.self) {
	
	    // First check if devtools is not installed
	    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined') {
	      // If we're in Chrome or Firefox, provide a download link if not installed.
	      if (navigator.userAgent.indexOf('Chrome') > -1 && navigator.userAgent.indexOf('Edge') === -1 || navigator.userAgent.indexOf('Firefox') > -1) {
	        console.debug('Download the React DevTools for a better development experience: ' + 'https://fb.me/react-devtools');
	      }
	    }
	
	    // If we're in IE8, check to see if we are in compatibility mode and provide
	    // information on preventing compatibility mode
	    var ieCompatibilityMode = document.documentMode && document.documentMode < 8;
	
	    process.env.NODE_ENV !== 'production' ? warning(!ieCompatibilityMode, 'Internet Explorer is running in compatibility mode; please add the ' + 'following tag to your HTML to prevent this from happening: ' + '<meta http-equiv="X-UA-Compatible" content="IE=edge" />') : undefined;
	
	    var expectedFeatures = [
	    // shims
	    Array.isArray, Array.prototype.every, Array.prototype.forEach, Array.prototype.indexOf, Array.prototype.map, Date.now, Function.prototype.bind, Object.keys, String.prototype.split, String.prototype.trim,
	
	    // shams
	    Object.create, Object.freeze];
	
	    for (var i = 0; i < expectedFeatures.length; i++) {
	      if (!expectedFeatures[i]) {
	        console.error('One or more ES5 shim/shams expected by React are not available: ' + 'https://fb.me/react-warning-polyfills');
	        break;
	      }
	    }
	  }
	}
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 11 */
/***/ function(module, exports) {

	'use strict';
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout() {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	})();
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e) {
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e) {
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while (len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () {
	    return '/';
	};
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function () {
	    return 0;
	};

/***/ },
/* 12 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCurrentOwner
	 */
	
	'use strict';
	
	/**
	 * Keeps track of the current owner.
	 *
	 * The current owner is the component who should own any components that are
	 * currently being constructed.
	 */
	
	var ReactCurrentOwner = {
	
	  /**
	   * @internal
	   * @type {ReactComponent}
	   */
	  current: null
	
	};
	
	module.exports = ReactCurrentOwner;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactMount = __webpack_require__(35);
	
	var assign = __webpack_require__(46);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setTextContent = __webpack_require__(27);
	var validateDOMNesting = __webpack_require__(77);
	
	/**
	 * Text nodes violate a couple assumptions that React makes about components:
	 *
	 *  - When mounting text into the DOM, adjacent text nodes are merged.
	 *  - Text nodes cannot be assigned a React root ID.
	 *
	 * This component is used to wrap strings in elements so that they can undergo
	 * the same reconciliation that is applied to elements.
	 *
	 * TODO: Investigate representing React components in the DOM with text nodes.
	 *
	 * @class ReactDOMTextComponent
	 * @extends ReactComponent
	 * @internal
	 */
	var ReactDOMTextComponent = function ReactDOMTextComponent(props) {
	  // This constructor and its argument is currently used by mocks.
	};
	
	assign(ReactDOMTextComponent.prototype, {
	
	  /**
	   * @param {ReactText} text
	   * @internal
	   */
	  construct: function construct(text) {
	    // TODO: This is really a ReactText (ReactNode), not a ReactElement
	    this._currentElement = text;
	    this._stringText = '' + text;
	
	    // Properties
	    this._rootNodeID = null;
	    this._mountIndex = 0;
	  },
	
	  /**
	   * Creates the markup for this text node. This node is not intended to have
	   * any features besides containing text content.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {string} Markup for this text node.
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting('span', null, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    this._rootNodeID = rootID;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement('span');
	      DOMPropertyOperations.setAttributeForID(el, rootID);
	      // Populate node cache
	      ReactMount.getID(el);
	      setTextContent(el, this._stringText);
	      return el;
	    } else {
	      var escapedText = escapeTextContentForBrowser(this._stringText);
	
	      if (transaction.renderToStaticMarkup) {
	        // Normally we'd wrap this in a `span` for the reasons stated above, but
	        // since this is a situation where React won't take over (static pages),
	        // we can simply return the text as it is.
	        return escapedText;
	      }
	
	      return '<span ' + DOMPropertyOperations.createMarkupForID(rootID) + '>' + escapedText + '</span>';
	    }
	  },
	
	  /**
	   * Updates this component by updating the text content.
	   *
	   * @param {ReactText} nextText The next text content
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  receiveComponent: function receiveComponent(nextText, transaction) {
	    if (nextText !== this._currentElement) {
	      this._currentElement = nextText;
	      var nextStringText = '' + nextText;
	      if (nextStringText !== this._stringText) {
	        // TODO: Save this as pending props and use performUpdateIfNecessary
	        // and/or updateComponent to do the actual update for consistency with
	        // other component types?
	        this._stringText = nextStringText;
	        var node = ReactMount.getNode(this._rootNodeID);
	        DOMChildrenOperations.updateTextContent(node, nextStringText);
	      }
	    }
	  },
	
	  unmountComponent: function unmountComponent() {
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	  }
	
	});
	
	module.exports = ReactDOMTextComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMChildrenOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var Danger = __webpack_require__(15);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	var ReactPerf = __webpack_require__(25);
	
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var invariant = __webpack_require__(20);
	
	/**
	 * Inserts `childNode` as a child of `parentNode` at the `index`.
	 *
	 * @param {DOMElement} parentNode Parent node in which to insert.
	 * @param {DOMElement} childNode Child node to insert.
	 * @param {number} index Index at which to insert the child.
	 * @internal
	 */
	function insertChildAt(parentNode, childNode, index) {
	  // By exploiting arrays returning `undefined` for an undefined index, we can
	  // rely exclusively on `insertBefore(node, null)` instead of also using
	  // `appendChild(node)`. However, using `undefined` is not allowed by all
	  // browsers so we must replace it with `null`.
	
	  // fix render order error in safari
	  // IE8 will throw error when index out of list size.
	  var beforeChild = index >= parentNode.childNodes.length ? null : parentNode.childNodes.item(index);
	
	  parentNode.insertBefore(childNode, beforeChild);
	}
	
	/**
	 * Operations for updating with DOM children.
	 */
	var DOMChildrenOperations = {
	
	  dangerouslyReplaceNodeWithMarkup: Danger.dangerouslyReplaceNodeWithMarkup,
	
	  updateTextContent: setTextContent,
	
	  /**
	   * Updates a component's children by processing a series of updates. The
	   * update configurations are each expected to have a `parentNode` property.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markupList List of markup strings.
	   * @internal
	   */
	  processUpdates: function processUpdates(updates, markupList) {
	    var update;
	    // Mapping from parent IDs to initial child orderings.
	    var initialChildren = null;
	    // List of children that will be moved or removed.
	    var updatedChildren = null;
	
	    for (var i = 0; i < updates.length; i++) {
	      update = updates[i];
	      if (update.type === ReactMultiChildUpdateTypes.MOVE_EXISTING || update.type === ReactMultiChildUpdateTypes.REMOVE_NODE) {
	        var updatedIndex = update.fromIndex;
	        var updatedChild = update.parentNode.childNodes[updatedIndex];
	        var parentID = update.parentID;
	
	        !updatedChild ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processUpdates(): Unable to find child %s of element. This ' + 'probably means the DOM was unexpectedly mutated (e.g., by the ' + 'browser), usually due to forgetting a <tbody> when using tables, ' + 'nesting tags like <form>, <p>, or <a>, or using non-SVG elements ' + 'in an <svg> parent. Try inspecting the child nodes of the element ' + 'with React ID `%s`.', updatedIndex, parentID) : invariant(false) : undefined;
	
	        initialChildren = initialChildren || {};
	        initialChildren[parentID] = initialChildren[parentID] || [];
	        initialChildren[parentID][updatedIndex] = updatedChild;
	
	        updatedChildren = updatedChildren || [];
	        updatedChildren.push(updatedChild);
	      }
	    }
	
	    var renderedMarkup;
	    // markupList is either a list of markup or just a list of elements
	    if (markupList.length && typeof markupList[0] === 'string') {
	      renderedMarkup = Danger.dangerouslyRenderMarkup(markupList);
	    } else {
	      renderedMarkup = markupList;
	    }
	
	    // Remove updated children first so that `toIndex` is consistent.
	    if (updatedChildren) {
	      for (var j = 0; j < updatedChildren.length; j++) {
	        updatedChildren[j].parentNode.removeChild(updatedChildren[j]);
	      }
	    }
	
	    for (var k = 0; k < updates.length; k++) {
	      update = updates[k];
	      switch (update.type) {
	        case ReactMultiChildUpdateTypes.INSERT_MARKUP:
	          insertChildAt(update.parentNode, renderedMarkup[update.markupIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.MOVE_EXISTING:
	          insertChildAt(update.parentNode, initialChildren[update.parentID][update.fromIndex], update.toIndex);
	          break;
	        case ReactMultiChildUpdateTypes.SET_MARKUP:
	          setInnerHTML(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.TEXT_CONTENT:
	          setTextContent(update.parentNode, update.content);
	          break;
	        case ReactMultiChildUpdateTypes.REMOVE_NODE:
	          // Already removed by the for-loop above.
	          break;
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMChildrenOperations, 'DOMChildrenOperations', {
	  updateTextContent: 'updateTextContent'
	});
	
	module.exports = DOMChildrenOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Danger
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createNodesFromMarkup = __webpack_require__(17);
	var emptyFunction = __webpack_require__(22);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	var OPEN_TAG_NAME_EXP = /^(<[^ \/>]+)/;
	var RESULT_INDEX_ATTR = 'data-danger-index';
	
	/**
	 * Extracts the `nodeName` from a string of markup.
	 *
	 * NOTE: Extracting the `nodeName` does not require a regular expression match
	 * because we make assumptions about React-generated markup (i.e. there are no
	 * spaces surrounding the opening tag and there is at least one attribute).
	 *
	 * @param {string} markup String of markup.
	 * @return {string} Node name of the supplied markup.
	 * @see http://jsperf.com/extract-nodename
	 */
	function getNodeName(markup) {
	  return markup.substring(1, markup.indexOf(' '));
	}
	
	var Danger = {
	
	  /**
	   * Renders markup into an array of nodes. The markup is expected to render
	   * into a list of root nodes. Also, the length of `resultList` and
	   * `markupList` should be the same.
	   *
	   * @param {array<string>} markupList List of markup strings to render.
	   * @return {array<DOMElement>} List of rendered nodes.
	   * @internal
	   */
	  dangerouslyRenderMarkup: function dangerouslyRenderMarkup(markupList) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Cannot render markup in a worker ' + 'thread. Make sure `window` and `document` are available globally ' + 'before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString for server rendering.') : invariant(false) : undefined;
	    var nodeName;
	    var markupByNodeName = {};
	    // Group markup by `nodeName` if a wrap is necessary, else by '*'.
	    for (var i = 0; i < markupList.length; i++) {
	      !markupList[i] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyRenderMarkup(...): Missing markup.') : invariant(false) : undefined;
	      nodeName = getNodeName(markupList[i]);
	      nodeName = getMarkupWrap(nodeName) ? nodeName : '*';
	      markupByNodeName[nodeName] = markupByNodeName[nodeName] || [];
	      markupByNodeName[nodeName][i] = markupList[i];
	    }
	    var resultList = [];
	    var resultListAssignmentCount = 0;
	    for (nodeName in markupByNodeName) {
	      if (!markupByNodeName.hasOwnProperty(nodeName)) {
	        continue;
	      }
	      var markupListByNodeName = markupByNodeName[nodeName];
	
	      // This for-in loop skips the holes of the sparse array. The order of
	      // iteration should follow the order of assignment, which happens to match
	      // numerical index order, but we don't rely on that.
	      var resultIndex;
	      for (resultIndex in markupListByNodeName) {
	        if (markupListByNodeName.hasOwnProperty(resultIndex)) {
	          var markup = markupListByNodeName[resultIndex];
	
	          // Push the requested markup with an additional RESULT_INDEX_ATTR
	          // attribute.  If the markup does not start with a < character, it
	          // will be discarded below (with an appropriate console.error).
	          markupListByNodeName[resultIndex] = markup.replace(OPEN_TAG_NAME_EXP,
	          // This index will be parsed back out below.
	          '$1 ' + RESULT_INDEX_ATTR + '="' + resultIndex + '" ');
	        }
	      }
	
	      // Render each group of markup with similar wrapping `nodeName`.
	      var renderNodes = createNodesFromMarkup(markupListByNodeName.join(''), emptyFunction // Do nothing special with <script> tags.
	      );
	
	      for (var j = 0; j < renderNodes.length; ++j) {
	        var renderNode = renderNodes[j];
	        if (renderNode.hasAttribute && renderNode.hasAttribute(RESULT_INDEX_ATTR)) {
	
	          resultIndex = +renderNode.getAttribute(RESULT_INDEX_ATTR);
	          renderNode.removeAttribute(RESULT_INDEX_ATTR);
	
	          !!resultList.hasOwnProperty(resultIndex) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Assigning to an already-occupied result index.') : invariant(false) : undefined;
	
	          resultList[resultIndex] = renderNode;
	
	          // This should match resultList.length and markupList.length when
	          // we're done.
	          resultListAssignmentCount += 1;
	        } else if (process.env.NODE_ENV !== 'production') {
	          console.error('Danger: Discarding unexpected node:', renderNode);
	        }
	      }
	    }
	
	    // Although resultList was populated out of order, it should now be a dense
	    // array.
	    !(resultListAssignmentCount === resultList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Did not assign to every index of resultList.') : invariant(false) : undefined;
	
	    !(resultList.length === markupList.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Danger: Expected markup to render %s nodes, but rendered %s.', markupList.length, resultList.length) : invariant(false) : undefined;
	
	    return resultList;
	  },
	
	  /**
	   * Replaces a node with a string of markup at its current position within its
	   * parent. The markup must render into a single root node.
	   *
	   * @param {DOMElement} oldChild Child node to replace.
	   * @param {string} markup Markup to render in place of the child node.
	   * @internal
	   */
	  dangerouslyReplaceNodeWithMarkup: function dangerouslyReplaceNodeWithMarkup(oldChild, markup) {
	    !ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot render markup in a ' + 'worker thread. Make sure `window` and `document` are available ' + 'globally before requiring React when unit testing or use ' + 'ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	    !markup ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Missing markup.') : invariant(false) : undefined;
	    !(oldChild.tagName.toLowerCase() !== 'html') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'dangerouslyReplaceNodeWithMarkup(...): Cannot replace markup of the ' + '<html> node. This is because browser quirks make this unreliable ' + 'and/or slow. If you want to render to the root you must use ' + 'server rendering. See ReactDOMServer.renderToString().') : invariant(false) : undefined;
	
	    var newChild;
	    if (typeof markup === 'string') {
	      newChild = createNodesFromMarkup(markup, emptyFunction)[0];
	    } else {
	      newChild = markup;
	    }
	    oldChild.parentNode.replaceChild(newChild, oldChild);
	  }
	
	};
	
	module.exports = Danger;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ExecutionEnvironment
	 */
	
	'use strict';
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	/**
	 * Simple, lightweight module assisting with the detection and context of
	 * Worker. Helps avoid circular dependencies and allows code to reason about
	 * whether or not they are in a Worker, even if they never include the main
	 * `ReactWorker` dependency.
	 */
	var ExecutionEnvironment = {
	
	  canUseDOM: canUseDOM,
	
	  canUseWorkers: typeof Worker !== 'undefined',
	
	  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
	
	  canUseViewport: canUseDOM && !!window.screen,
	
	  isInWorker: !canUseDOM // For now, this is true - might change in the future.
	
	};
	
	module.exports = ExecutionEnvironment;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createNodesFromMarkup
	 * @typechecks
	 */
	
	/*eslint-disable fb-www/unsafe-html*/
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var createArrayFromMixed = __webpack_require__(18);
	var getMarkupWrap = __webpack_require__(21);
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to render all markup.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Pattern used by `getNodeName`.
	 */
	var nodeNamePattern = /^\s*<(\w+)/;
	
	/**
	 * Extracts the `nodeName` of the first element in a string of markup.
	 *
	 * @param {string} markup String of markup.
	 * @return {?string} Node name of the supplied markup.
	 */
	function getNodeName(markup) {
	  var nodeNameMatch = markup.match(nodeNamePattern);
	  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
	}
	
	/**
	 * Creates an array containing the nodes rendered from the supplied markup. The
	 * optionally supplied `handleScript` function will be invoked once for each
	 * <script> element that is rendered. If no `handleScript` function is supplied,
	 * an exception is thrown if any <script> elements are rendered.
	 *
	 * @param {string} markup A string of valid HTML markup.
	 * @param {?function} handleScript Invoked once for each rendered <script>.
	 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
	 */
	function createNodesFromMarkup(markup, handleScript) {
	  var node = dummyNode;
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup dummy not initialized') : invariant(false) : undefined;
	  var nodeName = getNodeName(markup);
	
	  var wrap = nodeName && getMarkupWrap(nodeName);
	  if (wrap) {
	    node.innerHTML = wrap[1] + markup + wrap[2];
	
	    var wrapDepth = wrap[0];
	    while (wrapDepth--) {
	      node = node.lastChild;
	    }
	  } else {
	    node.innerHTML = markup;
	  }
	
	  var scripts = node.getElementsByTagName('script');
	  if (scripts.length) {
	    !handleScript ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createNodesFromMarkup(...): Unexpected <script> element rendered.') : invariant(false) : undefined;
	    createArrayFromMixed(scripts).forEach(handleScript);
	  }
	
	  var nodes = createArrayFromMixed(node.childNodes);
	  while (node.lastChild) {
	    node.removeChild(node.lastChild);
	  }
	  return nodes;
	}
	
	module.exports = createNodesFromMarkup;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule createArrayFromMixed
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var toArray = __webpack_require__(19);
	
	/**
	 * Perform a heuristic test to determine if an object is "array-like".
	 *
	 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
	 *   Joshu replied: "Mu."
	 *
	 * This function determines if its argument has "array nature": it returns
	 * true if the argument is an actual array, an `arguments' object, or an
	 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
	 *
	 * It will return false for other array-like objects like Filelist.
	 *
	 * @param {*} obj
	 * @return {boolean}
	 */
	function hasArrayNature(obj) {
	  return (
	    // not null/false
	    !!obj && (
	    // arrays are objects, NodeLists are functions in Safari
	    (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) == 'object' || typeof obj == 'function') &&
	    // quacks like an array
	    'length' in obj &&
	    // not window
	    !('setInterval' in obj) &&
	    // no DOM node should be considered an array-like
	    // a 'select' element has 'length' and 'item' properties on IE8
	    typeof obj.nodeType != 'number' && (
	    // a real array
	    Array.isArray(obj) ||
	    // arguments
	    'callee' in obj ||
	    // HTMLCollection/NodeList
	    'item' in obj)
	  );
	}
	
	/**
	 * Ensure that the argument is an array by wrapping it in an array if it is not.
	 * Creates a copy of the argument if it is already an array.
	 *
	 * This is mostly useful idiomatically:
	 *
	 *   var createArrayFromMixed = require('createArrayFromMixed');
	 *
	 *   function takesOneOrMoreThings(things) {
	 *     things = createArrayFromMixed(things);
	 *     ...
	 *   }
	 *
	 * This allows you to treat `things' as an array, but accept scalars in the API.
	 *
	 * If you need to convert an array-like object, like `arguments`, into an array
	 * use toArray instead.
	 *
	 * @param {*} obj
	 * @return {array}
	 */
	function createArrayFromMixed(obj) {
	  if (!hasArrayNature(obj)) {
	    return [obj];
	  } else if (Array.isArray(obj)) {
	    return obj.slice();
	  } else {
	    return toArray(obj);
	  }
	}
	
	module.exports = createArrayFromMixed;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule toArray
	 * @typechecks
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Convert array-like objects to arrays.
	 *
	 * This API assumes the caller knows the contents of the data type. For less
	 * well defined inputs use createArrayFromMixed.
	 *
	 * @param {object|function|filelist} obj
	 * @return {array}
	 */
	function toArray(obj) {
	  var length = obj.length;
	
	  // Some browse builtin objects can report typeof 'function' (e.g. NodeList in
	  // old versions of Safari).
	  !(!Array.isArray(obj) && ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' || typeof obj === 'function')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Array-like object expected') : invariant(false) : undefined;
	
	  !(typeof length === 'number') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object needs a length property') : invariant(false) : undefined;
	
	  !(length === 0 || length - 1 in obj) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'toArray: Object should have keys for indices') : invariant(false) : undefined;
	
	  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
	  // without method will throw during the slice call and skip straight to the
	  // fallback.
	  if (obj.hasOwnProperty) {
	    try {
	      return Array.prototype.slice.call(obj);
	    } catch (e) {
	      // IE < 9 does not support Array#slice on collections objects
	    }
	  }
	
	  // Fall back to copying key by key. This assumes all keys have a value,
	  // so will not preserve sparsely populated inputs.
	  var ret = Array(length);
	  for (var ii = 0; ii < length; ii++) {
	    ret[ii] = obj[ii];
	  }
	  return ret;
	}
	
	module.exports = toArray;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule invariant
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	}
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getMarkupWrap
	 */
	
	/*eslint-disable fb-www/unsafe-html */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Dummy container used to detect which wraps are necessary.
	 */
	var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;
	
	/**
	 * Some browsers cannot use `innerHTML` to render certain elements standalone,
	 * so we wrap them, render the wrapped nodes, then extract the desired node.
	 *
	 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
	 */
	
	var shouldWrap = {};
	
	var selectWrap = [1, '<select multiple="true">', '</select>'];
	var tableWrap = [1, '<table>', '</table>'];
	var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];
	
	var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];
	
	var markupWrap = {
	  '*': [1, '?<div>', '</div>'],
	
	  'area': [1, '<map>', '</map>'],
	  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
	  'legend': [1, '<fieldset>', '</fieldset>'],
	  'param': [1, '<object>', '</object>'],
	  'tr': [2, '<table><tbody>', '</tbody></table>'],
	
	  'optgroup': selectWrap,
	  'option': selectWrap,
	
	  'caption': tableWrap,
	  'colgroup': tableWrap,
	  'tbody': tableWrap,
	  'tfoot': tableWrap,
	  'thead': tableWrap,
	
	  'td': trWrap,
	  'th': trWrap
	};
	
	// Initialize the SVG elements since we know they'll always need to be wrapped
	// consistently. If they are created inside a <div> they will be initialized in
	// the wrong namespace (and will not display).
	var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
	svgElements.forEach(function (nodeName) {
	  markupWrap[nodeName] = svgWrap;
	  shouldWrap[nodeName] = true;
	});
	
	/**
	 * Gets the markup wrap configuration for the supplied `nodeName`.
	 *
	 * NOTE: This lazily detects which wraps are necessary for the current browser.
	 *
	 * @param {string} nodeName Lowercase `nodeName`.
	 * @return {?array} Markup wrap configuration, if applicable.
	 */
	function getMarkupWrap(nodeName) {
	  !!!dummyNode ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Markup wrapping node not initialized') : invariant(false) : undefined;
	  if (!markupWrap.hasOwnProperty(nodeName)) {
	    nodeName = '*';
	  }
	  if (!shouldWrap.hasOwnProperty(nodeName)) {
	    if (nodeName === '*') {
	      dummyNode.innerHTML = '<link />';
	    } else {
	      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
	    }
	    shouldWrap[nodeName] = !dummyNode.firstChild;
	  }
	  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
	}
	
	module.exports = getMarkupWrap;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 22 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyFunction
	 */
	
	"use strict";
	
	function makeEmptyFunction(arg) {
	  return function () {
	    return arg;
	  };
	}
	
	/**
	 * This function accepts and discards inputs; it has no side effects. This is
	 * primarily useful idiomatically for overridable function endpoints which
	 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
	 */
	function emptyFunction() {}
	
	emptyFunction.thatReturns = makeEmptyFunction;
	emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
	emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
	emptyFunction.thatReturnsNull = makeEmptyFunction(null);
	emptyFunction.thatReturnsThis = function () {
	  return this;
	};
	emptyFunction.thatReturnsArgument = function (arg) {
	  return arg;
	};
	
	module.exports = emptyFunction;

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChildUpdateTypes
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	/**
	 * When a component's children are updated, a series of update configuration
	 * objects are created in order to batch and serialize the required changes.
	 *
	 * Enumerates all the possible types of update configurations.
	 *
	 * @internal
	 */
	var ReactMultiChildUpdateTypes = keyMirror({
	  INSERT_MARKUP: null,
	  MOVE_EXISTING: null,
	  REMOVE_NODE: null,
	  SET_MARKUP: null,
	  TEXT_CONTENT: null
	});
	
	module.exports = ReactMultiChildUpdateTypes;

/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyMirror
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Constructs an enumeration with keys equal to their value.
	 *
	 * For example:
	 *
	 *   var COLORS = keyMirror({blue: null, red: null});
	 *   var myColor = COLORS.blue;
	 *   var isColorValid = !!COLORS[myColor];
	 *
	 * The last line could not be performed if the values of the generated enum were
	 * not equal to their keys.
	 *
	 *   Input:  {key1: val1, key2: val2}
	 *   Output: {key1: key1, key2: key2}
	 *
	 * @param {object} obj
	 * @return {object}
	 */
	var keyMirror = function keyMirror(obj) {
	  var ret = {};
	  var key;
	  !(obj instanceof Object && !Array.isArray(obj)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'keyMirror(...): Argument must be an object.') : invariant(false) : undefined;
	  for (key in obj) {
	    if (!obj.hasOwnProperty(key)) {
	      continue;
	    }
	    ret[key] = key;
	  }
	  return ret;
	};
	
	module.exports = keyMirror;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * ReactPerf is a general AOP system designed to measure performance. This
	 * module only has the hooks: see ReactDefaultPerf for the analysis tool.
	 */
	
	var ReactPerf = {
	  /**
	   * Boolean to enable/disable measurement. Set to false by default to prevent
	   * accidental logging and perf loss.
	   */
	  enableMeasure: false,
	
	  /**
	   * Holds onto the measure function in use. By default, don't measure
	   * anything, but we'll override this if we inject a measure function.
	   */
	  storedMeasure: _noMeasure,
	
	  /**
	   * @param {object} object
	   * @param {string} objectName
	   * @param {object<string>} methodNames
	   */
	  measureMethods: function measureMethods(object, objectName, methodNames) {
	    if (process.env.NODE_ENV !== 'production') {
	      for (var key in methodNames) {
	        if (!methodNames.hasOwnProperty(key)) {
	          continue;
	        }
	        object[key] = ReactPerf.measure(objectName, methodNames[key], object[key]);
	      }
	    }
	  },
	
	  /**
	   * Use this to wrap methods you want to measure. Zero overhead in production.
	   *
	   * @param {string} objName
	   * @param {string} fnName
	   * @param {function} func
	   * @return {function}
	   */
	  measure: function measure(objName, fnName, func) {
	    if (process.env.NODE_ENV !== 'production') {
	      var measuredFunc = null;
	      var wrapper = function wrapper() {
	        if (ReactPerf.enableMeasure) {
	          if (!measuredFunc) {
	            measuredFunc = ReactPerf.storedMeasure(objName, fnName, func);
	          }
	          return measuredFunc.apply(this, arguments);
	        }
	        return func.apply(this, arguments);
	      };
	      wrapper.displayName = objName + '_' + fnName;
	      return wrapper;
	    }
	    return func;
	  },
	
	  injection: {
	    /**
	     * @param {function} measure
	     */
	    injectMeasure: function injectMeasure(measure) {
	      ReactPerf.storedMeasure = measure;
	    }
	  }
	};
	
	/**
	 * Simply passes through the measured function, without measuring it.
	 *
	 * @param {string} objName
	 * @param {string} fnName
	 * @param {function} func
	 * @return {function}
	 */
	function _noMeasure(objName, fnName, func) {
	  return func;
	}
	
	module.exports = ReactPerf;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setInnerHTML
	 */
	
	/* globals MSApp */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var WHITESPACE_TEST = /^[ \r\n\t\f]/;
	var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;
	
	/**
	 * Set the innerHTML property of a node, ensuring that whitespace is preserved
	 * even in IE8.
	 *
	 * @param {DOMElement} node
	 * @param {string} html
	 * @internal
	 */
	var setInnerHTML = function setInnerHTML(node, html) {
	  node.innerHTML = html;
	};
	
	// Win8 apps: Allow all html to be inserted
	if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
	  setInnerHTML = function setInnerHTML(node, html) {
	    MSApp.execUnsafeLocalFunction(function () {
	      node.innerHTML = html;
	    });
	  };
	}
	
	if (ExecutionEnvironment.canUseDOM) {
	  // IE8: When updating a just created node with innerHTML only leading
	  // whitespace is removed. When updating an existing node with innerHTML
	  // whitespace in root TextNodes is also collapsed.
	  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html
	
	  // Feature detection; only IE8 is known to behave improperly like this.
	  var testElement = document.createElement('div');
	  testElement.innerHTML = ' ';
	  if (testElement.innerHTML === '') {
	    setInnerHTML = function setInnerHTML(node, html) {
	      // Magic theory: IE8 supposedly differentiates between added and updated
	      // nodes when processing innerHTML, innerHTML on updated nodes suffers
	      // from worse whitespace behavior. Re-adding a node like this triggers
	      // the initial and more favorable whitespace behavior.
	      // TODO: What to do on a detached node?
	      if (node.parentNode) {
	        node.parentNode.replaceChild(node, node);
	      }
	
	      // We also implement a workaround for non-visible tags disappearing into
	      // thin air on IE8, this only happens if there is no visible text
	      // in-front of the non-visible tags. Piggyback on the whitespace fix
	      // and simply check if any non-visible tags appear in the source.
	      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
	        // Recover leading whitespace by temporarily prepending any character.
	        // \uFEFF has the potential advantage of being zero-width/invisible.
	        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
	        // in hopes that this is preserved even if "\uFEFF" is transformed to
	        // the actual Unicode character (by Babel, for example).
	        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
	        node.innerHTML = String.fromCharCode(0xFEFF) + html;
	
	        // deleteData leaves an empty `TextNode` which offsets the index of all
	        // children. Definitely want to avoid this.
	        var textNode = node.firstChild;
	        if (textNode.data.length === 1) {
	          node.removeChild(textNode);
	        } else {
	          textNode.deleteData(0, 1);
	        }
	      } else {
	        node.innerHTML = html;
	      }
	    };
	  }
	}
	
	module.exports = setInnerHTML;

/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule setTextContent
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var setInnerHTML = __webpack_require__(26);
	
	/**
	 * Set the textContent property of a node, ensuring that whitespace is preserved
	 * even in IE8. innerText is a poor substitute for textContent and, among many
	 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
	 * as it should.
	 *
	 * @param {DOMElement} node
	 * @param {string} text
	 * @internal
	 */
	var setTextContent = function setTextContent(node, text) {
	  node.textContent = text;
	};
	
	if (ExecutionEnvironment.canUseDOM) {
	  if (!('textContent' in document.documentElement)) {
	    setTextContent = function setTextContent(node, text) {
	      setInnerHTML(node, escapeTextContentForBrowser(text));
	    };
	  }
	}
	
	module.exports = setTextContent;

/***/ },
/* 28 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule escapeTextContentForBrowser
	 */
	
	'use strict';
	
	var ESCAPE_LOOKUP = {
	  '&': '&amp;',
	  '>': '&gt;',
	  '<': '&lt;',
	  '"': '&quot;',
	  '\'': '&#x27;'
	};
	
	var ESCAPE_REGEX = /[&><"']/g;
	
	function escaper(match) {
	  return ESCAPE_LOOKUP[match];
	}
	
	/**
	 * Escapes text to prevent scripting attacks.
	 *
	 * @param {*} text Text value to escape.
	 * @return {string} An escaped string.
	 */
	function escapeTextContentForBrowser(text) {
	  return ('' + text).replace(ESCAPE_REGEX, escaper);
	}
	
	module.exports = escapeTextContentForBrowser;

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactPerf = __webpack_require__(25);
	
	var quoteAttributeValueForBrowser = __webpack_require__(31);
	var warning = __webpack_require__(32);
	
	// Simplified subset
	var VALID_ATTRIBUTE_NAME_REGEX = /^[a-zA-Z_][\w\.\-]*$/;
	var illegalAttributeNameCache = {};
	var validatedAttributeNameCache = {};
	
	function isAttributeNameSafe(attributeName) {
	  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
	    return true;
	  }
	  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
	    return false;
	  }
	  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
	    validatedAttributeNameCache[attributeName] = true;
	    return true;
	  }
	  illegalAttributeNameCache[attributeName] = true;
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid attribute name: `%s`', attributeName) : undefined;
	  return false;
	}
	
	function shouldIgnoreValue(propertyInfo, value) {
	  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  var reactProps = {
	    children: true,
	    dangerouslySetInnerHTML: true,
	    key: true,
	    ref: true
	  };
	  var warnedProperties = {};
	
	  var warnUnknownProperty = function warnUnknownProperty(name) {
	    if (reactProps.hasOwnProperty(name) && reactProps[name] || warnedProperties.hasOwnProperty(name) && warnedProperties[name]) {
	      return;
	    }
	
	    warnedProperties[name] = true;
	    var lowerCasedName = name.toLowerCase();
	
	    // data-* attributes should be lowercase; suggest the lowercase version
	    var standardName = DOMProperty.isCustomAttribute(lowerCasedName) ? lowerCasedName : DOMProperty.getPossibleStandardName.hasOwnProperty(lowerCasedName) ? DOMProperty.getPossibleStandardName[lowerCasedName] : null;
	
	    // For now, only warn when we have a suggested correction. This prevents
	    // logging too much when using transferPropsTo.
	    process.env.NODE_ENV !== 'production' ? warning(standardName == null, 'Unknown DOM property %s. Did you mean %s?', name, standardName) : undefined;
	  };
	}
	
	/**
	 * Operations for dealing with DOM properties.
	 */
	var DOMPropertyOperations = {
	
	  /**
	   * Creates markup for the ID property.
	   *
	   * @param {string} id Unescaped ID.
	   * @return {string} Markup string.
	   */
	  createMarkupForID: function createMarkupForID(id) {
	    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
	  },
	
	  setAttributeForID: function setAttributeForID(node, id) {
	    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
	  },
	
	  /**
	   * Creates markup for a property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {?string} Markup string, or null if the property was invalid.
	   */
	  createMarkupForProperty: function createMarkupForProperty(name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      if (shouldIgnoreValue(propertyInfo, value)) {
	        return '';
	      }
	      var attributeName = propertyInfo.attributeName;
	      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	        return attributeName + '=""';
	      }
	      return attributeName + '=' + quoteAttributeValueForBrowser(value);
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      if (value == null) {
	        return '';
	      }
	      return name + '=' + quoteAttributeValueForBrowser(value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	    return null;
	  },
	
	  /**
	   * Creates markup for a custom property.
	   *
	   * @param {string} name
	   * @param {*} value
	   * @return {string} Markup string, or empty string if the property was invalid.
	   */
	  createMarkupForCustomAttribute: function createMarkupForCustomAttribute(name, value) {
	    if (!isAttributeNameSafe(name) || value == null) {
	      return '';
	    }
	    return name + '=' + quoteAttributeValueForBrowser(value);
	  },
	
	  /**
	   * Sets the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   * @param {*} value
	   */
	  setValueForProperty: function setValueForProperty(node, name, value) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, value);
	      } else if (shouldIgnoreValue(propertyInfo, value)) {
	        this.deleteValueForProperty(node, name);
	      } else if (propertyInfo.mustUseAttribute) {
	        var attributeName = propertyInfo.attributeName;
	        var namespace = propertyInfo.attributeNamespace;
	        // `setAttribute` with objects becomes only `[object]` in IE8/9,
	        // ('' + value) makes it output the correct toString()-value.
	        if (namespace) {
	          node.setAttributeNS(namespace, attributeName, '' + value);
	        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
	          node.setAttribute(attributeName, '');
	        } else {
	          node.setAttribute(attributeName, '' + value);
	        }
	      } else {
	        var propName = propertyInfo.propertyName;
	        // Must explicitly cast values for HAS_SIDE_EFFECTS-properties to the
	        // property type before comparing; only `value` does and is string.
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== '' + value) {
	          // Contrary to `setAttribute`, object properties are properly
	          // `toString`ed by IE8/9.
	          node[propName] = value;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      DOMPropertyOperations.setValueForAttribute(node, name, value);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  },
	
	  setValueForAttribute: function setValueForAttribute(node, name, value) {
	    if (!isAttributeNameSafe(name)) {
	      return;
	    }
	    if (value == null) {
	      node.removeAttribute(name);
	    } else {
	      node.setAttribute(name, '' + value);
	    }
	  },
	
	  /**
	   * Deletes the value for a property on a node.
	   *
	   * @param {DOMElement} node
	   * @param {string} name
	   */
	  deleteValueForProperty: function deleteValueForProperty(node, name) {
	    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
	    if (propertyInfo) {
	      var mutationMethod = propertyInfo.mutationMethod;
	      if (mutationMethod) {
	        mutationMethod(node, undefined);
	      } else if (propertyInfo.mustUseAttribute) {
	        node.removeAttribute(propertyInfo.attributeName);
	      } else {
	        var propName = propertyInfo.propertyName;
	        var defaultValue = DOMProperty.getDefaultValueForProperty(node.nodeName, propName);
	        if (!propertyInfo.hasSideEffects || '' + node[propName] !== defaultValue) {
	          node[propName] = defaultValue;
	        }
	      }
	    } else if (DOMProperty.isCustomAttribute(name)) {
	      node.removeAttribute(name);
	    } else if (process.env.NODE_ENV !== 'production') {
	      warnUnknownProperty(name);
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(DOMPropertyOperations, 'DOMPropertyOperations', {
	  setValueForProperty: 'setValueForProperty',
	  setValueForAttribute: 'setValueForAttribute',
	  deleteValueForProperty: 'deleteValueForProperty'
	});
	
	module.exports = DOMPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DOMProperty
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	function checkMask(value, bitmask) {
	  return (value & bitmask) === bitmask;
	}
	
	var DOMPropertyInjection = {
	  /**
	   * Mapping from normalized, camelcased property names to a configuration that
	   * specifies how the associated DOM property should be accessed or rendered.
	   */
	  MUST_USE_ATTRIBUTE: 0x1,
	  MUST_USE_PROPERTY: 0x2,
	  HAS_SIDE_EFFECTS: 0x4,
	  HAS_BOOLEAN_VALUE: 0x8,
	  HAS_NUMERIC_VALUE: 0x10,
	  HAS_POSITIVE_NUMERIC_VALUE: 0x20 | 0x10,
	  HAS_OVERLOADED_BOOLEAN_VALUE: 0x40,
	
	  /**
	   * Inject some specialized knowledge about the DOM. This takes a config object
	   * with the following properties:
	   *
	   * isCustomAttribute: function that given an attribute name will return true
	   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
	   * attributes where it's impossible to enumerate all of the possible
	   * attribute names,
	   *
	   * Properties: object mapping DOM property name to one of the
	   * DOMPropertyInjection constants or null. If your attribute isn't in here,
	   * it won't get written to the DOM.
	   *
	   * DOMAttributeNames: object mapping React attribute name to the DOM
	   * attribute name. Attribute names not specified use the **lowercase**
	   * normalized name.
	   *
	   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
	   * attribute namespace URL. (Attribute names not specified use no namespace.)
	   *
	   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
	   * Property names not specified use the normalized name.
	   *
	   * DOMMutationMethods: Properties that require special mutation methods. If
	   * `value` is undefined, the mutation method should unset the property.
	   *
	   * @param {object} domPropertyConfig the config as described above.
	   */
	  injectDOMPropertyConfig: function injectDOMPropertyConfig(domPropertyConfig) {
	    var Injection = DOMPropertyInjection;
	    var Properties = domPropertyConfig.Properties || {};
	    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
	    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
	    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
	    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};
	
	    if (domPropertyConfig.isCustomAttribute) {
	      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
	    }
	
	    for (var propName in Properties) {
	      !!DOMProperty.properties.hasOwnProperty(propName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'injectDOMPropertyConfig(...): You\'re trying to inject DOM property ' + '\'%s\' which has already been injected. You may be accidentally ' + 'injecting the same DOM property config twice, or you may be ' + 'injecting two configs that have conflicting property names.', propName) : invariant(false) : undefined;
	
	      var lowerCased = propName.toLowerCase();
	      var propConfig = Properties[propName];
	
	      var propertyInfo = {
	        attributeName: lowerCased,
	        attributeNamespace: null,
	        propertyName: propName,
	        mutationMethod: null,
	
	        mustUseAttribute: checkMask(propConfig, Injection.MUST_USE_ATTRIBUTE),
	        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
	        hasSideEffects: checkMask(propConfig, Injection.HAS_SIDE_EFFECTS),
	        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
	        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
	        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
	        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
	      };
	
	      !(!propertyInfo.mustUseAttribute || !propertyInfo.mustUseProperty) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Cannot require using both attribute and property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.mustUseProperty || !propertyInfo.hasSideEffects) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Properties that have side effects must use property: %s', propName) : invariant(false) : undefined;
	      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'DOMProperty: Value can be one of boolean, overloaded boolean, or ' + 'numeric value, but not a combination: %s', propName) : invariant(false) : undefined;
	
	      if (process.env.NODE_ENV !== 'production') {
	        DOMProperty.getPossibleStandardName[lowerCased] = propName;
	      }
	
	      if (DOMAttributeNames.hasOwnProperty(propName)) {
	        var attributeName = DOMAttributeNames[propName];
	        propertyInfo.attributeName = attributeName;
	        if (process.env.NODE_ENV !== 'production') {
	          DOMProperty.getPossibleStandardName[attributeName] = propName;
	        }
	      }
	
	      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
	        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
	      }
	
	      if (DOMPropertyNames.hasOwnProperty(propName)) {
	        propertyInfo.propertyName = DOMPropertyNames[propName];
	      }
	
	      if (DOMMutationMethods.hasOwnProperty(propName)) {
	        propertyInfo.mutationMethod = DOMMutationMethods[propName];
	      }
	
	      DOMProperty.properties[propName] = propertyInfo;
	    }
	  }
	};
	var defaultValueCache = {};
	
	/**
	 * DOMProperty exports lookup objects that can be used like functions:
	 *
	 *   > DOMProperty.isValid['id']
	 *   true
	 *   > DOMProperty.isValid['foobar']
	 *   undefined
	 *
	 * Although this may be confusing, it performs better in general.
	 *
	 * @see http://jsperf.com/key-exists
	 * @see http://jsperf.com/key-missing
	 */
	var DOMProperty = {
	
	  ID_ATTRIBUTE_NAME: 'data-reactid',
	
	  /**
	   * Map from property "standard name" to an object with info about how to set
	   * the property in the DOM. Each object contains:
	   *
	   * attributeName:
	   *   Used when rendering markup or with `*Attribute()`.
	   * attributeNamespace
	   * propertyName:
	   *   Used on DOM node instances. (This includes properties that mutate due to
	   *   external factors.)
	   * mutationMethod:
	   *   If non-null, used instead of the property or `setAttribute()` after
	   *   initial render.
	   * mustUseAttribute:
	   *   Whether the property must be accessed and mutated using `*Attribute()`.
	   *   (This includes anything that fails `<propName> in <element>`.)
	   * mustUseProperty:
	   *   Whether the property must be accessed and mutated as an object property.
	   * hasSideEffects:
	   *   Whether or not setting a value causes side effects such as triggering
	   *   resources to be loaded or text selection changes. If true, we read from
	   *   the DOM before updating to ensure that the value is only set if it has
	   *   changed.
	   * hasBooleanValue:
	   *   Whether the property should be removed when set to a falsey value.
	   * hasNumericValue:
	   *   Whether the property must be numeric or parse as a numeric and should be
	   *   removed when set to a falsey value.
	   * hasPositiveNumericValue:
	   *   Whether the property must be positive numeric or parse as a positive
	   *   numeric and should be removed when set to a falsey value.
	   * hasOverloadedBooleanValue:
	   *   Whether the property can be used as a flag as well as with a value.
	   *   Removed when strictly equal to false; present without a value when
	   *   strictly equal to true; present with a value otherwise.
	   */
	  properties: {},
	
	  /**
	   * Mapping from lowercase property names to the properly cased version, used
	   * to warn in the case of missing properties. Available only in __DEV__.
	   * @type {Object}
	   */
	  getPossibleStandardName: process.env.NODE_ENV !== 'production' ? {} : null,
	
	  /**
	   * All of the isCustomAttribute() functions that have been injected.
	   */
	  _isCustomAttributeFunctions: [],
	
	  /**
	   * Checks whether a property name is a custom attribute.
	   * @method
	   */
	  isCustomAttribute: function isCustomAttribute(attributeName) {
	    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
	      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
	      if (isCustomAttributeFn(attributeName)) {
	        return true;
	      }
	    }
	    return false;
	  },
	
	  /**
	   * Returns the default property value for a DOM property (i.e., not an
	   * attribute). Most default values are '' or false, but not all. Worse yet,
	   * some (in particular, `type`) vary depending on the type of element.
	   *
	   * TODO: Is it better to grab all the possible properties when creating an
	   * element to avoid having to create the same element twice?
	   */
	  getDefaultValueForProperty: function getDefaultValueForProperty(nodeName, prop) {
	    var nodeDefaults = defaultValueCache[nodeName];
	    var testElement;
	    if (!nodeDefaults) {
	      defaultValueCache[nodeName] = nodeDefaults = {};
	    }
	    if (!(prop in nodeDefaults)) {
	      testElement = document.createElement(nodeName);
	      nodeDefaults[prop] = testElement[prop];
	    }
	    return nodeDefaults[prop];
	  },
	
	  injection: DOMPropertyInjection
	};
	
	module.exports = DOMProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule quoteAttributeValueForBrowser
	 */
	
	'use strict';
	
	var escapeTextContentForBrowser = __webpack_require__(28);
	
	/**
	 * Escapes attribute value to prevent scripting attacks.
	 *
	 * @param {*} value Value to escape.
	 * @return {string} An escaped string.
	 */
	function quoteAttributeValueForBrowser(value) {
	  return '"' + escapeTextContentForBrowser(value) + '"';
	}
	
	module.exports = quoteAttributeValueForBrowser;

/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule warning
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format) {
	    for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	      args[_key - 2] = arguments[_key];
	    }
	
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.indexOf('Failed Composite propType: ') === 0) {
	      return; // Ignore CompositeComponent proptype check.
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // --- Welcome to debugging React ---
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentBrowserEnvironment
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactMount = __webpack_require__(35);
	
	/**
	 * Abstracts away all functionality of the reconciler that requires knowledge of
	 * the browser context. TODO: These callers should be refactored to avoid the
	 * need for this injection.
	 */
	var ReactComponentBrowserEnvironment = {
	
	  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,
	
	  replaceNodeWithMarkupByID: ReactDOMIDOperations.dangerouslyReplaceNodeWithMarkupByID,
	
	  /**
	   * If a particular environment requires that some resources be cleaned up,
	   * specify this in the injected Mixin. In the DOM, we would likely want to
	   * purge any cached node ID lookups.
	   *
	   * @private
	   */
	  unmountIDFromEnvironment: function unmountIDFromEnvironment(rootNodeID) {
	    ReactMount.purgeID(rootNodeID);
	  }
	
	};
	
	module.exports = ReactComponentBrowserEnvironment;

/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMIDOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var DOMChildrenOperations = __webpack_require__(14);
	var DOMPropertyOperations = __webpack_require__(29);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Errors for properties that should not be updated with `updatePropertyByID()`.
	 *
	 * @type {object}
	 * @private
	 */
	var INVALID_PROPERTY_ERRORS = {
	  dangerouslySetInnerHTML: '`dangerouslySetInnerHTML` must be set using `updateInnerHTMLByID()`.',
	  style: '`style` must be set using `updateStylesByID()`.'
	};
	
	/**
	 * Operations used to process updates to DOM nodes.
	 */
	var ReactDOMIDOperations = {
	
	  /**
	   * Updates a DOM node with new property values. This should only be used to
	   * update DOM properties in `DOMProperty`.
	   *
	   * @param {string} id ID of the node to update.
	   * @param {string} name A valid property name, see `DOMProperty`.
	   * @param {*} value New value of the property.
	   * @internal
	   */
	  updatePropertyByID: function updatePropertyByID(id, name, value) {
	    var node = ReactMount.getNode(id);
	    !!INVALID_PROPERTY_ERRORS.hasOwnProperty(name) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'updatePropertyByID(...): %s', INVALID_PROPERTY_ERRORS[name]) : invariant(false) : undefined;
	
	    // If we're updating to null or undefined, we should remove the property
	    // from the DOM node instead of inadvertantly setting to a string. This
	    // brings us in line with the same behavior we have on initial render.
	    if (value != null) {
	      DOMPropertyOperations.setValueForProperty(node, name, value);
	    } else {
	      DOMPropertyOperations.deleteValueForProperty(node, name);
	    }
	  },
	
	  /**
	   * Replaces a DOM node that exists in the document with markup.
	   *
	   * @param {string} id ID of child to be replaced.
	   * @param {string} markup Dangerous markup to inject in place of child.
	   * @internal
	   * @see {Danger.dangerouslyReplaceNodeWithMarkup}
	   */
	  dangerouslyReplaceNodeWithMarkupByID: function dangerouslyReplaceNodeWithMarkupByID(id, markup) {
	    var node = ReactMount.getNode(id);
	    DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup(node, markup);
	  },
	
	  /**
	   * Updates a component's children by processing a series of updates.
	   *
	   * @param {array<object>} updates List of update configurations.
	   * @param {array<string>} markup List of markup strings.
	   * @internal
	   */
	  dangerouslyProcessChildrenUpdates: function dangerouslyProcessChildrenUpdates(updates, markup) {
	    for (var i = 0; i < updates.length; i++) {
	      updates[i].parentNode = ReactMount.getNode(updates[i].parentID);
	    }
	    DOMChildrenOperations.processUpdates(updates, markup);
	  }
	};
	
	ReactPerf.measureMethods(ReactDOMIDOperations, 'ReactDOMIDOperations', {
	  dangerouslyReplaceNodeWithMarkupByID: 'dangerouslyReplaceNodeWithMarkupByID',
	  dangerouslyProcessChildrenUpdates: 'dangerouslyProcessChildrenUpdates'
	});
	
	module.exports = ReactDOMIDOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMount
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var containsNode = __webpack_require__(66);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	var setInnerHTML = __webpack_require__(26);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
	var nodeCache = {};
	
	var ELEMENT_NODE_TYPE = 1;
	var DOC_NODE_TYPE = 9;
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	var ownerDocumentContextKey = '__ReactMount_ownerDocument$' + Math.random().toString(36).slice(2);
	
	/** Mapping from reactRootID to React component instance. */
	var instancesByReactRootID = {};
	
	/** Mapping from reactRootID to `container` nodes. */
	var containersByReactRootID = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  /** __DEV__-only mapping from reactRootID to root elements. */
	  var rootElementsByReactRootID = {};
	}
	
	// Used to store breadth-first search state in findComponentRoot.
	var findComponentRootReusableArray = [];
	
	/**
	 * Finds the index of the first character
	 * that's not common between the two given strings.
	 *
	 * @return {number} the index of the character where the strings diverge
	 */
	function firstDifferenceIndex(string1, string2) {
	  var minLen = Math.min(string1.length, string2.length);
	  for (var i = 0; i < minLen; i++) {
	    if (string1.charAt(i) !== string2.charAt(i)) {
	      return i;
	    }
	  }
	  return string1.length === string2.length ? -1 : minLen;
	}
	
	/**
	 * @param {DOMElement|DOMDocument} container DOM element that may contain
	 * a React component
	 * @return {?*} DOM element that may have the reactRoot ID, or null.
	 */
	function getReactRootElementInContainer(container) {
	  if (!container) {
	    return null;
	  }
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    return container.documentElement;
	  } else {
	    return container.firstChild;
	  }
	}
	
	/**
	 * @param {DOMElement} container DOM element that may contain a React component.
	 * @return {?string} A "reactRoot" ID, if a React component is rendered.
	 */
	function getReactRootID(container) {
	  var rootElement = getReactRootElementInContainer(container);
	  return rootElement && ReactMount.getID(rootElement);
	}
	
	/**
	 * Accessing node[ATTR_NAME] or calling getAttribute(ATTR_NAME) on a form
	 * element can return its control whose name or ID equals ATTR_NAME. All
	 * DOM nodes support `getAttributeNode` but this can also get called on
	 * other objects so just return '' if we're given something other than a
	 * DOM node (such as window).
	 *
	 * @param {?DOMElement|DOMWindow|DOMDocument|DOMTextNode} node DOM node.
	 * @return {string} ID of the supplied `domNode`.
	 */
	function getID(node) {
	  var id = internalGetID(node);
	  if (id) {
	    if (nodeCache.hasOwnProperty(id)) {
	      var cached = nodeCache[id];
	      if (cached !== node) {
	        !!isValid(cached, id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Two valid but unequal nodes with the same `%s`: %s', ATTR_NAME, id) : invariant(false) : undefined;
	
	        nodeCache[id] = node;
	      }
	    } else {
	      nodeCache[id] = node;
	    }
	  }
	
	  return id;
	}
	
	function internalGetID(node) {
	  // If node is something like a window, document, or text node, none of
	  // which support attributes or a .getAttribute method, gracefully return
	  // the empty string, as if the attribute were missing.
	  return node && node.getAttribute && node.getAttribute(ATTR_NAME) || '';
	}
	
	/**
	 * Sets the React-specific ID of the given node.
	 *
	 * @param {DOMElement} node The DOM node whose ID will be set.
	 * @param {string} id The value of the ID attribute.
	 */
	function setID(node, id) {
	  var oldID = internalGetID(node);
	  if (oldID !== id) {
	    delete nodeCache[oldID];
	  }
	  node.setAttribute(ATTR_NAME, id);
	  nodeCache[id] = node;
	}
	
	/**
	 * Finds the node with the supplied React-generated DOM ID.
	 *
	 * @param {string} id A React-generated DOM ID.
	 * @return {DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNode(id) {
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * Finds the node with the supplied public React instance.
	 *
	 * @param {*} instance A public React instance.
	 * @return {?DOMElement} DOM node with the suppled `id`.
	 * @internal
	 */
	function getNodeFromInstance(instance) {
	  var id = ReactInstanceMap.get(instance)._rootNodeID;
	  if (ReactEmptyComponentRegistry.isNullComponentID(id)) {
	    return null;
	  }
	  if (!nodeCache.hasOwnProperty(id) || !isValid(nodeCache[id], id)) {
	    nodeCache[id] = ReactMount.findReactNodeByID(id);
	  }
	  return nodeCache[id];
	}
	
	/**
	 * A node is "valid" if it is contained by a currently mounted container.
	 *
	 * This means that the node does not have to be contained by a document in
	 * order to be considered valid.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @param {string} id The expected ID of the node.
	 * @return {boolean} Whether the node is contained by a mounted container.
	 */
	function isValid(node, id) {
	  if (node) {
	    !(internalGetID(node) === id) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactMount: Unexpected modification of `%s`', ATTR_NAME) : invariant(false) : undefined;
	
	    var container = ReactMount.findReactContainerForID(id);
	    if (container && containsNode(container, node)) {
	      return true;
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Causes the cache to forget about one React-specific ID.
	 *
	 * @param {string} id The ID to forget.
	 */
	function purgeID(id) {
	  delete nodeCache[id];
	}
	
	var deepestNodeSoFar = null;
	function findDeepestCachedAncestorImpl(ancestorID) {
	  var ancestor = nodeCache[ancestorID];
	  if (ancestor && isValid(ancestor, ancestorID)) {
	    deepestNodeSoFar = ancestor;
	  } else {
	    // This node isn't populated in the cache, so presumably none of its
	    // descendants are. Break out of the loop.
	    return false;
	  }
	}
	
	/**
	 * Return the deepest cached node whose ID is a prefix of `targetID`.
	 */
	function findDeepestCachedAncestor(targetID) {
	  deepestNodeSoFar = null;
	  ReactInstanceHandles.traverseAncestors(targetID, findDeepestCachedAncestorImpl);
	
	  var foundNode = deepestNodeSoFar;
	  deepestNodeSoFar = null;
	  return foundNode;
	}
	
	/**
	 * Mounts this component and inserts it into the DOM.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {ReactReconcileTransaction} transaction
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function mountComponentIntoNode(componentInstance, rootID, container, transaction, shouldReuseMarkup, context) {
	  if (ReactDOMFeatureFlags.useCreateElement) {
	    context = assign({}, context);
	    if (container.nodeType === DOC_NODE_TYPE) {
	      context[ownerDocumentContextKey] = container;
	    } else {
	      context[ownerDocumentContextKey] = container.ownerDocument;
	    }
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    if (context === emptyObject) {
	      context = {};
	    }
	    var tag = container.nodeName.toLowerCase();
	    context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(null, tag, null);
	  }
	  var markup = ReactReconciler.mountComponent(componentInstance, rootID, transaction, context);
	  componentInstance._renderedComponent._topLevelWrapper = componentInstance;
	  ReactMount._mountImageIntoNode(markup, container, shouldReuseMarkup, transaction);
	}
	
	/**
	 * Batched mount.
	 *
	 * @param {ReactComponent} componentInstance The instance to mount.
	 * @param {string} rootID DOM ID of the root node.
	 * @param {DOMElement} container DOM element to mount into.
	 * @param {boolean} shouldReuseMarkup If true, do not insert markup
	 */
	function batchedMountComponentIntoNode(componentInstance, rootID, container, shouldReuseMarkup, context) {
	  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
	  /* forceHTML */shouldReuseMarkup);
	  transaction.perform(mountComponentIntoNode, null, componentInstance, rootID, container, transaction, shouldReuseMarkup, context);
	  ReactUpdates.ReactReconcileTransaction.release(transaction);
	}
	
	/**
	 * Unmounts a component and removes it from the DOM.
	 *
	 * @param {ReactComponent} instance React component instance.
	 * @param {DOMElement} container DOM element to unmount from.
	 * @final
	 * @internal
	 * @see {ReactMount.unmountComponentAtNode}
	 */
	function unmountComponentFromNode(instance, container) {
	  ReactReconciler.unmountComponent(instance);
	
	  if (container.nodeType === DOC_NODE_TYPE) {
	    container = container.documentElement;
	  }
	
	  // http://jsperf.com/emptying-a-node
	  while (container.lastChild) {
	    container.removeChild(container.lastChild);
	  }
	}
	
	/**
	 * True if the supplied DOM node has a direct React-rendered child that is
	 * not a React root element. Useful for warning in `render`,
	 * `unmountComponentAtNode`, etc.
	 *
	 * @param {?DOMElement} node The candidate DOM node.
	 * @return {boolean} True if the DOM element contains a direct child that was
	 * rendered by React but is not a root element.
	 * @internal
	 */
	function hasNonRootReactChild(node) {
	  var reactRootID = getReactRootID(node);
	  return reactRootID ? reactRootID !== ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID) : false;
	}
	
	/**
	 * Returns the first (deepest) ancestor of a node which is rendered by this copy
	 * of React.
	 */
	function findFirstReactDOMImpl(node) {
	  // This node might be from another React instance, so we make sure not to
	  // examine the node cache here
	  for (; node && node.parentNode !== node; node = node.parentNode) {
	    if (node.nodeType !== 1) {
	      // Not a DOMElement, therefore not a React component
	      continue;
	    }
	    var nodeID = internalGetID(node);
	    if (!nodeID) {
	      continue;
	    }
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	
	    // If containersByReactRootID contains the container we find by crawling up
	    // the tree, we know that this instance of React rendered the node.
	    // nb. isValid's strategy (with containsNode) does not work because render
	    // trees may be nested and we don't want a false positive in that case.
	    var current = node;
	    var lastID;
	    do {
	      lastID = internalGetID(current);
	      current = current.parentNode;
	      if (current == null) {
	        // The passed-in node has been detached from the container it was
	        // originally rendered into.
	        return null;
	      }
	    } while (lastID !== reactRootID);
	
	    if (current === containersByReactRootID[reactRootID]) {
	      return node;
	    }
	  }
	  return null;
	}
	
	/**
	 * Temporary (?) hack so that we can store all top-level pending updates on
	 * composites instead of having to worry about different types of components
	 * here.
	 */
	var TopLevelWrapper = function TopLevelWrapper() {};
	TopLevelWrapper.prototype.isReactComponent = {};
	if (process.env.NODE_ENV !== 'production') {
	  TopLevelWrapper.displayName = 'TopLevelWrapper';
	}
	TopLevelWrapper.prototype.render = function () {
	  // this.props is actually a ReactElement
	  return this.props;
	};
	
	/**
	 * Mounting is the process of initializing a React component by creating its
	 * representative DOM elements and inserting them into a supplied `container`.
	 * Any prior content inside `container` is destroyed in the process.
	 *
	 *   ReactMount.render(
	 *     component,
	 *     document.getElementById('container')
	 *   );
	 *
	 *   <div id="container">                   <-- Supplied `container`.
	 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
	 *       // ...                                 component.
	 *     </div>
	 *   </div>
	 *
	 * Inside of `container`, the first element rendered is the "reactRoot".
	 */
	var ReactMount = {
	
	  TopLevelWrapper: TopLevelWrapper,
	
	  /** Exposed for debugging purposes **/
	  _instancesByReactRootID: instancesByReactRootID,
	
	  /**
	   * This is a hook provided to support rendering React components while
	   * ensuring that the apparent scroll position of its `container` does not
	   * change.
	   *
	   * @param {DOMElement} container The `container` being rendered into.
	   * @param {function} renderCallback This must be called once to do the render.
	   */
	  scrollMonitor: function scrollMonitor(container, renderCallback) {
	    renderCallback();
	  },
	
	  /**
	   * Take a component that's already mounted into the DOM and replace its props
	   * @param {ReactComponent} prevComponent component instance already in the DOM
	   * @param {ReactElement} nextElement component instance to render
	   * @param {DOMElement} container container to render into
	   * @param {?function} callback function triggered on completion
	   */
	  _updateRootComponent: function _updateRootComponent(prevComponent, nextElement, container, callback) {
	    ReactMount.scrollMonitor(container, function () {
	      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement);
	      if (callback) {
	        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
	      }
	    });
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[getReactRootID(container)] = getReactRootElementInContainer(container);
	    }
	
	    return prevComponent;
	  },
	
	  /**
	   * Register a component into the instance map and starts scroll value
	   * monitoring
	   * @param {ReactComponent} nextComponent component instance to render
	   * @param {DOMElement} container container to render into
	   * @return {string} reactRoot ID prefix
	   */
	  _registerComponent: function _registerComponent(nextComponent, container) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '_registerComponent(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
	
	    var reactRootID = ReactMount.registerContainer(container);
	    instancesByReactRootID[reactRootID] = nextComponent;
	    return reactRootID;
	  },
	
	  /**
	   * Render a new component into the DOM.
	   * @param {ReactElement} nextElement element to render
	   * @param {DOMElement} container container to render into
	   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
	   * @return {ReactComponent} nextComponent
	   */
	  _renderNewRootComponent: function _renderNewRootComponent(nextElement, container, shouldReuseMarkup, context) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case.
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '_renderNewRootComponent(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from ' + 'render is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    var componentInstance = instantiateReactComponent(nextElement, null);
	    var reactRootID = ReactMount._registerComponent(componentInstance, container);
	
	    // The initial render is synchronous but any updates that happen during
	    // rendering, in componentWillMount or componentDidMount, will be batched
	    // according to the current batching strategy.
	
	    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, reactRootID, container, shouldReuseMarkup, context);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Record the root element in case it later gets transplanted.
	      rootElementsByReactRootID[reactRootID] = getReactRootElementInContainer(container);
	    }
	
	    return componentInstance;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  renderSubtreeIntoContainer: function renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !(parentComponent != null && parentComponent._reactInternalInstance != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'parentComponent must be a valid React Component') : invariant(false) : undefined;
	    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
	  },
	
	  _renderSubtreeIntoContainer: function _renderSubtreeIntoContainer(parentComponent, nextElement, container, callback) {
	    !ReactElement.isValidElement(nextElement) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOM.render(): Invalid component element.%s', typeof nextElement === 'string' ? ' Instead of passing an element string, make sure to instantiate ' + 'it by passing it to React.createElement.' : typeof nextElement === 'function' ? ' Instead of passing a component class, make sure to instantiate ' + 'it by passing it to React.createElement.' :
	    // Check if it quacks like an element
	    nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : invariant(false) : undefined;
	
	    process.env.NODE_ENV !== 'production' ? warning(!container || !container.tagName || container.tagName.toUpperCase() !== 'BODY', 'render(): Rendering components directly into document.body is ' + 'discouraged, since its children are often manipulated by third-party ' + 'scripts and browser extensions. This may lead to subtle ' + 'reconciliation issues. Try rendering into a container element created ' + 'for your app.') : undefined;
	
	    var nextWrappedElement = new ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement);
	
	    var prevComponent = instancesByReactRootID[getReactRootID(container)];
	
	    if (prevComponent) {
	      var prevWrappedElement = prevComponent._currentElement;
	      var prevElement = prevWrappedElement.props;
	      if (shouldUpdateReactComponent(prevElement, nextElement)) {
	        var publicInst = prevComponent._renderedComponent.getPublicInstance();
	        var updatedCallback = callback && function () {
	          callback.call(publicInst);
	        };
	        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback);
	        return publicInst;
	      } else {
	        ReactMount.unmountComponentAtNode(container);
	      }
	    }
	
	    var reactRootElement = getReactRootElementInContainer(container);
	    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
	    var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'render(...): Replacing React-rendered children with a new root ' + 'component. If you intended to update the children of this node, ' + 'you should instead have the existing children update their state ' + 'and render the new components instead of calling ReactDOM.render.') : undefined;
	
	      if (!containerHasReactMarkup || reactRootElement.nextSibling) {
	        var rootElementSibling = reactRootElement;
	        while (rootElementSibling) {
	          if (internalGetID(rootElementSibling)) {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'render(): Target node has markup rendered by React, but there ' + 'are unrelated nodes as well. This is most commonly caused by ' + 'white-space inserted around server-rendered markup.') : undefined;
	            break;
	          }
	          rootElementSibling = rootElementSibling.nextSibling;
	        }
	      }
	    }
	
	    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
	    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance();
	    if (callback) {
	      callback.call(component);
	    }
	    return component;
	  },
	
	  /**
	   * Renders a React component into the DOM in the supplied `container`.
	   *
	   * If the React component was previously rendered into `container`, this will
	   * perform an update on it and only mutate the DOM as necessary to reflect the
	   * latest React component.
	   *
	   * @param {ReactElement} nextElement Component element to render.
	   * @param {DOMElement} container DOM element to render into.
	   * @param {?function} callback function triggered on completion
	   * @return {ReactComponent} Component instance rendered in `container`.
	   */
	  render: function render(nextElement, container, callback) {
	    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
	  },
	
	  /**
	   * Registers a container node into which React components will be rendered.
	   * This also creates the "reactRoot" ID that will be assigned to the element
	   * rendered within.
	   *
	   * @param {DOMElement} container DOM element to register as a container.
	   * @return {string} The "reactRoot" ID of elements rendered within.
	   */
	  registerContainer: function registerContainer(container) {
	    var reactRootID = getReactRootID(container);
	    if (reactRootID) {
	      // If one exists, make sure it is a valid "reactRoot" ID.
	      reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID);
	    }
	    if (!reactRootID) {
	      // No valid "reactRoot" ID found, create one.
	      reactRootID = ReactInstanceHandles.createReactRootID();
	    }
	    containersByReactRootID[reactRootID] = container;
	    return reactRootID;
	  },
	
	  /**
	   * Unmounts and destroys the React component rendered in the `container`.
	   *
	   * @param {DOMElement} container DOM element containing a React component.
	   * @return {boolean} True if a component was found in and unmounted from
	   *                   `container`
	   */
	  unmountComponentAtNode: function unmountComponentAtNode(container) {
	    // Various parts of our code (such as ReactCompositeComponent's
	    // _renderValidatedComponent) assume that calls to render aren't nested;
	    // verify that that's the case. (Strictly speaking, unmounting won't cause a
	    // render but we still don't expect to be in a render call here.)
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, 'unmountComponentAtNode(): Render methods should be a pure function ' + 'of props and state; triggering nested component updates from render ' + 'is not allowed. If necessary, trigger nested updates in ' + 'componentDidUpdate. Check the render method of %s.', ReactCurrentOwner.current && ReactCurrentOwner.current.getName() || 'ReactCompositeComponent') : undefined;
	
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'unmountComponentAtNode(...): Target container is not a DOM element.') : invariant(false) : undefined;
	
	    var reactRootID = getReactRootID(container);
	    var component = instancesByReactRootID[reactRootID];
	    if (!component) {
	      // Check if the node being unmounted was rendered by React, but isn't a
	      // root node.
	      var containerHasNonRootReactChild = hasNonRootReactChild(container);
	
	      // Check if the container itself is a React root node.
	      var containerID = internalGetID(container);
	      var isContainerReactRoot = containerID && containerID === ReactInstanceHandles.getReactRootIDFromNodeID(containerID);
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(!containerHasNonRootReactChild, 'unmountComponentAtNode(): The node you\'re attempting to unmount ' + 'was rendered by React and is not a top-level container. %s', isContainerReactRoot ? 'You may have accidentally passed in a React root node instead ' + 'of its container.' : 'Instead, have the parent component update its state and ' + 'rerender in order to remove this component.') : undefined;
	      }
	
	      return false;
	    }
	    ReactUpdates.batchedUpdates(unmountComponentFromNode, component, container);
	    delete instancesByReactRootID[reactRootID];
	    delete containersByReactRootID[reactRootID];
	    if (process.env.NODE_ENV !== 'production') {
	      delete rootElementsByReactRootID[reactRootID];
	    }
	    return true;
	  },
	
	  /**
	   * Finds the container DOM element that contains React component to which the
	   * supplied DOM `id` belongs.
	   *
	   * @param {string} id The ID of an element rendered by a React component.
	   * @return {?DOMElement} DOM element that contains the `id`.
	   */
	  findReactContainerForID: function findReactContainerForID(id) {
	    var reactRootID = ReactInstanceHandles.getReactRootIDFromNodeID(id);
	    var container = containersByReactRootID[reactRootID];
	
	    if (process.env.NODE_ENV !== 'production') {
	      var rootElement = rootElementsByReactRootID[reactRootID];
	      if (rootElement && rootElement.parentNode !== container) {
	        process.env.NODE_ENV !== 'production' ? warning(
	        // Call internalGetID here because getID calls isValid which calls
	        // findReactContainerForID (this function).
	        internalGetID(rootElement) === reactRootID, 'ReactMount: Root element ID differed from reactRootID.') : undefined;
	        var containerChild = container.firstChild;
	        if (containerChild && reactRootID === internalGetID(containerChild)) {
	          // If the container has a new child with the same ID as the old
	          // root element, then rootElementsByReactRootID[reactRootID] is
	          // just stale and needs to be updated. The case that deserves a
	          // warning is when the container is empty.
	          rootElementsByReactRootID[reactRootID] = containerChild;
	        } else {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'ReactMount: Root element has been removed from its original ' + 'container. New container: %s', rootElement.parentNode) : undefined;
	        }
	      }
	    }
	
	    return container;
	  },
	
	  /**
	   * Finds an element rendered by React with the supplied ID.
	   *
	   * @param {string} id ID of a DOM node in the React component.
	   * @return {DOMElement} Root DOM node of the React component.
	   */
	  findReactNodeByID: function findReactNodeByID(id) {
	    var reactRoot = ReactMount.findReactContainerForID(id);
	    return ReactMount.findComponentRoot(reactRoot, id);
	  },
	
	  /**
	   * Traverses up the ancestors of the supplied node to find a node that is a
	   * DOM representation of a React component rendered by this copy of React.
	   *
	   * @param {*} node
	   * @return {?DOMEventTarget}
	   * @internal
	   */
	  getFirstReactDOM: function getFirstReactDOM(node) {
	    return findFirstReactDOMImpl(node);
	  },
	
	  /**
	   * Finds a node with the supplied `targetID` inside of the supplied
	   * `ancestorNode`.  Exploits the ID naming scheme to perform the search
	   * quickly.
	   *
	   * @param {DOMEventTarget} ancestorNode Search from this root.
	   * @pararm {string} targetID ID of the DOM representation of the component.
	   * @return {DOMEventTarget} DOM node with the supplied `targetID`.
	   * @internal
	   */
	  findComponentRoot: function findComponentRoot(ancestorNode, targetID) {
	    var firstChildren = findComponentRootReusableArray;
	    var childIndex = 0;
	
	    var deepestAncestor = findDeepestCachedAncestor(targetID) || ancestorNode;
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw on the next line; give an early warning
	      process.env.NODE_ENV !== 'production' ? warning(deepestAncestor != null, 'React can\'t find the root component node for data-reactid value ' + '`%s`. If you\'re seeing this message, it probably means that ' + 'you\'ve loaded two copies of React on the page. At this time, only ' + 'a single copy of React can be loaded at a time.', targetID) : undefined;
	    }
	
	    firstChildren[0] = deepestAncestor.firstChild;
	    firstChildren.length = 1;
	
	    while (childIndex < firstChildren.length) {
	      var child = firstChildren[childIndex++];
	      var targetChild;
	
	      while (child) {
	        var childID = ReactMount.getID(child);
	        if (childID) {
	          // Even if we find the node we're looking for, we finish looping
	          // through its siblings to ensure they're cached so that we don't have
	          // to revisit this node again. Otherwise, we make n^2 calls to getID
	          // when visiting the many children of a single node in order.
	
	          if (targetID === childID) {
	            targetChild = child;
	          } else if (ReactInstanceHandles.isAncestorIDOf(childID, targetID)) {
	            // If we find a child whose ID is an ancestor of the given ID,
	            // then we can be sure that we only want to search the subtree
	            // rooted at this child, so we can throw out the rest of the
	            // search state.
	            firstChildren.length = childIndex = 0;
	            firstChildren.push(child.firstChild);
	          }
	        } else {
	          // If this child had no ID, then there's a chance that it was
	          // injected automatically by the browser, as when a `<table>`
	          // element sprouts an extra `<tbody>` child as a side effect of
	          // `.innerHTML` parsing. Optimistically continue down this
	          // branch, but not before examining the other siblings.
	          firstChildren.push(child.firstChild);
	        }
	
	        child = child.nextSibling;
	      }
	
	      if (targetChild) {
	        // Emptying firstChildren/findComponentRootReusableArray is
	        // not necessary for correctness, but it helps the GC reclaim
	        // any nodes that were left at the end of the search.
	        firstChildren.length = 0;
	
	        return targetChild;
	      }
	    }
	
	    firstChildren.length = 0;
	
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findComponentRoot(..., %s): Unable to find element. This probably ' + 'means the DOM was unexpectedly mutated (e.g., by the browser), ' + 'usually due to forgetting a <tbody> when using tables, nesting tags ' + 'like <form>, <p>, or <a>, or using non-SVG elements in an <svg> ' + 'parent. ' + 'Try inspecting the child nodes of the element with React ID `%s`.', targetID, ReactMount.getID(ancestorNode)) : invariant(false) : undefined;
	  },
	
	  _mountImageIntoNode: function _mountImageIntoNode(markup, container, shouldReuseMarkup, transaction) {
	    !(container && (container.nodeType === ELEMENT_NODE_TYPE || container.nodeType === DOC_NODE_TYPE || container.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mountComponentIntoNode(...): Target container is not valid.') : invariant(false) : undefined;
	
	    if (shouldReuseMarkup) {
	      var rootElement = getReactRootElementInContainer(container);
	      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
	        return;
	      } else {
	        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	
	        var rootMarkup = rootElement.outerHTML;
	        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);
	
	        var normalizedMarkup = markup;
	        if (process.env.NODE_ENV !== 'production') {
	          // because rootMarkup is retrieved from the DOM, various normalizations
	          // will have occurred which will not be present in `markup`. Here,
	          // insert markup into a <div> or <iframe> depending on the container
	          // type to perform the same normalizations before comparing.
	          var normalizer;
	          if (container.nodeType === ELEMENT_NODE_TYPE) {
	            normalizer = document.createElement('div');
	            normalizer.innerHTML = markup;
	            normalizedMarkup = normalizer.innerHTML;
	          } else {
	            normalizer = document.createElement('iframe');
	            document.body.appendChild(normalizer);
	            normalizer.contentDocument.write(markup);
	            normalizedMarkup = normalizer.contentDocument.documentElement.outerHTML;
	            document.body.removeChild(normalizer);
	          }
	        }
	
	        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
	        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);
	
	        !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document using ' + 'server rendering but the checksum was invalid. This usually ' + 'means you rendered a different component type or props on ' + 'the client from the one on the server, or your render() ' + 'methods are impure. React cannot handle this case due to ' + 'cross-browser quirks by rendering at the document root. You ' + 'should look for environment dependent code in your components ' + 'and ensure the props are the same client and server side:\n%s', difference) : invariant(false) : undefined;
	
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(false, 'React attempted to reuse markup in a container but the ' + 'checksum was invalid. This generally means that you are ' + 'using server rendering and the markup generated on the ' + 'server was not what the client was expecting. React injected ' + 'new markup to compensate which works but you have lost many ' + 'of the benefits of server rendering. Instead, figure out ' + 'why the markup being generated is different on the client ' + 'or server:\n%s', difference) : undefined;
	        }
	      }
	    }
	
	    !(container.nodeType !== DOC_NODE_TYPE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'You\'re trying to render a component to the document but ' + 'you didn\'t use server rendering. We can\'t do this ' + 'without using server rendering due to cross-browser quirks. ' + 'See ReactDOMServer.renderToString() for server rendering.') : invariant(false) : undefined;
	
	    if (transaction.useCreateElement) {
	      while (container.lastChild) {
	        container.removeChild(container.lastChild);
	      }
	      container.appendChild(markup);
	    } else {
	      setInnerHTML(container, markup);
	    }
	  },
	
	  ownerDocumentContextKey: ownerDocumentContextKey,
	
	  /**
	   * React ID utilities.
	   */
	
	  getReactRootID: getReactRootID,
	
	  getID: getID,
	
	  setID: setID,
	
	  getNode: getNode,
	
	  getNodeFromInstance: getNodeFromInstance,
	
	  isValid: isValid,
	
	  purgeID: purgeID
	};
	
	ReactPerf.measureMethods(ReactMount, 'ReactMount', {
	  _renderNewRootComponent: '_renderNewRootComponent',
	  _mountImageIntoNode: '_mountImageIntoNode'
	});
	
	module.exports = ReactMount;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserEventEmitter
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPluginRegistry = __webpack_require__(39);
	var ReactEventEmitterMixin = __webpack_require__(44);
	var ReactPerf = __webpack_require__(25);
	var ViewportMetrics = __webpack_require__(45);
	
	var assign = __webpack_require__(46);
	var isEventSupported = __webpack_require__(47);
	
	/**
	 * Summary of `ReactBrowserEventEmitter` event handling:
	 *
	 *  - Top-level delegation is used to trap most native browser events. This
	 *    may only occur in the main thread and is the responsibility of
	 *    ReactEventListener, which is injected and can therefore support pluggable
	 *    event sources. This is the only work that occurs in the main thread.
	 *
	 *  - We normalize and de-duplicate events to account for browser quirks. This
	 *    may be done in the worker thread.
	 *
	 *  - Forward these native events (with the associated top-level type used to
	 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
	 *    to extract any synthetic events.
	 *
	 *  - The `EventPluginHub` will then process each event by annotating them with
	 *    "dispatches", a sequence of listeners and IDs that care about that event.
	 *
	 *  - The `EventPluginHub` then dispatches the events.
	 *
	 * Overview of React and the event system:
	 *
	 * +------------+    .
	 * |    DOM     |    .
	 * +------------+    .
	 *       |           .
	 *       v           .
	 * +------------+    .
	 * | ReactEvent |    .
	 * |  Listener  |    .
	 * +------------+    .                         +-----------+
	 *       |           .               +--------+|SimpleEvent|
	 *       |           .               |         |Plugin     |
	 * +-----|------+    .               v         +-----------+
	 * |     |      |    .    +--------------+                    +------------+
	 * |     +-----------.--->|EventPluginHub|                    |    Event   |
	 * |            |    .    |              |     +-----------+  | Propagators|
	 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
	 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
	 * |            |    .    |              |     +-----------+  |  utilities |
	 * |     +-----------.--->|              |                    +------------+
	 * |     |      |    .    +--------------+
	 * +-----|------+    .                ^        +-----------+
	 *       |           .                |        |Enter/Leave|
	 *       +           .                +-------+|Plugin     |
	 * +-------------+   .                         +-----------+
	 * | application |   .
	 * |-------------|   .
	 * |             |   .
	 * |             |   .
	 * +-------------+   .
	 *                   .
	 *    React Core     .  General Purpose Event Plugin System
	 */
	
	var alreadyListeningTo = {};
	var isMonitoringScrollValue = false;
	var reactTopListenersCounter = 0;
	
	// For events like 'submit' which don't consistently bubble (which we trap at a
	// lower node than `document`), binding at `document` would cause duplicate
	// events so we don't include them here
	var topEventMapping = {
	  topAbort: 'abort',
	  topBlur: 'blur',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topChange: 'change',
	  topClick: 'click',
	  topCompositionEnd: 'compositionend',
	  topCompositionStart: 'compositionstart',
	  topCompositionUpdate: 'compositionupdate',
	  topContextMenu: 'contextmenu',
	  topCopy: 'copy',
	  topCut: 'cut',
	  topDoubleClick: 'dblclick',
	  topDrag: 'drag',
	  topDragEnd: 'dragend',
	  topDragEnter: 'dragenter',
	  topDragExit: 'dragexit',
	  topDragLeave: 'dragleave',
	  topDragOver: 'dragover',
	  topDragStart: 'dragstart',
	  topDrop: 'drop',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topFocus: 'focus',
	  topInput: 'input',
	  topKeyDown: 'keydown',
	  topKeyPress: 'keypress',
	  topKeyUp: 'keyup',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topMouseDown: 'mousedown',
	  topMouseMove: 'mousemove',
	  topMouseOut: 'mouseout',
	  topMouseOver: 'mouseover',
	  topMouseUp: 'mouseup',
	  topPaste: 'paste',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topScroll: 'scroll',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topSelectionChange: 'selectionchange',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTextInput: 'textInput',
	  topTimeUpdate: 'timeupdate',
	  topTouchCancel: 'touchcancel',
	  topTouchEnd: 'touchend',
	  topTouchMove: 'touchmove',
	  topTouchStart: 'touchstart',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting',
	  topWheel: 'wheel'
	};
	
	/**
	 * To ensure no conflicts with other potential React instances on the page
	 */
	var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);
	
	function getListeningForDocument(mountAt) {
	  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
	  // directly.
	  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
	    mountAt[topListenersIDKey] = reactTopListenersCounter++;
	    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
	  }
	  return alreadyListeningTo[mountAt[topListenersIDKey]];
	}
	
	/**
	 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
	 * example:
	 *
	 *   ReactBrowserEventEmitter.putListener('myID', 'onClick', myFunction);
	 *
	 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
	 *
	 * @internal
	 */
	var ReactBrowserEventEmitter = assign({}, ReactEventEmitterMixin, {
	
	  /**
	   * Injectable event backend
	   */
	  ReactEventListener: null,
	
	  injection: {
	    /**
	     * @param {object} ReactEventListener
	     */
	    injectReactEventListener: function injectReactEventListener(ReactEventListener) {
	      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
	      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
	    }
	  },
	
	  /**
	   * Sets whether or not any created callbacks should be enabled.
	   *
	   * @param {boolean} enabled True if callbacks should be enabled.
	   */
	  setEnabled: function setEnabled(enabled) {
	    if (ReactBrowserEventEmitter.ReactEventListener) {
	      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
	    }
	  },
	
	  /**
	   * @return {boolean} True if callbacks are enabled.
	   */
	  isEnabled: function isEnabled() {
	    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
	  },
	
	  /**
	   * We listen for bubbled touch events on the document object.
	   *
	   * Firefox v8.01 (and possibly others) exhibited strange behavior when
	   * mounting `onmousemove` events at some node that was not the document
	   * element. The symptoms were that if your mouse is not moving over something
	   * contained within that mount point (for example on the background) the
	   * top-level listeners for `onmousemove` won't be called. However, if you
	   * register the `mousemove` on the document object, then it will of course
	   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
	   * top-level listeners to the document object only, at least for these
	   * movement types of events and possibly all events.
	   *
	   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
	   *
	   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
	   * they bubble to document.
	   *
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {object} contentDocumentHandle Document which owns the container
	   */
	  listenTo: function listenTo(registrationName, contentDocumentHandle) {
	    var mountAt = contentDocumentHandle;
	    var isListening = getListeningForDocument(mountAt);
	    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];
	
	    var topLevelTypes = EventConstants.topLevelTypes;
	    for (var i = 0; i < dependencies.length; i++) {
	      var dependency = dependencies[i];
	      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
	        if (dependency === topLevelTypes.topWheel) {
	          if (isEventSupported('wheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'wheel', mountAt);
	          } else if (isEventSupported('mousewheel')) {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'mousewheel', mountAt);
	          } else {
	            // Firefox needs to capture a different mouse scroll event.
	            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topWheel, 'DOMMouseScroll', mountAt);
	          }
	        } else if (dependency === topLevelTypes.topScroll) {
	
	          if (isEventSupported('scroll', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topScroll, 'scroll', mountAt);
	          } else {
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topScroll, 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
	          }
	        } else if (dependency === topLevelTypes.topFocus || dependency === topLevelTypes.topBlur) {
	
	          if (isEventSupported('focus', true)) {
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topFocus, 'focus', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelTypes.topBlur, 'blur', mountAt);
	          } else if (isEventSupported('focusin')) {
	            // IE has `focusin` and `focusout` events which bubble.
	            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topFocus, 'focusin', mountAt);
	            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelTypes.topBlur, 'focusout', mountAt);
	          }
	
	          // to make sure blur and focus event listeners are only attached once
	          isListening[topLevelTypes.topBlur] = true;
	          isListening[topLevelTypes.topFocus] = true;
	        } else if (topEventMapping.hasOwnProperty(dependency)) {
	          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
	        }
	
	        isListening[dependency] = true;
	      }
	    }
	  },
	
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
	  },
	
	  /**
	   * Listens to window scroll and resize events. We cache scroll values so that
	   * application code can access them without triggering reflows.
	   *
	   * NOTE: Scroll events do not bubble.
	   *
	   * @see http://www.quirksmode.org/dom/events/scroll.html
	   */
	  ensureScrollValueMonitoring: function ensureScrollValueMonitoring() {
	    if (!isMonitoringScrollValue) {
	      var refresh = ViewportMetrics.refreshScrollValues;
	      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
	      isMonitoringScrollValue = true;
	    }
	  },
	
	  eventNameDispatchConfigs: EventPluginHub.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginHub.registrationNameModules,
	
	  putListener: EventPluginHub.putListener,
	
	  getListener: EventPluginHub.getListener,
	
	  deleteListener: EventPluginHub.deleteListener,
	
	  deleteAllListeners: EventPluginHub.deleteAllListeners
	
	});
	
	ReactPerf.measureMethods(ReactBrowserEventEmitter, 'ReactBrowserEventEmitter', {
	  putListener: 'putListener',
	  deleteListener: 'deleteListener'
	});
	
	module.exports = ReactBrowserEventEmitter;

/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventConstants
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var PropagationPhases = keyMirror({ bubbled: null, captured: null });
	
	/**
	 * Types of raw signals from the browser caught at the top level.
	 */
	var topLevelTypes = keyMirror({
	  topAbort: null,
	  topBlur: null,
	  topCanPlay: null,
	  topCanPlayThrough: null,
	  topChange: null,
	  topClick: null,
	  topCompositionEnd: null,
	  topCompositionStart: null,
	  topCompositionUpdate: null,
	  topContextMenu: null,
	  topCopy: null,
	  topCut: null,
	  topDoubleClick: null,
	  topDrag: null,
	  topDragEnd: null,
	  topDragEnter: null,
	  topDragExit: null,
	  topDragLeave: null,
	  topDragOver: null,
	  topDragStart: null,
	  topDrop: null,
	  topDurationChange: null,
	  topEmptied: null,
	  topEncrypted: null,
	  topEnded: null,
	  topError: null,
	  topFocus: null,
	  topInput: null,
	  topKeyDown: null,
	  topKeyPress: null,
	  topKeyUp: null,
	  topLoad: null,
	  topLoadedData: null,
	  topLoadedMetadata: null,
	  topLoadStart: null,
	  topMouseDown: null,
	  topMouseMove: null,
	  topMouseOut: null,
	  topMouseOver: null,
	  topMouseUp: null,
	  topPaste: null,
	  topPause: null,
	  topPlay: null,
	  topPlaying: null,
	  topProgress: null,
	  topRateChange: null,
	  topReset: null,
	  topScroll: null,
	  topSeeked: null,
	  topSeeking: null,
	  topSelectionChange: null,
	  topStalled: null,
	  topSubmit: null,
	  topSuspend: null,
	  topTextInput: null,
	  topTimeUpdate: null,
	  topTouchCancel: null,
	  topTouchEnd: null,
	  topTouchMove: null,
	  topTouchStart: null,
	  topVolumeChange: null,
	  topWaiting: null,
	  topWheel: null
	});
	
	var EventConstants = {
	  topLevelTypes: topLevelTypes,
	  PropagationPhases: PropagationPhases
	};
	
	module.exports = EventConstants;

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginHub
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventPluginRegistry = __webpack_require__(39);
	var EventPluginUtils = __webpack_require__(40);
	var ReactErrorUtils = __webpack_require__(41);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Internal store for event listeners
	 */
	var listenerBank = {};
	
	/**
	 * Internal queue of events that have accumulated their dispatches and are
	 * waiting to have their dispatches executed.
	 */
	var eventQueue = null;
	
	/**
	 * Dispatches an event and releases it back into the pool, unless persistent.
	 *
	 * @param {?object} event Synthetic event to be dispatched.
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @private
	 */
	var executeDispatchesAndRelease = function executeDispatchesAndRelease(event, simulated) {
	  if (event) {
	    EventPluginUtils.executeDispatchesInOrder(event, simulated);
	
	    if (!event.isPersistent()) {
	      event.constructor.release(event);
	    }
	  }
	};
	var executeDispatchesAndReleaseSimulated = function executeDispatchesAndReleaseSimulated(e) {
	  return executeDispatchesAndRelease(e, true);
	};
	var executeDispatchesAndReleaseTopLevel = function executeDispatchesAndReleaseTopLevel(e) {
	  return executeDispatchesAndRelease(e, false);
	};
	
	/**
	 * - `InstanceHandle`: [required] Module that performs logical traversals of DOM
	 *   hierarchy given ids of the logical DOM elements involved.
	 */
	var InstanceHandle = null;
	
	function validateInstanceHandle() {
	  var valid = InstanceHandle && InstanceHandle.traverseTwoPhase && InstanceHandle.traverseEnterLeave;
	  process.env.NODE_ENV !== 'production' ? warning(valid, 'InstanceHandle not injected before use!') : undefined;
	}
	
	/**
	 * This is a unified interface for event plugins to be installed and configured.
	 *
	 * Event plugins can implement the following properties:
	 *
	 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
	 *     Required. When a top-level event is fired, this method is expected to
	 *     extract synthetic events that will in turn be queued and dispatched.
	 *
	 *   `eventTypes` {object}
	 *     Optional, plugins that fire events must publish a mapping of registration
	 *     names that are used to register listeners. Values of this mapping must
	 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
	 *
	 *   `executeDispatch` {function(object, function, string)}
	 *     Optional, allows plugins to override how an event gets dispatched. By
	 *     default, the listener is simply invoked.
	 *
	 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
	 *
	 * @public
	 */
	var EventPluginHub = {
	
	  /**
	   * Methods for injecting dependencies.
	   */
	  injection: {
	
	    /**
	     * @param {object} InjectedMount
	     * @public
	     */
	    injectMount: EventPluginUtils.injection.injectMount,
	
	    /**
	     * @param {object} InjectedInstanceHandle
	     * @public
	     */
	    injectInstanceHandle: function injectInstanceHandle(InjectedInstanceHandle) {
	      InstanceHandle = InjectedInstanceHandle;
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	    },
	
	    getInstanceHandle: function getInstanceHandle() {
	      if (process.env.NODE_ENV !== 'production') {
	        validateInstanceHandle();
	      }
	      return InstanceHandle;
	    },
	
	    /**
	     * @param {array} InjectedEventPluginOrder
	     * @public
	     */
	    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,
	
	    /**
	     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	     */
	    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName
	
	  },
	
	  eventNameDispatchConfigs: EventPluginRegistry.eventNameDispatchConfigs,
	
	  registrationNameModules: EventPluginRegistry.registrationNameModules,
	
	  /**
	   * Stores `listener` at `listenerBank[registrationName][id]`. Is idempotent.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @param {?function} listener The callback to store.
	   */
	  putListener: function putListener(id, registrationName, listener) {
	    !(typeof listener === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected %s listener to be a function, instead got type %s', registrationName, typeof listener === 'undefined' ? 'undefined' : _typeof(listener)) : invariant(false) : undefined;
	
	    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
	    bankForRegistrationName[id] = listener;
	
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.didPutListener) {
	      PluginModule.didPutListener(id, registrationName, listener);
	    }
	  },
	
	  /**
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   * @return {?function} The stored callback.
	   */
	  getListener: function getListener(id, registrationName) {
	    var bankForRegistrationName = listenerBank[registrationName];
	    return bankForRegistrationName && bankForRegistrationName[id];
	  },
	
	  /**
	   * Deletes a listener from the registration bank.
	   *
	   * @param {string} id ID of the DOM element.
	   * @param {string} registrationName Name of listener (e.g. `onClick`).
	   */
	  deleteListener: function deleteListener(id, registrationName) {
	    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	    if (PluginModule && PluginModule.willDeleteListener) {
	      PluginModule.willDeleteListener(id, registrationName);
	    }
	
	    var bankForRegistrationName = listenerBank[registrationName];
	    // TODO: This should never be null -- when is it?
	    if (bankForRegistrationName) {
	      delete bankForRegistrationName[id];
	    }
	  },
	
	  /**
	   * Deletes all listeners for the DOM element with the supplied ID.
	   *
	   * @param {string} id ID of the DOM element.
	   */
	  deleteAllListeners: function deleteAllListeners(id) {
	    for (var registrationName in listenerBank) {
	      if (!listenerBank[registrationName][id]) {
	        continue;
	      }
	
	      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
	      if (PluginModule && PluginModule.willDeleteListener) {
	        PluginModule.willDeleteListener(id, registrationName);
	      }
	
	      delete listenerBank[registrationName][id];
	    }
	  },
	
	  /**
	   * Allows registered plugins an opportunity to extract events from top-level
	   * native browser events.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @internal
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events;
	    var plugins = EventPluginRegistry.plugins;
	    for (var i = 0; i < plugins.length; i++) {
	      // Not every plugin in the ordering may be loaded at runtime.
	      var possiblePlugin = plugins[i];
	      if (possiblePlugin) {
	        var extractedEvents = possiblePlugin.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	        if (extractedEvents) {
	          events = accumulateInto(events, extractedEvents);
	        }
	      }
	    }
	    return events;
	  },
	
	  /**
	   * Enqueues a synthetic event that should be dispatched when
	   * `processEventQueue` is invoked.
	   *
	   * @param {*} events An accumulation of synthetic events.
	   * @internal
	   */
	  enqueueEvents: function enqueueEvents(events) {
	    if (events) {
	      eventQueue = accumulateInto(eventQueue, events);
	    }
	  },
	
	  /**
	   * Dispatches all synthetic events on the event queue.
	   *
	   * @internal
	   */
	  processEventQueue: function processEventQueue(simulated) {
	    // Set `eventQueue` to null before processing it so that we can tell if more
	    // events get enqueued while processing.
	    var processingEventQueue = eventQueue;
	    eventQueue = null;
	    if (simulated) {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
	    } else {
	      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
	    }
	    !!eventQueue ? process.env.NODE_ENV !== 'production' ? invariant(false, 'processEventQueue(): Additional events were enqueued while processing ' + 'an event queue. Support for this has not yet been implemented.') : invariant(false) : undefined;
	    // This would be a good time to rethrow if any of the event handlers threw.
	    ReactErrorUtils.rethrowCaughtError();
	  },
	
	  /**
	   * These are needed for tests only. Do not use!
	   */
	  __purge: function __purge() {
	    listenerBank = {};
	  },
	
	  __getListenerBank: function __getListenerBank() {
	    return listenerBank;
	  }
	
	};
	
	module.exports = EventPluginHub;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginRegistry
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Injectable ordering of event plugins.
	 */
	var EventPluginOrder = null;
	
	/**
	 * Injectable mapping from names to event plugin modules.
	 */
	var namesToPlugins = {};
	
	/**
	 * Recomputes the plugin list using the injected plugins and plugin ordering.
	 *
	 * @private
	 */
	function recomputePluginOrdering() {
	  if (!EventPluginOrder) {
	    // Wait until an `EventPluginOrder` is injected.
	    return;
	  }
	  for (var pluginName in namesToPlugins) {
	    var PluginModule = namesToPlugins[pluginName];
	    var pluginIndex = EventPluginOrder.indexOf(pluginName);
	    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;
	    if (EventPluginRegistry.plugins[pluginIndex]) {
	      continue;
	    }
	    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;
	    EventPluginRegistry.plugins[pluginIndex] = PluginModule;
	    var publishedEvents = PluginModule.eventTypes;
	    for (var eventName in publishedEvents) {
	      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;
	    }
	  }
	}
	
	/**
	 * Publishes an event so that it can be dispatched by the supplied plugin.
	 *
	 * @param {object} dispatchConfig Dispatch configuration for the event.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @return {boolean} True if the event was successfully published.
	 * @private
	 */
	function publishEventForPlugin(dispatchConfig, PluginModule, eventName) {
	  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;
	  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;
	
	  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
	  if (phasedRegistrationNames) {
	    for (var phaseName in phasedRegistrationNames) {
	      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
	        var phasedRegistrationName = phasedRegistrationNames[phaseName];
	        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);
	      }
	    }
	    return true;
	  } else if (dispatchConfig.registrationName) {
	    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);
	    return true;
	  }
	  return false;
	}
	
	/**
	 * Publishes a registration name that is used to identify dispatched events and
	 * can be used with `EventPluginHub.putListener` to register listeners.
	 *
	 * @param {string} registrationName Registration name to add.
	 * @param {object} PluginModule Plugin publishing the event.
	 * @private
	 */
	function publishRegistrationName(registrationName, PluginModule, eventName) {
	  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;
	  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;
	  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;
	}
	
	/**
	 * Registers plugins so that they can extract and dispatch events.
	 *
	 * @see {EventPluginHub}
	 */
	var EventPluginRegistry = {
	
	  /**
	   * Ordered list of injected plugins.
	   */
	  plugins: [],
	
	  /**
	   * Mapping from event name to dispatch config
	   */
	  eventNameDispatchConfigs: {},
	
	  /**
	   * Mapping from registration name to plugin module
	   */
	  registrationNameModules: {},
	
	  /**
	   * Mapping from registration name to event name
	   */
	  registrationNameDependencies: {},
	
	  /**
	   * Injects an ordering of plugins (by plugin name). This allows the ordering
	   * to be decoupled from injection of the actual plugins so that ordering is
	   * always deterministic regardless of packaging, on-the-fly injection, etc.
	   *
	   * @param {array} InjectedEventPluginOrder
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginOrder}
	   */
	  injectEventPluginOrder: function injectEventPluginOrder(InjectedEventPluginOrder) {
	    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;
	    // Clone the ordering so it cannot be dynamically mutated.
	    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);
	    recomputePluginOrdering();
	  },
	
	  /**
	   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
	   * in the ordering injected by `injectEventPluginOrder`.
	   *
	   * Plugins can be injected as part of page initialization or on-the-fly.
	   *
	   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
	   * @internal
	   * @see {EventPluginHub.injection.injectEventPluginsByName}
	   */
	  injectEventPluginsByName: function injectEventPluginsByName(injectedNamesToPlugins) {
	    var isOrderingDirty = false;
	    for (var pluginName in injectedNamesToPlugins) {
	      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
	        continue;
	      }
	      var PluginModule = injectedNamesToPlugins[pluginName];
	      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {
	        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;
	        namesToPlugins[pluginName] = PluginModule;
	        isOrderingDirty = true;
	      }
	    }
	    if (isOrderingDirty) {
	      recomputePluginOrdering();
	    }
	  },
	
	  /**
	   * Looks up the plugin for the supplied event.
	   *
	   * @param {object} event A synthetic event.
	   * @return {?object} The plugin that created the supplied event.
	   * @internal
	   */
	  getPluginModuleForEvent: function getPluginModuleForEvent(event) {
	    var dispatchConfig = event.dispatchConfig;
	    if (dispatchConfig.registrationName) {
	      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
	    }
	    for (var phase in dispatchConfig.phasedRegistrationNames) {
	      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {
	        continue;
	      }
	      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];
	      if (PluginModule) {
	        return PluginModule;
	      }
	    }
	    return null;
	  },
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _resetEventPlugins: function _resetEventPlugins() {
	    EventPluginOrder = null;
	    for (var pluginName in namesToPlugins) {
	      if (namesToPlugins.hasOwnProperty(pluginName)) {
	        delete namesToPlugins[pluginName];
	      }
	    }
	    EventPluginRegistry.plugins.length = 0;
	
	    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
	    for (var eventName in eventNameDispatchConfigs) {
	      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
	        delete eventNameDispatchConfigs[eventName];
	      }
	    }
	
	    var registrationNameModules = EventPluginRegistry.registrationNameModules;
	    for (var registrationName in registrationNameModules) {
	      if (registrationNameModules.hasOwnProperty(registrationName)) {
	        delete registrationNameModules[registrationName];
	      }
	    }
	  }
	
	};
	
	module.exports = EventPluginRegistry;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPluginUtils
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var ReactErrorUtils = __webpack_require__(41);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Injected dependencies:
	 */
	
	/**
	 * - `Mount`: [required] Module that can convert between React dom IDs and
	 *   actual node references.
	 */
	var injection = {
	  Mount: null,
	  injectMount: function injectMount(InjectedMount) {
	    injection.Mount = InjectedMount;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(InjectedMount && InjectedMount.getNode && InjectedMount.getID, 'EventPluginUtils.injection.injectMount(...): Injected Mount ' + 'module is missing getNode or getID.') : undefined;
	    }
	  }
	};
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	function isEndish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseUp || topLevelType === topLevelTypes.topTouchEnd || topLevelType === topLevelTypes.topTouchCancel;
	}
	
	function isMoveish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseMove || topLevelType === topLevelTypes.topTouchMove;
	}
	function isStartish(topLevelType) {
	  return topLevelType === topLevelTypes.topMouseDown || topLevelType === topLevelTypes.topTouchStart;
	}
	
	var validateEventDispatches;
	if (process.env.NODE_ENV !== 'production') {
	  validateEventDispatches = function validateEventDispatches(event) {
	    var dispatchListeners = event._dispatchListeners;
	    var dispatchIDs = event._dispatchIDs;
	
	    var listenersIsArr = Array.isArray(dispatchListeners);
	    var idsIsArr = Array.isArray(dispatchIDs);
	    var IDsLen = idsIsArr ? dispatchIDs.length : dispatchIDs ? 1 : 0;
	    var listenersLen = listenersIsArr ? dispatchListeners.length : dispatchListeners ? 1 : 0;
	
	    process.env.NODE_ENV !== 'production' ? warning(idsIsArr === listenersIsArr && IDsLen === listenersLen, 'EventPluginUtils: Invalid `event`.') : undefined;
	  };
	}
	
	/**
	 * Dispatch the event to the listener.
	 * @param {SyntheticEvent} event SyntheticEvent to handle
	 * @param {boolean} simulated If the event is simulated (changes exn behavior)
	 * @param {function} listener Application-level callback
	 * @param {string} domID DOM id to pass to the callback.
	 */
	function executeDispatch(event, simulated, listener, domID) {
	  var type = event.type || 'unknown-event';
	  event.currentTarget = injection.Mount.getNode(domID);
	  if (simulated) {
	    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event, domID);
	  } else {
	    ReactErrorUtils.invokeGuardedCallback(type, listener, event, domID);
	  }
	  event.currentTarget = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches.
	 */
	function executeDispatchesInOrder(event, simulated) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      executeDispatch(event, simulated, dispatchListeners[i], dispatchIDs[i]);
	    }
	  } else if (dispatchListeners) {
	    executeDispatch(event, simulated, dispatchListeners, dispatchIDs);
	  }
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	}
	
	/**
	 * Standard/simple iteration through an event's collected dispatches, but stops
	 * at the first dispatch execution returning true, and returns that id.
	 *
	 * @return {?string} id of the first dispatch execution who's listener returns
	 * true, or null if no listener returned true.
	 */
	function executeDispatchesInOrderStopAtTrueImpl(event) {
	  var dispatchListeners = event._dispatchListeners;
	  var dispatchIDs = event._dispatchIDs;
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  if (Array.isArray(dispatchListeners)) {
	    for (var i = 0; i < dispatchListeners.length; i++) {
	      if (event.isPropagationStopped()) {
	        break;
	      }
	      // Listeners and IDs are two parallel arrays that are always in sync.
	      if (dispatchListeners[i](event, dispatchIDs[i])) {
	        return dispatchIDs[i];
	      }
	    }
	  } else if (dispatchListeners) {
	    if (dispatchListeners(event, dispatchIDs)) {
	      return dispatchIDs;
	    }
	  }
	  return null;
	}
	
	/**
	 * @see executeDispatchesInOrderStopAtTrueImpl
	 */
	function executeDispatchesInOrderStopAtTrue(event) {
	  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
	  event._dispatchIDs = null;
	  event._dispatchListeners = null;
	  return ret;
	}
	
	/**
	 * Execution of a "direct" dispatch - there must be at most one dispatch
	 * accumulated on the event or it is considered an error. It doesn't really make
	 * sense for an event with multiple dispatches (bubbled) to keep track of the
	 * return values at each dispatch execution, but it does tend to make sense when
	 * dealing with "direct" dispatches.
	 *
	 * @return {*} The return value of executing the single dispatch.
	 */
	function executeDirectDispatch(event) {
	  if (process.env.NODE_ENV !== 'production') {
	    validateEventDispatches(event);
	  }
	  var dispatchListener = event._dispatchListeners;
	  var dispatchID = event._dispatchIDs;
	  !!Array.isArray(dispatchListener) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'executeDirectDispatch(...): Invalid `event`.') : invariant(false) : undefined;
	  var res = dispatchListener ? dispatchListener(event, dispatchID) : null;
	  event._dispatchListeners = null;
	  event._dispatchIDs = null;
	  return res;
	}
	
	/**
	 * @param {SyntheticEvent} event
	 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
	 */
	function hasDispatches(event) {
	  return !!event._dispatchListeners;
	}
	
	/**
	 * General utilities that are useful in creating custom Event Plugins.
	 */
	var EventPluginUtils = {
	  isEndish: isEndish,
	  isMoveish: isMoveish,
	  isStartish: isStartish,
	
	  executeDirectDispatch: executeDirectDispatch,
	  executeDispatchesInOrder: executeDispatchesInOrder,
	  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
	  hasDispatches: hasDispatches,
	
	  getNode: function getNode(id) {
	    return injection.Mount.getNode(id);
	  },
	  getID: function getID(node) {
	    return injection.Mount.getID(node);
	  },
	
	  injection: injection
	};
	
	module.exports = EventPluginUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactErrorUtils
	 * @typechecks
	 */
	
	'use strict';
	
	var caughtError = null;
	
	/**
	 * Call a function while guarding against errors that happens within it.
	 *
	 * @param {?String} name of the guard to use for logging or debugging
	 * @param {Function} func The function to invoke
	 * @param {*} a First argument
	 * @param {*} b Second argument
	 */
	function invokeGuardedCallback(name, func, a, b) {
	  try {
	    return func(a, b);
	  } catch (x) {
	    if (caughtError === null) {
	      caughtError = x;
	    }
	    return undefined;
	  }
	}
	
	var ReactErrorUtils = {
	  invokeGuardedCallback: invokeGuardedCallback,
	
	  /**
	   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
	   * handler are sure to be rethrown by rethrowCaughtError.
	   */
	  invokeGuardedCallbackWithCatch: invokeGuardedCallback,
	
	  /**
	   * During execution of guarded functions we will capture the first error which
	   * we will rethrow to be handled by the top level error handler.
	   */
	  rethrowCaughtError: function rethrowCaughtError() {
	    if (caughtError) {
	      var error = caughtError;
	      caughtError = null;
	      throw error;
	    }
	  }
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  /**
	   * To help development we can get better devtools integration by simulating a
	   * real browser event.
	   */
	  if (typeof window !== 'undefined' && typeof window.dispatchEvent === 'function' && typeof document !== 'undefined' && typeof document.createEvent === 'function') {
	    var fakeNode = document.createElement('react');
	    ReactErrorUtils.invokeGuardedCallback = function (name, func, a, b) {
	      var boundFunc = func.bind(null, a, b);
	      var evtType = 'react-' + name;
	      fakeNode.addEventListener(evtType, boundFunc, false);
	      var evt = document.createEvent('Event');
	      evt.initEvent(evtType, false, false);
	      fakeNode.dispatchEvent(evt);
	      fakeNode.removeEventListener(evtType, boundFunc, false);
	    };
	  }
	}
	
	module.exports = ReactErrorUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule accumulateInto
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 *
	 * Accumulates items that must not be null or undefined into the first one. This
	 * is used to conserve memory by avoiding array allocations, and thus sacrifices
	 * API cleanness. Since `current` can be null before being passed in and not
	 * null after this function, make sure to assign it back to `current`:
	 *
	 * `a = accumulateInto(a, b);`
	 *
	 * This API should be sparingly used. Try `accumulate` for something cleaner.
	 *
	 * @return {*|array<*>} An accumulation of items.
	 */
	
	function accumulateInto(current, next) {
	  !(next != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'accumulateInto(...): Accumulated items must not be null or undefined.') : invariant(false) : undefined;
	  if (current == null) {
	    return next;
	  }
	
	  // Both are not empty. Warning: Never call x.concat(y) when you are not
	  // certain that x is an Array (x could be a string with concat method).
	  var currentIsArray = Array.isArray(current);
	  var nextIsArray = Array.isArray(next);
	
	  if (currentIsArray && nextIsArray) {
	    current.push.apply(current, next);
	    return current;
	  }
	
	  if (currentIsArray) {
	    current.push(next);
	    return current;
	  }
	
	  if (nextIsArray) {
	    // A bit too dangerous to mutate `next`.
	    return [current].concat(next);
	  }
	
	  return [current, next];
	}
	
	module.exports = accumulateInto;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 43 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule forEachAccumulated
	 */
	
	'use strict';
	
	/**
	 * @param {array} arr an "accumulation" of items which is either an Array or
	 * a single item. Useful when paired with the `accumulate` module. This is a
	 * simple utility that allows us to reason about a collection of items, but
	 * handling the case when there is exactly one item (and we do not need to
	 * allocate an array).
	 */
	
	var forEachAccumulated = function forEachAccumulated(arr, cb, scope) {
	  if (Array.isArray(arr)) {
	    arr.forEach(cb, scope);
	  } else if (arr) {
	    cb.call(scope, arr);
	  }
	};
	
	module.exports = forEachAccumulated;

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventEmitterMixin
	 */
	
	'use strict';
	
	var EventPluginHub = __webpack_require__(38);
	
	function runEventQueueInBatch(events) {
	  EventPluginHub.enqueueEvents(events);
	  EventPluginHub.processEventQueue(false);
	}
	
	var ReactEventEmitterMixin = {
	
	  /**
	   * Streams a fired top-level event to `EventPluginHub` where plugins have the
	   * opportunity to create `ReactEvent`s to be dispatched.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {object} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native environment event.
	   */
	  handleTopLevel: function handleTopLevel(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var events = EventPluginHub.extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget);
	    runEventQueueInBatch(events);
	  }
	};
	
	module.exports = ReactEventEmitterMixin;

/***/ },
/* 45 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ViewportMetrics
	 */
	
	'use strict';
	
	var ViewportMetrics = {
	
	  currentScrollLeft: 0,
	
	  currentScrollTop: 0,
	
	  refreshScrollValues: function refreshScrollValues(scrollPosition) {
	    ViewportMetrics.currentScrollLeft = scrollPosition.x;
	    ViewportMetrics.currentScrollTop = scrollPosition.y;
	  }
	
	};
	
	module.exports = ViewportMetrics;

/***/ },
/* 46 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Object.assign
	 */
	
	// https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.assign
	
	'use strict';
	
	function assign(target, sources) {
	  if (target == null) {
	    throw new TypeError('Object.assign target cannot be null or undefined');
	  }
	
	  var to = Object(target);
	  var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	  for (var nextIndex = 1; nextIndex < arguments.length; nextIndex++) {
	    var nextSource = arguments[nextIndex];
	    if (nextSource == null) {
	      continue;
	    }
	
	    var from = Object(nextSource);
	
	    // We don't currently support accessors nor proxies. Therefore this
	    // copy cannot throw. If we ever supported this then we must handle
	    // exceptions and side-effects. We don't support symbols so they won't
	    // be transferred.
	
	    for (var key in from) {
	      if (hasOwnProperty.call(from, key)) {
	        to[key] = from[key];
	      }
	    }
	  }
	
	  return to;
	}
	
	module.exports = assign;

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isEventSupported
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var useHasFeature;
	if (ExecutionEnvironment.canUseDOM) {
	  useHasFeature = document.implementation && document.implementation.hasFeature &&
	  // always returns true in newer browsers as per the standard.
	  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
	  document.implementation.hasFeature('', '') !== true;
	}
	
	/**
	 * Checks if an event is supported in the current execution environment.
	 *
	 * NOTE: This will not work correctly for non-generic events such as `change`,
	 * `reset`, `load`, `error`, and `select`.
	 *
	 * Borrows from Modernizr.
	 *
	 * @param {string} eventNameSuffix Event name, e.g. "click".
	 * @param {?boolean} capture Check if the capture phase is supported.
	 * @return {boolean} True if the event is supported.
	 * @internal
	 * @license Modernizr 3.0.0pre (Custom Build) | MIT
	 */
	function isEventSupported(eventNameSuffix, capture) {
	  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
	    return false;
	  }
	
	  var eventName = 'on' + eventNameSuffix;
	  var isSupported = eventName in document;
	
	  if (!isSupported) {
	    var element = document.createElement('div');
	    element.setAttribute(eventName, 'return;');
	    isSupported = typeof element[eventName] === 'function';
	  }
	
	  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
	    // This is the only way to test support for the `wheel` event in IE9+.
	    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
	  }
	
	  return isSupported;
	}
	
	module.exports = isEventSupported;

/***/ },
/* 48 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFeatureFlags
	 */
	
	'use strict';
	
	var ReactDOMFeatureFlags = {
	  useCreateElement: false
	};
	
	module.exports = ReactDOMFeatureFlags;

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElement
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	
	// The Symbol used to tag the ReactElement type. If there is no native Symbol
	// nor polyfill, then a plain number is used for performance.
	var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;
	
	var RESERVED_PROPS = {
	  key: true,
	  ref: true,
	  __self: true,
	  __source: true
	};
	
	/**
	 * Base constructor for all React elements. This is only used to make this
	 * work with a dynamic instanceof check. Nothing should live on this prototype.
	 *
	 * @param {*} type
	 * @param {*} key
	 * @param {string|object} ref
	 * @param {*} self A *temporary* helper to detect places where `this` is
	 * different from the `owner` when React.createElement is called, so that we
	 * can warn. We want to get rid of owner and replace string `ref`s with arrow
	 * functions, and as long as `this` and owner are the same, there will be no
	 * change in behavior.
	 * @param {*} source An annotation object (added by a transpiler or otherwise)
	 * indicating filename, line number, and/or other information.
	 * @param {*} owner
	 * @param {*} props
	 * @internal
	 */
	var ReactElement = function ReactElement(type, key, ref, self, source, owner, props) {
	  var element = {
	    // This tag allow us to uniquely identify this as a React Element
	    $$typeof: REACT_ELEMENT_TYPE,
	
	    // Built-in properties that belong on the element
	    type: type,
	    key: key,
	    ref: ref,
	    props: props,
	
	    // Record the component responsible for creating this element.
	    _owner: owner
	  };
	
	  if (process.env.NODE_ENV !== 'production') {
	    // The validation flag is currently mutative. We put it on
	    // an external backing store so that we can freeze the whole object.
	    // This can be replaced with a WeakMap once they are implemented in
	    // commonly used development environments.
	    element._store = {};
	
	    // To make comparing ReactElements easier for testing purposes, we make
	    // the validation flag non-enumerable (where possible, which should
	    // include every environment we run tests in), so the test framework
	    // ignores it.
	    if (canDefineProperty) {
	      Object.defineProperty(element._store, 'validated', {
	        configurable: false,
	        enumerable: false,
	        writable: true,
	        value: false
	      });
	      // self and source are DEV only properties.
	      Object.defineProperty(element, '_self', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: self
	      });
	      // Two elements created in two different places should be considered
	      // equal for testing purposes and therefore we hide it from enumeration.
	      Object.defineProperty(element, '_source', {
	        configurable: false,
	        enumerable: false,
	        writable: false,
	        value: source
	      });
	    } else {
	      element._store.validated = false;
	      element._self = self;
	      element._source = source;
	    }
	    Object.freeze(element.props);
	    Object.freeze(element);
	  }
	
	  return element;
	};
	
	ReactElement.createElement = function (type, config, children) {
	  var propName;
	
	  // Reserved names are extracted
	  var props = {};
	
	  var key = null;
	  var ref = null;
	  var self = null;
	  var source = null;
	
	  if (config != null) {
	    ref = config.ref === undefined ? null : config.ref;
	    key = config.key === undefined ? null : '' + config.key;
	    self = config.__self === undefined ? null : config.__self;
	    source = config.__source === undefined ? null : config.__source;
	    // Remaining properties are added to a new props object
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  // Resolve default props
	  if (type && type.defaultProps) {
	    var defaultProps = type.defaultProps;
	    for (propName in defaultProps) {
	      if (typeof props[propName] === 'undefined') {
	        props[propName] = defaultProps[propName];
	      }
	    }
	  }
	
	  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
	};
	
	ReactElement.createFactory = function (type) {
	  var factory = ReactElement.createElement.bind(null, type);
	  // Expose the type on the factory and the prototype so that it can be
	  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
	  // This should not be named `constructor` since this may not be the function
	  // that created the element, and it may not even be a constructor.
	  // Legacy hook TODO: Warn if this is accessed
	  factory.type = type;
	  return factory;
	};
	
	ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
	  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
	
	  return newElement;
	};
	
	ReactElement.cloneAndReplaceProps = function (oldElement, newProps) {
	  var newElement = ReactElement(oldElement.type, oldElement.key, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, newProps);
	
	  if (process.env.NODE_ENV !== 'production') {
	    // If the key on the original is valid, then the clone is valid
	    newElement._store.validated = oldElement._store.validated;
	  }
	
	  return newElement;
	};
	
	ReactElement.cloneElement = function (element, config, children) {
	  var propName;
	
	  // Original props are copied
	  var props = assign({}, element.props);
	
	  // Reserved names are extracted
	  var key = element.key;
	  var ref = element.ref;
	  // Self is preserved since the owner is preserved.
	  var self = element._self;
	  // Source is preserved since cloneElement is unlikely to be targeted by a
	  // transpiler, and the original source is probably a better indicator of the
	  // true owner.
	  var source = element._source;
	
	  // Owner will be preserved, unless ref is overridden
	  var owner = element._owner;
	
	  if (config != null) {
	    if (config.ref !== undefined) {
	      // Silently steal the ref from the parent.
	      ref = config.ref;
	      owner = ReactCurrentOwner.current;
	    }
	    if (config.key !== undefined) {
	      key = '' + config.key;
	    }
	    // Remaining properties override existing props
	    for (propName in config) {
	      if (config.hasOwnProperty(propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
	        props[propName] = config[propName];
	      }
	    }
	  }
	
	  // Children can be more than one argument, and those are transferred onto
	  // the newly allocated props object.
	  var childrenLength = arguments.length - 2;
	  if (childrenLength === 1) {
	    props.children = children;
	  } else if (childrenLength > 1) {
	    var childArray = Array(childrenLength);
	    for (var i = 0; i < childrenLength; i++) {
	      childArray[i] = arguments[i + 2];
	    }
	    props.children = childArray;
	  }
	
	  return ReactElement(element.type, key, ref, self, source, owner, props);
	};
	
	/**
	 * @param {?object} object
	 * @return {boolean} True if `object` is a valid component.
	 * @final
	 */
	ReactElement.isValidElement = function (object) {
	  return (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
	};
	
	module.exports = ReactElement;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule canDefineProperty
	 */
	
	'use strict';
	
	var canDefineProperty = false;
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    Object.defineProperty({}, 'x', { get: function get() {} });
	    canDefineProperty = true;
	  } catch (x) {
	    // IE will fail on defineProperty
	  }
	}
	
	module.exports = canDefineProperty;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 51 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponentRegistry
	 */
	
	'use strict';
	
	// This registry keeps track of the React IDs of the components that rendered to
	// `null` (in reality a placeholder such as `noscript`)
	
	var nullComponentIDsRegistry = {};
	
	/**
	 * @param {string} id Component's `_rootNodeID`.
	 * @return {boolean} True if the component is rendered to null.
	 */
	function isNullComponentID(id) {
	  return !!nullComponentIDsRegistry[id];
	}
	
	/**
	 * Mark the component as having rendered to null.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function registerNullComponentID(id) {
	  nullComponentIDsRegistry[id] = true;
	}
	
	/**
	 * Unmark the component as having rendered to null: it renders to something now.
	 * @param {string} id Component's `_rootNodeID`.
	 */
	function deregisterNullComponentID(id) {
	  delete nullComponentIDsRegistry[id];
	}
	
	var ReactEmptyComponentRegistry = {
	  isNullComponentID: isNullComponentID,
	  registerNullComponentID: registerNullComponentID,
	  deregisterNullComponentID: deregisterNullComponentID
	};
	
	module.exports = ReactEmptyComponentRegistry;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceHandles
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactRootIndex = __webpack_require__(53);
	
	var invariant = __webpack_require__(20);
	
	var SEPARATOR = '.';
	var SEPARATOR_LENGTH = SEPARATOR.length;
	
	/**
	 * Maximum depth of traversals before we consider the possibility of a bad ID.
	 */
	var MAX_TREE_DEPTH = 10000;
	
	/**
	 * Creates a DOM ID prefix to use when mounting React components.
	 *
	 * @param {number} index A unique integer
	 * @return {string} React root ID.
	 * @internal
	 */
	function getReactRootIDString(index) {
	  return SEPARATOR + index.toString(36);
	}
	
	/**
	 * Checks if a character in the supplied ID is a separator or the end.
	 *
	 * @param {string} id A React DOM ID.
	 * @param {number} index Index of the character to check.
	 * @return {boolean} True if the character is a separator or end of the ID.
	 * @private
	 */
	function isBoundary(id, index) {
	  return id.charAt(index) === SEPARATOR || index === id.length;
	}
	
	/**
	 * Checks if the supplied string is a valid React DOM ID.
	 *
	 * @param {string} id A React DOM ID, maybe.
	 * @return {boolean} True if the string is a valid React DOM ID.
	 * @private
	 */
	function isValidID(id) {
	  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;
	}
	
	/**
	 * Checks if the first ID is an ancestor of or equal to the second ID.
	 *
	 * @param {string} ancestorID
	 * @param {string} descendantID
	 * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.
	 * @internal
	 */
	function isAncestorIDOf(ancestorID, descendantID) {
	  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);
	}
	
	/**
	 * Gets the parent ID of the supplied React DOM ID, `id`.
	 *
	 * @param {string} id ID of a component.
	 * @return {string} ID of the parent, or an empty string.
	 * @private
	 */
	function getParentID(id) {
	  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';
	}
	
	/**
	 * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the
	 * supplied `destinationID`. If they are equal, the ID is returned.
	 *
	 * @param {string} ancestorID ID of an ancestor node of `destinationID`.
	 * @param {string} destinationID ID of the destination node.
	 * @return {string} Next ID on the path from `ancestorID` to `destinationID`.
	 * @private
	 */
	function getNextDescendantID(ancestorID, destinationID) {
	  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;
	  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;
	  if (ancestorID === destinationID) {
	    return ancestorID;
	  }
	  // Skip over the ancestor and the immediate separator. Traverse until we hit
	  // another separator or we reach the end of `destinationID`.
	  var start = ancestorID.length + SEPARATOR_LENGTH;
	  var i;
	  for (i = start; i < destinationID.length; i++) {
	    if (isBoundary(destinationID, i)) {
	      break;
	    }
	  }
	  return destinationID.substr(0, i);
	}
	
	/**
	 * Gets the nearest common ancestor ID of two IDs.
	 *
	 * Using this ID scheme, the nearest common ancestor ID is the longest common
	 * prefix of the two IDs that immediately preceded a "marker" in both strings.
	 *
	 * @param {string} oneID
	 * @param {string} twoID
	 * @return {string} Nearest common ancestor ID, or the empty string if none.
	 * @private
	 */
	function getFirstCommonAncestorID(oneID, twoID) {
	  var minLength = Math.min(oneID.length, twoID.length);
	  if (minLength === 0) {
	    return '';
	  }
	  var lastCommonMarkerIndex = 0;
	  // Use `<=` to traverse until the "EOL" of the shorter string.
	  for (var i = 0; i <= minLength; i++) {
	    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {
	      lastCommonMarkerIndex = i;
	    } else if (oneID.charAt(i) !== twoID.charAt(i)) {
	      break;
	    }
	  }
	  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);
	  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;
	  return longestCommonID;
	}
	
	/**
	 * Traverses the parent path between two IDs (either up or down). The IDs must
	 * not be the same, and there must exist a parent path between them. If the
	 * callback returns `false`, traversal is stopped.
	 *
	 * @param {?string} start ID at which to start traversal.
	 * @param {?string} stop ID at which to end traversal.
	 * @param {function} cb Callback to invoke each ID with.
	 * @param {*} arg Argument to invoke the callback with.
	 * @param {?boolean} skipFirst Whether or not to skip the first node.
	 * @param {?boolean} skipLast Whether or not to skip the last node.
	 * @private
	 */
	function traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {
	  start = start || '';
	  stop = stop || '';
	  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;
	  var traverseUp = isAncestorIDOf(stop, start);
	  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;
	  // Traverse from `start` to `stop` one depth at a time.
	  var depth = 0;
	  var traverse = traverseUp ? getParentID : getNextDescendantID;
	  for (var id = start;; /* until break */id = traverse(id, stop)) {
	    var ret;
	    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {
	      ret = cb(id, traverseUp, arg);
	    }
	    if (ret === false || id === stop) {
	      // Only break //after// visiting `stop`.
	      break;
	    }
	    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Manages the IDs assigned to DOM representations of React components. This
	 * uses a specific scheme in order to traverse the DOM efficiently (e.g. in
	 * order to simulate events).
	 *
	 * @internal
	 */
	var ReactInstanceHandles = {
	
	  /**
	   * Constructs a React root ID
	   * @return {string} A React root ID.
	   */
	  createReactRootID: function createReactRootID() {
	    return getReactRootIDString(ReactRootIndex.createReactRootIndex());
	  },
	
	  /**
	   * Constructs a React ID by joining a root ID with a name.
	   *
	   * @param {string} rootID Root ID of a parent component.
	   * @param {string} name A component's name (as flattened children).
	   * @return {string} A React ID.
	   * @internal
	   */
	  createReactID: function createReactID(rootID, name) {
	    return rootID + name;
	  },
	
	  /**
	   * Gets the DOM ID of the React component that is the root of the tree that
	   * contains the React component with the supplied DOM ID.
	   *
	   * @param {string} id DOM ID of a React component.
	   * @return {?string} DOM ID of the React component that is the root.
	   * @internal
	   */
	  getReactRootIDFromNodeID: function getReactRootIDFromNodeID(id) {
	    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {
	      var index = id.indexOf(SEPARATOR, 1);
	      return index > -1 ? id.substr(0, index) : id;
	    }
	    return null;
	  },
	
	  /**
	   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
	   * should would receive a `mouseEnter` or `mouseLeave` event.
	   *
	   * NOTE: Does not invoke the callback on the nearest common ancestor because
	   * nothing "entered" or "left" that element.
	   *
	   * @param {string} leaveID ID being left.
	   * @param {string} enterID ID being entered.
	   * @param {function} cb Callback to invoke on each entered/left ID.
	   * @param {*} upArg Argument to invoke the callback with on left IDs.
	   * @param {*} downArg Argument to invoke the callback with on entered IDs.
	   * @internal
	   */
	  traverseEnterLeave: function traverseEnterLeave(leaveID, enterID, cb, upArg, downArg) {
	    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);
	    if (ancestorID !== leaveID) {
	      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);
	    }
	    if (ancestorID !== enterID) {
	      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);
	    }
	  },
	
	  /**
	   * Simulates the traversal of a two-phase, capture/bubble event dispatch.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseTwoPhase: function traverseTwoPhase(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, false);
	      traverseParentPath(targetID, '', cb, arg, false, true);
	    }
	  },
	
	  /**
	   * Same as `traverseTwoPhase` but skips the `targetID`.
	   */
	  traverseTwoPhaseSkipTarget: function traverseTwoPhaseSkipTarget(targetID, cb, arg) {
	    if (targetID) {
	      traverseParentPath('', targetID, cb, arg, true, true);
	      traverseParentPath(targetID, '', cb, arg, true, true);
	    }
	  },
	
	  /**
	   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For
	   * example, passing `.0.$row-0.1` would result in `cb` getting called
	   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.
	   *
	   * NOTE: This traversal happens on IDs without touching the DOM.
	   *
	   * @param {string} targetID ID of the target node.
	   * @param {function} cb Callback to invoke.
	   * @param {*} arg Argument to invoke the callback with.
	   * @internal
	   */
	  traverseAncestors: function traverseAncestors(targetID, cb, arg) {
	    traverseParentPath('', targetID, cb, arg, true, false);
	  },
	
	  getFirstCommonAncestorID: getFirstCommonAncestorID,
	
	  /**
	   * Exposed for unit testing.
	   * @private
	   */
	  _getNextDescendantID: getNextDescendantID,
	
	  isAncestorIDOf: isAncestorIDOf,
	
	  SEPARATOR: SEPARATOR
	
	};
	
	module.exports = ReactInstanceHandles;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 53 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactRootIndexInjection = {
	  /**
	   * @param {function} _createReactRootIndex
	   */
	  injectCreateReactRootIndex: function injectCreateReactRootIndex(_createReactRootIndex) {
	    ReactRootIndex.createReactRootIndex = _createReactRootIndex;
	  }
	};
	
	var ReactRootIndex = {
	  createReactRootIndex: null,
	  injection: ReactRootIndexInjection
	};
	
	module.exports = ReactRootIndex;

/***/ },
/* 54 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInstanceMap
	 */
	
	'use strict';
	
	/**
	 * `ReactInstanceMap` maintains a mapping from a public facing stateful
	 * instance (key) and the internal representation (value). This allows public
	 * methods to accept the user facing instance as an argument and map them back
	 * to internal methods.
	 */
	
	// TODO: Replace this with ES6: var ReactInstanceMap = new Map();
	
	var ReactInstanceMap = {
	
	  /**
	   * This API should be called `delete` but we'd have to make sure to always
	   * transform these to strings for IE support. When this transform is fully
	   * supported we can rename it.
	   */
	  remove: function remove(key) {
	    key._reactInternalInstance = undefined;
	  },
	
	  get: function get(key) {
	    return key._reactInternalInstance;
	  },
	
	  has: function has(key) {
	    return key._reactInternalInstance !== undefined;
	  },
	
	  set: function set(key, value) {
	    key._reactInternalInstance = value;
	  }
	
	};
	
	module.exports = ReactInstanceMap;

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMarkupChecksum
	 */
	
	'use strict';
	
	var adler32 = __webpack_require__(56);
	
	var TAG_END = /\/?>/;
	
	var ReactMarkupChecksum = {
	  CHECKSUM_ATTR_NAME: 'data-react-checksum',
	
	  /**
	   * @param {string} markup Markup string
	   * @return {string} Markup string with checksum attribute attached
	   */
	  addChecksumToMarkup: function addChecksumToMarkup(markup) {
	    var checksum = adler32(markup);
	
	    // Add checksum (handle both parent tags and self-closing tags)
	    return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
	  },
	
	  /**
	   * @param {string} markup to use
	   * @param {DOMElement} element root React element
	   * @returns {boolean} whether or not the markup is the same
	   */
	  canReuseMarkup: function canReuseMarkup(markup, element) {
	    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
	    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
	    var markupChecksum = adler32(markup);
	    return markupChecksum === existingChecksum;
	  }
	};
	
	module.exports = ReactMarkupChecksum;

/***/ },
/* 56 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule adler32
	 */
	
	'use strict';
	
	var MOD = 65521;
	
	// adler32 is not cryptographically strong, and is only used to sanity check that
	// markup generated on the server matches the markup generated on the client.
	// This implementation (a modified version of the SheetJS version) has been optimized
	// for our use case, at the expense of conforming to the adler32 specification
	// for non-ascii inputs.
	function adler32(data) {
	  var a = 1;
	  var b = 0;
	  var i = 0;
	  var l = data.length;
	  var m = l & ~0x3;
	  while (i < m) {
	    for (; i < Math.min(i + 4096, m); i += 4) {
	      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
	    }
	    a %= MOD;
	    b %= MOD;
	  }
	  for (; i < l; i++) {
	    b += a += data.charCodeAt(i);
	  }
	  a %= MOD;
	  b %= MOD;
	  return a | b << 16;
	}
	
	module.exports = adler32;

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconciler
	 */
	
	'use strict';
	
	var ReactRef = __webpack_require__(58);
	
	/**
	 * Helper to call ReactRef.attachRefs with this composite component, split out
	 * to avoid allocations in the transaction mount-ready queue.
	 */
	function attachRefs() {
	  ReactRef.attachRefs(this, this._currentElement);
	}
	
	var ReactReconciler = {
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(internalInstance, rootID, transaction, context) {
	    var markup = internalInstance.mountComponent(rootID, transaction, context);
	    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent(internalInstance) {
	    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
	    internalInstance.unmountComponent();
	  },
	
	  /**
	   * Update a component using a new element.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @internal
	   */
	  receiveComponent: function receiveComponent(internalInstance, nextElement, transaction, context) {
	    var prevElement = internalInstance._currentElement;
	
	    if (nextElement === prevElement && context === internalInstance._context) {
	      // Since elements are immutable after the owner is rendered,
	      // we can do a cheap identity compare here to determine if this is a
	      // superfluous reconcile. It's possible for state to be mutable but such
	      // change should trigger an update of the owner which would recreate
	      // the element. We explicitly check for the existence of an owner since
	      // it's possible for an element created outside a composite to be
	      // deeply mutated and reused.
	
	      // TODO: Bailing out early is just a perf optimization right?
	      // TODO: Removing the return statement should affect correctness?
	      return;
	    }
	
	    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);
	
	    if (refsChanged) {
	      ReactRef.detachRefs(internalInstance, prevElement);
	    }
	
	    internalInstance.receiveComponent(nextElement, transaction, context);
	
	    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
	      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
	    }
	  },
	
	  /**
	   * Flush any dirty changes in a component.
	   *
	   * @param {ReactComponent} internalInstance
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(internalInstance, transaction) {
	    internalInstance.performUpdateIfNecessary(transaction);
	  }
	
	};
	
	module.exports = ReactReconciler;

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactRef
	 */
	
	'use strict';
	
	var ReactOwner = __webpack_require__(59);
	
	var ReactRef = {};
	
	function attachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(component.getPublicInstance());
	  } else {
	    // Legacy ref
	    ReactOwner.addComponentAsRefTo(component, ref, owner);
	  }
	}
	
	function detachRef(ref, component, owner) {
	  if (typeof ref === 'function') {
	    ref(null);
	  } else {
	    // Legacy ref
	    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
	  }
	}
	
	ReactRef.attachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    attachRef(ref, instance, element._owner);
	  }
	};
	
	ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
	  // If either the owner or a `ref` has changed, make sure the newest owner
	  // has stored a reference to `this`, and the previous owner (if different)
	  // has forgotten the reference to `this`. We use the element instead
	  // of the public this.props because the post processing cannot determine
	  // a ref. The ref conceptually lives on the element.
	
	  // TODO: Should this even be possible? The owner cannot change because
	  // it's forbidden by shouldUpdateReactComponent. The ref can change
	  // if you swap the keys of but not the refs. Reconsider where this check
	  // is made. It probably belongs where the key checking and
	  // instantiateReactComponent is done.
	
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	
	  return (
	    // This has a few false positives w/r/t empty components.
	    prevEmpty || nextEmpty || nextElement._owner !== prevElement._owner || nextElement.ref !== prevElement.ref
	  );
	};
	
	ReactRef.detachRefs = function (instance, element) {
	  if (element === null || element === false) {
	    return;
	  }
	  var ref = element.ref;
	  if (ref != null) {
	    detachRef(ref, instance, element._owner);
	  }
	};
	
	module.exports = ReactRef;

/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactOwner
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * ReactOwners are capable of storing references to owned components.
	 *
	 * All components are capable of //being// referenced by owner components, but
	 * only ReactOwner components are capable of //referencing// owned components.
	 * The named reference is known as a "ref".
	 *
	 * Refs are available when mounted and updated during reconciliation.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return (
	 *         <div onClick={this.handleClick}>
	 *           <CustomComponent ref="custom" />
	 *         </div>
	 *       );
	 *     },
	 *     handleClick: function() {
	 *       this.refs.custom.handleClick();
	 *     },
	 *     componentDidMount: function() {
	 *       this.refs.custom.initialize();
	 *     }
	 *   });
	 *
	 * Refs should rarely be used. When refs are used, they should only be done to
	 * control data that is not handled by React's data flow.
	 *
	 * @class ReactOwner
	 */
	var ReactOwner = {
	
	  /**
	   * @param {?object} object
	   * @return {boolean} True if `object` is a valid owner.
	   * @final
	   */
	  isValidOwner: function isValidOwner(object) {
	    return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
	  },
	
	  /**
	   * Adds a component by ref to an owner component.
	   *
	   * @param {ReactComponent} component Component to reference.
	   * @param {string} ref Name by which to refer to the component.
	   * @param {ReactOwner} owner Component on which to record the ref.
	   * @final
	   * @internal
	   */
	  addComponentAsRefTo: function addComponentAsRefTo(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'addComponentAsRefTo(...): Only a ReactOwner can have refs. You might ' + 'be adding a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    owner.attachRef(ref, component);
	  },
	
	  /**
	   * Removes a component by ref from an owner component.
	   *
	   * @param {ReactComponent} component Component to dereference.
	   * @param {string} ref Name of the ref to remove.
	   * @param {ReactOwner} owner Component on which the ref is recorded.
	   * @final
	   * @internal
	   */
	  removeComponentAsRefFrom: function removeComponentAsRefFrom(component, ref, owner) {
	    !ReactOwner.isValidOwner(owner) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'removeComponentAsRefFrom(...): Only a ReactOwner can have refs. You might ' + 'be removing a ref to a component that was not created inside a component\'s ' + '`render` method, or you have multiple copies of React loaded ' + '(details: https://fb.me/react-refs-must-have-owner).') : invariant(false) : undefined;
	    // Check that `component` is still the current ref because we do not want to
	    // detach the ref if another component stole it.
	    if (owner.getPublicInstance().refs[ref] === component.getPublicInstance()) {
	      owner.detachRef(ref);
	    }
	  }
	
	};
	
	module.exports = ReactOwner;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdateQueue
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function enqueueUpdate(internalInstance) {
	  ReactUpdates.enqueueUpdate(internalInstance);
	}
	
	function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
	  var internalInstance = ReactInstanceMap.get(publicInstance);
	  if (!internalInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      // Only warn when we have a callerName. Otherwise we should be silent.
	      // We're probably calling from enqueueCallback. We don't want to warn
	      // there because we already warned for the corresponding lifecycle method.
	      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;
	    }
	    return null;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;
	  }
	
	  return internalInstance;
	}
	
	/**
	 * ReactUpdateQueue allows for state updates to be scheduled into a later
	 * reconciliation step.
	 */
	var ReactUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    if (process.env.NODE_ENV !== 'production') {
	      var owner = ReactCurrentOwner.current;
	      if (owner !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	        owner._warnedAboutRefsInRender = true;
	      }
	    }
	    var internalInstance = ReactInstanceMap.get(publicInstance);
	    if (internalInstance) {
	      // During componentWillMount and render this will still be null but after
	      // that will always render to something. At least for now. So we can use
	      // this hack.
	      return !!internalInstance._renderedComponent;
	    } else {
	      return false;
	    }
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);
	
	    // Previously we would throw an error if we didn't have an internal
	    // instance. Since we want to make it a no-op instead, we mirror the same
	    // behavior we have in other enqueue* methods.
	    // We also need to ignore callbacks in componentWillMount. See
	    // enqueueUpdates.
	    if (!internalInstance) {
	      return null;
	    }
	
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    // TODO: The callback here is ignored when setState is called from
	    // componentWillMount. Either fix it or disallow doing so completely in
	    // favor of getInitialState. Alternatively, we can disallow
	    // componentWillMount during server-side rendering.
	    enqueueUpdate(internalInstance);
	  },
	
	  enqueueCallbackInternal: function enqueueCallbackInternal(internalInstance, callback) {
	    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\'t callable.') : invariant(false) : undefined;
	    if (internalInstance._pendingCallbacks) {
	      internalInstance._pendingCallbacks.push(callback);
	    } else {
	      internalInstance._pendingCallbacks = [callback];
	    }
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingForceUpdate = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    internalInstance._pendingStateQueue = [completeState];
	    internalInstance._pendingReplaceState = true;
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');
	
	    if (!internalInstance) {
	      return;
	    }
	
	    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
	    queue.push(partialState);
	
	    enqueueUpdate(internalInstance);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);
	  },
	
	  enqueueSetPropsInternal: function enqueueSetPropsInternal(internalInstance, partialProps) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    var props = assign({}, element.props, partialProps);
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');
	    if (!internalInstance) {
	      return;
	    }
	    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);
	  },
	
	  enqueueReplacePropsInternal: function enqueueReplacePropsInternal(internalInstance, props) {
	    var topLevelWrapper = internalInstance._topLevelWrapper;
	    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;
	
	    // Merge with the pending element if it exists, otherwise with existing
	    // element props.
	    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;
	    var element = wrapElement.props;
	    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));
	
	    enqueueUpdate(topLevelWrapper);
	  },
	
	  enqueueElementInternal: function enqueueElementInternal(internalInstance, newElement) {
	    internalInstance._pendingElement = newElement;
	    enqueueUpdate(internalInstance);
	  }
	
	};
	
	module.exports = ReactUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactUpdates
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactPerf = __webpack_require__(25);
	var ReactReconciler = __webpack_require__(57);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var dirtyComponents = [];
	var asapCallbackQueue = CallbackQueue.getPooled();
	var asapEnqueued = false;
	
	var batchingStrategy = null;
	
	function ensureInjected() {
	  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;
	}
	
	var NESTED_UPDATES = {
	  initialize: function initialize() {
	    this.dirtyComponentsLength = dirtyComponents.length;
	  },
	  close: function close() {
	    if (this.dirtyComponentsLength !== dirtyComponents.length) {
	      // Additional updates were enqueued by componentDidUpdate handlers or
	      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
	      // these new updates so that if A's componentDidUpdate calls setState on
	      // B, B will update before the callback A's updater provided when calling
	      // setState.
	      dirtyComponents.splice(0, this.dirtyComponentsLength);
	      flushBatchedUpdates();
	    } else {
	      dirtyComponents.length = 0;
	    }
	  }
	};
	
	var UPDATE_QUEUEING = {
	  initialize: function initialize() {
	    this.callbackQueue.reset();
	  },
	  close: function close() {
	    this.callbackQueue.notifyAll();
	  }
	};
	
	var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];
	
	function ReactUpdatesFlushTransaction() {
	  this.reinitializeTransaction();
	  this.dirtyComponentsLength = null;
	  this.callbackQueue = CallbackQueue.getPooled();
	  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);
	}
	
	assign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  destructor: function destructor() {
	    this.dirtyComponentsLength = null;
	    CallbackQueue.release(this.callbackQueue);
	    this.callbackQueue = null;
	    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
	    this.reconcileTransaction = null;
	  },
	
	  perform: function perform(method, scope, a) {
	    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
	    // with this transaction's wrappers around it.
	    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
	  }
	});
	
	PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);
	
	function batchedUpdates(callback, a, b, c, d, e) {
	  ensureInjected();
	  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
	}
	
	/**
	 * Array comparator for ReactComponents by mount ordering.
	 *
	 * @param {ReactComponent} c1 first component you're comparing
	 * @param {ReactComponent} c2 second component you're comparing
	 * @return {number} Return value usable by Array.prototype.sort().
	 */
	function mountOrderComparator(c1, c2) {
	  return c1._mountOrder - c2._mountOrder;
	}
	
	function runBatchedUpdates(transaction) {
	  var len = transaction.dirtyComponentsLength;
	  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;
	
	  // Since reconciling a component higher in the owner hierarchy usually (not
	  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
	  // them before their children by sorting the array.
	  dirtyComponents.sort(mountOrderComparator);
	
	  for (var i = 0; i < len; i++) {
	    // If a component is unmounted before pending changes apply, it will still
	    // be here, but we assume that it has cleared its _pendingCallbacks and
	    // that performUpdateIfNecessary is a noop.
	    var component = dirtyComponents[i];
	
	    // If performUpdateIfNecessary happens to enqueue any new updates, we
	    // shouldn't execute the callbacks until the next render happens, so
	    // stash the callbacks first
	    var callbacks = component._pendingCallbacks;
	    component._pendingCallbacks = null;
	
	    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);
	
	    if (callbacks) {
	      for (var j = 0; j < callbacks.length; j++) {
	        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
	      }
	    }
	  }
	}
	
	var flushBatchedUpdates = function flushBatchedUpdates() {
	  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
	  // array and perform any updates enqueued by mount-ready handlers (i.e.,
	  // componentDidUpdate) but we need to check here too in order to catch
	  // updates enqueued by setState callbacks and asap calls.
	  while (dirtyComponents.length || asapEnqueued) {
	    if (dirtyComponents.length) {
	      var transaction = ReactUpdatesFlushTransaction.getPooled();
	      transaction.perform(runBatchedUpdates, null, transaction);
	      ReactUpdatesFlushTransaction.release(transaction);
	    }
	
	    if (asapEnqueued) {
	      asapEnqueued = false;
	      var queue = asapCallbackQueue;
	      asapCallbackQueue = CallbackQueue.getPooled();
	      queue.notifyAll();
	      CallbackQueue.release(queue);
	    }
	  }
	};
	flushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);
	
	/**
	 * Mark a component as needing a rerender, adding an optional callback to a
	 * list of functions which will be executed once the rerender occurs.
	 */
	function enqueueUpdate(component) {
	  ensureInjected();
	
	  // Various parts of our code (such as ReactCompositeComponent's
	  // _renderValidatedComponent) assume that calls to render aren't nested;
	  // verify that that's the case. (This is called by each top-level update
	  // function, like setProps, setState, forceUpdate, etc.; creation and
	  // destruction of top-level components is guarded in ReactMount.)
	
	  if (!batchingStrategy.isBatchingUpdates) {
	    batchingStrategy.batchedUpdates(enqueueUpdate, component);
	    return;
	  }
	
	  dirtyComponents.push(component);
	}
	
	/**
	 * Enqueue a callback to be run at the end of the current batching cycle. Throws
	 * if no updates are currently being performed.
	 */
	function asap(callback, context) {
	  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;
	  asapCallbackQueue.enqueue(callback, context);
	  asapEnqueued = true;
	}
	
	var ReactUpdatesInjection = {
	  injectReconcileTransaction: function injectReconcileTransaction(ReconcileTransaction) {
	    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;
	    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
	  },
	
	  injectBatchingStrategy: function injectBatchingStrategy(_batchingStrategy) {
	    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;
	    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;
	    batchingStrategy = _batchingStrategy;
	  }
	};
	
	var ReactUpdates = {
	  /**
	   * React references `ReactReconcileTransaction` using this property in order
	   * to allow dependency injection.
	   *
	   * @internal
	   */
	  ReactReconcileTransaction: null,
	
	  batchedUpdates: batchedUpdates,
	  enqueueUpdate: enqueueUpdate,
	  flushBatchedUpdates: flushBatchedUpdates,
	  injection: ReactUpdatesInjection,
	  asap: asap
	};
	
	module.exports = ReactUpdates;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CallbackQueue
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	/**
	 * A specialized pseudo-event module to help keep track of components waiting to
	 * be notified when their DOM representations are available for use.
	 *
	 * This implements `PooledClass`, so you should never need to instantiate this.
	 * Instead, use `CallbackQueue.getPooled()`.
	 *
	 * @class ReactMountReady
	 * @implements PooledClass
	 * @internal
	 */
	function CallbackQueue() {
	  this._callbacks = null;
	  this._contexts = null;
	}
	
	assign(CallbackQueue.prototype, {
	
	  /**
	   * Enqueues a callback to be invoked when `notifyAll` is invoked.
	   *
	   * @param {function} callback Invoked when `notifyAll` is invoked.
	   * @param {?object} context Context to call `callback` with.
	   * @internal
	   */
	  enqueue: function enqueue(callback, context) {
	    this._callbacks = this._callbacks || [];
	    this._contexts = this._contexts || [];
	    this._callbacks.push(callback);
	    this._contexts.push(context);
	  },
	
	  /**
	   * Invokes all enqueued callbacks and clears the queue. This is invoked after
	   * the DOM representation of a component has been created or updated.
	   *
	   * @internal
	   */
	  notifyAll: function notifyAll() {
	    var callbacks = this._callbacks;
	    var contexts = this._contexts;
	    if (callbacks) {
	      !(callbacks.length === contexts.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Mismatched list of contexts in callback queue') : invariant(false) : undefined;
	      this._callbacks = null;
	      this._contexts = null;
	      for (var i = 0; i < callbacks.length; i++) {
	        callbacks[i].call(contexts[i]);
	      }
	      callbacks.length = 0;
	      contexts.length = 0;
	    }
	  },
	
	  /**
	   * Resets the internal queue.
	   *
	   * @internal
	   */
	  reset: function reset() {
	    this._callbacks = null;
	    this._contexts = null;
	  },
	
	  /**
	   * `PooledClass` looks for this.
	   */
	  destructor: function destructor() {
	    this.reset();
	  }
	
	});
	
	PooledClass.addPoolingTo(CallbackQueue);
	
	module.exports = CallbackQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule PooledClass
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Static poolers. Several custom versions for each potential number of
	 * arguments. A completely generic pooler is easy to implement, but would
	 * require accessing the `arguments` object. In each of these, `this` refers to
	 * the Class itself, not an instance. If any others are needed, simply add them
	 * here, or in their own files.
	 */
	var oneArgumentPooler = function oneArgumentPooler(copyFieldsFrom) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, copyFieldsFrom);
	    return instance;
	  } else {
	    return new Klass(copyFieldsFrom);
	  }
	};
	
	var twoArgumentPooler = function twoArgumentPooler(a1, a2) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2);
	    return instance;
	  } else {
	    return new Klass(a1, a2);
	  }
	};
	
	var threeArgumentPooler = function threeArgumentPooler(a1, a2, a3) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3);
	  }
	};
	
	var fourArgumentPooler = function fourArgumentPooler(a1, a2, a3, a4) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4);
	  }
	};
	
	var fiveArgumentPooler = function fiveArgumentPooler(a1, a2, a3, a4, a5) {
	  var Klass = this;
	  if (Klass.instancePool.length) {
	    var instance = Klass.instancePool.pop();
	    Klass.call(instance, a1, a2, a3, a4, a5);
	    return instance;
	  } else {
	    return new Klass(a1, a2, a3, a4, a5);
	  }
	};
	
	var standardReleaser = function standardReleaser(instance) {
	  var Klass = this;
	  !(instance instanceof Klass) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Trying to release an instance into a pool of a different type.') : invariant(false) : undefined;
	  instance.destructor();
	  if (Klass.instancePool.length < Klass.poolSize) {
	    Klass.instancePool.push(instance);
	  }
	};
	
	var DEFAULT_POOL_SIZE = 10;
	var DEFAULT_POOLER = oneArgumentPooler;
	
	/**
	 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
	 * itself (statically) not adding any prototypical fields. Any CopyConstructor
	 * you give this may have a `poolSize` property, and will look for a
	 * prototypical `destructor` on instances (optional).
	 *
	 * @param {Function} CopyConstructor Constructor that can be used to reset.
	 * @param {Function} pooler Customizable pooler.
	 */
	var addPoolingTo = function addPoolingTo(CopyConstructor, pooler) {
	  var NewKlass = CopyConstructor;
	  NewKlass.instancePool = [];
	  NewKlass.getPooled = pooler || DEFAULT_POOLER;
	  if (!NewKlass.poolSize) {
	    NewKlass.poolSize = DEFAULT_POOL_SIZE;
	  }
	  NewKlass.release = standardReleaser;
	  return NewKlass;
	};
	
	var PooledClass = {
	  addPoolingTo: addPoolingTo,
	  oneArgumentPooler: oneArgumentPooler,
	  twoArgumentPooler: twoArgumentPooler,
	  threeArgumentPooler: threeArgumentPooler,
	  fourArgumentPooler: fourArgumentPooler,
	  fiveArgumentPooler: fiveArgumentPooler
	};
	
	module.exports = PooledClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule Transaction
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	/**
	 * `Transaction` creates a black box that is able to wrap any method such that
	 * certain invariants are maintained before and after the method is invoked
	 * (Even if an exception is thrown while invoking the wrapped method). Whoever
	 * instantiates a transaction can provide enforcers of the invariants at
	 * creation time. The `Transaction` class itself will supply one additional
	 * automatic invariant for you - the invariant that any transaction instance
	 * should not be run while it is already being run. You would typically create a
	 * single instance of a `Transaction` for reuse multiple times, that potentially
	 * is used to wrap several different methods. Wrappers are extremely simple -
	 * they only require implementing two methods.
	 *
	 * <pre>
	 *                       wrappers (injected at creation time)
	 *                                      +        +
	 *                                      |        |
	 *                    +-----------------|--------|--------------+
	 *                    |                 v        |              |
	 *                    |      +---------------+   |              |
	 *                    |   +--|    wrapper1   |---|----+         |
	 *                    |   |  +---------------+   v    |         |
	 *                    |   |          +-------------+  |         |
	 *                    |   |     +----|   wrapper2  |--------+   |
	 *                    |   |     |    +-------------+  |     |   |
	 *                    |   |     |                     |     |   |
	 *                    |   v     v                     v     v   | wrapper
	 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
	 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
	 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | |   | |   |   |         |   |   | |   | |
	 *                    | +---+ +---+   +---------+   +---+ +---+ |
	 *                    |  initialize                    close    |
	 *                    +-----------------------------------------+
	 * </pre>
	 *
	 * Use cases:
	 * - Preserving the input selection ranges before/after reconciliation.
	 *   Restoring selection even in the event of an unexpected error.
	 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
	 *   while guaranteeing that afterwards, the event system is reactivated.
	 * - Flushing a queue of collected DOM mutations to the main UI thread after a
	 *   reconciliation takes place in a worker thread.
	 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
	 *   content.
	 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
	 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
	 * - (Future use case): Layout calculations before and after DOM updates.
	 *
	 * Transactional plugin API:
	 * - A module that has an `initialize` method that returns any precomputation.
	 * - and a `close` method that accepts the precomputation. `close` is invoked
	 *   when the wrapped process is completed, or has failed.
	 *
	 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
	 * that implement `initialize` and `close`.
	 * @return {Transaction} Single transaction for reuse in thread.
	 *
	 * @class Transaction
	 */
	var Mixin = {
	  /**
	   * Sets up this instance so that it is prepared for collecting metrics. Does
	   * so such that this setup method may be used on an instance that is already
	   * initialized, in a way that does not consume additional memory upon reuse.
	   * That can be useful if you decide to make your subclass of this mixin a
	   * "PooledClass".
	   */
	  reinitializeTransaction: function reinitializeTransaction() {
	    this.transactionWrappers = this.getTransactionWrappers();
	    if (this.wrapperInitData) {
	      this.wrapperInitData.length = 0;
	    } else {
	      this.wrapperInitData = [];
	    }
	    this._isInTransaction = false;
	  },
	
	  _isInTransaction: false,
	
	  /**
	   * @abstract
	   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
	   */
	  getTransactionWrappers: null,
	
	  isInTransaction: function isInTransaction() {
	    return !!this._isInTransaction;
	  },
	
	  /**
	   * Executes the function within a safety window. Use this for the top level
	   * methods that result in large amounts of computation/mutations that would
	   * need to be safety checked. The optional arguments helps prevent the need
	   * to bind in many cases.
	   *
	   * @param {function} method Member of scope to call.
	   * @param {Object} scope Scope to invoke from.
	   * @param {Object?=} a Argument to pass to the method.
	   * @param {Object?=} b Argument to pass to the method.
	   * @param {Object?=} c Argument to pass to the method.
	   * @param {Object?=} d Argument to pass to the method.
	   * @param {Object?=} e Argument to pass to the method.
	   * @param {Object?=} f Argument to pass to the method.
	   *
	   * @return {*} Return value from `method`.
	   */
	  perform: function perform(method, scope, a, b, c, d, e, f) {
	    !!this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.perform(...): Cannot initialize a transaction when there ' + 'is already an outstanding transaction.') : invariant(false) : undefined;
	    var errorThrown;
	    var ret;
	    try {
	      this._isInTransaction = true;
	      // Catching errors makes debugging more difficult, so we start with
	      // errorThrown set to true before setting it to false after calling
	      // close -- if it's still set to true in the finally block, it means
	      // one of these calls threw.
	      errorThrown = true;
	      this.initializeAll(0);
	      ret = method.call(scope, a, b, c, d, e, f);
	      errorThrown = false;
	    } finally {
	      try {
	        if (errorThrown) {
	          // If `method` throws, prefer to show that stack trace over any thrown
	          // by invoking `closeAll`.
	          try {
	            this.closeAll(0);
	          } catch (err) {}
	        } else {
	          // Since `method` didn't throw, we don't want to silence the exception
	          // here.
	          this.closeAll(0);
	        }
	      } finally {
	        this._isInTransaction = false;
	      }
	    }
	    return ret;
	  },
	
	  initializeAll: function initializeAll(startIndex) {
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      try {
	        // Catching errors makes debugging more difficult, so we start with the
	        // OBSERVED_ERROR state before overwriting it with the real return value
	        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
	        // block, it means wrapper.initialize threw.
	        this.wrapperInitData[i] = Transaction.OBSERVED_ERROR;
	        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
	      } finally {
	        if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) {
	          // The initializer for wrapper i threw an error; initialize the
	          // remaining wrappers but silence any exceptions from them to ensure
	          // that the first error is the one to bubble up.
	          try {
	            this.initializeAll(i + 1);
	          } catch (err) {}
	        }
	      }
	    }
	  },
	
	  /**
	   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
	   * them the respective return values of `this.transactionWrappers.init[i]`
	   * (`close`rs that correspond to initializers that failed will not be
	   * invoked).
	   */
	  closeAll: function closeAll(startIndex) {
	    !this.isInTransaction() ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Transaction.closeAll(): Cannot close transaction when none are open.') : invariant(false) : undefined;
	    var transactionWrappers = this.transactionWrappers;
	    for (var i = startIndex; i < transactionWrappers.length; i++) {
	      var wrapper = transactionWrappers[i];
	      var initData = this.wrapperInitData[i];
	      var errorThrown;
	      try {
	        // Catching errors makes debugging more difficult, so we start with
	        // errorThrown set to true before setting it to false after calling
	        // close -- if it's still set to true in the finally block, it means
	        // wrapper.close threw.
	        errorThrown = true;
	        if (initData !== Transaction.OBSERVED_ERROR && wrapper.close) {
	          wrapper.close.call(this, initData);
	        }
	        errorThrown = false;
	      } finally {
	        if (errorThrown) {
	          // The closer for wrapper i threw an error; close the remaining
	          // wrappers but silence any exceptions from them to ensure that the
	          // first error is the one to bubble up.
	          try {
	            this.closeAll(i + 1);
	          } catch (e) {}
	        }
	      }
	    }
	    this.wrapperInitData.length = 0;
	  }
	};
	
	var Transaction = {
	
	  Mixin: Mixin,
	
	  /**
	   * Token to look for to determine if an error occurred.
	   */
	  OBSERVED_ERROR: {}
	
	};
	
	module.exports = Transaction;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule emptyObject
	 */
	
	'use strict';
	
	var emptyObject = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  Object.freeze(emptyObject);
	}
	
	module.exports = emptyObject;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule containsNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isTextNode = __webpack_require__(67);
	
	/*eslint-disable no-bitwise */
	
	/**
	 * Checks if a given DOM node contains or is another DOM node.
	 *
	 * @param {?DOMNode} outerNode Outer DOM node.
	 * @param {?DOMNode} innerNode Inner DOM node.
	 * @return {boolean} True if `outerNode` contains or is `innerNode`.
	 */
	function containsNode(_x, _x2) {
	  var _again = true;
	
	  _function: while (_again) {
	    var outerNode = _x,
	        innerNode = _x2;
	    _again = false;
	
	    if (!outerNode || !innerNode) {
	      return false;
	    } else if (outerNode === innerNode) {
	      return true;
	    } else if (isTextNode(outerNode)) {
	      return false;
	    } else if (isTextNode(innerNode)) {
	      _x = outerNode;
	      _x2 = innerNode.parentNode;
	      _again = true;
	      continue _function;
	    } else if (outerNode.contains) {
	      return outerNode.contains(innerNode);
	    } else if (outerNode.compareDocumentPosition) {
	      return !!(outerNode.compareDocumentPosition(innerNode) & 16);
	    } else {
	      return false;
	    }
	  }
	}
	
	module.exports = containsNode;

/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextNode
	 * @typechecks
	 */
	
	'use strict';
	
	var isNode = __webpack_require__(68);
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM text node.
	 */
	function isTextNode(object) {
	  return isNode(object) && object.nodeType == 3;
	}
	
	module.exports = isTextNode;

/***/ },
/* 68 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isNode
	 * @typechecks
	 */
	
	/**
	 * @param {*} object The object to check.
	 * @return {boolean} Whether or not the object is a DOM node.
	 */
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function isNode(object) {
	  return !!(object && (typeof Node === 'function' ? object instanceof Node : (typeof object === 'undefined' ? 'undefined' : _typeof(object)) === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
	}
	
	module.exports = isNode;

/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule instantiateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCompositeComponent = __webpack_require__(70);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactNativeComponent = __webpack_require__(76);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	// To avoid a cyclic dependency, we create the final class in this module
	var ReactCompositeComponentWrapper = function ReactCompositeComponentWrapper() {};
	assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent.Mixin, {
	  _instantiateReactComponent: instantiateReactComponent
	});
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Check if the type reference is a known internal type. I.e. not a user
	 * provided composite type.
	 *
	 * @param {function} type
	 * @return {boolean} Returns true if this is a valid internal type.
	 */
	function isInternalComponentType(type) {
	  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
	}
	
	/**
	 * Given a ReactNode, create an instance that will actually be mounted.
	 *
	 * @param {ReactNode} node
	 * @return {object} A new instance of the element's constructor.
	 * @protected
	 */
	function instantiateReactComponent(node) {
	  var instance;
	
	  if (node === null || node === false) {
	    instance = new ReactEmptyComponent(instantiateReactComponent);
	  } else if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) === 'object') {
	    var element = node;
	    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element type is invalid: expected a string (for built-in components) ' + 'or a class/function (for composite components) but got: %s.%s', element.type == null ? element.type : _typeof(element.type), getDeclarationErrorAddendum(element._owner)) : invariant(false) : undefined;
	
	    // Special case string values
	    if (typeof element.type === 'string') {
	      instance = ReactNativeComponent.createInternalComponent(element);
	    } else if (isInternalComponentType(element.type)) {
	      // This is temporarily available for custom components that are not string
	      // representations. I.e. ART. Once those are updated to use the string
	      // representation, we can drop this code path.
	      instance = new element.type(element);
	    } else {
	      instance = new ReactCompositeComponentWrapper();
	    }
	  } else if (typeof node === 'string' || typeof node === 'number') {
	    instance = ReactNativeComponent.createInstanceForText(node);
	  } else {
	     true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Encountered invalid React node of type %s', typeof node === 'undefined' ? 'undefined' : _typeof(node)) : invariant(false) : undefined;
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(typeof instance.construct === 'function' && typeof instance.mountComponent === 'function' && typeof instance.receiveComponent === 'function' && typeof instance.unmountComponent === 'function', 'Only React Components can be mounted.') : undefined;
	  }
	
	  // Sets up the instance. This can probably just move into the constructor now.
	  instance.construct(node);
	
	  // These two fields are used by the DOM and ART diffing algorithms
	  // respectively. Instead of using expandos on components, we should be
	  // storing the state needed by the diffing algorithms elsewhere.
	  instance._mountIndex = 0;
	  instance._mountImage = null;
	
	  if (process.env.NODE_ENV !== 'production') {
	    instance._isOwnerNecessary = false;
	    instance._warnedAboutRefsInRender = false;
	  }
	
	  // Internal instances should fully constructed at this point, so they should
	  // not get any new fields added to them at this point.
	  if (process.env.NODE_ENV !== 'production') {
	    if (Object.preventExtensions) {
	      Object.preventExtensions(instance);
	    }
	  }
	
	  return instance;
	}
	
	module.exports = instantiateReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactCompositeComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactPerf = __webpack_require__(25);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactReconciler = __webpack_require__(57);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum(component) {
	  var owner = component._currentElement._owner || null;
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	function StatelessComponent(Component) {}
	StatelessComponent.prototype.render = function () {
	  var Component = ReactInstanceMap.get(this)._currentElement.type;
	  return Component(this.props, this.context, this.updater);
	};
	
	/**
	 * ------------------ The Life-Cycle of a Composite Component ------------------
	 *
	 * - constructor: Initialization of state. The instance is now retained.
	 *   - componentWillMount
	 *   - render
	 *   - [children's constructors]
	 *     - [children's componentWillMount and render]
	 *     - [children's componentDidMount]
	 *     - componentDidMount
	 *
	 *       Update Phases:
	 *       - componentWillReceiveProps (only called if parent updated)
	 *       - shouldComponentUpdate
	 *         - componentWillUpdate
	 *           - render
	 *           - [children's constructors or receive props phases]
	 *         - componentDidUpdate
	 *
	 *     - componentWillUnmount
	 *     - [children's componentWillUnmount]
	 *   - [children destroyed]
	 * - (destroyed): The instance is now blank, released by React and ready for GC.
	 *
	 * -----------------------------------------------------------------------------
	 */
	
	/**
	 * An incrementing ID assigned to each component when it is mounted. This is
	 * used to enforce the order in which `ReactUpdates` updates dirty components.
	 *
	 * @private
	 */
	var nextMountID = 1;
	
	/**
	 * @lends {ReactCompositeComponent.prototype}
	 */
	var ReactCompositeComponentMixin = {
	
	  /**
	   * Base constructor for all composite component.
	   *
	   * @param {ReactElement} element
	   * @final
	   * @internal
	   */
	  construct: function construct(element) {
	    this._currentElement = element;
	    this._rootNodeID = null;
	    this._instance = null;
	
	    // See ReactUpdateQueue
	    this._pendingElement = null;
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    this._renderedComponent = null;
	
	    this._context = null;
	    this._mountOrder = 0;
	    this._topLevelWrapper = null;
	
	    // See ReactUpdates and ReactUpdateQueue.
	    this._pendingCallbacks = null;
	  },
	
	  /**
	   * Initializes the component, renders markup, and registers event listeners.
	   *
	   * @param {string} rootID DOM ID of the root node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @return {?string} Rendered markup to be inserted into the DOM.
	   * @final
	   * @internal
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._context = context;
	    this._mountOrder = nextMountID++;
	    this._rootNodeID = rootID;
	
	    var publicProps = this._processProps(this._currentElement.props);
	    var publicContext = this._processContext(context);
	
	    var Component = this._currentElement.type;
	
	    // Initialize the public class
	    var inst;
	    var renderedElement;
	
	    // This is a way to detect if Component is a stateless arrow function
	    // component, which is not newable. It might not be 100% reliable but is
	    // something we can do until we start detecting that Component extends
	    // React.Component. We already assume that typeof Component === 'function'.
	    var canInstantiate = 'prototype' in Component;
	
	    if (canInstantiate) {
	      if (process.env.NODE_ENV !== 'production') {
	        ReactCurrentOwner.current = this;
	        try {
	          inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	        } finally {
	          ReactCurrentOwner.current = null;
	        }
	      } else {
	        inst = new Component(publicProps, publicContext, ReactUpdateQueue);
	      }
	    }
	
	    if (!canInstantiate || inst === null || inst === false || ReactElement.isValidElement(inst)) {
	      renderedElement = inst;
	      inst = new StatelessComponent(Component);
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This will throw later in _renderValidatedComponent, but add an early
	      // warning now to help debugging
	      if (inst.render == null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): No `render` method found on the returned component ' + 'instance: you may have forgotten to define `render`, returned ' + 'null/false from a stateless component, or tried to render an ' + 'element whose type is a function that isn\'t a React component.', Component.displayName || Component.name || 'Component') : undefined;
	      } else {
	        // We support ES6 inheriting from React.Component, the module pattern,
	        // and stateless components, but not ES6 classes that don't extend
	        process.env.NODE_ENV !== 'production' ? warning(Component.prototype && Component.prototype.isReactComponent || !canInstantiate || !(inst instanceof Component), '%s(...): React component classes must extend React.Component.', Component.displayName || Component.name || 'Component') : undefined;
	      }
	    }
	
	    // These should be set up in the constructor, but as a convenience for
	    // simpler class abstractions, we set them up after the fact.
	    inst.props = publicProps;
	    inst.context = publicContext;
	    inst.refs = emptyObject;
	    inst.updater = ReactUpdateQueue;
	
	    this._instance = inst;
	
	    // Store a reference from the instance back to the internal representation
	    ReactInstanceMap.set(inst, this);
	
	    if (process.env.NODE_ENV !== 'production') {
	      // Since plain JS classes are defined without any special initialization
	      // logic, we can not catch common errors early. Therefore, we have to
	      // catch them here, at initialization time, instead.
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getInitialState || inst.getInitialState.isReactClassApproved, 'getInitialState was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Did you mean to define a state property instead?', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.getDefaultProps || inst.getDefaultProps.isReactClassApproved, 'getDefaultProps was defined on %s, a plain JavaScript class. ' + 'This is only supported for classes created using React.createClass. ' + 'Use a static property to define defaultProps instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.propTypes, 'propTypes was defined as an instance property on %s. Use a static ' + 'property to define propTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!inst.contextTypes, 'contextTypes was defined as an instance property on %s. Use a ' + 'static property to define contextTypes instead.', this.getName() || 'a component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentShouldUpdate !== 'function', '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentDidUnmount !== 'function', '%s has a method called ' + 'componentDidUnmount(). But there is no such lifecycle method. ' + 'Did you mean componentWillUnmount()?', this.getName() || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(typeof inst.componentWillRecieveProps !== 'function', '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', this.getName() || 'A component') : undefined;
	    }
	
	    var initialState = inst.state;
	    if (initialState === undefined) {
	      inst.state = initialState = null;
	    }
	    !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.state: must be set to an object or null', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	
	    if (inst.componentWillMount) {
	      inst.componentWillMount();
	      // When mounting, calls to `setState` by `componentWillMount` will set
	      // `this._pendingStateQueue` without triggering a re-render.
	      if (this._pendingStateQueue) {
	        inst.state = this._processPendingState(inst.props, inst.context);
	      }
	    }
	
	    // If not a stateless component, we now render
	    if (renderedElement === undefined) {
	      renderedElement = this._renderValidatedComponent();
	    }
	
	    this._renderedComponent = this._instantiateReactComponent(renderedElement);
	
	    var markup = ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, this._processChildContext(context));
	    if (inst.componentDidMount) {
	      transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
	    }
	
	    return markup;
	  },
	
	  /**
	   * Releases any resources allocated by `mountComponent`.
	   *
	   * @final
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    var inst = this._instance;
	
	    if (inst.componentWillUnmount) {
	      inst.componentWillUnmount();
	    }
	
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    this._renderedComponent = null;
	    this._instance = null;
	
	    // Reset pending fields
	    // Even if this component is scheduled for another update in ReactUpdates,
	    // it would still be ignored because these fields are reset.
	    this._pendingStateQueue = null;
	    this._pendingReplaceState = false;
	    this._pendingForceUpdate = false;
	    this._pendingCallbacks = null;
	    this._pendingElement = null;
	
	    // These fields do not really need to be reset since this object is no
	    // longer accessible.
	    this._context = null;
	    this._rootNodeID = null;
	    this._topLevelWrapper = null;
	
	    // Delete the reference from the instance to this internal representation
	    // which allow the internals to be properly cleaned up even if the user
	    // leaks a reference to the public instance.
	    ReactInstanceMap.remove(inst);
	
	    // Some existing components rely on inst.props even after they've been
	    // destroyed (in event handlers).
	    // TODO: inst.props = null;
	    // TODO: inst.state = null;
	    // TODO: inst.context = null;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _maskContext: function _maskContext(context) {
	    var maskedContext = null;
	    var Component = this._currentElement.type;
	    var contextTypes = Component.contextTypes;
	    if (!contextTypes) {
	      return emptyObject;
	    }
	    maskedContext = {};
	    for (var contextName in contextTypes) {
	      maskedContext[contextName] = context[contextName];
	    }
	    return maskedContext;
	  },
	
	  /**
	   * Filters the context object to only contain keys specified in
	   * `contextTypes`, and asserts that they are valid.
	   *
	   * @param {object} context
	   * @return {?object}
	   * @private
	   */
	  _processContext: function _processContext(context) {
	    var maskedContext = this._maskContext(context);
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.contextTypes) {
	        this._checkPropTypes(Component.contextTypes, maskedContext, ReactPropTypeLocations.context);
	      }
	    }
	    return maskedContext;
	  },
	
	  /**
	   * @param {object} currentContext
	   * @return {object}
	   * @private
	   */
	  _processChildContext: function _processChildContext(currentContext) {
	    var Component = this._currentElement.type;
	    var inst = this._instance;
	    var childContext = inst.getChildContext && inst.getChildContext();
	    if (childContext) {
	      !(_typeof(Component.childContextTypes) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): childContextTypes must be defined in order to ' + 'use getChildContext().', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	      if (process.env.NODE_ENV !== 'production') {
	        this._checkPropTypes(Component.childContextTypes, childContext, ReactPropTypeLocations.childContext);
	      }
	      for (var name in childContext) {
	        !(name in Component.childContextTypes) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getChildContext(): key "%s" is not defined in childContextTypes.', this.getName() || 'ReactCompositeComponent', name) : invariant(false) : undefined;
	      }
	      return assign({}, currentContext, childContext);
	    }
	    return currentContext;
	  },
	
	  /**
	   * Processes props by setting default values for unspecified props and
	   * asserting that the props are valid. Does not mutate its argument; returns
	   * a new props object with defaults merged in.
	   *
	   * @param {object} newProps
	   * @return {object}
	   * @private
	   */
	  _processProps: function _processProps(newProps) {
	    if (process.env.NODE_ENV !== 'production') {
	      var Component = this._currentElement.type;
	      if (Component.propTypes) {
	        this._checkPropTypes(Component.propTypes, newProps, ReactPropTypeLocations.prop);
	      }
	    }
	    return newProps;
	  },
	
	  /**
	   * Assert that the props are valid
	   *
	   * @param {object} propTypes Map of prop name to a ReactPropType
	   * @param {object} props
	   * @param {string} location e.g. "prop", "context", "child context"
	   * @private
	   */
	  _checkPropTypes: function _checkPropTypes(propTypes, props, location) {
	    // TODO: Stop validating prop types here and only use the element
	    // validation.
	    var componentName = this.getName();
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error;
	        try {
	          // This is intentionally an invariant that gets caught. It's the same
	          // behavior as without this statement except with a better message.
	          !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually ' + 'from React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	          error = propTypes[propName](props, propName, componentName, location);
	        } catch (ex) {
	          error = ex;
	        }
	        if (error instanceof Error) {
	          // We may want to extend this logic for similar errors in
	          // top-level render calls, so I'm abstracting it away into
	          // a function to minimize refactoring in the future
	          var addendum = getDeclarationErrorAddendum(this);
	
	          if (location === ReactPropTypeLocations.prop) {
	            // Preface gives us something to blacklist in warning module
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Composite propType: %s%s', error.message, addendum) : undefined;
	          } else {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Failed Context Types: %s%s', error.message, addendum) : undefined;
	          }
	        }
	      }
	    }
	  },
	
	  receiveComponent: function receiveComponent(nextElement, transaction, nextContext) {
	    var prevElement = this._currentElement;
	    var prevContext = this._context;
	
	    this._pendingElement = null;
	
	    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
	  },
	
	  /**
	   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
	   * is set, update the component.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  performUpdateIfNecessary: function performUpdateIfNecessary(transaction) {
	    if (this._pendingElement != null) {
	      ReactReconciler.receiveComponent(this, this._pendingElement || this._currentElement, transaction, this._context);
	    }
	
	    if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
	      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
	    }
	  },
	
	  /**
	   * Perform an update to a mounted component. The componentWillReceiveProps and
	   * shouldComponentUpdate methods are called, then (assuming the update isn't
	   * skipped) the remaining update lifecycle methods are called and the DOM
	   * representation is updated.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevParentElement
	   * @param {ReactElement} nextParentElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
	    var inst = this._instance;
	
	    var nextContext = this._context === nextUnmaskedContext ? inst.context : this._processContext(nextUnmaskedContext);
	    var nextProps;
	
	    // Distinguish between a props update versus a simple state update
	    if (prevParentElement === nextParentElement) {
	      // Skip checking prop types again -- we don't read inst.props to avoid
	      // warning for DOM component props in this upgrade
	      nextProps = nextParentElement.props;
	    } else {
	      nextProps = this._processProps(nextParentElement.props);
	      // An update here will schedule an update but immediately set
	      // _pendingStateQueue which will ensure that any state updates gets
	      // immediately reconciled instead of waiting for the next batch.
	
	      if (inst.componentWillReceiveProps) {
	        inst.componentWillReceiveProps(nextProps, nextContext);
	      }
	    }
	
	    var nextState = this._processPendingState(nextProps, nextContext);
	
	    var shouldUpdate = this._pendingForceUpdate || !inst.shouldComponentUpdate || inst.shouldComponentUpdate(nextProps, nextState, nextContext);
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(typeof shouldUpdate !== 'undefined', '%s.shouldComponentUpdate(): Returned undefined instead of a ' + 'boolean value. Make sure to return true or false.', this.getName() || 'ReactCompositeComponent') : undefined;
	    }
	
	    if (shouldUpdate) {
	      this._pendingForceUpdate = false;
	      // Will set `this.props`, `this.state` and `this.context`.
	      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
	    } else {
	      // If it's determined that a component should not update, we still want
	      // to set props and state but we shortcut the rest of the update.
	      this._currentElement = nextParentElement;
	      this._context = nextUnmaskedContext;
	      inst.props = nextProps;
	      inst.state = nextState;
	      inst.context = nextContext;
	    }
	  },
	
	  _processPendingState: function _processPendingState(props, context) {
	    var inst = this._instance;
	    var queue = this._pendingStateQueue;
	    var replace = this._pendingReplaceState;
	    this._pendingReplaceState = false;
	    this._pendingStateQueue = null;
	
	    if (!queue) {
	      return inst.state;
	    }
	
	    if (replace && queue.length === 1) {
	      return queue[0];
	    }
	
	    var nextState = assign({}, replace ? queue[0] : inst.state);
	    for (var i = replace ? 1 : 0; i < queue.length; i++) {
	      var partial = queue[i];
	      assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
	    }
	
	    return nextState;
	  },
	
	  /**
	   * Merges new props and state, notifies delegate methods of update and
	   * performs update.
	   *
	   * @param {ReactElement} nextElement Next element
	   * @param {object} nextProps Next public object to set as properties.
	   * @param {?object} nextState Next object to set as state.
	   * @param {?object} nextContext Next public object to set as context.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?object} unmaskedContext
	   * @private
	   */
	  _performComponentUpdate: function _performComponentUpdate(nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
	    var inst = this._instance;
	
	    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
	    var prevProps;
	    var prevState;
	    var prevContext;
	    if (hasComponentDidUpdate) {
	      prevProps = inst.props;
	      prevState = inst.state;
	      prevContext = inst.context;
	    }
	
	    if (inst.componentWillUpdate) {
	      inst.componentWillUpdate(nextProps, nextState, nextContext);
	    }
	
	    this._currentElement = nextElement;
	    this._context = unmaskedContext;
	    inst.props = nextProps;
	    inst.state = nextState;
	    inst.context = nextContext;
	
	    this._updateRenderedComponent(transaction, unmaskedContext);
	
	    if (hasComponentDidUpdate) {
	      transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
	    }
	  },
	
	  /**
	   * Call the component's `render` method and update the DOM accordingly.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   */
	  _updateRenderedComponent: function _updateRenderedComponent(transaction, context) {
	    var prevComponentInstance = this._renderedComponent;
	    var prevRenderedElement = prevComponentInstance._currentElement;
	    var nextRenderedElement = this._renderValidatedComponent();
	    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
	      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
	    } else {
	      // These two IDs are actually the same! But nothing should rely on that.
	      var thisID = this._rootNodeID;
	      var prevComponentID = prevComponentInstance._rootNodeID;
	      ReactReconciler.unmountComponent(prevComponentInstance);
	
	      this._renderedComponent = this._instantiateReactComponent(nextRenderedElement);
	      var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, thisID, transaction, this._processChildContext(context));
	      this._replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	    }
	  },
	
	  /**
	   * @protected
	   */
	  _replaceNodeWithMarkupByID: function _replaceNodeWithMarkupByID(prevComponentID, nextMarkup) {
	    ReactComponentEnvironment.replaceNodeWithMarkupByID(prevComponentID, nextMarkup);
	  },
	
	  /**
	   * @protected
	   */
	  _renderValidatedComponentWithoutOwnerOrContext: function _renderValidatedComponentWithoutOwnerOrContext() {
	    var inst = this._instance;
	    var renderedComponent = inst.render();
	    if (process.env.NODE_ENV !== 'production') {
	      // We allow auto-mocks to proceed as if they're returning null.
	      if (typeof renderedComponent === 'undefined' && inst.render._isMockFunction) {
	        // This is probably bad practice. Consider warning here and
	        // deprecating this convenience.
	        renderedComponent = null;
	      }
	    }
	
	    return renderedComponent;
	  },
	
	  /**
	   * @private
	   */
	  _renderValidatedComponent: function _renderValidatedComponent() {
	    var renderedComponent;
	    ReactCurrentOwner.current = this;
	    try {
	      renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext();
	    } finally {
	      ReactCurrentOwner.current = null;
	    }
	    !(
	    // TODO: An `isValidNode` function would probably be more appropriate
	    renderedComponent === null || renderedComponent === false || ReactElement.isValidElement(renderedComponent)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.render(): A valid ReactComponent must be returned. You may have ' + 'returned undefined, an array or some other invalid object.', this.getName() || 'ReactCompositeComponent') : invariant(false) : undefined;
	    return renderedComponent;
	  },
	
	  /**
	   * Lazily allocates the refs object and stores `component` as `ref`.
	   *
	   * @param {string} ref Reference name.
	   * @param {component} component Component to store as `ref`.
	   * @final
	   * @private
	   */
	  attachRef: function attachRef(ref, component) {
	    var inst = this.getPublicInstance();
	    !(inst != null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Stateless function components cannot have refs.') : invariant(false) : undefined;
	    var publicComponentInstance = component.getPublicInstance();
	    if (process.env.NODE_ENV !== 'production') {
	      var componentName = component && component.getName ? component.getName() : 'a component';
	      process.env.NODE_ENV !== 'production' ? warning(publicComponentInstance != null, 'Stateless function components cannot be given refs ' + '(See ref "%s" in %s created by %s). ' + 'Attempts to access this ref will fail.', ref, componentName, this.getName()) : undefined;
	    }
	    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
	    refs[ref] = publicComponentInstance;
	  },
	
	  /**
	   * Detaches a reference name.
	   *
	   * @param {string} ref Name to dereference.
	   * @final
	   * @private
	   */
	  detachRef: function detachRef(ref) {
	    var refs = this.getPublicInstance().refs;
	    delete refs[ref];
	  },
	
	  /**
	   * Get a text description of the component that can be used to identify it
	   * in error messages.
	   * @return {string} The name or null.
	   * @internal
	   */
	  getName: function getName() {
	    var type = this._currentElement.type;
	    var constructor = this._instance && this._instance.constructor;
	    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
	  },
	
	  /**
	   * Get the publicly accessible representation of this component - i.e. what
	   * is exposed by refs and returned by render. Can be null for stateless
	   * components.
	   *
	   * @return {ReactComponent} the public component instance.
	   * @internal
	   */
	  getPublicInstance: function getPublicInstance() {
	    var inst = this._instance;
	    if (inst instanceof StatelessComponent) {
	      return null;
	    }
	    return inst;
	  },
	
	  // Stub
	  _instantiateReactComponent: null
	
	};
	
	ReactPerf.measureMethods(ReactCompositeComponentMixin, 'ReactCompositeComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent',
	  _renderValidatedComponent: '_renderValidatedComponent'
	});
	
	var ReactCompositeComponent = {
	
	  Mixin: ReactCompositeComponentMixin
	
	};
	
	module.exports = ReactCompositeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponentEnvironment
	 */
	
	'use strict';
	
	var invariant = __webpack_require__(20);
	
	var injected = false;
	
	var ReactComponentEnvironment = {
	
	  /**
	   * Optionally injectable environment dependent cleanup hook. (server vs.
	   * browser etc). Example: A browser system caches DOM nodes based on component
	   * ID and must remove that cache entry when this instance is unmounted.
	   */
	  unmountIDFromEnvironment: null,
	
	  /**
	   * Optionally injectable hook for swapping out mount images in the middle of
	   * the tree.
	   */
	  replaceNodeWithMarkupByID: null,
	
	  /**
	   * Optionally injectable hook for processing a queue of child updates. Will
	   * later move into MultiChildComponents.
	   */
	  processChildrenUpdates: null,
	
	  injection: {
	    injectEnvironment: function injectEnvironment(environment) {
	      !!injected ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactCompositeComponent: injectEnvironment() can only be called once.') : invariant(false) : undefined;
	      ReactComponentEnvironment.unmountIDFromEnvironment = environment.unmountIDFromEnvironment;
	      ReactComponentEnvironment.replaceNodeWithMarkupByID = environment.replaceNodeWithMarkupByID;
	      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
	      injected = true;
	    }
	  }
	
	};
	
	module.exports = ReactComponentEnvironment;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocations
	 */
	
	'use strict';
	
	var keyMirror = __webpack_require__(24);
	
	var ReactPropTypeLocations = keyMirror({
	  prop: null,
	  context: null,
	  childContext: null
	});
	
	module.exports = ReactPropTypeLocations;

/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypeLocationNames
	 */
	
	'use strict';
	
	var ReactPropTypeLocationNames = {};
	
	if (process.env.NODE_ENV !== 'production') {
	  ReactPropTypeLocationNames = {
	    prop: 'prop',
	    context: 'context',
	    childContext: 'child context'
	  };
	}
	
	module.exports = ReactPropTypeLocationNames;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 74 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shouldUpdateReactComponent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Given a `prevElement` and `nextElement`, determines if the existing
	 * instance should be updated as opposed to being destroyed or replaced by a new
	 * instance. Both arguments are elements. This ensures that this logic can
	 * operate on stateless trees without any backing instance.
	 *
	 * @param {?object} prevElement
	 * @param {?object} nextElement
	 * @return {boolean} True if the existing instance should be updated.
	 * @protected
	 */
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	function shouldUpdateReactComponent(prevElement, nextElement) {
	  var prevEmpty = prevElement === null || prevElement === false;
	  var nextEmpty = nextElement === null || nextElement === false;
	  if (prevEmpty || nextEmpty) {
	    return prevEmpty === nextEmpty;
	  }
	
	  var prevType = typeof prevElement === 'undefined' ? 'undefined' : _typeof(prevElement);
	  var nextType = typeof nextElement === 'undefined' ? 'undefined' : _typeof(nextElement);
	  if (prevType === 'string' || prevType === 'number') {
	    return nextType === 'string' || nextType === 'number';
	  } else {
	    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
	  }
	  return false;
	}
	
	module.exports = shouldUpdateReactComponent;

/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEmptyComponent
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactEmptyComponentRegistry = __webpack_require__(51);
	var ReactReconciler = __webpack_require__(57);
	
	var assign = __webpack_require__(46);
	
	var placeholderElement;
	
	var ReactEmptyComponentInjection = {
	  injectEmptyComponent: function injectEmptyComponent(component) {
	    placeholderElement = ReactElement.createElement(component);
	  }
	};
	
	function registerNullComponentID() {
	  ReactEmptyComponentRegistry.registerNullComponentID(this._rootNodeID);
	}
	
	var ReactEmptyComponent = function ReactEmptyComponent(instantiate) {
	  this._currentElement = null;
	  this._rootNodeID = null;
	  this._renderedComponent = instantiate(placeholderElement);
	};
	assign(ReactEmptyComponent.prototype, {
	  construct: function construct(element) {},
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    transaction.getReactMountReady().enqueue(registerNullComponentID, this);
	    this._rootNodeID = rootID;
	    return ReactReconciler.mountComponent(this._renderedComponent, rootID, transaction, context);
	  },
	  receiveComponent: function receiveComponent() {},
	  unmountComponent: function unmountComponent(rootID, transaction, context) {
	    ReactReconciler.unmountComponent(this._renderedComponent);
	    ReactEmptyComponentRegistry.deregisterNullComponentID(this._rootNodeID);
	    this._rootNodeID = null;
	    this._renderedComponent = null;
	  }
	});
	
	ReactEmptyComponent.injection = ReactEmptyComponentInjection;
	
	module.exports = ReactEmptyComponent;

/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNativeComponent
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var autoGenerateWrapperClass = null;
	var genericComponentClass = null;
	// This registry keeps track of wrapper classes around native tags.
	var tagToComponentClass = {};
	var textComponentClass = null;
	
	var ReactNativeComponentInjection = {
	  // This accepts a class that receives the tag string. This is a catch all
	  // that can render any kind of tag.
	  injectGenericComponentClass: function injectGenericComponentClass(componentClass) {
	    genericComponentClass = componentClass;
	  },
	  // This accepts a text component class that takes the text string to be
	  // rendered as props.
	  injectTextComponentClass: function injectTextComponentClass(componentClass) {
	    textComponentClass = componentClass;
	  },
	  // This accepts a keyed object with classes as values. Each key represents a
	  // tag. That particular tag will use this class instead of the generic one.
	  injectComponentClasses: function injectComponentClasses(componentClasses) {
	    assign(tagToComponentClass, componentClasses);
	  }
	};
	
	/**
	 * Get a composite component wrapper class for a specific tag.
	 *
	 * @param {ReactElement} element The tag for which to get the class.
	 * @return {function} The React class constructor function.
	 */
	function getComponentClassForElement(element) {
	  if (typeof element.type === 'function') {
	    return element.type;
	  }
	  var tag = element.type;
	  var componentClass = tagToComponentClass[tag];
	  if (componentClass == null) {
	    tagToComponentClass[tag] = componentClass = autoGenerateWrapperClass(tag);
	  }
	  return componentClass;
	}
	
	/**
	 * Get a native internal component class for a specific tag.
	 *
	 * @param {ReactElement} element The element to create.
	 * @return {function} The internal class constructor function.
	 */
	function createInternalComponent(element) {
	  !genericComponentClass ? process.env.NODE_ENV !== 'production' ? invariant(false, 'There is no registered component for the tag %s', element.type) : invariant(false) : undefined;
	  return new genericComponentClass(element.type, element.props);
	}
	
	/**
	 * @param {ReactText} text
	 * @return {ReactComponent}
	 */
	function createInstanceForText(text) {
	  return new textComponentClass(text);
	}
	
	/**
	 * @param {ReactComponent} component
	 * @return {boolean}
	 */
	function isTextComponent(component) {
	  return component instanceof textComponentClass;
	}
	
	var ReactNativeComponent = {
	  getComponentClassForElement: getComponentClassForElement,
	  createInternalComponent: createInternalComponent,
	  createInstanceForText: createInstanceForText,
	  isTextComponent: isTextComponent,
	  injection: ReactNativeComponentInjection
	};
	
	module.exports = ReactNativeComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule validateDOMNesting
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	var validateDOMNesting = emptyFunction;
	
	if (process.env.NODE_ENV !== 'production') {
	  // This validation code was written based on the HTML5 parsing spec:
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  //
	  // Note: this does not catch all invalid nesting, nor does it try to (as it's
	  // not clear what practical benefit doing so provides); instead, we warn only
	  // for cases where the parser will give a parse tree differing from what React
	  // intended. For example, <b><div></div></b> is invalid but we don't warn
	  // because it still parses correctly; we do warn for other cases like nested
	  // <p> tags where the beginning of the second element implicitly closes the
	  // first, causing a confusing mess.
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#special
	  var specialTags = ['address', 'applet', 'area', 'article', 'aside', 'base', 'basefont', 'bgsound', 'blockquote', 'body', 'br', 'button', 'caption', 'center', 'col', 'colgroup', 'dd', 'details', 'dir', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'frame', 'frameset', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'head', 'header', 'hgroup', 'hr', 'html', 'iframe', 'img', 'input', 'isindex', 'li', 'link', 'listing', 'main', 'marquee', 'menu', 'menuitem', 'meta', 'nav', 'noembed', 'noframes', 'noscript', 'object', 'ol', 'p', 'param', 'plaintext', 'pre', 'script', 'section', 'select', 'source', 'style', 'summary', 'table', 'tbody', 'td', 'template', 'textarea', 'tfoot', 'th', 'thead', 'title', 'tr', 'track', 'ul', 'wbr', 'xmp'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-scope
	  var inScopeTags = ['applet', 'caption', 'html', 'table', 'td', 'th', 'marquee', 'object', 'template',
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
	  // TODO: Distinguish by namespace here -- for <title>, including it here
	  // errs on the side of fewer warnings
	  'foreignObject', 'desc', 'title'];
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#has-an-element-in-button-scope
	  var buttonScopeTags = inScopeTags.concat(['button']);
	
	  // https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags
	  var impliedEndTags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];
	
	  var emptyAncestorInfo = {
	    parentTag: null,
	
	    formTag: null,
	    aTagInScope: null,
	    buttonTagInScope: null,
	    nobrTagInScope: null,
	    pTagInButtonScope: null,
	
	    listItemTagAutoclosing: null,
	    dlItemTagAutoclosing: null
	  };
	
	  var updatedAncestorInfo = function updatedAncestorInfo(oldInfo, tag, instance) {
	    var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
	    var info = { tag: tag, instance: instance };
	
	    if (inScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.aTagInScope = null;
	      ancestorInfo.buttonTagInScope = null;
	      ancestorInfo.nobrTagInScope = null;
	    }
	    if (buttonScopeTags.indexOf(tag) !== -1) {
	      ancestorInfo.pTagInButtonScope = null;
	    }
	
	    // See rules for 'li', 'dd', 'dt' start tags in
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    if (specialTags.indexOf(tag) !== -1 && tag !== 'address' && tag !== 'div' && tag !== 'p') {
	      ancestorInfo.listItemTagAutoclosing = null;
	      ancestorInfo.dlItemTagAutoclosing = null;
	    }
	
	    ancestorInfo.parentTag = info;
	
	    if (tag === 'form') {
	      ancestorInfo.formTag = info;
	    }
	    if (tag === 'a') {
	      ancestorInfo.aTagInScope = info;
	    }
	    if (tag === 'button') {
	      ancestorInfo.buttonTagInScope = info;
	    }
	    if (tag === 'nobr') {
	      ancestorInfo.nobrTagInScope = info;
	    }
	    if (tag === 'p') {
	      ancestorInfo.pTagInButtonScope = info;
	    }
	    if (tag === 'li') {
	      ancestorInfo.listItemTagAutoclosing = info;
	    }
	    if (tag === 'dd' || tag === 'dt') {
	      ancestorInfo.dlItemTagAutoclosing = info;
	    }
	
	    return ancestorInfo;
	  };
	
	  /**
	   * Returns whether
	   */
	  var isTagValidWithParent = function isTagValidWithParent(tag, parentTag) {
	    // First, let's check if we're in an unusual parsing mode...
	    switch (parentTag) {
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
	      case 'select':
	        return tag === 'option' || tag === 'optgroup' || tag === '#text';
	      case 'optgroup':
	        return tag === 'option' || tag === '#text';
	      // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
	      // but
	      case 'option':
	        return tag === '#text';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
	      // No special behavior since these rules fall back to "in body" mode for
	      // all except special table nodes which cause bad parsing behavior anyway.
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
	      case 'tr':
	        return tag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
	      case 'tbody':
	      case 'thead':
	      case 'tfoot':
	        return tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
	      case 'colgroup':
	        return tag === 'col' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
	      case 'table':
	        return tag === 'caption' || tag === 'colgroup' || tag === 'tbody' || tag === 'tfoot' || tag === 'thead' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
	      case 'head':
	        return tag === 'base' || tag === 'basefont' || tag === 'bgsound' || tag === 'link' || tag === 'meta' || tag === 'title' || tag === 'noscript' || tag === 'noframes' || tag === 'style' || tag === 'script' || tag === 'template';
	
	      // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
	      case 'html':
	        return tag === 'head' || tag === 'body';
	    }
	
	    // Probably in the "in body" parsing mode, so we outlaw only tag combos
	    // where the parsing rules cause implicit opens or closes to be added.
	    // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody
	    switch (tag) {
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return parentTag !== 'h1' && parentTag !== 'h2' && parentTag !== 'h3' && parentTag !== 'h4' && parentTag !== 'h5' && parentTag !== 'h6';
	
	      case 'rp':
	      case 'rt':
	        return impliedEndTags.indexOf(parentTag) === -1;
	
	      case 'caption':
	      case 'col':
	      case 'colgroup':
	      case 'frame':
	      case 'head':
	      case 'tbody':
	      case 'td':
	      case 'tfoot':
	      case 'th':
	      case 'thead':
	      case 'tr':
	        // These tags are only valid with a few parents that have special child
	        // parsing rules -- if we're down here, then none of those matched and
	        // so we allow it only if we don't know what the parent is, as all other
	        // cases are invalid.
	        return parentTag == null;
	    }
	
	    return true;
	  };
	
	  /**
	   * Returns whether
	   */
	  var findInvalidAncestorForTag = function findInvalidAncestorForTag(tag, ancestorInfo) {
	    switch (tag) {
	      case 'address':
	      case 'article':
	      case 'aside':
	      case 'blockquote':
	      case 'center':
	      case 'details':
	      case 'dialog':
	      case 'dir':
	      case 'div':
	      case 'dl':
	      case 'fieldset':
	      case 'figcaption':
	      case 'figure':
	      case 'footer':
	      case 'header':
	      case 'hgroup':
	      case 'main':
	      case 'menu':
	      case 'nav':
	      case 'ol':
	      case 'p':
	      case 'section':
	      case 'summary':
	      case 'ul':
	
	      case 'pre':
	      case 'listing':
	
	      case 'table':
	
	      case 'hr':
	
	      case 'xmp':
	
	      case 'h1':
	      case 'h2':
	      case 'h3':
	      case 'h4':
	      case 'h5':
	      case 'h6':
	        return ancestorInfo.pTagInButtonScope;
	
	      case 'form':
	        return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
	
	      case 'li':
	        return ancestorInfo.listItemTagAutoclosing;
	
	      case 'dd':
	      case 'dt':
	        return ancestorInfo.dlItemTagAutoclosing;
	
	      case 'button':
	        return ancestorInfo.buttonTagInScope;
	
	      case 'a':
	        // Spec says something about storing a list of markers, but it sounds
	        // equivalent to this check.
	        return ancestorInfo.aTagInScope;
	
	      case 'nobr':
	        return ancestorInfo.nobrTagInScope;
	    }
	
	    return null;
	  };
	
	  /**
	   * Given a ReactCompositeComponent instance, return a list of its recursive
	   * owners, starting at the root and ending with the instance itself.
	   */
	  var findOwnerStack = function findOwnerStack(instance) {
	    if (!instance) {
	      return [];
	    }
	
	    var stack = [];
	    /*eslint-disable space-after-keywords */
	    do {
	      /*eslint-enable space-after-keywords */
	      stack.push(instance);
	    } while (instance = instance._currentElement._owner);
	    stack.reverse();
	    return stack;
	  };
	
	  var didWarn = {};
	
	  validateDOMNesting = function validateDOMNesting(childTag, childInstance, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	
	    var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
	    var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
	    var problematic = invalidParent || invalidAncestor;
	
	    if (problematic) {
	      var ancestorTag = problematic.tag;
	      var ancestorInstance = problematic.instance;
	
	      var childOwner = childInstance && childInstance._currentElement._owner;
	      var ancestorOwner = ancestorInstance && ancestorInstance._currentElement._owner;
	
	      var childOwners = findOwnerStack(childOwner);
	      var ancestorOwners = findOwnerStack(ancestorOwner);
	
	      var minStackLen = Math.min(childOwners.length, ancestorOwners.length);
	      var i;
	
	      var deepestCommon = -1;
	      for (i = 0; i < minStackLen; i++) {
	        if (childOwners[i] === ancestorOwners[i]) {
	          deepestCommon = i;
	        } else {
	          break;
	        }
	      }
	
	      var UNKNOWN = '(unknown)';
	      var childOwnerNames = childOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ancestorOwnerNames = ancestorOwners.slice(deepestCommon + 1).map(function (inst) {
	        return inst.getName() || UNKNOWN;
	      });
	      var ownerInfo = [].concat(
	      // If the parent and child instances have a common owner ancestor, start
	      // with that -- otherwise we just start with the parent's owners.
	      deepestCommon !== -1 ? childOwners[deepestCommon].getName() || UNKNOWN : [], ancestorOwnerNames, ancestorTag,
	      // If we're warning about an invalid (non-parent) ancestry, add '...'
	      invalidAncestor ? ['...'] : [], childOwnerNames, childTag).join(' > ');
	
	      var warnKey = !!invalidParent + '|' + childTag + '|' + ancestorTag + '|' + ownerInfo;
	      if (didWarn[warnKey]) {
	        return;
	      }
	      didWarn[warnKey] = true;
	
	      if (invalidParent) {
	        var info = '';
	        if (ancestorTag === 'table' && childTag === 'tr') {
	          info += ' Add a <tbody> to your code to match the DOM tree generated by ' + 'the browser.';
	        }
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a child of <%s>. ' + 'See %s.%s', childTag, ancestorTag, ownerInfo, info) : undefined;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'validateDOMNesting(...): <%s> cannot appear as a descendant of ' + '<%s>. See %s.', childTag, ancestorTag, ownerInfo) : undefined;
	      }
	    }
	  };
	
	  validateDOMNesting.ancestorInfoContextKey = '__validateDOMNesting_ancestorInfo$' + Math.random().toString(36).slice(2);
	
	  validateDOMNesting.updatedAncestorInfo = updatedAncestorInfo;
	
	  // For testing
	  validateDOMNesting.isTagValidInContext = function (tag, ancestorInfo) {
	    ancestorInfo = ancestorInfo || emptyAncestorInfo;
	    var parentInfo = ancestorInfo.parentTag;
	    var parentTag = parentInfo && parentInfo.tag;
	    return isTagValidWithParent(tag, parentTag) && !findInvalidAncestorForTag(tag, ancestorInfo);
	  };
	}
	
	module.exports = validateDOMNesting;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultInjection
	 */
	
	'use strict';
	
	var BeforeInputEventPlugin = __webpack_require__(79);
	var ChangeEventPlugin = __webpack_require__(87);
	var ClientReactRootIndex = __webpack_require__(90);
	var DefaultEventPluginOrder = __webpack_require__(91);
	var EnterLeaveEventPlugin = __webpack_require__(92);
	var ExecutionEnvironment = __webpack_require__(16);
	var HTMLDOMPropertyConfig = __webpack_require__(96);
	var ReactBrowserComponentMixin = __webpack_require__(97);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactDOMComponent = __webpack_require__(100);
	var ReactDOMTextComponent = __webpack_require__(13);
	var ReactEventListener = __webpack_require__(125);
	var ReactInjection = __webpack_require__(128);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactReconcileTransaction = __webpack_require__(132);
	var SelectEventPlugin = __webpack_require__(137);
	var ServerReactRootIndex = __webpack_require__(138);
	var SimpleEventPlugin = __webpack_require__(139);
	var SVGDOMPropertyConfig = __webpack_require__(148);
	
	var alreadyInjected = false;
	
	function inject() {
	  if (alreadyInjected) {
	    // TODO: This is currently true because these injections are shared between
	    // the client and the server package. They should be built independently
	    // and not share any injection state. Then this problem will be solved.
	    return;
	  }
	  alreadyInjected = true;
	
	  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);
	
	  /**
	   * Inject modules for resolving DOM hierarchy and plugin ordering.
	   */
	  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
	  ReactInjection.EventPluginHub.injectInstanceHandle(ReactInstanceHandles);
	  ReactInjection.EventPluginHub.injectMount(ReactMount);
	
	  /**
	   * Some important event plugins included by default (without having to require
	   * them).
	   */
	  ReactInjection.EventPluginHub.injectEventPluginsByName({
	    SimpleEventPlugin: SimpleEventPlugin,
	    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
	    ChangeEventPlugin: ChangeEventPlugin,
	    SelectEventPlugin: SelectEventPlugin,
	    BeforeInputEventPlugin: BeforeInputEventPlugin
	  });
	
	  ReactInjection.NativeComponent.injectGenericComponentClass(ReactDOMComponent);
	
	  ReactInjection.NativeComponent.injectTextComponentClass(ReactDOMTextComponent);
	
	  ReactInjection.Class.injectMixin(ReactBrowserComponentMixin);
	
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
	  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);
	
	  ReactInjection.EmptyComponent.injectEmptyComponent('noscript');
	
	  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
	  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	
	  ReactInjection.RootIndex.injectCreateReactRootIndex(ExecutionEnvironment.canUseDOM ? ClientReactRootIndex.createReactRootIndex : ServerReactRootIndex.createReactRootIndex);
	
	  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
	
	  if (process.env.NODE_ENV !== 'production') {
	    var url = ExecutionEnvironment.canUseDOM && window.location.href || '';
	    if (/[?&]react_perf\b/.test(url)) {
	      var ReactDefaultPerf = __webpack_require__(149);
	      ReactDefaultPerf.start();
	    }
	  }
	}
	
	module.exports = {
	  inject: inject
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015 Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule BeforeInputEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var FallbackCompositionState = __webpack_require__(81);
	var SyntheticCompositionEvent = __webpack_require__(83);
	var SyntheticInputEvent = __webpack_require__(85);
	
	var keyOf = __webpack_require__(86);
	
	var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
	var START_KEYCODE = 229;
	
	var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;
	
	var documentMode = null;
	if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
	  documentMode = document.documentMode;
	}
	
	// Webkit offers a very useful `textInput` event that can be used to
	// directly represent `beforeInput`. The IE `textinput` event is not as
	// useful, so we don't use it.
	var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();
	
	// In IE9+, we have access to composition events, but the data supplied
	// by the native compositionend event may be incorrect. Japanese ideographic
	// spaces, for instance (\u3000) are not recorded correctly.
	var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
	
	/**
	 * Opera <= 12 includes TextEvent in window, but does not fire
	 * text input events. Rely on keypress instead.
	 */
	function isPresto() {
	  var opera = window.opera;
	  return (typeof opera === 'undefined' ? 'undefined' : _typeof(opera)) === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
	}
	
	var SPACEBAR_CODE = 32;
	var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	// Events and their corresponding property names.
	var eventTypes = {
	  beforeInput: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBeforeInput: null }),
	      captured: keyOf({ onBeforeInputCapture: null })
	    },
	    dependencies: [topLevelTypes.topCompositionEnd, topLevelTypes.topKeyPress, topLevelTypes.topTextInput, topLevelTypes.topPaste]
	  },
	  compositionEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionEnd: null }),
	      captured: keyOf({ onCompositionEndCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionEnd, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionStart: null }),
	      captured: keyOf({ onCompositionStartCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionStart, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  },
	  compositionUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCompositionUpdate: null }),
	      captured: keyOf({ onCompositionUpdateCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topCompositionUpdate, topLevelTypes.topKeyDown, topLevelTypes.topKeyPress, topLevelTypes.topKeyUp, topLevelTypes.topMouseDown]
	  }
	};
	
	// Track whether we've ever handled a keypress on the space key.
	var hasSpaceKeypress = false;
	
	/**
	 * Return whether a native keypress event is assumed to be a command.
	 * This is required because Firefox fires `keypress` events for key commands
	 * (cut, copy, select-all, etc.) even though no character is inserted.
	 */
	function isKeypressCommand(nativeEvent) {
	  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
	  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
	  !(nativeEvent.ctrlKey && nativeEvent.altKey);
	}
	
	/**
	 * Translate native top level events into event types.
	 *
	 * @param {string} topLevelType
	 * @return {object}
	 */
	function getCompositionEventType(topLevelType) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionStart:
	      return eventTypes.compositionStart;
	    case topLevelTypes.topCompositionEnd:
	      return eventTypes.compositionEnd;
	    case topLevelTypes.topCompositionUpdate:
	      return eventTypes.compositionUpdate;
	  }
	}
	
	/**
	 * Does our fallback best-guess model think this event signifies that
	 * composition has begun?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionStart(topLevelType, nativeEvent) {
	  return topLevelType === topLevelTypes.topKeyDown && nativeEvent.keyCode === START_KEYCODE;
	}
	
	/**
	 * Does our fallback mode think that this event is the end of composition?
	 *
	 * @param {string} topLevelType
	 * @param {object} nativeEvent
	 * @return {boolean}
	 */
	function isFallbackCompositionEnd(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topKeyUp:
	      // Command keys insert or clear IME input.
	      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
	    case topLevelTypes.topKeyDown:
	      // Expect IME keyCode on each keydown. If we get any other
	      // code we must have exited earlier.
	      return nativeEvent.keyCode !== START_KEYCODE;
	    case topLevelTypes.topKeyPress:
	    case topLevelTypes.topMouseDown:
	    case topLevelTypes.topBlur:
	      // Events are not possible without cancelling IME.
	      return true;
	    default:
	      return false;
	  }
	}
	
	/**
	 * Google Input Tools provides composition data via a CustomEvent,
	 * with the `data` property populated in the `detail` object. If this
	 * is available on the event object, use it. If not, this is a plain
	 * composition event and we have nothing special to extract.
	 *
	 * @param {object} nativeEvent
	 * @return {?string}
	 */
	function getDataFromCustomEvent(nativeEvent) {
	  var detail = nativeEvent.detail;
	  if ((typeof detail === 'undefined' ? 'undefined' : _typeof(detail)) === 'object' && 'data' in detail) {
	    return detail.data;
	  }
	  return null;
	}
	
	// Track the current IME composition fallback object, if any.
	var currentComposition = null;
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticCompositionEvent.
	 */
	function extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var eventType;
	  var fallbackData;
	
	  if (canUseCompositionEvent) {
	    eventType = getCompositionEventType(topLevelType);
	  } else if (!currentComposition) {
	    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
	      eventType = eventTypes.compositionStart;
	    }
	  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	    eventType = eventTypes.compositionEnd;
	  }
	
	  if (!eventType) {
	    return null;
	  }
	
	  if (useFallbackCompositionData) {
	    // The current composition is stored statically and must not be
	    // overwritten while composition continues.
	    if (!currentComposition && eventType === eventTypes.compositionStart) {
	      currentComposition = FallbackCompositionState.getPooled(topLevelTarget);
	    } else if (eventType === eventTypes.compositionEnd) {
	      if (currentComposition) {
	        fallbackData = currentComposition.getData();
	      }
	    }
	  }
	
	  var event = SyntheticCompositionEvent.getPooled(eventType, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  if (fallbackData) {
	    // Inject data generated from fallback path into the synthetic event.
	    // This matches the property of native CompositionEventInterface.
	    event.data = fallbackData;
	  } else {
	    var customData = getDataFromCustomEvent(nativeEvent);
	    if (customData !== null) {
	      event.data = customData;
	    }
	  }
	
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The string corresponding to this `beforeInput` event.
	 */
	function getNativeBeforeInputChars(topLevelType, nativeEvent) {
	  switch (topLevelType) {
	    case topLevelTypes.topCompositionEnd:
	      return getDataFromCustomEvent(nativeEvent);
	    case topLevelTypes.topKeyPress:
	      /**
	       * If native `textInput` events are available, our goal is to make
	       * use of them. However, there is a special case: the spacebar key.
	       * In Webkit, preventing default on a spacebar `textInput` event
	       * cancels character insertion, but it *also* causes the browser
	       * to fall back to its default spacebar behavior of scrolling the
	       * page.
	       *
	       * Tracking at:
	       * https://code.google.com/p/chromium/issues/detail?id=355103
	       *
	       * To avoid this issue, use the keypress event as if no `textInput`
	       * event is available.
	       */
	      var which = nativeEvent.which;
	      if (which !== SPACEBAR_CODE) {
	        return null;
	      }
	
	      hasSpaceKeypress = true;
	      return SPACEBAR_CHAR;
	
	    case topLevelTypes.topTextInput:
	      // Record the characters to be added to the DOM.
	      var chars = nativeEvent.data;
	
	      // If it's a spacebar character, assume that we have already handled
	      // it at the keypress level and bail immediately. Android Chrome
	      // doesn't give us keycodes, so we need to blacklist it.
	      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
	        return null;
	      }
	
	      return chars;
	
	    default:
	      // For other native event types, do nothing.
	      return null;
	  }
	}
	
	/**
	 * For browsers that do not provide the `textInput` event, extract the
	 * appropriate string to use for SyntheticInputEvent.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?string} The fallback string for this `beforeInput` event.
	 */
	function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
	  // If we are currently composing (IME) and using a fallback to do so,
	  // try to extract the composed characters from the fallback object.
	  if (currentComposition) {
	    if (topLevelType === topLevelTypes.topCompositionEnd || isFallbackCompositionEnd(topLevelType, nativeEvent)) {
	      var chars = currentComposition.getData();
	      FallbackCompositionState.release(currentComposition);
	      currentComposition = null;
	      return chars;
	    }
	    return null;
	  }
	
	  switch (topLevelType) {
	    case topLevelTypes.topPaste:
	      // If a paste event occurs after a keypress, throw out the input
	      // chars. Paste events should not lead to BeforeInput events.
	      return null;
	    case topLevelTypes.topKeyPress:
	      /**
	       * As of v27, Firefox may fire keypress events even when no character
	       * will be inserted. A few possibilities:
	       *
	       * - `which` is `0`. Arrow keys, Esc key, etc.
	       *
	       * - `which` is the pressed key code, but no char is available.
	       *   Ex: 'AltGr + d` in Polish. There is no modified character for
	       *   this key combination and no character is inserted into the
	       *   document, but FF fires the keypress for char code `100` anyway.
	       *   No `input` event will occur.
	       *
	       * - `which` is the pressed key code, but a command combination is
	       *   being used. Ex: `Cmd+C`. No character is inserted, and no
	       *   `input` event will occur.
	       */
	      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
	        return String.fromCharCode(nativeEvent.which);
	      }
	      return null;
	    case topLevelTypes.topCompositionEnd:
	      return useFallbackCompositionData ? null : nativeEvent.data;
	    default:
	      return null;
	  }
	}
	
	/**
	 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
	 * `textInput` or fallback behavior.
	 *
	 * @param {string} topLevelType Record from `EventConstants`.
	 * @param {DOMEventTarget} topLevelTarget The listening component root node.
	 * @param {string} topLevelTargetID ID of `topLevelTarget`.
	 * @param {object} nativeEvent Native browser event.
	 * @return {?object} A SyntheticInputEvent.
	 */
	function extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	  var chars;
	
	  if (canUseTextInputEvent) {
	    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
	  } else {
	    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
	  }
	
	  // If no characters are being inserted, no BeforeInput event should
	  // be fired.
	  if (!chars) {
	    return null;
	  }
	
	  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, topLevelTargetID, nativeEvent, nativeEventTarget);
	
	  event.data = chars;
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	  return event;
	}
	
	/**
	 * Create an `onBeforeInput` event to match
	 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
	 *
	 * This event plugin is based on the native `textInput` event
	 * available in Chrome, Safari, Opera, and IE. This event fires after
	 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
	 *
	 * `beforeInput` is spec'd but not implemented in any browsers, and
	 * the `input` event does not provide any useful information about what has
	 * actually been added, contrary to the spec. Thus, `textInput` is the best
	 * available event to identify the characters that have actually been inserted
	 * into the target node.
	 *
	 * This plugin is also responsible for emitting `composition` events, thus
	 * allowing us to share composition fallback code for both `beforeInput` and
	 * `composition` event types.
	 */
	var BeforeInputEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    return [extractCompositionEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget)];
	  }
	};
	
	module.exports = BeforeInputEventPlugin;

/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EventPropagators
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	
	var warning = __webpack_require__(32);
	
	var accumulateInto = __webpack_require__(42);
	var forEachAccumulated = __webpack_require__(43);
	
	var PropagationPhases = EventConstants.PropagationPhases;
	var getListener = EventPluginHub.getListener;
	
	/**
	 * Some event types have a notion of different registration names for different
	 * "phases" of propagation. This finds listeners by a given phase.
	 */
	function listenerAtPhase(id, event, propagationPhase) {
	  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
	  return getListener(id, registrationName);
	}
	
	/**
	 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
	 * here, allows us to not have to bind or create functions for each event.
	 * Mutating the event's members allows us to not have to create a wrapping
	 * "dispatch" object that pairs the event with the listener.
	 */
	function accumulateDirectionalDispatches(domID, upwards, event) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;
	  }
	  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;
	  var listener = listenerAtPhase(domID, event, phase);
	  if (listener) {
	    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);
	  }
	}
	
	/**
	 * Collect dispatches (must be entirely collected before dispatching - see unit
	 * tests). Lazily allocate the array to conserve memory.  We must loop through
	 * each event and perform the traversal for each one. We cannot perform a
	 * single traversal for the entire collection of events because each event may
	 * have a different target.
	 */
	function accumulateTwoPhaseDispatchesSingle(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
	 */
	function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
	  if (event && event.dispatchConfig.phasedRegistrationNames) {
	    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);
	  }
	}
	
	/**
	 * Accumulates without regard to direction, does not look for phased
	 * registration names. Same as `accumulateDirectDispatchesSingle` but without
	 * requiring that the `dispatchMarker` be the same as the dispatched ID.
	 */
	function accumulateDispatches(id, ignoredDirection, event) {
	  if (event && event.dispatchConfig.registrationName) {
	    var registrationName = event.dispatchConfig.registrationName;
	    var listener = getListener(id, registrationName);
	    if (listener) {
	      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
	      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);
	    }
	  }
	}
	
	/**
	 * Accumulates dispatches on an `SyntheticEvent`, but only for the
	 * `dispatchMarker`.
	 * @param {SyntheticEvent} event
	 */
	function accumulateDirectDispatchesSingle(event) {
	  if (event && event.dispatchConfig.registrationName) {
	    accumulateDispatches(event.dispatchMarker, null, event);
	  }
	}
	
	function accumulateTwoPhaseDispatches(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
	}
	
	function accumulateTwoPhaseDispatchesSkipTarget(events) {
	  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
	}
	
	function accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {
	  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);
	}
	
	function accumulateDirectDispatches(events) {
	  forEachAccumulated(events, accumulateDirectDispatchesSingle);
	}
	
	/**
	 * A small set of propagation patterns, each of which will accept a small amount
	 * of information, and generate a set of "dispatch ready event objects" - which
	 * are sets of events that have already been annotated with a set of dispatched
	 * listener functions/ids. The API is designed this way to discourage these
	 * propagation strategies from actually executing the dispatches, since we
	 * always want to collect the entire set of dispatches before executing event a
	 * single one.
	 *
	 * @constructor EventPropagators
	 */
	var EventPropagators = {
	  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
	  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
	  accumulateDirectDispatches: accumulateDirectDispatches,
	  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
	};
	
	module.exports = EventPropagators;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule FallbackCompositionState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * This helper class stores information about text content of a target node,
	 * allowing comparison of content before and after a given event.
	 *
	 * Identify the node where selection currently begins, then observe
	 * both its text content and its current position in the DOM. Since the
	 * browser may natively replace the target node during composition, we can
	 * use its position to find its replacement.
	 *
	 * @param {DOMEventTarget} root
	 */
	function FallbackCompositionState(root) {
	  this._root = root;
	  this._startText = this.getText();
	  this._fallbackText = null;
	}
	
	assign(FallbackCompositionState.prototype, {
	  destructor: function destructor() {
	    this._root = null;
	    this._startText = null;
	    this._fallbackText = null;
	  },
	
	  /**
	   * Get current text of input.
	   *
	   * @return {string}
	   */
	  getText: function getText() {
	    if ('value' in this._root) {
	      return this._root.value;
	    }
	    return this._root[getTextContentAccessor()];
	  },
	
	  /**
	   * Determine the differing substring between the initially stored
	   * text content and the current content.
	   *
	   * @return {string}
	   */
	  getData: function getData() {
	    if (this._fallbackText) {
	      return this._fallbackText;
	    }
	
	    var start;
	    var startValue = this._startText;
	    var startLength = startValue.length;
	    var end;
	    var endValue = this.getText();
	    var endLength = endValue.length;
	
	    for (start = 0; start < startLength; start++) {
	      if (startValue[start] !== endValue[start]) {
	        break;
	      }
	    }
	
	    var minEnd = startLength - start;
	    for (end = 1; end <= minEnd; end++) {
	      if (startValue[startLength - end] !== endValue[endLength - end]) {
	        break;
	      }
	    }
	
	    var sliceTail = end > 1 ? 1 - end : undefined;
	    this._fallbackText = endValue.slice(start, sliceTail);
	    return this._fallbackText;
	  }
	});
	
	PooledClass.addPoolingTo(FallbackCompositionState);
	
	module.exports = FallbackCompositionState;

/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getTextContentAccessor
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var contentKey = null;
	
	/**
	 * Gets the key used to access text content on a DOM node.
	 *
	 * @return {?string} Key used to access text content.
	 * @internal
	 */
	function getTextContentAccessor() {
	  if (!contentKey && ExecutionEnvironment.canUseDOM) {
	    // Prefer textContent to innerText because many browsers support both but
	    // SVG <text> elements don't support innerText even when <div> does.
	    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
	  }
	  return contentKey;
	}
	
	module.exports = getTextContentAccessor;

/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticCompositionEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
	 */
	var CompositionEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);
	
	module.exports = SyntheticCompositionEvent;

/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	var warning = __webpack_require__(32);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var EventInterface = {
	  type: null,
	  target: null,
	  // currentTarget is set when dispatching; no use in copying it here
	  currentTarget: emptyFunction.thatReturnsNull,
	  eventPhase: null,
	  bubbles: null,
	  cancelable: null,
	  timeStamp: function timeStamp(event) {
	    return event.timeStamp || Date.now();
	  },
	  defaultPrevented: null,
	  isTrusted: null
	};
	
	/**
	 * Synthetic events are dispatched by event plugins, typically in response to a
	 * top-level event delegation handler.
	 *
	 * These systems should generally use pooling to reduce the frequency of garbage
	 * collection. The system should check `isPersistent` to determine whether the
	 * event should be released into the pool after being dispatched. Users that
	 * need a persisted event should invoke `persist`.
	 *
	 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
	 * normalizing browser quirks. Subclasses do not necessarily have to implement a
	 * DOM interface; custom application-specific events can also subclass this.
	 *
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 */
	function SyntheticEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  this.dispatchConfig = dispatchConfig;
	  this.dispatchMarker = dispatchMarker;
	  this.nativeEvent = nativeEvent;
	
	  var Interface = this.constructor.Interface;
	  for (var propName in Interface) {
	    if (!Interface.hasOwnProperty(propName)) {
	      continue;
	    }
	    var normalize = Interface[propName];
	    if (normalize) {
	      this[propName] = normalize(nativeEvent);
	    } else {
	      if (propName === 'target') {
	        this.target = nativeEventTarget;
	      } else {
	        this[propName] = nativeEvent[propName];
	      }
	    }
	  }
	
	  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
	  if (defaultPrevented) {
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  } else {
	    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
	  }
	  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
	}
	
	assign(SyntheticEvent.prototype, {
	
	  preventDefault: function preventDefault() {
	    this.defaultPrevented = true;
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `preventDefault` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.preventDefault) {
	      event.preventDefault();
	    } else {
	      event.returnValue = false;
	    }
	    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
	  },
	
	  stopPropagation: function stopPropagation() {
	    var event = this.nativeEvent;
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(event, 'This synthetic event is reused for performance reasons. If you\'re ' + 'seeing this, you\'re calling `stopPropagation` on a ' + 'released/nullified synthetic event. This is a no-op. See ' + 'https://fb.me/react-event-pooling for more information.') : undefined;
	    }
	    if (!event) {
	      return;
	    }
	
	    if (event.stopPropagation) {
	      event.stopPropagation();
	    } else {
	      event.cancelBubble = true;
	    }
	    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * We release all dispatched `SyntheticEvent`s after each event loop, adding
	   * them back into the pool. This allows a way to hold onto a reference that
	   * won't be added back into the pool.
	   */
	  persist: function persist() {
	    this.isPersistent = emptyFunction.thatReturnsTrue;
	  },
	
	  /**
	   * Checks if this event should be released back into the pool.
	   *
	   * @return {boolean} True if this should not be released, false otherwise.
	   */
	  isPersistent: emptyFunction.thatReturnsFalse,
	
	  /**
	   * `PooledClass` looks for `destructor` on each instance it releases.
	   */
	  destructor: function destructor() {
	    var Interface = this.constructor.Interface;
	    for (var propName in Interface) {
	      this[propName] = null;
	    }
	    this.dispatchConfig = null;
	    this.dispatchMarker = null;
	    this.nativeEvent = null;
	  }
	
	});
	
	SyntheticEvent.Interface = EventInterface;
	
	/**
	 * Helper to reduce boilerplate when creating subclasses.
	 *
	 * @param {function} Class
	 * @param {?object} Interface
	 */
	SyntheticEvent.augmentClass = function (Class, Interface) {
	  var Super = this;
	
	  var prototype = Object.create(Super.prototype);
	  assign(prototype, Class.prototype);
	  Class.prototype = prototype;
	  Class.prototype.constructor = Class;
	
	  Class.Interface = assign({}, Super.Interface, Interface);
	  Class.augmentClass = Super.augmentClass;
	
	  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
	};
	
	PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);
	
	module.exports = SyntheticEvent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticInputEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
	 *      /#events-inputevents
	 */
	var InputEventInterface = {
	  data: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);
	
	module.exports = SyntheticInputEvent;

/***/ },
/* 86 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule keyOf
	 */
	
	/**
	 * Allows extraction of a minified key. Let's the build system minify keys
	 * without losing the ability to dynamically use key strings as values
	 * themselves. Pass in an object with a single key/val pair and it will return
	 * you the string key of that single record. Suppose you want to grab the
	 * value for a key 'className' inside of an object. Key/val minification may
	 * have aliased that key to be 'xa12'. keyOf({className: null}) will return
	 * 'xa12' in that case. Resolve keys you want to use once at startup time, then
	 * reuse those resolutions.
	 */
	"use strict";
	
	var keyOf = function keyOf(oneKeyObj) {
	  var key;
	  for (key in oneKeyObj) {
	    if (!oneKeyObj.hasOwnProperty(key)) {
	      continue;
	    }
	    return key;
	  }
	  return null;
	};
	
	module.exports = keyOf;

/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ChangeEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPluginHub = __webpack_require__(38);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactUpdates = __webpack_require__(61);
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	var isEventSupported = __webpack_require__(47);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  change: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onChange: null }),
	      captured: keyOf({ onChangeCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topChange, topLevelTypes.topClick, topLevelTypes.topFocus, topLevelTypes.topInput, topLevelTypes.topKeyDown, topLevelTypes.topKeyUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	/**
	 * For IE shims
	 */
	var activeElement = null;
	var activeElementID = null;
	var activeElementValue = null;
	var activeElementValueProp = null;
	
	/**
	 * SECTION: handle `change` event
	 */
	function shouldUseChangeEvent(elem) {
	  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
	}
	
	var doesChangeEventBubble = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // See `handleChange` comment below
	  doesChangeEventBubble = isEventSupported('change') && (!('documentMode' in document) || document.documentMode > 8);
	}
	
	function manualDispatchChangeEvent(nativeEvent) {
	  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementID, nativeEvent, getEventTarget(nativeEvent));
	  EventPropagators.accumulateTwoPhaseDispatches(event);
	
	  // If change and propertychange bubbled, we'd just bind to it like all the
	  // other events and have it go through ReactBrowserEventEmitter. Since it
	  // doesn't, we manually listen for the events and so we have to enqueue and
	  // process the abstract event manually.
	  //
	  // Batching is necessary here in order to ensure that all event handlers run
	  // before the next rerender (including event handlers attached to ancestor
	  // elements instead of directly on the input). Without this, controlled
	  // components don't work properly in conjunction with event bubbling because
	  // the component is rerendered and the value reverted before all the event
	  // handlers can run. See https://github.com/facebook/react/issues/708.
	  ReactUpdates.batchedUpdates(runEventInBatch, event);
	}
	
	function runEventInBatch(event) {
	  EventPluginHub.enqueueEvents(event);
	  EventPluginHub.processEventQueue(false);
	}
	
	function startWatchingForChangeEventIE8(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
	}
	
	function stopWatchingForChangeEventIE8() {
	  if (!activeElement) {
	    return;
	  }
	  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
	  activeElement = null;
	  activeElementID = null;
	}
	
	function getTargetIDForChangeEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topChange) {
	    return topLevelTargetID;
	  }
	}
	function handleEventsForChangeEventIE8(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForChangeEventIE8();
	    startWatchingForChangeEventIE8(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForChangeEventIE8();
	  }
	}
	
	/**
	 * SECTION: handle `input` event
	 */
	var isInputEventSupported = false;
	if (ExecutionEnvironment.canUseDOM) {
	  // IE9 claims to support the input event but fails to trigger it when
	  // deleting text, so we ignore its input events
	  isInputEventSupported = isEventSupported('input') && (!('documentMode' in document) || document.documentMode > 9);
	}
	
	/**
	 * (For old IE.) Replacement getter/setter for the `value` property that gets
	 * set on the active element.
	 */
	var newValueProp = {
	  get: function get() {
	    return activeElementValueProp.get.call(this);
	  },
	  set: function set(val) {
	    // Cast to a string so we can do equality checks.
	    activeElementValue = '' + val;
	    activeElementValueProp.set.call(this, val);
	  }
	};
	
	/**
	 * (For old IE.) Starts tracking propertychange events on the passed-in element
	 * and override the value property so that we can distinguish user events from
	 * value changes in JS.
	 */
	function startWatchingForValueChange(target, targetID) {
	  activeElement = target;
	  activeElementID = targetID;
	  activeElementValue = target.value;
	  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');
	
	  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
	  // on DOM elements
	  Object.defineProperty(activeElement, 'value', newValueProp);
	  activeElement.attachEvent('onpropertychange', handlePropertyChange);
	}
	
	/**
	 * (For old IE.) Removes the event listeners from the currently-tracked element,
	 * if any exists.
	 */
	function stopWatchingForValueChange() {
	  if (!activeElement) {
	    return;
	  }
	
	  // delete restores the original property definition
	  delete activeElement.value;
	  activeElement.detachEvent('onpropertychange', handlePropertyChange);
	
	  activeElement = null;
	  activeElementID = null;
	  activeElementValue = null;
	  activeElementValueProp = null;
	}
	
	/**
	 * (For old IE.) Handles a propertychange event, sending a `change` event if
	 * the value of the active element has changed.
	 */
	function handlePropertyChange(nativeEvent) {
	  if (nativeEvent.propertyName !== 'value') {
	    return;
	  }
	  var value = nativeEvent.srcElement.value;
	  if (value === activeElementValue) {
	    return;
	  }
	  activeElementValue = value;
	
	  manualDispatchChangeEvent(nativeEvent);
	}
	
	/**
	 * If a `change` event should be fired, returns the target's ID.
	 */
	function getTargetIDForInputEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topInput) {
	    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
	    // what we want so fall through here and trigger an abstract event
	    return topLevelTargetID;
	  }
	}
	
	// For IE8 and IE9.
	function handleEventsForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topFocus) {
	    // In IE8, we can capture almost all .value changes by adding a
	    // propertychange handler and looking for events with propertyName
	    // equal to 'value'
	    // In IE9, propertychange fires for most input events but is buggy and
	    // doesn't fire when text is deleted, but conveniently, selectionchange
	    // appears to fire in all of the remaining cases so we catch those and
	    // forward the event if the value has changed
	    // In either case, we don't want to call the event handler if the value
	    // is changed from JS so we redefine a setter for `.value` that updates
	    // our activeElementValue variable, allowing us to ignore those changes
	    //
	    // stopWatching() should be a noop here but we call it just in case we
	    // missed a blur event somehow.
	    stopWatchingForValueChange();
	    startWatchingForValueChange(topLevelTarget, topLevelTargetID);
	  } else if (topLevelType === topLevelTypes.topBlur) {
	    stopWatchingForValueChange();
	  }
	}
	
	// For IE8 and IE9.
	function getTargetIDForInputEventIE(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topSelectionChange || topLevelType === topLevelTypes.topKeyUp || topLevelType === topLevelTypes.topKeyDown) {
	    // On the selectionchange event, the target is just document which isn't
	    // helpful for us so just check activeElement instead.
	    //
	    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
	    // propertychange on the first input event after setting `value` from a
	    // script and fires only keydown, keypress, keyup. Catching keyup usually
	    // gets it and catching keydown lets us fire an event for the first
	    // keystroke if user does a key repeat (it'll be a little delayed: right
	    // before the second keystroke). Other input methods (e.g., paste) seem to
	    // fire selectionchange normally.
	    if (activeElement && activeElement.value !== activeElementValue) {
	      activeElementValue = activeElement.value;
	      return activeElementID;
	    }
	  }
	}
	
	/**
	 * SECTION: handle `click` event
	 */
	function shouldUseClickEvent(elem) {
	  // Use the `click` event to detect changes to checkbox and radio inputs.
	  // This approach works across all browsers, whereas `change` does not fire
	  // until `blur` in IE8.
	  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
	}
	
	function getTargetIDForClickEvent(topLevelType, topLevelTarget, topLevelTargetID) {
	  if (topLevelType === topLevelTypes.topClick) {
	    return topLevelTargetID;
	  }
	}
	
	/**
	 * This plugin creates an `onChange` event that normalizes change events
	 * across form elements. This event fires at a time when it's possible to
	 * change the element's value without seeing a flicker.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - select
	 */
	var ChangeEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	
	    var getTargetIDFunc, handleEventFunc;
	    if (shouldUseChangeEvent(topLevelTarget)) {
	      if (doesChangeEventBubble) {
	        getTargetIDFunc = getTargetIDForChangeEvent;
	      } else {
	        handleEventFunc = handleEventsForChangeEventIE8;
	      }
	    } else if (isTextInputElement(topLevelTarget)) {
	      if (isInputEventSupported) {
	        getTargetIDFunc = getTargetIDForInputEvent;
	      } else {
	        getTargetIDFunc = getTargetIDForInputEventIE;
	        handleEventFunc = handleEventsForInputEventIE;
	      }
	    } else if (shouldUseClickEvent(topLevelTarget)) {
	      getTargetIDFunc = getTargetIDForClickEvent;
	    }
	
	    if (getTargetIDFunc) {
	      var targetID = getTargetIDFunc(topLevelType, topLevelTarget, topLevelTargetID);
	      if (targetID) {
	        var event = SyntheticEvent.getPooled(eventTypes.change, targetID, nativeEvent, nativeEventTarget);
	        event.type = 'change';
	        EventPropagators.accumulateTwoPhaseDispatches(event);
	        return event;
	      }
	    }
	
	    if (handleEventFunc) {
	      handleEventFunc(topLevelType, topLevelTarget, topLevelTargetID);
	    }
	  }
	
	};
	
	module.exports = ChangeEventPlugin;

/***/ },
/* 88 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventTarget
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Gets the target node from a native browser event by accounting for
	 * inconsistencies in browser DOM APIs.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {DOMEventTarget} Target node.
	 */
	
	function getEventTarget(nativeEvent) {
	  var target = nativeEvent.target || nativeEvent.srcElement || window;
	  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
	  // @see http://www.quirksmode.org/js/events_properties.html
	  return target.nodeType === 3 ? target.parentNode : target;
	}
	
	module.exports = getEventTarget;

/***/ },
/* 89 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule isTextInputElement
	 */
	
	'use strict';
	
	/**
	 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
	 */
	
	var supportedInputTypes = {
	  'color': true,
	  'date': true,
	  'datetime': true,
	  'datetime-local': true,
	  'email': true,
	  'month': true,
	  'number': true,
	  'password': true,
	  'range': true,
	  'search': true,
	  'tel': true,
	  'text': true,
	  'time': true,
	  'url': true,
	  'week': true
	};
	
	function isTextInputElement(elem) {
	  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	  return nodeName && (nodeName === 'input' && supportedInputTypes[elem.type] || nodeName === 'textarea');
	}
	
	module.exports = isTextInputElement;

/***/ },
/* 90 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ClientReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	var nextReactRootIndex = 0;
	
	var ClientReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return nextReactRootIndex++;
	  }
	};
	
	module.exports = ClientReactRootIndex;

/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule DefaultEventPluginOrder
	 */
	
	'use strict';
	
	var keyOf = __webpack_require__(86);
	
	/**
	 * Module that is injectable into `EventPluginHub`, that specifies a
	 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
	 * plugins, without having to package every one of them. This is better than
	 * having plugins be ordered in the same order that they are injected because
	 * that ordering would be influenced by the packaging order.
	 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
	 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
	 */
	var DefaultEventPluginOrder = [keyOf({ ResponderEventPlugin: null }), keyOf({ SimpleEventPlugin: null }), keyOf({ TapEventPlugin: null }), keyOf({ EnterLeaveEventPlugin: null }), keyOf({ ChangeEventPlugin: null }), keyOf({ SelectEventPlugin: null }), keyOf({ BeforeInputEventPlugin: null })];
	
	module.exports = DefaultEventPluginOrder;

/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule EnterLeaveEventPlugin
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var SyntheticMouseEvent = __webpack_require__(93);
	
	var ReactMount = __webpack_require__(35);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	var getFirstReactDOM = ReactMount.getFirstReactDOM;
	
	var eventTypes = {
	  mouseEnter: {
	    registrationName: keyOf({ onMouseEnter: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  },
	  mouseLeave: {
	    registrationName: keyOf({ onMouseLeave: null }),
	    dependencies: [topLevelTypes.topMouseOut, topLevelTypes.topMouseOver]
	  }
	};
	
	var extractedEvents = [null, null];
	
	var EnterLeaveEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * For almost every interaction we care about, there will be both a top-level
	   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
	   * we do not extract duplicate events. However, moving the mouse into the
	   * browser from outside will not fire a `mouseout` event. In this case, we use
	   * the `mouseover` top-level event.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (topLevelType === topLevelTypes.topMouseOver && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
	      return null;
	    }
	    if (topLevelType !== topLevelTypes.topMouseOut && topLevelType !== topLevelTypes.topMouseOver) {
	      // Must not be a mouse in or mouse out - ignoring.
	      return null;
	    }
	
	    var win;
	    if (topLevelTarget.window === topLevelTarget) {
	      // `topLevelTarget` is probably a window object.
	      win = topLevelTarget;
	    } else {
	      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	      var doc = topLevelTarget.ownerDocument;
	      if (doc) {
	        win = doc.defaultView || doc.parentWindow;
	      } else {
	        win = window;
	      }
	    }
	
	    var from;
	    var to;
	    var fromID = '';
	    var toID = '';
	    if (topLevelType === topLevelTypes.topMouseOut) {
	      from = topLevelTarget;
	      fromID = topLevelTargetID;
	      to = getFirstReactDOM(nativeEvent.relatedTarget || nativeEvent.toElement);
	      if (to) {
	        toID = ReactMount.getID(to);
	      } else {
	        to = win;
	      }
	      to = to || win;
	    } else {
	      from = win;
	      to = topLevelTarget;
	      toID = topLevelTargetID;
	    }
	
	    if (from === to) {
	      // Nothing pertains to our managed components.
	      return null;
	    }
	
	    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, fromID, nativeEvent, nativeEventTarget);
	    leave.type = 'mouseleave';
	    leave.target = from;
	    leave.relatedTarget = to;
	
	    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, toID, nativeEvent, nativeEventTarget);
	    enter.type = 'mouseenter';
	    enter.target = to;
	    enter.relatedTarget = from;
	
	    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, fromID, toID);
	
	    extractedEvents[0] = leave;
	    extractedEvents[1] = enter;
	
	    return extractedEvents;
	  }
	
	};
	
	module.exports = EnterLeaveEventPlugin;

/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticMouseEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	var ViewportMetrics = __webpack_require__(45);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface MouseEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var MouseEventInterface = {
	  screenX: null,
	  screenY: null,
	  clientX: null,
	  clientY: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  getModifierState: getEventModifierState,
	  button: function button(event) {
	    // Webkit, Firefox, IE9+
	    // which:  1 2 3
	    // button: 0 1 2 (standard)
	    var button = event.button;
	    if ('which' in event) {
	      return button;
	    }
	    // IE<9
	    // which:  undefined
	    // button: 0 0 0
	    // button: 1 4 2 (onmouseup)
	    return button === 2 ? 2 : button === 4 ? 1 : 0;
	  },
	  buttons: null,
	  relatedTarget: function relatedTarget(event) {
	    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
	  },
	  // "Proprietary" Interface.
	  pageX: function pageX(event) {
	    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
	  },
	  pageY: function pageY(event) {
	    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);
	
	module.exports = SyntheticMouseEvent;

/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticUIEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	var getEventTarget = __webpack_require__(88);
	
	/**
	 * @interface UIEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var UIEventInterface = {
	  view: function view(event) {
	    if (event.view) {
	      return event.view;
	    }
	
	    var target = getEventTarget(event);
	    if (target != null && target.window === target) {
	      // target is a window object
	      return target;
	    }
	
	    var doc = target.ownerDocument;
	    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
	    if (doc) {
	      return doc.defaultView || doc.parentWindow;
	    } else {
	      return window;
	    }
	  },
	  detail: function detail(event) {
	    return event.detail || 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticEvent}
	 */
	function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);
	
	module.exports = SyntheticUIEvent;

/***/ },
/* 95 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventModifierState
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Translation from modifier key to the associated property in the event.
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
	 */
	
	var modifierKeyToProp = {
	  'Alt': 'altKey',
	  'Control': 'ctrlKey',
	  'Meta': 'metaKey',
	  'Shift': 'shiftKey'
	};
	
	// IE8 does not implement getModifierState so we simply map it to the only
	// modifier keys exposed by the event itself, does not support Lock-keys.
	// Currently, all major browsers except Chrome seems to support Lock-keys.
	function modifierStateGetter(keyArg) {
	  var syntheticEvent = this;
	  var nativeEvent = syntheticEvent.nativeEvent;
	  if (nativeEvent.getModifierState) {
	    return nativeEvent.getModifierState(keyArg);
	  }
	  var keyProp = modifierKeyToProp[keyArg];
	  return keyProp ? !!nativeEvent[keyProp] : false;
	}
	
	function getEventModifierState(nativeEvent) {
	  return modifierStateGetter;
	}
	
	module.exports = getEventModifierState;

/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule HTMLDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var ExecutionEnvironment = __webpack_require__(16);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
	var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
	var HAS_SIDE_EFFECTS = DOMProperty.injection.HAS_SIDE_EFFECTS;
	var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
	var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
	var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;
	
	var hasSVG;
	if (ExecutionEnvironment.canUseDOM) {
	  var implementation = document.implementation;
	  hasSVG = implementation && implementation.hasFeature && implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#BasicStructure', '1.1');
	}
	
	var HTMLDOMPropertyConfig = {
	  isCustomAttribute: RegExp.prototype.test.bind(/^(data|aria)-[a-z_][a-z\d_.\-]*$/),
	  Properties: {
	    /**
	     * Standard Properties
	     */
	    accept: null,
	    acceptCharset: null,
	    accessKey: null,
	    action: null,
	    allowFullScreen: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    allowTransparency: MUST_USE_ATTRIBUTE,
	    alt: null,
	    async: HAS_BOOLEAN_VALUE,
	    autoComplete: null,
	    // autoFocus is polyfilled/normalized by AutoFocusUtils
	    // autoFocus: HAS_BOOLEAN_VALUE,
	    autoPlay: HAS_BOOLEAN_VALUE,
	    capture: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    cellPadding: null,
	    cellSpacing: null,
	    charSet: MUST_USE_ATTRIBUTE,
	    challenge: MUST_USE_ATTRIBUTE,
	    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    classID: MUST_USE_ATTRIBUTE,
	    // To set className on SVG elements, it's necessary to use .setAttribute;
	    // this works on HTML elements too in all browsers except IE8. Conveniently,
	    // IE8 doesn't support SVG and so we can simply use the attribute in
	    // browsers that support SVG and the property in browsers that don't,
	    // regardless of whether the element is HTML or SVG.
	    className: hasSVG ? MUST_USE_ATTRIBUTE : MUST_USE_PROPERTY,
	    cols: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    colSpan: null,
	    content: null,
	    contentEditable: null,
	    contextMenu: MUST_USE_ATTRIBUTE,
	    controls: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    coords: null,
	    crossOrigin: null,
	    data: null, // For `<object />` acts as `src`.
	    dateTime: MUST_USE_ATTRIBUTE,
	    'default': HAS_BOOLEAN_VALUE,
	    defer: HAS_BOOLEAN_VALUE,
	    dir: null,
	    disabled: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    download: HAS_OVERLOADED_BOOLEAN_VALUE,
	    draggable: null,
	    encType: null,
	    form: MUST_USE_ATTRIBUTE,
	    formAction: MUST_USE_ATTRIBUTE,
	    formEncType: MUST_USE_ATTRIBUTE,
	    formMethod: MUST_USE_ATTRIBUTE,
	    formNoValidate: HAS_BOOLEAN_VALUE,
	    formTarget: MUST_USE_ATTRIBUTE,
	    frameBorder: MUST_USE_ATTRIBUTE,
	    headers: null,
	    height: MUST_USE_ATTRIBUTE,
	    hidden: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    high: null,
	    href: null,
	    hrefLang: null,
	    htmlFor: null,
	    httpEquiv: null,
	    icon: null,
	    id: MUST_USE_PROPERTY,
	    inputMode: MUST_USE_ATTRIBUTE,
	    integrity: null,
	    is: MUST_USE_ATTRIBUTE,
	    keyParams: MUST_USE_ATTRIBUTE,
	    keyType: MUST_USE_ATTRIBUTE,
	    kind: null,
	    label: null,
	    lang: null,
	    list: MUST_USE_ATTRIBUTE,
	    loop: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    low: null,
	    manifest: MUST_USE_ATTRIBUTE,
	    marginHeight: null,
	    marginWidth: null,
	    max: null,
	    maxLength: MUST_USE_ATTRIBUTE,
	    media: MUST_USE_ATTRIBUTE,
	    mediaGroup: null,
	    method: null,
	    min: null,
	    minLength: MUST_USE_ATTRIBUTE,
	    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    name: null,
	    nonce: MUST_USE_ATTRIBUTE,
	    noValidate: HAS_BOOLEAN_VALUE,
	    open: HAS_BOOLEAN_VALUE,
	    optimum: null,
	    pattern: null,
	    placeholder: null,
	    poster: null,
	    preload: null,
	    radioGroup: null,
	    readOnly: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    rel: null,
	    required: HAS_BOOLEAN_VALUE,
	    reversed: HAS_BOOLEAN_VALUE,
	    role: MUST_USE_ATTRIBUTE,
	    rows: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    rowSpan: null,
	    sandbox: null,
	    scope: null,
	    scoped: HAS_BOOLEAN_VALUE,
	    scrolling: null,
	    seamless: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
	    shape: null,
	    size: MUST_USE_ATTRIBUTE | HAS_POSITIVE_NUMERIC_VALUE,
	    sizes: MUST_USE_ATTRIBUTE,
	    span: HAS_POSITIVE_NUMERIC_VALUE,
	    spellCheck: null,
	    src: null,
	    srcDoc: MUST_USE_PROPERTY,
	    srcLang: null,
	    srcSet: MUST_USE_ATTRIBUTE,
	    start: HAS_NUMERIC_VALUE,
	    step: null,
	    style: null,
	    summary: null,
	    tabIndex: null,
	    target: null,
	    title: null,
	    type: null,
	    useMap: null,
	    value: MUST_USE_PROPERTY | HAS_SIDE_EFFECTS,
	    width: MUST_USE_ATTRIBUTE,
	    wmode: MUST_USE_ATTRIBUTE,
	    wrap: null,
	
	    /**
	     * RDFa Properties
	     */
	    about: MUST_USE_ATTRIBUTE,
	    datatype: MUST_USE_ATTRIBUTE,
	    inlist: MUST_USE_ATTRIBUTE,
	    prefix: MUST_USE_ATTRIBUTE,
	    // property is also supported for OpenGraph in meta tags.
	    property: MUST_USE_ATTRIBUTE,
	    resource: MUST_USE_ATTRIBUTE,
	    'typeof': MUST_USE_ATTRIBUTE,
	    vocab: MUST_USE_ATTRIBUTE,
	
	    /**
	     * Non-standard Properties
	     */
	    // autoCapitalize and autoCorrect are supported in Mobile Safari for
	    // keyboard hints.
	    autoCapitalize: MUST_USE_ATTRIBUTE,
	    autoCorrect: MUST_USE_ATTRIBUTE,
	    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
	    autoSave: null,
	    // color is for Safari mask-icon link
	    color: null,
	    // itemProp, itemScope, itemType are for
	    // Microdata support. See http://schema.org/docs/gs.html
	    itemProp: MUST_USE_ATTRIBUTE,
	    itemScope: MUST_USE_ATTRIBUTE | HAS_BOOLEAN_VALUE,
	    itemType: MUST_USE_ATTRIBUTE,
	    // itemID and itemRef are for Microdata support as well but
	    // only specified in the the WHATWG spec document. See
	    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
	    itemID: MUST_USE_ATTRIBUTE,
	    itemRef: MUST_USE_ATTRIBUTE,
	    // results show looking glass icon and recent searches on input
	    // search fields in WebKit/Blink
	    results: null,
	    // IE-only attribute that specifies security restrictions on an iframe
	    // as an alternative to the sandbox attribute on IE<10
	    security: MUST_USE_ATTRIBUTE,
	    // IE-only attribute that controls focus behavior
	    unselectable: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNames: {
	    acceptCharset: 'accept-charset',
	    className: 'class',
	    htmlFor: 'for',
	    httpEquiv: 'http-equiv'
	  },
	  DOMPropertyNames: {
	    autoComplete: 'autocomplete',
	    autoFocus: 'autofocus',
	    autoPlay: 'autoplay',
	    autoSave: 'autosave',
	    // `encoding` is equivalent to `enctype`, IE8 lacks an `enctype` setter.
	    // http://www.w3.org/TR/html5/forms.html#dom-fs-encoding
	    encType: 'encoding',
	    hrefLang: 'hreflang',
	    radioGroup: 'radiogroup',
	    spellCheck: 'spellcheck',
	    srcDoc: 'srcdoc',
	    srcSet: 'srcset'
	  }
	};
	
	module.exports = HTMLDOMPropertyConfig;

/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactBrowserComponentMixin
	 */
	
	'use strict';
	
	var ReactInstanceMap = __webpack_require__(54);
	
	var findDOMNode = __webpack_require__(98);
	var warning = __webpack_require__(32);
	
	var didWarnKey = '_getDOMNodeDidWarn';
	
	var ReactBrowserComponentMixin = {
	  /**
	   * Returns the DOM node rendered by this component.
	   *
	   * @return {DOMElement} The root node of this component.
	   * @final
	   * @protected
	   */
	  getDOMNode: function getDOMNode() {
	    process.env.NODE_ENV !== 'production' ? warning(this.constructor[didWarnKey], '%s.getDOMNode(...) is deprecated. Please use ' + 'ReactDOM.findDOMNode(instance) instead.', ReactInstanceMap.get(this).getName() || this.tagName || 'Unknown') : undefined;
	    this.constructor[didWarnKey] = true;
	    return findDOMNode(this);
	  }
	};
	
	module.exports = ReactBrowserComponentMixin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule findDOMNode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactInstanceMap = __webpack_require__(54);
	var ReactMount = __webpack_require__(35);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Returns the DOM node rendered by this element.
	 *
	 * @param {ReactComponent|DOMElement} componentOrElement
	 * @return {?DOMElement} The root node of this element.
	 */
	function findDOMNode(componentOrElement) {
	  if (process.env.NODE_ENV !== 'production') {
	    var owner = ReactCurrentOwner.current;
	    if (owner !== null) {
	      process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing getDOMNode or findDOMNode inside its render(). ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;
	      owner._warnedAboutRefsInRender = true;
	    }
	  }
	  if (componentOrElement == null) {
	    return null;
	  }
	  if (componentOrElement.nodeType === 1) {
	    return componentOrElement;
	  }
	  if (ReactInstanceMap.has(componentOrElement)) {
	    return ReactMount.getNodeFromInstance(componentOrElement);
	  }
	  !(componentOrElement.render == null || typeof componentOrElement.render !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'findDOMNode was called on an unmounted component.') : invariant(false) : undefined;
	   true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Element appears to be neither ReactComponent nor DOMNode (keys: %s)', Object.keys(componentOrElement)) : invariant(false) : undefined;
	}
	
	module.exports = findDOMNode;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultBatchingStrategy
	 */
	
	'use strict';
	
	var ReactUpdates = __webpack_require__(61);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	var RESET_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: function close() {
	    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
	  }
	};
	
	var FLUSH_BATCHED_UPDATES = {
	  initialize: emptyFunction,
	  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
	};
	
	var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];
	
	function ReactDefaultBatchingStrategyTransaction() {
	  this.reinitializeTransaction();
	}
	
	assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction.Mixin, {
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  }
	});
	
	var transaction = new ReactDefaultBatchingStrategyTransaction();
	
	var ReactDefaultBatchingStrategy = {
	  isBatchingUpdates: false,
	
	  /**
	   * Call the provided function in a context within which calls to `setState`
	   * and friends are batched such that components aren't updated unnecessarily.
	   */
	  batchedUpdates: function batchedUpdates(callback, a, b, c, d, e) {
	    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;
	
	    ReactDefaultBatchingStrategy.isBatchingUpdates = true;
	
	    // The code is written this way to avoid extra allocations
	    if (alreadyBatchingUpdates) {
	      callback(a, b, c, d, e);
	    } else {
	      transaction.perform(callback, null, a, b, c, d, e);
	    }
	  }
	};
	
	module.exports = ReactDefaultBatchingStrategy;

/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMComponent
	 * @typechecks static-only
	 */
	
	/* global hasOwnProperty:true */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var AutoFocusUtils = __webpack_require__(101);
	var CSSPropertyOperations = __webpack_require__(103);
	var DOMProperty = __webpack_require__(30);
	var DOMPropertyOperations = __webpack_require__(29);
	var EventConstants = __webpack_require__(37);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactComponentBrowserEnvironment = __webpack_require__(33);
	var ReactDOMButton = __webpack_require__(111);
	var ReactDOMInput = __webpack_require__(112);
	var ReactDOMOption = __webpack_require__(116);
	var ReactDOMSelect = __webpack_require__(119);
	var ReactDOMTextarea = __webpack_require__(120);
	var ReactMount = __webpack_require__(35);
	var ReactMultiChild = __webpack_require__(121);
	var ReactPerf = __webpack_require__(25);
	var ReactUpdateQueue = __webpack_require__(60);
	
	var assign = __webpack_require__(46);
	var canDefineProperty = __webpack_require__(50);
	var escapeTextContentForBrowser = __webpack_require__(28);
	var invariant = __webpack_require__(20);
	var isEventSupported = __webpack_require__(47);
	var keyOf = __webpack_require__(86);
	var setInnerHTML = __webpack_require__(26);
	var setTextContent = __webpack_require__(27);
	var shallowEqual = __webpack_require__(124);
	var validateDOMNesting = __webpack_require__(77);
	var warning = __webpack_require__(32);
	
	var deleteListener = ReactBrowserEventEmitter.deleteListener;
	var listenTo = ReactBrowserEventEmitter.listenTo;
	var registrationNameModules = ReactBrowserEventEmitter.registrationNameModules;
	
	// For quickly matching children type, to test if can be treated as content.
	var CONTENT_TYPES = { 'string': true, 'number': true };
	
	var CHILDREN = keyOf({ children: null });
	var STYLE = keyOf({ style: null });
	var HTML = keyOf({ __html: null });
	
	var ELEMENT_NODE_TYPE = 1;
	
	function getDeclarationErrorAddendum(internalInstance) {
	  if (internalInstance) {
	    var owner = internalInstance._currentElement._owner || null;
	    if (owner) {
	      var name = owner.getName();
	      if (name) {
	        return ' This DOM node was rendered by `' + name + '`.';
	      }
	    }
	  }
	  return '';
	}
	
	var legacyPropsDescriptor;
	if (process.env.NODE_ENV !== 'production') {
	  legacyPropsDescriptor = {
	    props: {
	      enumerable: false,
	      get: function get() {
	        var component = this._reactInternalComponent;
	        process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .props of a DOM node; instead, ' + 'recreate the props as `render` did originally or read the DOM ' + 'properties/attributes directly from this node (e.g., ' + 'this.refs.box.className).%s', getDeclarationErrorAddendum(component)) : undefined;
	        return component._currentElement.props;
	      }
	    }
	  };
	}
	
	function legacyGetDOMNode() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .getDOMNode() of a DOM node; ' + 'instead, use the node directly.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return this;
	}
	
	function legacyIsMounted() {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .isMounted() of a DOM node.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  return !!component;
	}
	
	function legacySetStateEtc() {
	  if (process.env.NODE_ENV !== 'production') {
	    var component = this._reactInternalComponent;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setState(), .replaceState(), or ' + '.forceUpdate() of a DOM node. This is a no-op.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	}
	
	function legacySetProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .setProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueSetPropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function legacyReplaceProps(partialProps, callback) {
	  var component = this._reactInternalComponent;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, 'ReactDOMComponent: Do not access .replaceProps() of a DOM node. ' + 'Instead, call ReactDOM.render again at the top level.%s', getDeclarationErrorAddendum(component)) : undefined;
	  }
	  if (!component) {
	    return;
	  }
	  ReactUpdateQueue.enqueueReplacePropsInternal(component, partialProps);
	  if (callback) {
	    ReactUpdateQueue.enqueueCallbackInternal(component, callback);
	  }
	}
	
	function friendlyStringify(obj) {
	  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object') {
	    if (Array.isArray(obj)) {
	      return '[' + obj.map(friendlyStringify).join(', ') + ']';
	    } else {
	      var pairs = [];
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) {
	          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
	          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
	        }
	      }
	      return '{' + pairs.join(', ') + '}';
	    }
	  } else if (typeof obj === 'string') {
	    return JSON.stringify(obj);
	  } else if (typeof obj === 'function') {
	    return '[function object]';
	  }
	  // Differs from JSON.stringify in that undefined becauses undefined and that
	  // inf and nan don't become null
	  return String(obj);
	}
	
	var styleMutationWarning = {};
	
	function checkAndWarnForMutatedStyle(style1, style2, component) {
	  if (style1 == null || style2 == null) {
	    return;
	  }
	  if (shallowEqual(style1, style2)) {
	    return;
	  }
	
	  var componentName = component._tag;
	  var owner = component._currentElement._owner;
	  var ownerName;
	  if (owner) {
	    ownerName = owner.getName();
	  }
	
	  var hash = ownerName + '|' + componentName;
	
	  if (styleMutationWarning.hasOwnProperty(hash)) {
	    return;
	  }
	
	  styleMutationWarning[hash] = true;
	
	  process.env.NODE_ENV !== 'production' ? warning(false, '`%s` was passed a style object that has previously been mutated. ' + 'Mutating `style` is deprecated. Consider cloning it beforehand. Check ' + 'the `render` %s. Previous style: %s. Mutated style: %s.', componentName, owner ? 'of `' + ownerName + '`' : 'using <' + componentName + '>', friendlyStringify(style1), friendlyStringify(style2)) : undefined;
	}
	
	/**
	 * @param {object} component
	 * @param {?object} props
	 */
	function assertValidProps(component, props) {
	  if (!props) {
	    return;
	  }
	  // Note the use of `==` which checks for null or undefined.
	  if (process.env.NODE_ENV !== 'production') {
	    if (voidElementTags[component._tag]) {
	      process.env.NODE_ENV !== 'production' ? warning(props.children == null && props.dangerouslySetInnerHTML == null, '%s is a void element tag and must not have `children` or ' + 'use `props.dangerouslySetInnerHTML`.%s', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : undefined;
	    }
	  }
	  if (props.dangerouslySetInnerHTML != null) {
	    !(props.children == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Can only set one of `children` or `props.dangerouslySetInnerHTML`.') : invariant(false) : undefined;
	    !(_typeof(props.dangerouslySetInnerHTML) === 'object' && HTML in props.dangerouslySetInnerHTML) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. ' + 'Please visit https://fb.me/react-invariant-dangerously-set-inner-html ' + 'for more information.') : invariant(false) : undefined;
	  }
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(props.innerHTML == null, 'Directly setting property `innerHTML` is not permitted. ' + 'For more information, lookup documentation on `dangerouslySetInnerHTML`.') : undefined;
	    process.env.NODE_ENV !== 'production' ? warning(!props.contentEditable || props.children == null, 'A component is `contentEditable` and contains `children` managed by ' + 'React. It is now your responsibility to guarantee that none of ' + 'those nodes are unexpectedly modified or duplicated. This is ' + 'probably not intentional.') : undefined;
	  }
	  !(props.style == null || _typeof(props.style) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'The `style` prop expects a mapping from style properties to values, ' + 'not a string. For example, style={{marginRight: spacing + \'em\'}} when ' + 'using JSX.%s', getDeclarationErrorAddendum(component)) : invariant(false) : undefined;
	}
	
	function enqueuePutListener(id, registrationName, listener, transaction) {
	  if (process.env.NODE_ENV !== 'production') {
	    // IE8 has no API for event capturing and the `onScroll` event doesn't
	    // bubble.
	    process.env.NODE_ENV !== 'production' ? warning(registrationName !== 'onScroll' || isEventSupported('scroll', true), 'This browser doesn\'t support the `onScroll` event') : undefined;
	  }
	  var container = ReactMount.findReactContainerForID(id);
	  if (container) {
	    var doc = container.nodeType === ELEMENT_NODE_TYPE ? container.ownerDocument : container;
	    listenTo(registrationName, doc);
	  }
	  transaction.getReactMountReady().enqueue(putListener, {
	    id: id,
	    registrationName: registrationName,
	    listener: listener
	  });
	}
	
	function putListener() {
	  var listenerToPut = this;
	  ReactBrowserEventEmitter.putListener(listenerToPut.id, listenerToPut.registrationName, listenerToPut.listener);
	}
	
	// There are so many media events, it makes sense to just
	// maintain a list rather than create a `trapBubbledEvent` for each
	var mediaEvents = {
	  topAbort: 'abort',
	  topCanPlay: 'canplay',
	  topCanPlayThrough: 'canplaythrough',
	  topDurationChange: 'durationchange',
	  topEmptied: 'emptied',
	  topEncrypted: 'encrypted',
	  topEnded: 'ended',
	  topError: 'error',
	  topLoadedData: 'loadeddata',
	  topLoadedMetadata: 'loadedmetadata',
	  topLoadStart: 'loadstart',
	  topPause: 'pause',
	  topPlay: 'play',
	  topPlaying: 'playing',
	  topProgress: 'progress',
	  topRateChange: 'ratechange',
	  topSeeked: 'seeked',
	  topSeeking: 'seeking',
	  topStalled: 'stalled',
	  topSuspend: 'suspend',
	  topTimeUpdate: 'timeupdate',
	  topVolumeChange: 'volumechange',
	  topWaiting: 'waiting'
	};
	
	function trapBubbledEventsLocal() {
	  var inst = this;
	  // If a component renders to null or if another component fatals and causes
	  // the state of the tree to be corrupted, `node` here can be null.
	  !inst._rootNodeID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Must be mounted to trap events') : invariant(false) : undefined;
	  var node = ReactMount.getNode(inst._rootNodeID);
	  !node ? process.env.NODE_ENV !== 'production' ? invariant(false, 'trapBubbledEvent(...): Requires node to be rendered.') : invariant(false) : undefined;
	
	  switch (inst._tag) {
	    case 'iframe':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'video':
	    case 'audio':
	
	      inst._wrapperState.listeners = [];
	      // create listener for each media event
	      for (var event in mediaEvents) {
	        if (mediaEvents.hasOwnProperty(event)) {
	          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes[event], mediaEvents[event], node));
	        }
	      }
	
	      break;
	    case 'img':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topError, 'error', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topLoad, 'load', node)];
	      break;
	    case 'form':
	      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topReset, 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent(EventConstants.topLevelTypes.topSubmit, 'submit', node)];
	      break;
	  }
	}
	
	function mountReadyInputWrapper() {
	  ReactDOMInput.mountReadyWrapper(this);
	}
	
	function postUpdateSelectWrapper() {
	  ReactDOMSelect.postUpdateWrapper(this);
	}
	
	// For HTML, certain tags should omit their close tag. We keep a whitelist for
	// those special cased tags.
	
	var omittedCloseTags = {
	  'area': true,
	  'base': true,
	  'br': true,
	  'col': true,
	  'embed': true,
	  'hr': true,
	  'img': true,
	  'input': true,
	  'keygen': true,
	  'link': true,
	  'meta': true,
	  'param': true,
	  'source': true,
	  'track': true,
	  'wbr': true
	};
	
	// NOTE: menuitem's close tag should be omitted, but that causes problems.
	var newlineEatingTags = {
	  'listing': true,
	  'pre': true,
	  'textarea': true
	};
	
	// For HTML, certain tags cannot have children. This has the same purpose as
	// `omittedCloseTags` except that `menuitem` should still have its closing tag.
	
	var voidElementTags = assign({
	  'menuitem': true
	}, omittedCloseTags);
	
	// We accept any tag to be rendered but since this gets injected into arbitrary
	// HTML, we want to make sure that it's a safe tag.
	// http://www.w3.org/TR/REC-xml/#NT-Name
	
	var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
	var validatedTagCache = {};
	var hasOwnProperty = {}.hasOwnProperty;
	
	function validateDangerousTag(tag) {
	  if (!hasOwnProperty.call(validatedTagCache, tag)) {
	    !VALID_TAG_REGEX.test(tag) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Invalid tag: %s', tag) : invariant(false) : undefined;
	    validatedTagCache[tag] = true;
	  }
	}
	
	function processChildContextDev(context, inst) {
	  // Pass down our tag name to child components for validation purposes
	  context = assign({}, context);
	  var info = context[validateDOMNesting.ancestorInfoContextKey];
	  context[validateDOMNesting.ancestorInfoContextKey] = validateDOMNesting.updatedAncestorInfo(info, inst._tag, inst);
	  return context;
	}
	
	function isCustomComponent(tagName, props) {
	  return tagName.indexOf('-') >= 0 || props.is != null;
	}
	
	/**
	 * Creates a new React class that is idempotent and capable of containing other
	 * React components. It accepts event listeners and DOM properties that are
	 * valid according to `DOMProperty`.
	 *
	 *  - Event listeners: `onClick`, `onMouseDown`, etc.
	 *  - DOM properties: `className`, `name`, `title`, etc.
	 *
	 * The `style` property functions differently from the DOM API. It accepts an
	 * object mapping of style properties to values.
	 *
	 * @constructor ReactDOMComponent
	 * @extends ReactMultiChild
	 */
	function ReactDOMComponent(tag) {
	  validateDangerousTag(tag);
	  this._tag = tag.toLowerCase();
	  this._renderedChildren = null;
	  this._previousStyle = null;
	  this._previousStyleCopy = null;
	  this._rootNodeID = null;
	  this._wrapperState = null;
	  this._topLevelWrapper = null;
	  this._nodeWithLegacyProperties = null;
	  if (process.env.NODE_ENV !== 'production') {
	    this._unprocessedContextDev = null;
	    this._processedContextDev = null;
	  }
	}
	
	ReactDOMComponent.displayName = 'ReactDOMComponent';
	
	ReactDOMComponent.Mixin = {
	
	  construct: function construct(element) {
	    this._currentElement = element;
	  },
	
	  /**
	   * Generates root tag markup then recurses. This method has side effects and
	   * is not idempotent.
	   *
	   * @internal
	   * @param {string} rootID The root DOM ID for this node.
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   * @return {string} The computed markup.
	   */
	  mountComponent: function mountComponent(rootID, transaction, context) {
	    this._rootNodeID = rootID;
	
	    var props = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        this._wrapperState = {
	          listeners: null
	        };
	        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
	        break;
	      case 'button':
	        props = ReactDOMButton.getNativeProps(this, props, context);
	        break;
	      case 'input':
	        ReactDOMInput.mountWrapper(this, props, context);
	        props = ReactDOMInput.getNativeProps(this, props, context);
	        break;
	      case 'option':
	        ReactDOMOption.mountWrapper(this, props, context);
	        props = ReactDOMOption.getNativeProps(this, props, context);
	        break;
	      case 'select':
	        ReactDOMSelect.mountWrapper(this, props, context);
	        props = ReactDOMSelect.getNativeProps(this, props, context);
	        context = ReactDOMSelect.processChildContext(this, props, context);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.mountWrapper(this, props, context);
	        props = ReactDOMTextarea.getNativeProps(this, props, context);
	        break;
	    }
	
	    assertValidProps(this, props);
	    if (process.env.NODE_ENV !== 'production') {
	      if (context[validateDOMNesting.ancestorInfoContextKey]) {
	        validateDOMNesting(this._tag, this, context[validateDOMNesting.ancestorInfoContextKey]);
	      }
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      this._unprocessedContextDev = context;
	      this._processedContextDev = processChildContextDev(context, this);
	      context = this._processedContextDev;
	    }
	
	    var mountImage;
	    if (transaction.useCreateElement) {
	      var ownerDocument = context[ReactMount.ownerDocumentContextKey];
	      var el = ownerDocument.createElement(this._currentElement.type);
	      DOMPropertyOperations.setAttributeForID(el, this._rootNodeID);
	      // Populate node cache
	      ReactMount.getID(el);
	      this._updateDOMProperties({}, props, transaction, el);
	      this._createInitialChildren(transaction, props, context, el);
	      mountImage = el;
	    } else {
	      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
	      var tagContent = this._createContentMarkup(transaction, props, context);
	      if (!tagContent && omittedCloseTags[this._tag]) {
	        mountImage = tagOpen + '/>';
	      } else {
	        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
	      }
	    }
	
	    switch (this._tag) {
	      case 'input':
	        transaction.getReactMountReady().enqueue(mountReadyInputWrapper, this);
	      // falls through
	      case 'button':
	      case 'select':
	      case 'textarea':
	        if (props.autoFocus) {
	          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
	        }
	        break;
	    }
	
	    return mountImage;
	  },
	
	  /**
	   * Creates markup for the open tag and all attributes.
	   *
	   * This method has side effects because events get registered.
	   *
	   * Iterating over object properties is faster than iterating over arrays.
	   * @see http://jsperf.com/obj-vs-arr-iteration
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @return {string} Markup of opening tag.
	   */
	  _createOpenTagMarkupAndPutListeners: function _createOpenTagMarkupAndPutListeners(transaction, props) {
	    var ret = '<' + this._currentElement.type;
	
	    for (var propKey in props) {
	      if (!props.hasOwnProperty(propKey)) {
	        continue;
	      }
	      var propValue = props[propKey];
	      if (propValue == null) {
	        continue;
	      }
	      if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (propValue) {
	          enqueuePutListener(this._rootNodeID, propKey, propValue, transaction);
	        }
	      } else {
	        if (propKey === STYLE) {
	          if (propValue) {
	            if (process.env.NODE_ENV !== 'production') {
	              // See `_updateDOMProperties`. style block
	              this._previousStyle = propValue;
	            }
	            propValue = this._previousStyleCopy = assign({}, props.style);
	          }
	          propValue = CSSPropertyOperations.createMarkupForStyles(propValue);
	        }
	        var markup = null;
	        if (this._tag != null && isCustomComponent(this._tag, props)) {
	          if (propKey !== CHILDREN) {
	            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
	          }
	        } else {
	          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
	        }
	        if (markup) {
	          ret += ' ' + markup;
	        }
	      }
	    }
	
	    // For static pages, no need to put React ID and checksum. Saves lots of
	    // bytes.
	    if (transaction.renderToStaticMarkup) {
	      return ret;
	    }
	
	    var markupForID = DOMPropertyOperations.createMarkupForID(this._rootNodeID);
	    return ret + ' ' + markupForID;
	  },
	
	  /**
	   * Creates markup for the content between the tags.
	   *
	   * @private
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} props
	   * @param {object} context
	   * @return {string} Content markup.
	   */
	  _createContentMarkup: function _createContentMarkup(transaction, props, context) {
	    var ret = '';
	
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        ret = innerHTML.__html;
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        ret = escapeTextContentForBrowser(contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        ret = mountImages.join('');
	      }
	    }
	    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
	      // text/html ignores the first character in these tags if it's a newline
	      // Prefer to break application/xml over text/html (for now) by adding
	      // a newline specifically to get eaten by the parser. (Alternately for
	      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
	      // \r is normalized out by HTMLTextAreaElement#value.)
	      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
	      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
	      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
	      // See: Parsing of "textarea" "listing" and "pre" elements
	      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
	      return '\n' + ret;
	    } else {
	      return ret;
	    }
	  },
	
	  _createInitialChildren: function _createInitialChildren(transaction, props, context, el) {
	    // Intentional use of != to avoid catching zero/false.
	    var innerHTML = props.dangerouslySetInnerHTML;
	    if (innerHTML != null) {
	      if (innerHTML.__html != null) {
	        setInnerHTML(el, innerHTML.__html);
	      }
	    } else {
	      var contentToUse = CONTENT_TYPES[_typeof(props.children)] ? props.children : null;
	      var childrenToUse = contentToUse != null ? null : props.children;
	      if (contentToUse != null) {
	        // TODO: Validate that text is allowed as a child of this node
	        setTextContent(el, contentToUse);
	      } else if (childrenToUse != null) {
	        var mountImages = this.mountChildren(childrenToUse, transaction, context);
	        for (var i = 0; i < mountImages.length; i++) {
	          el.appendChild(mountImages[i]);
	        }
	      }
	    }
	  },
	
	  /**
	   * Receives a next element and updates the component.
	   *
	   * @internal
	   * @param {ReactElement} nextElement
	   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
	   * @param {object} context
	   */
	  receiveComponent: function receiveComponent(nextElement, transaction, context) {
	    var prevElement = this._currentElement;
	    this._currentElement = nextElement;
	    this.updateComponent(transaction, prevElement, nextElement, context);
	  },
	
	  /**
	   * Updates a native DOM component after it has already been allocated and
	   * attached to the DOM. Reconciles the root DOM node, then recurses.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @param {ReactElement} prevElement
	   * @param {ReactElement} nextElement
	   * @internal
	   * @overridable
	   */
	  updateComponent: function updateComponent(transaction, prevElement, nextElement, context) {
	    var lastProps = prevElement.props;
	    var nextProps = this._currentElement.props;
	
	    switch (this._tag) {
	      case 'button':
	        lastProps = ReactDOMButton.getNativeProps(this, lastProps);
	        nextProps = ReactDOMButton.getNativeProps(this, nextProps);
	        break;
	      case 'input':
	        ReactDOMInput.updateWrapper(this);
	        lastProps = ReactDOMInput.getNativeProps(this, lastProps);
	        nextProps = ReactDOMInput.getNativeProps(this, nextProps);
	        break;
	      case 'option':
	        lastProps = ReactDOMOption.getNativeProps(this, lastProps);
	        nextProps = ReactDOMOption.getNativeProps(this, nextProps);
	        break;
	      case 'select':
	        lastProps = ReactDOMSelect.getNativeProps(this, lastProps);
	        nextProps = ReactDOMSelect.getNativeProps(this, nextProps);
	        break;
	      case 'textarea':
	        ReactDOMTextarea.updateWrapper(this);
	        lastProps = ReactDOMTextarea.getNativeProps(this, lastProps);
	        nextProps = ReactDOMTextarea.getNativeProps(this, nextProps);
	        break;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // If the context is reference-equal to the old one, pass down the same
	      // processed object so the update bailout in ReactReconciler behaves
	      // correctly (and identically in dev and prod). See #5005.
	      if (this._unprocessedContextDev !== context) {
	        this._unprocessedContextDev = context;
	        this._processedContextDev = processChildContextDev(context, this);
	      }
	      context = this._processedContextDev;
	    }
	
	    assertValidProps(this, nextProps);
	    this._updateDOMProperties(lastProps, nextProps, transaction, null);
	    this._updateDOMChildren(lastProps, nextProps, transaction, context);
	
	    if (!canDefineProperty && this._nodeWithLegacyProperties) {
	      this._nodeWithLegacyProperties.props = nextProps;
	    }
	
	    if (this._tag === 'select') {
	      // <select> value update needs to occur after <option> children
	      // reconciliation
	      transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
	    }
	  },
	
	  /**
	   * Reconciles the properties by detecting differences in property values and
	   * updating the DOM as necessary. This function is probably the single most
	   * critical path for performance optimization.
	   *
	   * TODO: Benchmark whether checking for changed values in memory actually
	   *       improves performance (especially statically positioned elements).
	   * TODO: Benchmark the effects of putting this at the top since 99% of props
	   *       do not change for a given reconciliation.
	   * TODO: Benchmark areas that can be improved with caching.
	   *
	   * @private
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {?DOMElement} node
	   */
	  _updateDOMProperties: function _updateDOMProperties(lastProps, nextProps, transaction, node) {
	    var propKey;
	    var styleName;
	    var styleUpdates;
	    for (propKey in lastProps) {
	      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey)) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        var lastStyle = this._previousStyleCopy;
	        for (styleName in lastStyle) {
	          if (lastStyle.hasOwnProperty(styleName)) {
	            styleUpdates = styleUpdates || {};
	            styleUpdates[styleName] = '';
	          }
	        }
	        this._previousStyleCopy = null;
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (lastProps[propKey]) {
	          // Only call deleteListener if there was a listener previously or
	          // else willDeleteListener gets called when there wasn't actually a
	          // listener (e.g., onClick={null})
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        DOMPropertyOperations.deleteValueForProperty(node, propKey);
	      }
	    }
	    for (propKey in nextProps) {
	      var nextProp = nextProps[propKey];
	      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps[propKey];
	      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp) {
	        continue;
	      }
	      if (propKey === STYLE) {
	        if (nextProp) {
	          if (process.env.NODE_ENV !== 'production') {
	            checkAndWarnForMutatedStyle(this._previousStyleCopy, this._previousStyle, this);
	            this._previousStyle = nextProp;
	          }
	          nextProp = this._previousStyleCopy = assign({}, nextProp);
	        } else {
	          this._previousStyleCopy = null;
	        }
	        if (lastProp) {
	          // Unset styles on `lastProp` but not on `nextProp`.
	          for (styleName in lastProp) {
	            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = '';
	            }
	          }
	          // Update styles that changed since `lastProp`.
	          for (styleName in nextProp) {
	            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
	              styleUpdates = styleUpdates || {};
	              styleUpdates[styleName] = nextProp[styleName];
	            }
	          }
	        } else {
	          // Relies on `updateStylesByID` not mutating `styleUpdates`.
	          styleUpdates = nextProp;
	        }
	      } else if (registrationNameModules.hasOwnProperty(propKey)) {
	        if (nextProp) {
	          enqueuePutListener(this._rootNodeID, propKey, nextProp, transaction);
	        } else if (lastProp) {
	          deleteListener(this._rootNodeID, propKey);
	        }
	      } else if (isCustomComponent(this._tag, nextProps)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        if (propKey === CHILDREN) {
	          nextProp = null;
	        }
	        DOMPropertyOperations.setValueForAttribute(node, propKey, nextProp);
	      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
	        if (!node) {
	          node = ReactMount.getNode(this._rootNodeID);
	        }
	        // If we're updating to null or undefined, we should remove the property
	        // from the DOM node instead of inadvertantly setting to a string. This
	        // brings us in line with the same behavior we have on initial render.
	        if (nextProp != null) {
	          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
	        } else {
	          DOMPropertyOperations.deleteValueForProperty(node, propKey);
	        }
	      }
	    }
	    if (styleUpdates) {
	      if (!node) {
	        node = ReactMount.getNode(this._rootNodeID);
	      }
	      CSSPropertyOperations.setValueForStyles(node, styleUpdates);
	    }
	  },
	
	  /**
	   * Reconciles the children with the various properties that affect the
	   * children content.
	   *
	   * @param {object} lastProps
	   * @param {object} nextProps
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   */
	  _updateDOMChildren: function _updateDOMChildren(lastProps, nextProps, transaction, context) {
	    var lastContent = CONTENT_TYPES[_typeof(lastProps.children)] ? lastProps.children : null;
	    var nextContent = CONTENT_TYPES[_typeof(nextProps.children)] ? nextProps.children : null;
	
	    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
	    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;
	
	    // Note the use of `!=` which checks for null or undefined.
	    var lastChildren = lastContent != null ? null : lastProps.children;
	    var nextChildren = nextContent != null ? null : nextProps.children;
	
	    // If we're switching from children to content/html or vice versa, remove
	    // the old content
	    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
	    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
	    if (lastChildren != null && nextChildren == null) {
	      this.updateChildren(null, transaction, context);
	    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
	      this.updateTextContent('');
	    }
	
	    if (nextContent != null) {
	      if (lastContent !== nextContent) {
	        this.updateTextContent('' + nextContent);
	      }
	    } else if (nextHtml != null) {
	      if (lastHtml !== nextHtml) {
	        this.updateMarkup('' + nextHtml);
	      }
	    } else if (nextChildren != null) {
	      this.updateChildren(nextChildren, transaction, context);
	    }
	  },
	
	  /**
	   * Destroys all event registrations for this instance. Does not remove from
	   * the DOM. That must be done by the parent.
	   *
	   * @internal
	   */
	  unmountComponent: function unmountComponent() {
	    switch (this._tag) {
	      case 'iframe':
	      case 'img':
	      case 'form':
	      case 'video':
	      case 'audio':
	        var listeners = this._wrapperState.listeners;
	        if (listeners) {
	          for (var i = 0; i < listeners.length; i++) {
	            listeners[i].remove();
	          }
	        }
	        break;
	      case 'input':
	        ReactDOMInput.unmountWrapper(this);
	        break;
	      case 'html':
	      case 'head':
	      case 'body':
	        /**
	         * Components like <html> <head> and <body> can't be removed or added
	         * easily in a cross-browser way, however it's valuable to be able to
	         * take advantage of React's reconciliation for styling and <title>
	         * management. So we just document it and throw in dangerous cases.
	         */
	         true ? process.env.NODE_ENV !== 'production' ? invariant(false, '<%s> tried to unmount. Because of cross-browser quirks it is ' + 'impossible to unmount some top-level components (eg <html>, ' + '<head>, and <body>) reliably and efficiently. To fix this, have a ' + 'single top-level component that never unmounts render these ' + 'elements.', this._tag) : invariant(false) : undefined;
	        break;
	    }
	
	    this.unmountChildren();
	    ReactBrowserEventEmitter.deleteAllListeners(this._rootNodeID);
	    ReactComponentBrowserEnvironment.unmountIDFromEnvironment(this._rootNodeID);
	    this._rootNodeID = null;
	    this._wrapperState = null;
	    if (this._nodeWithLegacyProperties) {
	      var node = this._nodeWithLegacyProperties;
	      node._reactInternalComponent = null;
	      this._nodeWithLegacyProperties = null;
	    }
	  },
	
	  getPublicInstance: function getPublicInstance() {
	    if (!this._nodeWithLegacyProperties) {
	      var node = ReactMount.getNode(this._rootNodeID);
	
	      node._reactInternalComponent = this;
	      node.getDOMNode = legacyGetDOMNode;
	      node.isMounted = legacyIsMounted;
	      node.setState = legacySetStateEtc;
	      node.replaceState = legacySetStateEtc;
	      node.forceUpdate = legacySetStateEtc;
	      node.setProps = legacySetProps;
	      node.replaceProps = legacyReplaceProps;
	
	      if (process.env.NODE_ENV !== 'production') {
	        if (canDefineProperty) {
	          Object.defineProperties(node, legacyPropsDescriptor);
	        } else {
	          // updateComponent will update this property on subsequent renders
	          node.props = this._currentElement.props;
	        }
	      } else {
	        // updateComponent will update this property on subsequent renders
	        node.props = this._currentElement.props;
	      }
	
	      this._nodeWithLegacyProperties = node;
	    }
	    return this._nodeWithLegacyProperties;
	  }
	
	};
	
	ReactPerf.measureMethods(ReactDOMComponent, 'ReactDOMComponent', {
	  mountComponent: 'mountComponent',
	  updateComponent: 'updateComponent'
	});
	
	assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);
	
	module.exports = ReactDOMComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule AutoFocusUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	var findDOMNode = __webpack_require__(98);
	var focusNode = __webpack_require__(102);
	
	var Mixin = {
	  componentDidMount: function componentDidMount() {
	    if (this.props.autoFocus) {
	      focusNode(findDOMNode(this));
	    }
	  }
	};
	
	var AutoFocusUtils = {
	  Mixin: Mixin,
	
	  focusDOMComponent: function focusDOMComponent() {
	    focusNode(ReactMount.getNode(this._rootNodeID));
	  }
	};
	
	module.exports = AutoFocusUtils;

/***/ },
/* 102 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule focusNode
	 */
	
	'use strict';
	
	/**
	 * @param {DOMElement} node input/textarea to focus
	 */
	
	function focusNode(node) {
	  // IE8 can throw "Can't move focus to the control because it is invisible,
	  // not enabled, or of a type that does not accept the focus." for all kinds of
	  // reasons that are too expensive and fragile to test.
	  try {
	    node.focus();
	  } catch (e) {}
	}
	
	module.exports = focusNode;

/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSPropertyOperations
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactPerf = __webpack_require__(25);
	
	var camelizeStyleName = __webpack_require__(105);
	var dangerousStyleValue = __webpack_require__(107);
	var hyphenateStyleName = __webpack_require__(108);
	var memoizeStringOnly = __webpack_require__(110);
	var warning = __webpack_require__(32);
	
	var processStyleName = memoizeStringOnly(function (styleName) {
	  return hyphenateStyleName(styleName);
	});
	
	var hasShorthandPropertyBug = false;
	var styleFloatAccessor = 'cssFloat';
	if (ExecutionEnvironment.canUseDOM) {
	  var tempStyle = document.createElement('div').style;
	  try {
	    // IE8 throws "Invalid argument." if resetting shorthand style properties.
	    tempStyle.font = '';
	  } catch (e) {
	    hasShorthandPropertyBug = true;
	  }
	  // IE8 only supports accessing cssFloat (standard) as styleFloat
	  if (document.documentElement.style.cssFloat === undefined) {
	    styleFloatAccessor = 'styleFloat';
	  }
	}
	
	if (process.env.NODE_ENV !== 'production') {
	  // 'msTransform' is correct, but the other prefixes should be capitalized
	  var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
	
	  // style values shouldn't contain a semicolon
	  var badStyleValueWithSemicolonPattern = /;\s*$/;
	
	  var warnedStyleNames = {};
	  var warnedStyleValues = {};
	
	  var warnHyphenatedStyleName = function warnHyphenatedStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported style property %s. Did you mean %s?', name, camelizeStyleName(name)) : undefined;
	  };
	
	  var warnBadVendoredStyleName = function warnBadVendoredStyleName(name) {
	    if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
	      return;
	    }
	
	    warnedStyleNames[name] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Unsupported vendor-prefixed style property %s. Did you mean %s?', name, name.charAt(0).toUpperCase() + name.slice(1)) : undefined;
	  };
	
	  var warnStyleValueWithSemicolon = function warnStyleValueWithSemicolon(name, value) {
	    if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
	      return;
	    }
	
	    warnedStyleValues[value] = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'Style property values shouldn\'t contain a semicolon. ' + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, '')) : undefined;
	  };
	
	  /**
	   * @param {string} name
	   * @param {*} value
	   */
	  var warnValidStyle = function warnValidStyle(name, value) {
	    if (name.indexOf('-') > -1) {
	      warnHyphenatedStyleName(name);
	    } else if (badVendoredStyleNamePattern.test(name)) {
	      warnBadVendoredStyleName(name);
	    } else if (badStyleValueWithSemicolonPattern.test(value)) {
	      warnStyleValueWithSemicolon(name, value);
	    }
	  };
	}
	
	/**
	 * Operations for dealing with CSS properties.
	 */
	var CSSPropertyOperations = {
	
	  /**
	   * Serializes a mapping of style properties for use as inline styles:
	   *
	   *   > createMarkupForStyles({width: '200px', height: 0})
	   *   "width:200px;height:0;"
	   *
	   * Undefined values are ignored so that declarative programming is easier.
	   * The result should be HTML-escaped before insertion into the DOM.
	   *
	   * @param {object} styles
	   * @return {?string}
	   */
	  createMarkupForStyles: function createMarkupForStyles(styles) {
	    var serialized = '';
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      var styleValue = styles[styleName];
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styleValue);
	      }
	      if (styleValue != null) {
	        serialized += processStyleName(styleName) + ':';
	        serialized += dangerousStyleValue(styleName, styleValue) + ';';
	      }
	    }
	    return serialized || null;
	  },
	
	  /**
	   * Sets the value for multiple styles on a node.  If a value is specified as
	   * '' (empty string), the corresponding style property will be unset.
	   *
	   * @param {DOMElement} node
	   * @param {object} styles
	   */
	  setValueForStyles: function setValueForStyles(node, styles) {
	    var style = node.style;
	    for (var styleName in styles) {
	      if (!styles.hasOwnProperty(styleName)) {
	        continue;
	      }
	      if (process.env.NODE_ENV !== 'production') {
	        warnValidStyle(styleName, styles[styleName]);
	      }
	      var styleValue = dangerousStyleValue(styleName, styles[styleName]);
	      if (styleName === 'float') {
	        styleName = styleFloatAccessor;
	      }
	      if (styleValue) {
	        style[styleName] = styleValue;
	      } else {
	        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
	        if (expansion) {
	          // Shorthand property that IE8 won't like unsetting, so unset each
	          // component to placate it
	          for (var individualStyleName in expansion) {
	            style[individualStyleName] = '';
	          }
	        } else {
	          style[styleName] = '';
	        }
	      }
	    }
	  }
	
	};
	
	ReactPerf.measureMethods(CSSPropertyOperations, 'CSSPropertyOperations', {
	  setValueForStyles: 'setValueForStyles'
	});
	
	module.exports = CSSPropertyOperations;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 104 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule CSSProperty
	 */
	
	'use strict';
	
	/**
	 * CSS properties which accept numbers but are not in units of "px".
	 */
	
	var isUnitlessNumber = {
	  animationIterationCount: true,
	  boxFlex: true,
	  boxFlexGroup: true,
	  boxOrdinalGroup: true,
	  columnCount: true,
	  flex: true,
	  flexGrow: true,
	  flexPositive: true,
	  flexShrink: true,
	  flexNegative: true,
	  flexOrder: true,
	  fontWeight: true,
	  lineClamp: true,
	  lineHeight: true,
	  opacity: true,
	  order: true,
	  orphans: true,
	  tabSize: true,
	  widows: true,
	  zIndex: true,
	  zoom: true,
	
	  // SVG-related properties
	  fillOpacity: true,
	  stopOpacity: true,
	  strokeDashoffset: true,
	  strokeOpacity: true,
	  strokeWidth: true
	};
	
	/**
	 * @param {string} prefix vendor-specific prefix, eg: Webkit
	 * @param {string} key style name, eg: transitionDuration
	 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
	 * WebkitTransitionDuration
	 */
	function prefixKey(prefix, key) {
	  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
	}
	
	/**
	 * Support style names that may come passed in prefixed by adding permutations
	 * of vendor prefixes.
	 */
	var prefixes = ['Webkit', 'ms', 'Moz', 'O'];
	
	// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
	// infinite loop, because it iterates over the newly added props too.
	Object.keys(isUnitlessNumber).forEach(function (prop) {
	  prefixes.forEach(function (prefix) {
	    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
	  });
	});
	
	/**
	 * Most style properties can be unset by doing .style[prop] = '' but IE8
	 * doesn't like doing that with shorthand properties so for the properties that
	 * IE8 breaks on, which are listed here, we instead unset each of the
	 * individual properties. See http://bugs.jquery.com/ticket/12385.
	 * The 4-value 'clock' properties like margin, padding, border-width seem to
	 * behave without any problems. Curiously, list-style works too without any
	 * special prodding.
	 */
	var shorthandPropertyExpansions = {
	  background: {
	    backgroundAttachment: true,
	    backgroundColor: true,
	    backgroundImage: true,
	    backgroundPositionX: true,
	    backgroundPositionY: true,
	    backgroundRepeat: true
	  },
	  backgroundPosition: {
	    backgroundPositionX: true,
	    backgroundPositionY: true
	  },
	  border: {
	    borderWidth: true,
	    borderStyle: true,
	    borderColor: true
	  },
	  borderBottom: {
	    borderBottomWidth: true,
	    borderBottomStyle: true,
	    borderBottomColor: true
	  },
	  borderLeft: {
	    borderLeftWidth: true,
	    borderLeftStyle: true,
	    borderLeftColor: true
	  },
	  borderRight: {
	    borderRightWidth: true,
	    borderRightStyle: true,
	    borderRightColor: true
	  },
	  borderTop: {
	    borderTopWidth: true,
	    borderTopStyle: true,
	    borderTopColor: true
	  },
	  font: {
	    fontStyle: true,
	    fontVariant: true,
	    fontWeight: true,
	    fontSize: true,
	    lineHeight: true,
	    fontFamily: true
	  },
	  outline: {
	    outlineWidth: true,
	    outlineStyle: true,
	    outlineColor: true
	  }
	};
	
	var CSSProperty = {
	  isUnitlessNumber: isUnitlessNumber,
	  shorthandPropertyExpansions: shorthandPropertyExpansions
	};
	
	module.exports = CSSProperty;

/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelizeStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var camelize = __webpack_require__(106);
	
	var msPattern = /^-ms-/;
	
	/**
	 * Camelcases a hyphenated CSS property name, for example:
	 *
	 *   > camelizeStyleName('background-color')
	 *   < "backgroundColor"
	 *   > camelizeStyleName('-moz-transition')
	 *   < "MozTransition"
	 *   > camelizeStyleName('-ms-transition')
	 *   < "msTransition"
	 *
	 * As Andi Smith suggests
	 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
	 * is converted to lowercase `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelizeStyleName(string) {
	  return camelize(string.replace(msPattern, 'ms-'));
	}
	
	module.exports = camelizeStyleName;

/***/ },
/* 106 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule camelize
	 * @typechecks
	 */
	
	"use strict";
	
	var _hyphenPattern = /-(.)/g;
	
	/**
	 * Camelcases a hyphenated string, for example:
	 *
	 *   > camelize('background-color')
	 *   < "backgroundColor"
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function camelize(string) {
	  return string.replace(_hyphenPattern, function (_, character) {
	    return character.toUpperCase();
	  });
	}
	
	module.exports = camelize;

/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule dangerousStyleValue
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CSSProperty = __webpack_require__(104);
	
	var isUnitlessNumber = CSSProperty.isUnitlessNumber;
	
	/**
	 * Convert a value into the proper css writable value. The style name `name`
	 * should be logical (no hyphens), as specified
	 * in `CSSProperty.isUnitlessNumber`.
	 *
	 * @param {string} name CSS property name such as `topMargin`.
	 * @param {*} value CSS property value such as `10px`.
	 * @return {string} Normalized style value with dimensions applied.
	 */
	function dangerousStyleValue(name, value) {
	  // Note that we've removed escapeTextForBrowser() calls here since the
	  // whole string will be escaped when the attribute is injected into
	  // the markup. If you provide unsafe user data here they can inject
	  // arbitrary CSS which may be problematic (I couldn't repro this):
	  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
	  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
	  // This is not an XSS hole but instead a potential CSS injection issue
	  // which has lead to a greater discussion about how we're going to
	  // trust URLs moving forward. See #2115901
	
	  var isEmpty = value == null || typeof value === 'boolean' || value === '';
	  if (isEmpty) {
	    return '';
	  }
	
	  var isNonNumeric = isNaN(value);
	  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
	    return '' + value; // cast to string
	  }
	
	  if (typeof value === 'string') {
	    value = value.trim();
	  }
	  return value + 'px';
	}
	
	module.exports = dangerousStyleValue;

/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenateStyleName
	 * @typechecks
	 */
	
	'use strict';
	
	var hyphenate = __webpack_require__(109);
	
	var msPattern = /^ms-/;
	
	/**
	 * Hyphenates a camelcased CSS property name, for example:
	 *
	 *   > hyphenateStyleName('backgroundColor')
	 *   < "background-color"
	 *   > hyphenateStyleName('MozTransition')
	 *   < "-moz-transition"
	 *   > hyphenateStyleName('msTransition')
	 *   < "-ms-transition"
	 *
	 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
	 * is converted to `-ms-`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenateStyleName(string) {
	  return hyphenate(string).replace(msPattern, '-ms-');
	}
	
	module.exports = hyphenateStyleName;

/***/ },
/* 109 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule hyphenate
	 * @typechecks
	 */
	
	'use strict';
	
	var _uppercasePattern = /([A-Z])/g;
	
	/**
	 * Hyphenates a camelcased string, for example:
	 *
	 *   > hyphenate('backgroundColor')
	 *   < "background-color"
	 *
	 * For CSS style names, use `hyphenateStyleName` instead which works properly
	 * with all vendor prefixes, including `ms`.
	 *
	 * @param {string} string
	 * @return {string}
	 */
	function hyphenate(string) {
	  return string.replace(_uppercasePattern, '-$1').toLowerCase();
	}
	
	module.exports = hyphenate;

/***/ },
/* 110 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule memoizeStringOnly
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * Memoizes the return value of a function that accepts one string argument.
	 *
	 * @param {function} callback
	 * @return {function}
	 */
	
	function memoizeStringOnly(callback) {
	  var cache = {};
	  return function (string) {
	    if (!cache.hasOwnProperty(string)) {
	      cache[string] = callback.call(this, string);
	    }
	    return cache[string];
	  };
	}
	
	module.exports = memoizeStringOnly;

/***/ },
/* 111 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMButton
	 */
	
	'use strict';
	
	var mouseListenerNames = {
	  onClick: true,
	  onDoubleClick: true,
	  onMouseDown: true,
	  onMouseMove: true,
	  onMouseUp: true,
	
	  onClickCapture: true,
	  onDoubleClickCapture: true,
	  onMouseDownCapture: true,
	  onMouseMoveCapture: true,
	  onMouseUpCapture: true
	};
	
	/**
	 * Implements a <button> native component that does not receive mouse events
	 * when `disabled` is set.
	 */
	var ReactDOMButton = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    if (!props.disabled) {
	      return props;
	    }
	
	    // Copy the props, except the mouse listeners
	    var nativeProps = {};
	    for (var key in props) {
	      if (props.hasOwnProperty(key) && !mouseListenerNames[key]) {
	        nativeProps[key] = props[key];
	      }
	    }
	
	    return nativeProps;
	  }
	};
	
	module.exports = ReactDOMButton;

/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMInput
	 */
	
	'use strict';
	
	var ReactDOMIDOperations = __webpack_require__(34);
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	
	var instancesByReactID = {};
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMInput.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements an <input> native component that allows setting these optional
	 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
	 *
	 * If `checked` or `value` are not supplied (or null/undefined), user actions
	 * that affect the checked state or value will trigger updates to the element.
	 *
	 * If they are supplied (and not null/undefined), the rendered element will not
	 * trigger updates to the element. Instead, the props must change in order for
	 * the rendered element to be updated.
	 *
	 * The rendered element will be initialized as unchecked (or `defaultChecked`)
	 * with an empty value (or `defaultValue`).
	 *
	 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
	 */
	var ReactDOMInput = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var value = LinkedValueUtils.getValue(props);
	    var checked = LinkedValueUtils.getChecked(props);
	
	    var nativeProps = assign({}, props, {
	      defaultChecked: undefined,
	      defaultValue: undefined,
	      value: value != null ? value : inst._wrapperState.initialValue,
	      checked: checked != null ? checked : inst._wrapperState.initialChecked,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('input', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    inst._wrapperState = {
	      initialChecked: props.defaultChecked || false,
	      initialValue: defaultValue != null ? defaultValue : null,
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  mountReadyWrapper: function mountReadyWrapper(inst) {
	    // Can't be in mountWrapper or else server rendering leaks.
	    instancesByReactID[inst._rootNodeID] = inst;
	  },
	
	  unmountWrapper: function unmountWrapper(inst) {
	    delete instancesByReactID[inst._rootNodeID];
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // TODO: Shouldn't this be getChecked(props)?
	    var checked = props.checked;
	    if (checked != null) {
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'checked', checked || false);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  // Here we use asap to wait until all updates have propagated, which
	  // is important when using controlled components within layers:
	  // https://github.com/facebook/react/issues/1698
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	
	  var name = props.name;
	  if (props.type === 'radio' && name != null) {
	    var rootNode = ReactMount.getNode(this._rootNodeID);
	    var queryRoot = rootNode;
	
	    while (queryRoot.parentNode) {
	      queryRoot = queryRoot.parentNode;
	    }
	
	    // If `rootNode.form` was non-null, then we could try `form.elements`,
	    // but that sometimes behaves strangely in IE8. We could also try using
	    // `form.getElementsByName`, but that will only return direct children
	    // and won't include inputs that use the HTML5 `form=` attribute. Since
	    // the input might not even be in a form, let's just use the global
	    // `querySelectorAll` to ensure we don't miss anything.
	    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');
	
	    for (var i = 0; i < group.length; i++) {
	      var otherNode = group[i];
	      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
	        continue;
	      }
	      // This will throw if radio buttons rendered by different copies of React
	      // and the same name are rendered into the same form (same as #1939).
	      // That's probably okay; we don't support it just as we don't support
	      // mixing React with non-React.
	      var otherID = ReactMount.getID(otherNode);
	      !otherID ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Mixing React and non-React radio inputs with the ' + 'same `name` is not supported.') : invariant(false) : undefined;
	      var otherInstance = instancesByReactID[otherID];
	      !otherInstance ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactDOMInput: Unknown radio button ID %s.', otherID) : invariant(false) : undefined;
	      // If this is a controlled radio button group, forcing the input that
	      // was previously checked to update will cause it to be come re-checked
	      // as appropriate.
	      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
	    }
	  }
	
	  return returnValue;
	}
	
	module.exports = ReactDOMInput;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule LinkedValueUtils
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactPropTypes = __webpack_require__(114);
	var ReactPropTypeLocations = __webpack_require__(72);
	
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var hasReadOnlyValue = {
	  'button': true,
	  'checkbox': true,
	  'image': true,
	  'hidden': true,
	  'radio': true,
	  'reset': true,
	  'submit': true
	};
	
	function _assertSingleLink(inputProps) {
	  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a valueLink. If you want to use ' + 'checkedLink, you probably don\'t want to use valueLink and vice versa.') : invariant(false) : undefined;
	}
	function _assertValueLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.value == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a valueLink and a value or onChange event. If you want ' + 'to use value or onChange, you probably don\'t want to use valueLink.') : invariant(false) : undefined;
	}
	
	function _assertCheckedLink(inputProps) {
	  _assertSingleLink(inputProps);
	  !(inputProps.checked == null && inputProps.onChange == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Cannot provide a checkedLink and a checked property or onChange event. ' + 'If you want to use checked or onChange, you probably don\'t want to ' + 'use checkedLink') : invariant(false) : undefined;
	}
	
	var propTypes = {
	  value: function value(props, propName, componentName) {
	    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  checked: function checked(props, propName, componentName) {
	    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
	      return null;
	    }
	    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
	  },
	  onChange: ReactPropTypes.func
	};
	
	var loggedTypeFailures = {};
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Provide a linked `value` attribute for controlled forms. You should not use
	 * this outside of the ReactDOM controlled form components.
	 */
	var LinkedValueUtils = {
	  checkPropTypes: function checkPropTypes(tagName, props, owner) {
	    for (var propName in propTypes) {
	      if (propTypes.hasOwnProperty(propName)) {
	        var error = propTypes[propName](props, propName, tagName, ReactPropTypeLocations.prop);
	      }
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum(owner);
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed form propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current value of the input either from value prop or link.
	   */
	  getValue: function getValue(inputProps) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.value;
	    }
	    return inputProps.value;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @return {*} current checked status of the input either from checked prop
	   *             or link.
	   */
	  getChecked: function getChecked(inputProps) {
	    if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.value;
	    }
	    return inputProps.checked;
	  },
	
	  /**
	   * @param {object} inputProps Props for form component
	   * @param {SyntheticEvent} event change event to handle
	   */
	  executeOnChange: function executeOnChange(inputProps, event) {
	    if (inputProps.valueLink) {
	      _assertValueLink(inputProps);
	      return inputProps.valueLink.requestChange(event.target.value);
	    } else if (inputProps.checkedLink) {
	      _assertCheckedLink(inputProps);
	      return inputProps.checkedLink.requestChange(event.target.checked);
	    } else if (inputProps.onChange) {
	      return inputProps.onChange.call(undefined, event);
	    }
	  }
	};
	
	module.exports = LinkedValueUtils;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 114 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactPropTypes
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	
	var emptyFunction = __webpack_require__(22);
	var getIteratorFn = __webpack_require__(115);
	
	/**
	 * Collection of methods that allow declaration and validation of props that are
	 * supplied to React components. Example usage:
	 *
	 *   var Props = require('ReactPropTypes');
	 *   var MyArticle = React.createClass({
	 *     propTypes: {
	 *       // An optional string prop named "description".
	 *       description: Props.string,
	 *
	 *       // A required enum prop named "category".
	 *       category: Props.oneOf(['News','Photos']).isRequired,
	 *
	 *       // A prop named "dialog" that requires an instance of Dialog.
	 *       dialog: Props.instanceOf(Dialog).isRequired
	 *     },
	 *     render: function() { ... }
	 *   });
	 *
	 * A more formal specification of how these methods are used:
	 *
	 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
	 *   decl := ReactPropTypes.{type}(.isRequired)?
	 *
	 * Each and every declaration produces a function with the same signature. This
	 * allows the creation of custom validation functions. For example:
	 *
	 *  var MyLink = React.createClass({
	 *    propTypes: {
	 *      // An optional string or URI prop named "href".
	 *      href: function(props, propName, componentName) {
	 *        var propValue = props[propName];
	 *        if (propValue != null && typeof propValue !== 'string' &&
	 *            !(propValue instanceof URI)) {
	 *          return new Error(
	 *            'Expected a string or an URI for ' + propName + ' in ' +
	 *            componentName
	 *          );
	 *        }
	 *      }
	 *    },
	 *    render: function() {...}
	 *  });
	 *
	 * @internal
	 */
	
	var ANONYMOUS = '<<anonymous>>';
	
	var ReactPropTypes = {
	  array: createPrimitiveTypeChecker('array'),
	  bool: createPrimitiveTypeChecker('boolean'),
	  func: createPrimitiveTypeChecker('function'),
	  number: createPrimitiveTypeChecker('number'),
	  object: createPrimitiveTypeChecker('object'),
	  string: createPrimitiveTypeChecker('string'),
	
	  any: createAnyTypeChecker(),
	  arrayOf: createArrayOfTypeChecker,
	  element: createElementTypeChecker(),
	  instanceOf: createInstanceTypeChecker,
	  node: createNodeChecker(),
	  objectOf: createObjectOfTypeChecker,
	  oneOf: createEnumTypeChecker,
	  oneOfType: createUnionTypeChecker,
	  shape: createShapeTypeChecker
	};
	
	function createChainableTypeChecker(validate) {
	  function checkType(isRequired, props, propName, componentName, location, propFullName) {
	    componentName = componentName || ANONYMOUS;
	    propFullName = propFullName || propName;
	    if (props[propName] == null) {
	      var locationName = ReactPropTypeLocationNames[location];
	      if (isRequired) {
	        return new Error('Required ' + locationName + ' `' + propFullName + '` was not specified in ' + ('`' + componentName + '`.'));
	      }
	      return null;
	    } else {
	      return validate(props, propName, componentName, location, propFullName);
	    }
	  }
	
	  var chainedCheckType = checkType.bind(null, false);
	  chainedCheckType.isRequired = checkType.bind(null, true);
	
	  return chainedCheckType;
	}
	
	function createPrimitiveTypeChecker(expectedType) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== expectedType) {
	      var locationName = ReactPropTypeLocationNames[location];
	      // `propValue` being instance of, say, date/regexp, pass the 'object'
	      // check, but we can offer a more precise error message here rather than
	      // 'of type `object`'.
	      var preciseType = getPreciseType(propValue);
	
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createAnyTypeChecker() {
	  return createChainableTypeChecker(emptyFunction.thatReturns(null));
	}
	
	function createArrayOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    if (!Array.isArray(propValue)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var propType = getPropType(propValue);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
	    }
	    for (var i = 0; i < propValue.length; i++) {
	      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']');
	      if (error instanceof Error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createElementTypeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!ReactElement.isValidElement(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a single ReactElement.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createInstanceTypeChecker(expectedClass) {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!(props[propName] instanceof expectedClass)) {
	      var locationName = ReactPropTypeLocationNames[location];
	      var expectedClassName = expectedClass.name || ANONYMOUS;
	      var actualClassName = getClassName(props[propName]);
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createEnumTypeChecker(expectedValues) {
	  if (!Array.isArray(expectedValues)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOf, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    for (var i = 0; i < expectedValues.length; i++) {
	      if (propValue === expectedValues[i]) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    var valuesString = JSON.stringify(expectedValues);
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createObjectOfTypeChecker(typeChecker) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
	    }
	    for (var key in propValue) {
	      if (propValue.hasOwnProperty(key)) {
	        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key);
	        if (error instanceof Error) {
	          return error;
	        }
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createUnionTypeChecker(arrayOfTypeCheckers) {
	  if (!Array.isArray(arrayOfTypeCheckers)) {
	    return createChainableTypeChecker(function () {
	      return new Error('Invalid argument supplied to oneOfType, expected an instance of array.');
	    });
	  }
	
	  function validate(props, propName, componentName, location, propFullName) {
	    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
	      var checker = arrayOfTypeCheckers[i];
	      if (checker(props, propName, componentName, location, propFullName) == null) {
	        return null;
	      }
	    }
	
	    var locationName = ReactPropTypeLocationNames[location];
	    return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createNodeChecker() {
	  function validate(props, propName, componentName, location, propFullName) {
	    if (!isNode(props[propName])) {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function createShapeTypeChecker(shapeTypes) {
	  function validate(props, propName, componentName, location, propFullName) {
	    var propValue = props[propName];
	    var propType = getPropType(propValue);
	    if (propType !== 'object') {
	      var locationName = ReactPropTypeLocationNames[location];
	      return new Error('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
	    }
	    for (var key in shapeTypes) {
	      var checker = shapeTypes[key];
	      if (!checker) {
	        continue;
	      }
	      var error = checker(propValue, key, componentName, location, propFullName + '.' + key);
	      if (error) {
	        return error;
	      }
	    }
	    return null;
	  }
	  return createChainableTypeChecker(validate);
	}
	
	function isNode(propValue) {
	  switch (typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue)) {
	    case 'number':
	    case 'string':
	    case 'undefined':
	      return true;
	    case 'boolean':
	      return !propValue;
	    case 'object':
	      if (Array.isArray(propValue)) {
	        return propValue.every(isNode);
	      }
	      if (propValue === null || ReactElement.isValidElement(propValue)) {
	        return true;
	      }
	
	      var iteratorFn = getIteratorFn(propValue);
	      if (iteratorFn) {
	        var iterator = iteratorFn.call(propValue);
	        var step;
	        if (iteratorFn !== propValue.entries) {
	          while (!(step = iterator.next()).done) {
	            if (!isNode(step.value)) {
	              return false;
	            }
	          }
	        } else {
	          // Iterator will provide entry [k,v] tuples rather than values.
	          while (!(step = iterator.next()).done) {
	            var entry = step.value;
	            if (entry) {
	              if (!isNode(entry[1])) {
	                return false;
	              }
	            }
	          }
	        }
	      } else {
	        return false;
	      }
	
	      return true;
	    default:
	      return false;
	  }
	}
	
	// Equivalent of `typeof` but with special handling for array and regexp.
	function getPropType(propValue) {
	  var propType = typeof propValue === 'undefined' ? 'undefined' : _typeof(propValue);
	  if (Array.isArray(propValue)) {
	    return 'array';
	  }
	  if (propValue instanceof RegExp) {
	    // Old webkits (at least until Android 4.0) return 'function' rather than
	    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
	    // passes PropTypes.object.
	    return 'object';
	  }
	  return propType;
	}
	
	// This handles more types than `getPropType`. Only used for error messages.
	// See `createPrimitiveTypeChecker`.
	function getPreciseType(propValue) {
	  var propType = getPropType(propValue);
	  if (propType === 'object') {
	    if (propValue instanceof Date) {
	      return 'date';
	    } else if (propValue instanceof RegExp) {
	      return 'regexp';
	    }
	  }
	  return propType;
	}
	
	// Returns class name of the object, if any.
	function getClassName(propValue) {
	  if (!propValue.constructor || !propValue.constructor.name) {
	    return '<<anonymous>>';
	  }
	  return propValue.constructor.name;
	}
	
	module.exports = ReactPropTypes;

/***/ },
/* 115 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getIteratorFn
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/* global Symbol */
	
	var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
	
	/**
	 * Returns the iterator method function contained on the iterable object.
	 *
	 * Be sure to invoke the function with the iterable as context:
	 *
	 *     var iteratorFn = getIteratorFn(myIterable);
	 *     if (iteratorFn) {
	 *       var iterator = iteratorFn.call(myIterable);
	 *       ...
	 *     }
	 *
	 * @param {?object} maybeIterable
	 * @return {?function}
	 */
	function getIteratorFn(maybeIterable) {
	  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
	  if (typeof iteratorFn === 'function') {
	    return iteratorFn;
	  }
	}
	
	module.exports = getIteratorFn;

/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMOption
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactDOMSelect = __webpack_require__(119);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = ReactDOMSelect.valueContextKey;
	
	/**
	 * Implements an <option> native component that warns when `selected` is set.
	 */
	var ReactDOMOption = {
	  mountWrapper: function mountWrapper(inst, props, context) {
	    // TODO (yungsters): Remove support for `selected` in <option>.
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(props.selected == null, 'Use the `defaultValue` or `value` props on <select> instead of ' + 'setting `selected` on <option>.') : undefined;
	    }
	
	    // Look up whether this option is 'selected' via context
	    var selectValue = context[valueContextKey];
	
	    // If context key is null (e.g., no specified value or after initial mount)
	    // or missing (e.g., for <datalist>), we don't change props.selected
	    var selected = null;
	    if (selectValue != null) {
	      selected = false;
	      if (Array.isArray(selectValue)) {
	        // multiple
	        for (var i = 0; i < selectValue.length; i++) {
	          if ('' + selectValue[i] === '' + props.value) {
	            selected = true;
	            break;
	          }
	        }
	      } else {
	        selected = '' + selectValue === '' + props.value;
	      }
	    }
	
	    inst._wrapperState = { selected: selected };
	  },
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    var nativeProps = assign({ selected: undefined, children: undefined }, props);
	
	    // Read state only from initial mount because <select> updates value
	    // manually; we need the initial state only for server rendering
	    if (inst._wrapperState.selected != null) {
	      nativeProps.selected = inst._wrapperState.selected;
	    }
	
	    var content = '';
	
	    // Flatten children and warn if they aren't strings or numbers;
	    // invalid types are ignored.
	    ReactChildren.forEach(props.children, function (child) {
	      if (child == null) {
	        return;
	      }
	      if (typeof child === 'string' || typeof child === 'number') {
	        content += child;
	      } else {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Only strings and numbers are supported as <option> children.') : undefined;
	      }
	    });
	
	    if (content) {
	      nativeProps.children = content;
	    }
	
	    return nativeProps;
	  }
	
	};
	
	module.exports = ReactDOMOption;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildren
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var ReactElement = __webpack_require__(49);
	
	var emptyFunction = __webpack_require__(22);
	var traverseAllChildren = __webpack_require__(118);
	
	var twoArgumentPooler = PooledClass.twoArgumentPooler;
	var fourArgumentPooler = PooledClass.fourArgumentPooler;
	
	var userProvidedKeyEscapeRegex = /\/(?!\/)/g;
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, '//');
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * traversal. Allows avoiding binding callbacks.
	 *
	 * @constructor ForEachBookKeeping
	 * @param {!function} forEachFunction Function to perform traversal with.
	 * @param {?*} forEachContext Context to perform context with.
	 */
	function ForEachBookKeeping(forEachFunction, forEachContext) {
	  this.func = forEachFunction;
	  this.context = forEachContext;
	  this.count = 0;
	}
	ForEachBookKeeping.prototype.destructor = function () {
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);
	
	function forEachSingleChild(bookKeeping, child, name) {
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  func.call(context, child, bookKeeping.count++);
	}
	
	/**
	 * Iterates through children that are typically specified as `props.children`.
	 *
	 * The provided forEachFunc(child, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} forEachFunc
	 * @param {*} forEachContext Context for forEachContext.
	 */
	function forEachChildren(children, forEachFunc, forEachContext) {
	  if (children == null) {
	    return children;
	  }
	  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
	  traverseAllChildren(children, forEachSingleChild, traverseContext);
	  ForEachBookKeeping.release(traverseContext);
	}
	
	/**
	 * PooledClass representing the bookkeeping associated with performing a child
	 * mapping. Allows avoiding binding callbacks.
	 *
	 * @constructor MapBookKeeping
	 * @param {!*} mapResult Object containing the ordered map of results.
	 * @param {!function} mapFunction Function to perform mapping with.
	 * @param {?*} mapContext Context to perform mapping with.
	 */
	function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
	  this.result = mapResult;
	  this.keyPrefix = keyPrefix;
	  this.func = mapFunction;
	  this.context = mapContext;
	  this.count = 0;
	}
	MapBookKeeping.prototype.destructor = function () {
	  this.result = null;
	  this.keyPrefix = null;
	  this.func = null;
	  this.context = null;
	  this.count = 0;
	};
	PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);
	
	function mapSingleChildIntoContext(bookKeeping, child, childKey) {
	  var result = bookKeeping.result;
	  var keyPrefix = bookKeeping.keyPrefix;
	  var func = bookKeeping.func;
	  var context = bookKeeping.context;
	
	  var mappedChild = func.call(context, child, bookKeeping.count++);
	  if (Array.isArray(mappedChild)) {
	    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
	  } else if (mappedChild != null) {
	    if (ReactElement.isValidElement(mappedChild)) {
	      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
	      // Keep both the (mapped) and old keys if they differ, just as
	      // traverseAllChildren used to do for objects as children
	      keyPrefix + (mappedChild !== child ? escapeUserProvidedKey(mappedChild.key || '') + '/' : '') + childKey);
	    }
	    result.push(mappedChild);
	  }
	}
	
	function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
	  var escapedPrefix = '';
	  if (prefix != null) {
	    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
	  }
	  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
	  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
	  MapBookKeeping.release(traverseContext);
	}
	
	/**
	 * Maps children that are typically specified as `props.children`.
	 *
	 * The provided mapFunction(child, key, index) will be called for each
	 * leaf child.
	 *
	 * @param {?*} children Children tree container.
	 * @param {function(*, int)} func The map function.
	 * @param {*} context Context for mapFunction.
	 * @return {object} Object containing the ordered map of results.
	 */
	function mapChildren(children, func, context) {
	  if (children == null) {
	    return children;
	  }
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
	  return result;
	}
	
	function forEachSingleChildDummy(traverseContext, child, name) {
	  return null;
	}
	
	/**
	 * Count the number of children that are typically specified as
	 * `props.children`.
	 *
	 * @param {?*} children Children tree container.
	 * @return {number} The number of children.
	 */
	function countChildren(children, context) {
	  return traverseAllChildren(children, forEachSingleChildDummy, null);
	}
	
	/**
	 * Flatten a children object (typically specified as `props.children`) and
	 * return an array with appropriately re-keyed children.
	 */
	function toArray(children) {
	  var result = [];
	  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
	  return result;
	}
	
	var ReactChildren = {
	  forEach: forEachChildren,
	  map: mapChildren,
	  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
	  count: countChildren,
	  toArray: toArray
	};
	
	module.exports = ReactChildren;

/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule traverseAllChildren
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	var SEPARATOR = ReactInstanceHandles.SEPARATOR;
	var SUBSEPARATOR = ':';
	
	/**
	 * TODO: Test that a single child and an array with one item have the same key
	 * pattern.
	 */
	
	var userProvidedKeyEscaperLookup = {
	  '=': '=0',
	  '.': '=1',
	  ':': '=2'
	};
	
	var userProvidedKeyEscapeRegex = /[=.:]/g;
	
	var didWarnAboutMaps = false;
	
	function userProvidedKeyEscaper(match) {
	  return userProvidedKeyEscaperLookup[match];
	}
	
	/**
	 * Generate a key string that identifies a component within a set.
	 *
	 * @param {*} component A component that could contain a manual key.
	 * @param {number} index Index that is used if a manual key is not provided.
	 * @return {string}
	 */
	function getComponentKey(component, index) {
	  if (component && component.key != null) {
	    // Explicit key
	    return wrapUserProvidedKey(component.key);
	  }
	  // Implicit key determined by the index in the set
	  return index.toString(36);
	}
	
	/**
	 * Escape a component key so that it is safe to use in a reactid.
	 *
	 * @param {*} text Component key to be escaped.
	 * @return {string} An escaped string.
	 */
	function escapeUserProvidedKey(text) {
	  return ('' + text).replace(userProvidedKeyEscapeRegex, userProvidedKeyEscaper);
	}
	
	/**
	 * Wrap a `key` value explicitly provided by the user to distinguish it from
	 * implicitly-generated keys generated by a component's index in its parent.
	 *
	 * @param {string} key Value of a user-provided `key` attribute
	 * @return {string}
	 */
	function wrapUserProvidedKey(key) {
	  return '$' + escapeUserProvidedKey(key);
	}
	
	/**
	 * @param {?*} children Children tree container.
	 * @param {!string} nameSoFar Name of the key path so far.
	 * @param {!function} callback Callback to invoke with each child found.
	 * @param {?*} traverseContext Used to pass information throughout the traversal
	 * process.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
	  var type = typeof children === 'undefined' ? 'undefined' : _typeof(children);
	
	  if (type === 'undefined' || type === 'boolean') {
	    // All of the above are perceived as null.
	    children = null;
	  }
	
	  if (children === null || type === 'string' || type === 'number' || ReactElement.isValidElement(children)) {
	    callback(traverseContext, children,
	    // If it's the only child, treat the name as if it was wrapped in an array
	    // so that it's consistent if the number of children grows.
	    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
	    return 1;
	  }
	
	  var child;
	  var nextName;
	  var subtreeCount = 0; // Count of children found in the current subtree.
	  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;
	
	  if (Array.isArray(children)) {
	    for (var i = 0; i < children.length; i++) {
	      child = children[i];
	      nextName = nextNamePrefix + getComponentKey(child, i);
	      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	    }
	  } else {
	    var iteratorFn = getIteratorFn(children);
	    if (iteratorFn) {
	      var iterator = iteratorFn.call(children);
	      var step;
	      if (iteratorFn !== children.entries) {
	        var ii = 0;
	        while (!(step = iterator.next()).done) {
	          child = step.value;
	          nextName = nextNamePrefix + getComponentKey(child, ii++);
	          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	        }
	      } else {
	        if (process.env.NODE_ENV !== 'production') {
	          process.env.NODE_ENV !== 'production' ? warning(didWarnAboutMaps, 'Using Maps as children is not yet fully supported. It is an ' + 'experimental feature that might be removed. Convert it to a ' + 'sequence / iterable of keyed ReactElements instead.') : undefined;
	          didWarnAboutMaps = true;
	        }
	        // Iterator will provide entry [k,v] tuples rather than values.
	        while (!(step = iterator.next()).done) {
	          var entry = step.value;
	          if (entry) {
	            child = entry[1];
	            nextName = nextNamePrefix + wrapUserProvidedKey(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
	            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
	          }
	        }
	      }
	    } else if (type === 'object') {
	      var addendum = '';
	      if (process.env.NODE_ENV !== 'production') {
	        addendum = ' If you meant to render a collection of children, use an array ' + 'instead or wrap the object using createFragment(object) from the ' + 'React add-ons.';
	        if (children._isReactElement) {
	          addendum = ' It looks like you\'re using an element created by a different ' + 'version of React. Make sure to use only one copy of React.';
	        }
	        if (ReactCurrentOwner.current) {
	          var name = ReactCurrentOwner.current.getName();
	          if (name) {
	            addendum += ' Check the render method of `' + name + '`.';
	          }
	        }
	      }
	      var childrenString = String(children);
	       true ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Objects are not valid as a React child (found: %s).%s', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum) : invariant(false) : undefined;
	    }
	  }
	
	  return subtreeCount;
	}
	
	/**
	 * Traverses children that are typically specified as `props.children`, but
	 * might also be specified through attributes:
	 *
	 * - `traverseAllChildren(this.props.children, ...)`
	 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
	 *
	 * The `traverseContext` is an optional argument that is passed through the
	 * entire traversal. It can be used to store accumulations or anything else that
	 * the callback might find relevant.
	 *
	 * @param {?*} children Children tree object.
	 * @param {!function} callback To invoke upon traversing each child.
	 * @param {?*} traverseContext Context for traversal.
	 * @return {!number} The number of children in this subtree.
	 */
	function traverseAllChildren(children, callback, traverseContext) {
	  if (children == null) {
	    return 0;
	  }
	
	  return traverseAllChildrenImpl(children, '', callback, traverseContext);
	}
	
	module.exports = traverseAllChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelect
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	var valueContextKey = '__ReactDOMSelect_value$' + Math.random().toString(36).slice(2);
	
	function updateOptionsIfPendingUpdateAndMounted() {
	  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
	    this._wrapperState.pendingUpdate = false;
	
	    var props = this._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	
	    if (value != null) {
	      updateOptions(this, Boolean(props.multiple), value);
	    }
	  }
	}
	
	function getDeclarationErrorAddendum(owner) {
	  if (owner) {
	    var name = owner.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	var valuePropNames = ['value', 'defaultValue'];
	
	/**
	 * Validation function for `value` and `defaultValue`.
	 * @private
	 */
	function checkSelectPropTypes(inst, props) {
	  var owner = inst._currentElement._owner;
	  LinkedValueUtils.checkPropTypes('select', props, owner);
	
	  for (var i = 0; i < valuePropNames.length; i++) {
	    var propName = valuePropNames[i];
	    if (props[propName] == null) {
	      continue;
	    }
	    if (props.multiple) {
	      process.env.NODE_ENV !== 'production' ? warning(Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be an array if ' + '`multiple` is true.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    } else {
	      process.env.NODE_ENV !== 'production' ? warning(!Array.isArray(props[propName]), 'The `%s` prop supplied to <select> must be a scalar ' + 'value if `multiple` is false.%s', propName, getDeclarationErrorAddendum(owner)) : undefined;
	    }
	  }
	}
	
	/**
	 * @param {ReactDOMComponent} inst
	 * @param {boolean} multiple
	 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
	 * @private
	 */
	function updateOptions(inst, multiple, propValue) {
	  var selectedValue, i;
	  var options = ReactMount.getNode(inst._rootNodeID).options;
	
	  if (multiple) {
	    selectedValue = {};
	    for (i = 0; i < propValue.length; i++) {
	      selectedValue['' + propValue[i]] = true;
	    }
	    for (i = 0; i < options.length; i++) {
	      var selected = selectedValue.hasOwnProperty(options[i].value);
	      if (options[i].selected !== selected) {
	        options[i].selected = selected;
	      }
	    }
	  } else {
	    // Do not set `select.value` as exact behavior isn't consistent across all
	    // browsers for all cases.
	    selectedValue = '' + propValue;
	    for (i = 0; i < options.length; i++) {
	      if (options[i].value === selectedValue) {
	        options[i].selected = true;
	        return;
	      }
	    }
	    if (options.length) {
	      options[0].selected = true;
	    }
	  }
	}
	
	/**
	 * Implements a <select> native component that allows optionally setting the
	 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
	 * stringable. If `multiple` is true, the prop must be an array of stringables.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that change the
	 * selected option will trigger updates to the rendered options.
	 *
	 * If it is supplied (and not null/undefined), the rendered options will not
	 * update in response to user actions. Instead, the `value` prop must change in
	 * order for the rendered options to update.
	 *
	 * If `defaultValue` is provided, any options with the supplied values will be
	 * selected.
	 */
	var ReactDOMSelect = {
	  valueContextKey: valueContextKey,
	
	  getNativeProps: function getNativeProps(inst, props, context) {
	    return assign({}, props, {
	      onChange: inst._wrapperState.onChange,
	      value: undefined
	    });
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      checkSelectPropTypes(inst, props);
	    }
	
	    var value = LinkedValueUtils.getValue(props);
	    inst._wrapperState = {
	      pendingUpdate: false,
	      initialValue: value != null ? value : props.defaultValue,
	      onChange: _handleChange.bind(inst),
	      wasMultiple: Boolean(props.multiple)
	    };
	  },
	
	  processChildContext: function processChildContext(inst, props, context) {
	    // Pass down initial value so initial generated markup has correct
	    // `selected` attributes
	    var childContext = assign({}, context);
	    childContext[valueContextKey] = inst._wrapperState.initialValue;
	    return childContext;
	  },
	
	  postUpdateWrapper: function postUpdateWrapper(inst) {
	    var props = inst._currentElement.props;
	
	    // After the initial mount, we control selected-ness manually so don't pass
	    // the context value down
	    inst._wrapperState.initialValue = undefined;
	
	    var wasMultiple = inst._wrapperState.wasMultiple;
	    inst._wrapperState.wasMultiple = Boolean(props.multiple);
	
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      inst._wrapperState.pendingUpdate = false;
	      updateOptions(inst, Boolean(props.multiple), value);
	    } else if (wasMultiple !== Boolean(props.multiple)) {
	      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
	      if (props.defaultValue != null) {
	        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
	      } else {
	        // Revert the select back to its default unselected state.
	        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
	      }
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	
	  this._wrapperState.pendingUpdate = true;
	  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMSelect;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMTextarea
	 */
	
	'use strict';
	
	var LinkedValueUtils = __webpack_require__(113);
	var ReactDOMIDOperations = __webpack_require__(34);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function forceUpdateIfMounted() {
	  if (this._rootNodeID) {
	    // DOM component is still mounted; update
	    ReactDOMTextarea.updateWrapper(this);
	  }
	}
	
	/**
	 * Implements a <textarea> native component that allows setting `value`, and
	 * `defaultValue`. This differs from the traditional DOM API because value is
	 * usually set as PCDATA children.
	 *
	 * If `value` is not supplied (or null/undefined), user actions that affect the
	 * value will trigger updates to the element.
	 *
	 * If `value` is supplied (and not null/undefined), the rendered element will
	 * not trigger updates to the element. Instead, the `value` prop must change in
	 * order for the rendered element to be updated.
	 *
	 * The rendered element will be initialized with an empty value, the prop
	 * `defaultValue` if specified, or the children content (deprecated).
	 */
	var ReactDOMTextarea = {
	  getNativeProps: function getNativeProps(inst, props, context) {
	    !(props.dangerouslySetInnerHTML == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, '`dangerouslySetInnerHTML` does not make sense on <textarea>.') : invariant(false) : undefined;
	
	    // Always set children to the same thing. In IE9, the selection range will
	    // get reset if `textContent` is mutated.
	    var nativeProps = assign({}, props, {
	      defaultValue: undefined,
	      value: undefined,
	      children: inst._wrapperState.initialValue,
	      onChange: inst._wrapperState.onChange
	    });
	
	    return nativeProps;
	  },
	
	  mountWrapper: function mountWrapper(inst, props) {
	    if (process.env.NODE_ENV !== 'production') {
	      LinkedValueUtils.checkPropTypes('textarea', props, inst._currentElement._owner);
	    }
	
	    var defaultValue = props.defaultValue;
	    // TODO (yungsters): Remove support for children content in <textarea>.
	    var children = props.children;
	    if (children != null) {
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Use the `defaultValue` or `value` props instead of setting ' + 'children on <textarea>.') : undefined;
	      }
	      !(defaultValue == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'If you supply `defaultValue` on a <textarea>, do not pass children.') : invariant(false) : undefined;
	      if (Array.isArray(children)) {
	        !(children.length <= 1) ? process.env.NODE_ENV !== 'production' ? invariant(false, '<textarea> can only have at most one child.') : invariant(false) : undefined;
	        children = children[0];
	      }
	
	      defaultValue = '' + children;
	    }
	    if (defaultValue == null) {
	      defaultValue = '';
	    }
	    var value = LinkedValueUtils.getValue(props);
	
	    inst._wrapperState = {
	      // We save the initial value so that `ReactDOMComponent` doesn't update
	      // `textContent` (unnecessary since we update value).
	      // The initial value can be a boolean or object so that's why it's
	      // forced to be a string.
	      initialValue: '' + (value != null ? value : defaultValue),
	      onChange: _handleChange.bind(inst)
	    };
	  },
	
	  updateWrapper: function updateWrapper(inst) {
	    var props = inst._currentElement.props;
	    var value = LinkedValueUtils.getValue(props);
	    if (value != null) {
	      // Cast `value` to a string to ensure the value is set correctly. While
	      // browsers typically do this as necessary, jsdom doesn't.
	      ReactDOMIDOperations.updatePropertyByID(inst._rootNodeID, 'value', '' + value);
	    }
	  }
	};
	
	function _handleChange(event) {
	  var props = this._currentElement.props;
	  var returnValue = LinkedValueUtils.executeOnChange(props, event);
	  ReactUpdates.asap(forceUpdateIfMounted, this);
	  return returnValue;
	}
	
	module.exports = ReactDOMTextarea;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactMultiChild
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactMultiChildUpdateTypes = __webpack_require__(23);
	
	var ReactCurrentOwner = __webpack_require__(12);
	var ReactReconciler = __webpack_require__(57);
	var ReactChildReconciler = __webpack_require__(122);
	
	var flattenChildren = __webpack_require__(123);
	
	/**
	 * Updating children of a component may trigger recursive updates. The depth is
	 * used to batch recursive updates to render markup more efficiently.
	 *
	 * @type {number}
	 * @private
	 */
	var updateDepth = 0;
	
	/**
	 * Queue of update configuration objects.
	 *
	 * Each object has a `type` property that is in `ReactMultiChildUpdateTypes`.
	 *
	 * @type {array<object>}
	 * @private
	 */
	var updateQueue = [];
	
	/**
	 * Queue of markup to be rendered.
	 *
	 * @type {array<string>}
	 * @private
	 */
	var markupQueue = [];
	
	/**
	 * Enqueues markup to be rendered and inserted at a supplied index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @param {number} toIndex Destination index.
	 * @private
	 */
	function enqueueInsertMarkup(parentID, markup, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.INSERT_MARKUP,
	    markupIndex: markupQueue.push(markup) - 1,
	    content: null,
	    fromIndex: null,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues moving an existing element to another index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Source index of the existing element.
	 * @param {number} toIndex Destination index of the element.
	 * @private
	 */
	function enqueueMove(parentID, fromIndex, toIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.MOVE_EXISTING,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: toIndex
	  });
	}
	
	/**
	 * Enqueues removing an element at an index.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {number} fromIndex Index of the element to remove.
	 * @private
	 */
	function enqueueRemove(parentID, fromIndex) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.REMOVE_NODE,
	    markupIndex: null,
	    content: null,
	    fromIndex: fromIndex,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the markup of a node.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} markup Markup that renders into an element.
	 * @private
	 */
	function enqueueSetMarkup(parentID, markup) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.SET_MARKUP,
	    markupIndex: null,
	    content: markup,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Enqueues setting the text content.
	 *
	 * @param {string} parentID ID of the parent component.
	 * @param {string} textContent Text content to set.
	 * @private
	 */
	function enqueueTextContent(parentID, textContent) {
	  // NOTE: Null values reduce hidden classes.
	  updateQueue.push({
	    parentID: parentID,
	    parentNode: null,
	    type: ReactMultiChildUpdateTypes.TEXT_CONTENT,
	    markupIndex: null,
	    content: textContent,
	    fromIndex: null,
	    toIndex: null
	  });
	}
	
	/**
	 * Processes any enqueued updates.
	 *
	 * @private
	 */
	function processQueue() {
	  if (updateQueue.length) {
	    ReactComponentEnvironment.processChildrenUpdates(updateQueue, markupQueue);
	    clearQueue();
	  }
	}
	
	/**
	 * Clears any enqueued updates.
	 *
	 * @private
	 */
	function clearQueue() {
	  updateQueue.length = 0;
	  markupQueue.length = 0;
	}
	
	/**
	 * ReactMultiChild are capable of reconciling multiple children.
	 *
	 * @class ReactMultiChild
	 * @internal
	 */
	var ReactMultiChild = {
	
	  /**
	   * Provides common functionality for components that must reconcile multiple
	   * children. This is used by `ReactDOMComponent` to mount, update, and
	   * unmount child components.
	   *
	   * @lends {ReactMultiChild.prototype}
	   */
	  Mixin: {
	
	    _reconcilerInstantiateChildren: function _reconcilerInstantiateChildren(nestedChildren, transaction, context) {
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	        }
	      }
	      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
	    },
	
	    _reconcilerUpdateChildren: function _reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context) {
	      var nextChildren;
	      if (process.env.NODE_ENV !== 'production') {
	        if (this._currentElement) {
	          try {
	            ReactCurrentOwner.current = this._currentElement._owner;
	            nextChildren = flattenChildren(nextNestedChildrenElements);
	          } finally {
	            ReactCurrentOwner.current = null;
	          }
	          return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	        }
	      }
	      nextChildren = flattenChildren(nextNestedChildrenElements);
	      return ReactChildReconciler.updateChildren(prevChildren, nextChildren, transaction, context);
	    },
	
	    /**
	     * Generates a "mount image" for each of the supplied children. In the case
	     * of `ReactDOMComponent`, a mount image is a string of markup.
	     *
	     * @param {?object} nestedChildren Nested child maps.
	     * @return {array} An array of mounted representations.
	     * @internal
	     */
	    mountChildren: function mountChildren(nestedChildren, transaction, context) {
	      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
	      this._renderedChildren = children;
	      var mountImages = [];
	      var index = 0;
	      for (var name in children) {
	        if (children.hasOwnProperty(name)) {
	          var child = children[name];
	          // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	          var rootID = this._rootNodeID + name;
	          var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	          child._mountIndex = index++;
	          mountImages.push(mountImage);
	        }
	      }
	      return mountImages;
	    },
	
	    /**
	     * Replaces any rendered children with a text content string.
	     *
	     * @param {string} nextContent String of content.
	     * @internal
	     */
	    updateTextContent: function updateTextContent(nextContent) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        // TODO: The setTextContent operation should be enough
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChild(prevChildren[name]);
	          }
	        }
	        // Set new text content.
	        this.setTextContent(nextContent);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Replaces any rendered children with a markup string.
	     *
	     * @param {string} nextMarkup String of markup.
	     * @internal
	     */
	    updateMarkup: function updateMarkup(nextMarkup) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        var prevChildren = this._renderedChildren;
	        // Remove any rendered children.
	        ReactChildReconciler.unmountChildren(prevChildren);
	        for (var name in prevChildren) {
	          if (prevChildren.hasOwnProperty(name)) {
	            this._unmountChildByName(prevChildren[name], name);
	          }
	        }
	        this.setMarkup(nextMarkup);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Updates the rendered children with new children.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @internal
	     */
	    updateChildren: function updateChildren(nextNestedChildrenElements, transaction, context) {
	      updateDepth++;
	      var errorThrown = true;
	      try {
	        this._updateChildren(nextNestedChildrenElements, transaction, context);
	        errorThrown = false;
	      } finally {
	        updateDepth--;
	        if (!updateDepth) {
	          if (errorThrown) {
	            clearQueue();
	          } else {
	            processQueue();
	          }
	        }
	      }
	    },
	
	    /**
	     * Improve performance by isolating this hot code path from the try/catch
	     * block in `updateChildren`.
	     *
	     * @param {?object} nextNestedChildrenElements Nested child element maps.
	     * @param {ReactReconcileTransaction} transaction
	     * @final
	     * @protected
	     */
	    _updateChildren: function _updateChildren(nextNestedChildrenElements, transaction, context) {
	      var prevChildren = this._renderedChildren;
	      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, transaction, context);
	      this._renderedChildren = nextChildren;
	      if (!nextChildren && !prevChildren) {
	        return;
	      }
	      var name;
	      // `nextIndex` will increment for each child in `nextChildren`, but
	      // `lastIndex` will be the last index visited in `prevChildren`.
	      var lastIndex = 0;
	      var nextIndex = 0;
	      for (name in nextChildren) {
	        if (!nextChildren.hasOwnProperty(name)) {
	          continue;
	        }
	        var prevChild = prevChildren && prevChildren[name];
	        var nextChild = nextChildren[name];
	        if (prevChild === nextChild) {
	          this.moveChild(prevChild, nextIndex, lastIndex);
	          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	          prevChild._mountIndex = nextIndex;
	        } else {
	          if (prevChild) {
	            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
	            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
	            this._unmountChild(prevChild);
	          }
	          // The child must be instantiated before it's mounted.
	          this._mountChildByNameAtIndex(nextChild, name, nextIndex, transaction, context);
	        }
	        nextIndex++;
	      }
	      // Remove children that are no longer present.
	      for (name in prevChildren) {
	        if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	          this._unmountChild(prevChildren[name]);
	        }
	      }
	    },
	
	    /**
	     * Unmounts all rendered children. This should be used to clean up children
	     * when this component is unmounted.
	     *
	     * @internal
	     */
	    unmountChildren: function unmountChildren() {
	      var renderedChildren = this._renderedChildren;
	      ReactChildReconciler.unmountChildren(renderedChildren);
	      this._renderedChildren = null;
	    },
	
	    /**
	     * Moves a child component to the supplied index.
	     *
	     * @param {ReactComponent} child Component to move.
	     * @param {number} toIndex Destination index of the element.
	     * @param {number} lastIndex Last index visited of the siblings of `child`.
	     * @protected
	     */
	    moveChild: function moveChild(child, toIndex, lastIndex) {
	      // If the index of `child` is less than `lastIndex`, then it needs to
	      // be moved. Otherwise, we do not need to move it because a child will be
	      // inserted or moved before `child`.
	      if (child._mountIndex < lastIndex) {
	        enqueueMove(this._rootNodeID, child._mountIndex, toIndex);
	      }
	    },
	
	    /**
	     * Creates a child component.
	     *
	     * @param {ReactComponent} child Component to create.
	     * @param {string} mountImage Markup to insert.
	     * @protected
	     */
	    createChild: function createChild(child, mountImage) {
	      enqueueInsertMarkup(this._rootNodeID, mountImage, child._mountIndex);
	    },
	
	    /**
	     * Removes a child component.
	     *
	     * @param {ReactComponent} child Child to remove.
	     * @protected
	     */
	    removeChild: function removeChild(child) {
	      enqueueRemove(this._rootNodeID, child._mountIndex);
	    },
	
	    /**
	     * Sets this text content string.
	     *
	     * @param {string} textContent Text content to set.
	     * @protected
	     */
	    setTextContent: function setTextContent(textContent) {
	      enqueueTextContent(this._rootNodeID, textContent);
	    },
	
	    /**
	     * Sets this markup string.
	     *
	     * @param {string} markup Markup to set.
	     * @protected
	     */
	    setMarkup: function setMarkup(markup) {
	      enqueueSetMarkup(this._rootNodeID, markup);
	    },
	
	    /**
	     * Mounts a child with the supplied name.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to mount.
	     * @param {string} name Name of the child.
	     * @param {number} index Index at which to insert the child.
	     * @param {ReactReconcileTransaction} transaction
	     * @private
	     */
	    _mountChildByNameAtIndex: function _mountChildByNameAtIndex(child, name, index, transaction, context) {
	      // Inlined for performance, see `ReactInstanceHandles.createReactID`.
	      var rootID = this._rootNodeID + name;
	      var mountImage = ReactReconciler.mountComponent(child, rootID, transaction, context);
	      child._mountIndex = index;
	      this.createChild(child, mountImage);
	    },
	
	    /**
	     * Unmounts a rendered child.
	     *
	     * NOTE: This is part of `updateChildren` and is here for readability.
	     *
	     * @param {ReactComponent} child Component to unmount.
	     * @private
	     */
	    _unmountChild: function _unmountChild(child) {
	      this.removeChild(child);
	      child._mountIndex = null;
	    }
	
	  }
	
	};
	
	module.exports = ReactMultiChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactChildReconciler
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactReconciler = __webpack_require__(57);
	
	var instantiateReactComponent = __webpack_require__(69);
	var shouldUpdateReactComponent = __webpack_require__(74);
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	function instantiateChild(childInstances, child, name) {
	  // We found a component instance.
	  var keyUnique = childInstances[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (child != null && keyUnique) {
	    childInstances[name] = instantiateReactComponent(child, null);
	  }
	}
	
	/**
	 * ReactChildReconciler provides helpers for initializing or updating a set of
	 * children. Its output is suitable for passing it onto ReactMultiChild which
	 * does diffed reordering and insertion.
	 */
	var ReactChildReconciler = {
	  /**
	   * Generates a "mount image" for each of the supplied children. In the case
	   * of `ReactDOMComponent`, a mount image is a string of markup.
	   *
	   * @param {?object} nestedChildNodes Nested child maps.
	   * @return {?object} A set of child instances.
	   * @internal
	   */
	  instantiateChildren: function instantiateChildren(nestedChildNodes, transaction, context) {
	    if (nestedChildNodes == null) {
	      return null;
	    }
	    var childInstances = {};
	    traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
	    return childInstances;
	  },
	
	  /**
	   * Updates the rendered children and returns a new set of children.
	   *
	   * @param {?object} prevChildren Previously initialized set of children.
	   * @param {?object} nextChildren Flat child element maps.
	   * @param {ReactReconcileTransaction} transaction
	   * @param {object} context
	   * @return {?object} A new set of child instances.
	   * @internal
	   */
	  updateChildren: function updateChildren(prevChildren, nextChildren, transaction, context) {
	    // We currently don't have a way to track moves here but if we use iterators
	    // instead of for..in we can zip the iterators and check if an item has
	    // moved.
	    // TODO: If nothing has changed, return the prevChildren object so that we
	    // can quickly bailout if nothing has changed.
	    if (!nextChildren && !prevChildren) {
	      return null;
	    }
	    var name;
	    for (name in nextChildren) {
	      if (!nextChildren.hasOwnProperty(name)) {
	        continue;
	      }
	      var prevChild = prevChildren && prevChildren[name];
	      var prevElement = prevChild && prevChild._currentElement;
	      var nextElement = nextChildren[name];
	      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
	        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
	        nextChildren[name] = prevChild;
	      } else {
	        if (prevChild) {
	          ReactReconciler.unmountComponent(prevChild, name);
	        }
	        // The child must be instantiated before it's mounted.
	        var nextChildInstance = instantiateReactComponent(nextElement, null);
	        nextChildren[name] = nextChildInstance;
	      }
	    }
	    // Unmount children that are no longer present.
	    for (name in prevChildren) {
	      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
	        ReactReconciler.unmountComponent(prevChildren[name]);
	      }
	    }
	    return nextChildren;
	  },
	
	  /**
	   * Unmounts all rendered children. This should be used to clean up children
	   * when this component is unmounted.
	   *
	   * @param {?object} renderedChildren Previously initialized set of children.
	   * @internal
	   */
	  unmountChildren: function unmountChildren(renderedChildren) {
	    for (var name in renderedChildren) {
	      if (renderedChildren.hasOwnProperty(name)) {
	        var renderedChild = renderedChildren[name];
	        ReactReconciler.unmountComponent(renderedChild);
	      }
	    }
	  }
	
	};
	
	module.exports = ReactChildReconciler;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule flattenChildren
	 */
	
	'use strict';
	
	var traverseAllChildren = __webpack_require__(118);
	var warning = __webpack_require__(32);
	
	/**
	 * @param {function} traverseContext Context passed through traversal.
	 * @param {?ReactComponent} child React child component.
	 * @param {!string} name String name of key path to child.
	 */
	function flattenSingleChildIntoContext(traverseContext, child, name) {
	  // We found a component instance.
	  var result = traverseContext;
	  var keyUnique = result[name] === undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(keyUnique, 'flattenChildren(...): Encountered two children with the same key, ' + '`%s`. Child keys must be unique; when two children share a key, only ' + 'the first child will be used.', name) : undefined;
	  }
	  if (keyUnique && child != null) {
	    result[name] = child;
	  }
	}
	
	/**
	 * Flattens children that are typically specified as `props.children`. Any null
	 * children will not be included in the resulting object.
	 * @return {!object} flattened children keyed by name.
	 */
	function flattenChildren(children) {
	  if (children == null) {
	    return children;
	  }
	  var result = {};
	  traverseAllChildren(children, flattenSingleChildIntoContext, result);
	  return result;
	}
	
	module.exports = flattenChildren;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 124 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule shallowEqual
	 * @typechecks
	 * 
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Performs equality by iterating through keys on an object and returning false
	 * when any key has values which are not strictly equal between the arguments.
	 * Returns true when the values of all keys are strictly equal.
	 */
	function shallowEqual(objA, objB) {
	  if (objA === objB) {
	    return true;
	  }
	
	  if ((typeof objA === 'undefined' ? 'undefined' : _typeof(objA)) !== 'object' || objA === null || (typeof objB === 'undefined' ? 'undefined' : _typeof(objB)) !== 'object' || objB === null) {
	    return false;
	  }
	
	  var keysA = Object.keys(objA);
	  var keysB = Object.keys(objB);
	
	  if (keysA.length !== keysB.length) {
	    return false;
	  }
	
	  // Test for A's keys different from B.
	  var bHasOwnProperty = hasOwnProperty.bind(objB);
	  for (var i = 0; i < keysA.length; i++) {
	    if (!bHasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
	      return false;
	    }
	  }
	
	  return true;
	}
	
	module.exports = shallowEqual;

/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactEventListener
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var EventListener = __webpack_require__(126);
	var ExecutionEnvironment = __webpack_require__(16);
	var PooledClass = __webpack_require__(63);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMount = __webpack_require__(35);
	var ReactUpdates = __webpack_require__(61);
	
	var assign = __webpack_require__(46);
	var getEventTarget = __webpack_require__(88);
	var getUnboundedScrollPosition = __webpack_require__(127);
	
	var DOCUMENT_FRAGMENT_NODE_TYPE = 11;
	
	/**
	 * Finds the parent React component of `node`.
	 *
	 * @param {*} node
	 * @return {?DOMEventTarget} Parent container, or `null` if the specified node
	 *                           is not nested.
	 */
	function findParent(node) {
	  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
	  // traversal, but caching is difficult to do correctly without using a
	  // mutation observer to listen for all DOM changes.
	  var nodeID = ReactMount.getID(node);
	  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);
	  var container = ReactMount.findReactContainerForID(rootID);
	  var parent = ReactMount.getFirstReactDOM(container);
	  return parent;
	}
	
	// Used to store ancestor hierarchy in top level callback
	function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
	  this.topLevelType = topLevelType;
	  this.nativeEvent = nativeEvent;
	  this.ancestors = [];
	}
	assign(TopLevelCallbackBookKeeping.prototype, {
	  destructor: function destructor() {
	    this.topLevelType = null;
	    this.nativeEvent = null;
	    this.ancestors.length = 0;
	  }
	});
	PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);
	
	function handleTopLevelImpl(bookKeeping) {
	  // TODO: Re-enable event.path handling
	  //
	  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {
	  //   // New browsers have a path attribute on native events
	  //   handleTopLevelWithPath(bookKeeping);
	  // } else {
	  //   // Legacy browsers don't have a path attribute on native events
	  //   handleTopLevelWithoutPath(bookKeeping);
	  // }
	
	  void handleTopLevelWithPath; // temporarily unused
	  handleTopLevelWithoutPath(bookKeeping);
	}
	
	// Legacy browsers don't have a path attribute on native events
	function handleTopLevelWithoutPath(bookKeeping) {
	  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;
	
	  // Loop through the hierarchy, in case there's any nested components.
	  // It's important that we build the array of ancestors before calling any
	  // event handlers, because event handlers can modify the DOM, leading to
	  // inconsistencies with ReactMount's node cache. See #1105.
	  var ancestor = topLevelTarget;
	  while (ancestor) {
	    bookKeeping.ancestors.push(ancestor);
	    ancestor = findParent(ancestor);
	  }
	
	  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
	    topLevelTarget = bookKeeping.ancestors[i];
	    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	// New browsers have a path attribute on native events
	function handleTopLevelWithPath(bookKeeping) {
	  var path = bookKeeping.nativeEvent.path;
	  var currentNativeTarget = path[0];
	  var eventsFired = 0;
	  for (var i = 0; i < path.length; i++) {
	    var currentPathElement = path[i];
	    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {
	      currentNativeTarget = path[i + 1];
	    }
	    // TODO: slow
	    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);
	    if (reactParent === currentPathElement) {
	      var currentPathElementID = ReactMount.getID(currentPathElement);
	      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);
	      bookKeeping.ancestors.push(currentPathElement);
	
	      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';
	      eventsFired++;
	      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);
	
	      // Jump to the root of this React render tree
	      while (currentPathElementID !== newRootID) {
	        i++;
	        currentPathElement = path[i];
	        currentPathElementID = ReactMount.getID(currentPathElement);
	      }
	    }
	  }
	  if (eventsFired === 0) {
	    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
	  }
	}
	
	function scrollValueMonitor(cb) {
	  var scrollPosition = getUnboundedScrollPosition(window);
	  cb(scrollPosition);
	}
	
	var ReactEventListener = {
	  _enabled: true,
	  _handleTopLevel: null,
	
	  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,
	
	  setHandleTopLevel: function setHandleTopLevel(handleTopLevel) {
	    ReactEventListener._handleTopLevel = handleTopLevel;
	  },
	
	  setEnabled: function setEnabled(enabled) {
	    ReactEventListener._enabled = !!enabled;
	  },
	
	  isEnabled: function isEnabled() {
	    return ReactEventListener._enabled;
	  },
	
	  /**
	   * Traps top-level events by using event bubbling.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapBubbledEvent: function trapBubbledEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  /**
	   * Traps a top-level event by using event capturing.
	   *
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {string} handlerBaseName Event name (e.g. "click").
	   * @param {object} handle Element on which to attach listener.
	   * @return {?object} An object with a remove function which will forcefully
	   *                  remove the listener.
	   * @internal
	   */
	  trapCapturedEvent: function trapCapturedEvent(topLevelType, handlerBaseName, handle) {
	    var element = handle;
	    if (!element) {
	      return null;
	    }
	    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
	  },
	
	  monitorScrollValue: function monitorScrollValue(refresh) {
	    var callback = scrollValueMonitor.bind(null, refresh);
	    EventListener.listen(window, 'scroll', callback);
	  },
	
	  dispatchEvent: function dispatchEvent(topLevelType, nativeEvent) {
	    if (!ReactEventListener._enabled) {
	      return;
	    }
	
	    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
	    try {
	      // Event queue being processed in the same cycle allows
	      // `preventDefault`.
	      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
	    } finally {
	      TopLevelCallbackBookKeeping.release(bookKeeping);
	    }
	  }
	};
	
	module.exports = ReactEventListener;

/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 * @providesModule EventListener
	 * @typechecks
	 */
	
	'use strict';
	
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Upstream version of event listener. Does not take into account specific
	 * nature of platform.
	 */
	var EventListener = {
	  /**
	   * Listen to DOM events during the bubble phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  listen: function listen(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, false);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, false);
	        }
	      };
	    } else if (target.attachEvent) {
	      target.attachEvent('on' + eventType, callback);
	      return {
	        remove: function remove() {
	          target.detachEvent('on' + eventType, callback);
	        }
	      };
	    }
	  },
	
	  /**
	   * Listen to DOM events during the capture phase.
	   *
	   * @param {DOMEventTarget} target DOM element to register listener on.
	   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
	   * @param {function} callback Callback function.
	   * @return {object} Object with a `remove` method.
	   */
	  capture: function capture(target, eventType, callback) {
	    if (target.addEventListener) {
	      target.addEventListener(eventType, callback, true);
	      return {
	        remove: function remove() {
	          target.removeEventListener(eventType, callback, true);
	        }
	      };
	    } else {
	      if (process.env.NODE_ENV !== 'production') {
	        console.error('Attempted to listen to events during the capture phase on a ' + 'browser that does not support the capture phase. Your application ' + 'will not receive some events.');
	      }
	      return {
	        remove: emptyFunction
	      };
	    }
	  },
	
	  registerDefault: function registerDefault() {}
	};
	
	module.exports = EventListener;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 127 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getUnboundedScrollPosition
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Gets the scroll position of the supplied element or window.
	 *
	 * The return values are unbounded, unlike `getScrollPosition`. This means they
	 * may be negative or exceed the element boundaries (which is possible using
	 * inertial scrolling).
	 *
	 * @param {DOMWindow|DOMElement} scrollable
	 * @return {object} Map with `x` and `y` keys.
	 */
	
	function getUnboundedScrollPosition(scrollable) {
	  if (scrollable === window) {
	    return {
	      x: window.pageXOffset || document.documentElement.scrollLeft,
	      y: window.pageYOffset || document.documentElement.scrollTop
	    };
	  }
	  return {
	    x: scrollable.scrollLeft,
	    y: scrollable.scrollTop
	  };
	}
	
	module.exports = getUnboundedScrollPosition;

/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInjection
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	var EventPluginHub = __webpack_require__(38);
	var ReactComponentEnvironment = __webpack_require__(71);
	var ReactClass = __webpack_require__(129);
	var ReactEmptyComponent = __webpack_require__(75);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactNativeComponent = __webpack_require__(76);
	var ReactPerf = __webpack_require__(25);
	var ReactRootIndex = __webpack_require__(53);
	var ReactUpdates = __webpack_require__(61);
	
	var ReactInjection = {
	  Component: ReactComponentEnvironment.injection,
	  Class: ReactClass.injection,
	  DOMProperty: DOMProperty.injection,
	  EmptyComponent: ReactEmptyComponent.injection,
	  EventPluginHub: EventPluginHub.injection,
	  EventEmitter: ReactBrowserEventEmitter.injection,
	  NativeComponent: ReactNativeComponent.injection,
	  Perf: ReactPerf.injection,
	  RootIndex: ReactRootIndex.injection,
	  Updates: ReactUpdates.injection
	};
	
	module.exports = ReactInjection;

/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactClass
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactComponent = __webpack_require__(130);
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var assign = __webpack_require__(46);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var keyMirror = __webpack_require__(24);
	var keyOf = __webpack_require__(86);
	var warning = __webpack_require__(32);
	
	var MIXINS_KEY = keyOf({ mixins: null });
	
	/**
	 * Policies that describe methods in `ReactClassInterface`.
	 */
	var SpecPolicy = keyMirror({
	  /**
	   * These methods may be defined only once by the class specification or mixin.
	   */
	  DEFINE_ONCE: null,
	  /**
	   * These methods may be defined by both the class specification and mixins.
	   * Subsequent definitions will be chained. These methods must return void.
	   */
	  DEFINE_MANY: null,
	  /**
	   * These methods are overriding the base class.
	   */
	  OVERRIDE_BASE: null,
	  /**
	   * These methods are similar to DEFINE_MANY, except we assume they return
	   * objects. We try to merge the keys of the return values of all the mixed in
	   * functions. If there is a key conflict we throw.
	   */
	  DEFINE_MANY_MERGED: null
	});
	
	var injectedMixins = [];
	
	var warnedSetProps = false;
	function warnSetProps() {
	  if (!warnedSetProps) {
	    warnedSetProps = true;
	    process.env.NODE_ENV !== 'production' ? warning(false, 'setProps(...) and replaceProps(...) are deprecated. ' + 'Instead, call render again at the top level.') : undefined;
	  }
	}
	
	/**
	 * Composite components are higher-level components that compose other composite
	 * or native components.
	 *
	 * To create a new type of `ReactClass`, pass a specification of
	 * your new class to `React.createClass`. The only requirement of your class
	 * specification is that you implement a `render` method.
	 *
	 *   var MyComponent = React.createClass({
	 *     render: function() {
	 *       return <div>Hello World</div>;
	 *     }
	 *   });
	 *
	 * The class specification supports a specific protocol of methods that have
	 * special meaning (e.g. `render`). See `ReactClassInterface` for
	 * more the comprehensive protocol. Any other properties and methods in the
	 * class specification will be available on the prototype.
	 *
	 * @interface ReactClassInterface
	 * @internal
	 */
	var ReactClassInterface = {
	
	  /**
	   * An array of Mixin objects to include when defining your component.
	   *
	   * @type {array}
	   * @optional
	   */
	  mixins: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * An object containing properties and methods that should be defined on
	   * the component's constructor instead of its prototype (static methods).
	   *
	   * @type {object}
	   * @optional
	   */
	  statics: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of prop types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  propTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types for this component.
	   *
	   * @type {object}
	   * @optional
	   */
	  contextTypes: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Definition of context types this component sets for its children.
	   *
	   * @type {object}
	   * @optional
	   */
	  childContextTypes: SpecPolicy.DEFINE_MANY,
	
	  // ==== Definition methods ====
	
	  /**
	   * Invoked when the component is mounted. Values in the mapping will be set on
	   * `this.props` if that prop is not specified (i.e. using an `in` check).
	   *
	   * This method is invoked before `getInitialState` and therefore cannot rely
	   * on `this.state` or use `this.setState`.
	   *
	   * @return {object}
	   * @optional
	   */
	  getDefaultProps: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Invoked once before the component is mounted. The return value will be used
	   * as the initial value of `this.state`.
	   *
	   *   getInitialState: function() {
	   *     return {
	   *       isOn: false,
	   *       fooBaz: new BazFoo()
	   *     }
	   *   }
	   *
	   * @return {object}
	   * @optional
	   */
	  getInitialState: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * @return {object}
	   * @optional
	   */
	  getChildContext: SpecPolicy.DEFINE_MANY_MERGED,
	
	  /**
	   * Uses props from `this.props` and state from `this.state` to render the
	   * structure of the component.
	   *
	   * No guarantees are made about when or how often this method is invoked, so
	   * it must not have side effects.
	   *
	   *   render: function() {
	   *     var name = this.props.name;
	   *     return <div>Hello, {name}!</div>;
	   *   }
	   *
	   * @return {ReactComponent}
	   * @nosideeffects
	   * @required
	   */
	  render: SpecPolicy.DEFINE_ONCE,
	
	  // ==== Delegate methods ====
	
	  /**
	   * Invoked when the component is initially created and about to be mounted.
	   * This may have side effects, but any external subscriptions or data created
	   * by this method must be cleaned up in `componentWillUnmount`.
	   *
	   * @optional
	   */
	  componentWillMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component has been mounted and has a DOM representation.
	   * However, there is no guarantee that the DOM node is in the document.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been mounted (initialized and rendered) for the first time.
	   *
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidMount: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked before the component receives new props.
	   *
	   * Use this as an opportunity to react to a prop transition by updating the
	   * state using `this.setState`. Current props are accessed via `this.props`.
	   *
	   *   componentWillReceiveProps: function(nextProps, nextContext) {
	   *     this.setState({
	   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
	   *     });
	   *   }
	   *
	   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
	   * transition may cause a state change, but the opposite is not true. If you
	   * need it, you are probably looking for `componentWillUpdate`.
	   *
	   * @param {object} nextProps
	   * @optional
	   */
	  componentWillReceiveProps: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked while deciding if the component should be updated as a result of
	   * receiving new props, state and/or context.
	   *
	   * Use this as an opportunity to `return false` when you're certain that the
	   * transition to the new props/state/context will not require a component
	   * update.
	   *
	   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
	   *     return !equal(nextProps, this.props) ||
	   *       !equal(nextState, this.state) ||
	   *       !equal(nextContext, this.context);
	   *   }
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @return {boolean} True if the component should update.
	   * @optional
	   */
	  shouldComponentUpdate: SpecPolicy.DEFINE_ONCE,
	
	  /**
	   * Invoked when the component is about to update due to a transition from
	   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
	   * and `nextContext`.
	   *
	   * Use this as an opportunity to perform preparation before an update occurs.
	   *
	   * NOTE: You **cannot** use `this.setState()` in this method.
	   *
	   * @param {object} nextProps
	   * @param {?object} nextState
	   * @param {?object} nextContext
	   * @param {ReactReconcileTransaction} transaction
	   * @optional
	   */
	  componentWillUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component's DOM representation has been updated.
	   *
	   * Use this as an opportunity to operate on the DOM when the component has
	   * been updated.
	   *
	   * @param {object} prevProps
	   * @param {?object} prevState
	   * @param {?object} prevContext
	   * @param {DOMElement} rootNode DOM element representing the component.
	   * @optional
	   */
	  componentDidUpdate: SpecPolicy.DEFINE_MANY,
	
	  /**
	   * Invoked when the component is about to be removed from its parent and have
	   * its DOM representation destroyed.
	   *
	   * Use this as an opportunity to deallocate any external resources.
	   *
	   * NOTE: There is no `componentDidUnmount` since your component will have been
	   * destroyed by that point.
	   *
	   * @optional
	   */
	  componentWillUnmount: SpecPolicy.DEFINE_MANY,
	
	  // ==== Advanced methods ====
	
	  /**
	   * Updates the component's currently mounted DOM representation.
	   *
	   * By default, this implements React's rendering and reconciliation algorithm.
	   * Sophisticated clients may wish to override this.
	   *
	   * @param {ReactReconcileTransaction} transaction
	   * @internal
	   * @overridable
	   */
	  updateComponent: SpecPolicy.OVERRIDE_BASE
	
	};
	
	/**
	 * Mapping from class specification keys to special processing functions.
	 *
	 * Although these are declared like instance properties in the specification
	 * when defining classes using `React.createClass`, they are actually static
	 * and are accessible on the constructor instead of the prototype. Despite
	 * being static, they must be defined outside of the "statics" key under
	 * which all other static methods are defined.
	 */
	var RESERVED_SPEC_KEYS = {
	  displayName: function displayName(Constructor, _displayName) {
	    Constructor.displayName = _displayName;
	  },
	  mixins: function mixins(Constructor, _mixins) {
	    if (_mixins) {
	      for (var i = 0; i < _mixins.length; i++) {
	        mixSpecIntoComponent(Constructor, _mixins[i]);
	      }
	    }
	  },
	  childContextTypes: function childContextTypes(Constructor, _childContextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _childContextTypes, ReactPropTypeLocations.childContext);
	    }
	    Constructor.childContextTypes = assign({}, Constructor.childContextTypes, _childContextTypes);
	  },
	  contextTypes: function contextTypes(Constructor, _contextTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _contextTypes, ReactPropTypeLocations.context);
	    }
	    Constructor.contextTypes = assign({}, Constructor.contextTypes, _contextTypes);
	  },
	  /**
	   * Special case getDefaultProps which should move into statics but requires
	   * automatic merging.
	   */
	  getDefaultProps: function getDefaultProps(Constructor, _getDefaultProps) {
	    if (Constructor.getDefaultProps) {
	      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, _getDefaultProps);
	    } else {
	      Constructor.getDefaultProps = _getDefaultProps;
	    }
	  },
	  propTypes: function propTypes(Constructor, _propTypes) {
	    if (process.env.NODE_ENV !== 'production') {
	      validateTypeDef(Constructor, _propTypes, ReactPropTypeLocations.prop);
	    }
	    Constructor.propTypes = assign({}, Constructor.propTypes, _propTypes);
	  },
	  statics: function statics(Constructor, _statics) {
	    mixStaticSpecIntoComponent(Constructor, _statics);
	  },
	  autobind: function autobind() {} };
	
	// noop
	function validateTypeDef(Constructor, typeDef, location) {
	  for (var propName in typeDef) {
	    if (typeDef.hasOwnProperty(propName)) {
	      // use a warning instead of an invariant so components
	      // don't show up in prod but not in __DEV__
	      process.env.NODE_ENV !== 'production' ? warning(typeof typeDef[propName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', Constructor.displayName || 'ReactClass', ReactPropTypeLocationNames[location], propName) : undefined;
	    }
	  }
	}
	
	function validateMethodOverride(proto, name) {
	  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;
	
	  // Disallow overriding of base class methods unless explicitly allowed.
	  if (ReactClassMixin.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.OVERRIDE_BASE) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to override ' + '`%s` from your class specification. Ensure that your method names ' + 'do not overlap with React methods.', name) : invariant(false) : undefined;
	  }
	
	  // Disallow defining methods more than once unless explicitly allowed.
	  if (proto.hasOwnProperty(name)) {
	    !(specPolicy === SpecPolicy.DEFINE_MANY || specPolicy === SpecPolicy.DEFINE_MANY_MERGED) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClassInterface: You are attempting to define ' + '`%s` on your component more than once. This conflict may be due ' + 'to a mixin.', name) : invariant(false) : undefined;
	  }
	}
	
	/**
	 * Mixin helper which handles policy validation and reserved
	 * specification keys when building React classses.
	 */
	function mixSpecIntoComponent(Constructor, spec) {
	  if (!spec) {
	    return;
	  }
	
	  !(typeof spec !== 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component class as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	  !!ReactElement.isValidElement(spec) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You\'re attempting to ' + 'use a component as a mixin. Instead, just use a regular object.') : invariant(false) : undefined;
	
	  var proto = Constructor.prototype;
	
	  // By handling mixins before any other properties, we ensure the same
	  // chaining order is applied to methods with DEFINE_MANY policy, whether
	  // mixins are listed before or after these methods in the spec.
	  if (spec.hasOwnProperty(MIXINS_KEY)) {
	    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
	  }
	
	  for (var name in spec) {
	    if (!spec.hasOwnProperty(name)) {
	      continue;
	    }
	
	    if (name === MIXINS_KEY) {
	      // We have already handled mixins in a special case above.
	      continue;
	    }
	
	    var property = spec[name];
	    validateMethodOverride(proto, name);
	
	    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
	      RESERVED_SPEC_KEYS[name](Constructor, property);
	    } else {
	      // Setup methods on prototype:
	      // The following member methods should not be automatically bound:
	      // 1. Expected ReactClass methods (in the "interface").
	      // 2. Overridden methods (that were mixed in).
	      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
	      var isAlreadyDefined = proto.hasOwnProperty(name);
	      var isFunction = typeof property === 'function';
	      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;
	
	      if (shouldAutoBind) {
	        if (!proto.__reactAutoBindMap) {
	          proto.__reactAutoBindMap = {};
	        }
	        proto.__reactAutoBindMap[name] = property;
	        proto[name] = property;
	      } else {
	        if (isAlreadyDefined) {
	          var specPolicy = ReactClassInterface[name];
	
	          // These cases should already be caught by validateMethodOverride.
	          !(isReactClassMethod && (specPolicy === SpecPolicy.DEFINE_MANY_MERGED || specPolicy === SpecPolicy.DEFINE_MANY)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: Unexpected spec policy %s for key %s ' + 'when mixing in component specs.', specPolicy, name) : invariant(false) : undefined;
	
	          // For methods which are defined more than once, call the existing
	          // methods before calling the new property, merging if appropriate.
	          if (specPolicy === SpecPolicy.DEFINE_MANY_MERGED) {
	            proto[name] = createMergedResultFunction(proto[name], property);
	          } else if (specPolicy === SpecPolicy.DEFINE_MANY) {
	            proto[name] = createChainedFunction(proto[name], property);
	          }
	        } else {
	          proto[name] = property;
	          if (process.env.NODE_ENV !== 'production') {
	            // Add verbose displayName to the function, which helps when looking
	            // at profiling tools.
	            if (typeof property === 'function' && spec.displayName) {
	              proto[name].displayName = spec.displayName + '_' + name;
	            }
	          }
	        }
	      }
	    }
	  }
	}
	
	function mixStaticSpecIntoComponent(Constructor, statics) {
	  if (!statics) {
	    return;
	  }
	  for (var name in statics) {
	    var property = statics[name];
	    if (!statics.hasOwnProperty(name)) {
	      continue;
	    }
	
	    var isReserved = name in RESERVED_SPEC_KEYS;
	    !!isReserved ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define a reserved ' + 'property, `%s`, that shouldn\'t be on the "statics" key. Define it ' + 'as an instance property instead; it will still be accessible on the ' + 'constructor.', name) : invariant(false) : undefined;
	
	    var isInherited = name in Constructor;
	    !!isInherited ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactClass: You are attempting to define ' + '`%s` on your component more than once. This conflict may be ' + 'due to a mixin.', name) : invariant(false) : undefined;
	    Constructor[name] = property;
	  }
	}
	
	/**
	 * Merge two objects, but throw if both contain the same key.
	 *
	 * @param {object} one The first object, which is mutated.
	 * @param {object} two The second object
	 * @return {object} one after it has been mutated to contain everything in two.
	 */
	function mergeIntoWithNoDuplicateKeys(one, two) {
	  !(one && two && (typeof one === 'undefined' ? 'undefined' : _typeof(one)) === 'object' && (typeof two === 'undefined' ? 'undefined' : _typeof(two)) === 'object') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.') : invariant(false) : undefined;
	
	  for (var key in two) {
	    if (two.hasOwnProperty(key)) {
	      !(one[key] === undefined) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'mergeIntoWithNoDuplicateKeys(): ' + 'Tried to merge two objects with the same key: `%s`. This conflict ' + 'may be due to a mixin; in particular, this may be caused by two ' + 'getInitialState() or getDefaultProps() methods returning objects ' + 'with clashing keys.', key) : invariant(false) : undefined;
	      one[key] = two[key];
	    }
	  }
	  return one;
	}
	
	/**
	 * Creates a function that invokes two functions and merges their return values.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createMergedResultFunction(one, two) {
	  return function mergedResult() {
	    var a = one.apply(this, arguments);
	    var b = two.apply(this, arguments);
	    if (a == null) {
	      return b;
	    } else if (b == null) {
	      return a;
	    }
	    var c = {};
	    mergeIntoWithNoDuplicateKeys(c, a);
	    mergeIntoWithNoDuplicateKeys(c, b);
	    return c;
	  };
	}
	
	/**
	 * Creates a function that invokes two functions and ignores their return vales.
	 *
	 * @param {function} one Function to invoke first.
	 * @param {function} two Function to invoke second.
	 * @return {function} Function that invokes the two argument functions.
	 * @private
	 */
	function createChainedFunction(one, two) {
	  return function chainedFunction() {
	    one.apply(this, arguments);
	    two.apply(this, arguments);
	  };
	}
	
	/**
	 * Binds a method to the component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 * @param {function} method Method to be bound.
	 * @return {function} The bound method.
	 */
	function bindAutoBindMethod(component, method) {
	  var boundMethod = method.bind(component);
	  if (process.env.NODE_ENV !== 'production') {
	    boundMethod.__reactBoundContext = component;
	    boundMethod.__reactBoundMethod = method;
	    boundMethod.__reactBoundArguments = null;
	    var componentName = component.constructor.displayName;
	    var _bind = boundMethod.bind;
	    /* eslint-disable block-scoped-var, no-undef */
	    boundMethod.bind = function (newThis) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      // User is trying to bind() an autobound method; we effectively will
	      // ignore the value of "this" that the user is trying to use, so
	      // let's warn.
	      if (newThis !== component && newThis !== null) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): React component methods may only be bound to the ' + 'component instance. See %s', componentName) : undefined;
	      } else if (!args.length) {
	        process.env.NODE_ENV !== 'production' ? warning(false, 'bind(): You are binding a component method to the component. ' + 'React does this for you automatically in a high-performance ' + 'way, so you can safely remove this call. See %s', componentName) : undefined;
	        return boundMethod;
	      }
	      var reboundMethod = _bind.apply(boundMethod, arguments);
	      reboundMethod.__reactBoundContext = component;
	      reboundMethod.__reactBoundMethod = method;
	      reboundMethod.__reactBoundArguments = args;
	      return reboundMethod;
	      /* eslint-enable */
	    };
	  }
	  return boundMethod;
	}
	
	/**
	 * Binds all auto-bound methods in a component.
	 *
	 * @param {object} component Component whose method is going to be bound.
	 */
	function bindAutoBindMethods(component) {
	  for (var autoBindKey in component.__reactAutoBindMap) {
	    if (component.__reactAutoBindMap.hasOwnProperty(autoBindKey)) {
	      var method = component.__reactAutoBindMap[autoBindKey];
	      component[autoBindKey] = bindAutoBindMethod(component, method);
	    }
	  }
	}
	
	/**
	 * Add more to the ReactClass base class. These are all legacy features and
	 * therefore not already part of the modern ReactComponent.
	 */
	var ReactClassMixin = {
	
	  /**
	   * TODO: This will be deprecated because state should always keep a consistent
	   * type signature and the only use case for this, is to avoid that.
	   */
	  replaceState: function replaceState(newState, callback) {
	    this.updater.enqueueReplaceState(this, newState);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted() {
	    return this.updater.isMounted(this);
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {object} partialProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  setProps: function setProps(partialProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueSetProps(this, partialProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  },
	
	  /**
	   * Replace all the props.
	   *
	   * @param {object} newProps Subset of the next props.
	   * @param {?function} callback Called after props are updated.
	   * @final
	   * @public
	   * @deprecated
	   */
	  replaceProps: function replaceProps(newProps, callback) {
	    if (process.env.NODE_ENV !== 'production') {
	      warnSetProps();
	    }
	    this.updater.enqueueReplaceProps(this, newProps);
	    if (callback) {
	      this.updater.enqueueCallback(this, callback);
	    }
	  }
	};
	
	var ReactClassComponent = function ReactClassComponent() {};
	assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);
	
	/**
	 * Module for creating composite components.
	 *
	 * @class ReactClass
	 */
	var ReactClass = {
	
	  /**
	   * Creates a composite component class given a class specification.
	   *
	   * @param {object} spec Class specification (which must define `render`).
	   * @return {function} Component constructor function.
	   * @public
	   */
	  createClass: function createClass(spec) {
	    var Constructor = function Constructor(props, context, updater) {
	      // This constructor is overridden by mocks. The argument is used
	      // by mocks to assert on what gets mounted.
	
	      if (process.env.NODE_ENV !== 'production') {
	        process.env.NODE_ENV !== 'production' ? warning(this instanceof Constructor, 'Something is calling a React component directly. Use a factory or ' + 'JSX instead. See: https://fb.me/react-legacyfactory') : undefined;
	      }
	
	      // Wire up auto-binding
	      if (this.__reactAutoBindMap) {
	        bindAutoBindMethods(this);
	      }
	
	      this.props = props;
	      this.context = context;
	      this.refs = emptyObject;
	      this.updater = updater || ReactNoopUpdateQueue;
	
	      this.state = null;
	
	      // ReactClasses doesn't have constructors. Instead, they use the
	      // getInitialState and componentWillMount methods for initialization.
	
	      var initialState = this.getInitialState ? this.getInitialState() : null;
	      if (process.env.NODE_ENV !== 'production') {
	        // We allow auto-mocks to proceed as if they're returning null.
	        if (typeof initialState === 'undefined' && this.getInitialState._isMockFunction) {
	          // This is probably bad practice. Consider warning here and
	          // deprecating this convenience.
	          initialState = null;
	        }
	      }
	      !((typeof initialState === 'undefined' ? 'undefined' : _typeof(initialState)) === 'object' && !Array.isArray(initialState)) ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s.getInitialState(): must return an object or null', Constructor.displayName || 'ReactCompositeComponent') : invariant(false) : undefined;
	
	      this.state = initialState;
	    };
	    Constructor.prototype = new ReactClassComponent();
	    Constructor.prototype.constructor = Constructor;
	
	    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));
	
	    mixSpecIntoComponent(Constructor, spec);
	
	    // Initialize the defaultProps property after all mixins have been merged.
	    if (Constructor.getDefaultProps) {
	      Constructor.defaultProps = Constructor.getDefaultProps();
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      // This is a tag to indicate that the use of these method names is ok,
	      // since it's used with createClass. If it's not, then it's likely a
	      // mistake so we'll warn you to use the static property, property
	      // initializer or constructor respectively.
	      if (Constructor.getDefaultProps) {
	        Constructor.getDefaultProps.isReactClassApproved = {};
	      }
	      if (Constructor.prototype.getInitialState) {
	        Constructor.prototype.getInitialState.isReactClassApproved = {};
	      }
	    }
	
	    !Constructor.prototype.render ? process.env.NODE_ENV !== 'production' ? invariant(false, 'createClass(...): Class specification must implement a `render` method.') : invariant(false) : undefined;
	
	    if (process.env.NODE_ENV !== 'production') {
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentShouldUpdate, '%s has a method called ' + 'componentShouldUpdate(). Did you mean shouldComponentUpdate()? ' + 'The name is phrased as a question because the function is ' + 'expected to return a value.', spec.displayName || 'A component') : undefined;
	      process.env.NODE_ENV !== 'production' ? warning(!Constructor.prototype.componentWillRecieveProps, '%s has a method called ' + 'componentWillRecieveProps(). Did you mean componentWillReceiveProps()?', spec.displayName || 'A component') : undefined;
	    }
	
	    // Reduce time spent doing lookups by setting these on the prototype.
	    for (var methodName in ReactClassInterface) {
	      if (!Constructor.prototype[methodName]) {
	        Constructor.prototype[methodName] = null;
	      }
	    }
	
	    return Constructor;
	  },
	
	  injection: {
	    injectMixin: function injectMixin(mixin) {
	      injectedMixins.push(mixin);
	    }
	  }
	
	};
	
	module.exports = ReactClass;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactComponent
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactNoopUpdateQueue = __webpack_require__(131);
	
	var canDefineProperty = __webpack_require__(50);
	var emptyObject = __webpack_require__(65);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	/**
	 * Base class helpers for the updating state of a component.
	 */
	function ReactComponent(props, context, updater) {
	  this.props = props;
	  this.context = context;
	  this.refs = emptyObject;
	  // We initialize the default updater but the real one gets injected by the
	  // renderer.
	  this.updater = updater || ReactNoopUpdateQueue;
	}
	
	ReactComponent.prototype.isReactComponent = {};
	
	/**
	 * Sets a subset of the state. Always use this to mutate
	 * state. You should treat `this.state` as immutable.
	 *
	 * There is no guarantee that `this.state` will be immediately updated, so
	 * accessing `this.state` after calling this method may return the old value.
	 *
	 * There is no guarantee that calls to `setState` will run synchronously,
	 * as they may eventually be batched together.  You can provide an optional
	 * callback that will be executed when the call to setState is actually
	 * completed.
	 *
	 * When a function is provided to setState, it will be called at some point in
	 * the future (not synchronously). It will be called with the up to date
	 * component arguments (state, props, context). These values can be different
	 * from this.* because your function may be called after receiveProps but before
	 * shouldComponentUpdate, and this new state, props, and context will not yet be
	 * assigned to this.
	 *
	 * @param {object|function} partialState Next partial state or function to
	 *        produce next partial state to be merged with current state.
	 * @param {?function} callback Called after state is updated.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.setState = function (partialState, callback) {
	  !((typeof partialState === 'undefined' ? 'undefined' : _typeof(partialState)) === 'object' || typeof partialState === 'function' || partialState == null) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setState(...): takes an object of state variables to update or a ' + 'function which returns an object of state variables.') : invariant(false) : undefined;
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(partialState != null, 'setState(...): You passed an undefined or null state object; ' + 'instead, use forceUpdate().') : undefined;
	  }
	  this.updater.enqueueSetState(this, partialState);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Forces an update. This should only be invoked when it is known with
	 * certainty that we are **not** in a DOM transaction.
	 *
	 * You may want to call this when you know that some deeper aspect of the
	 * component's state has changed but `setState` was not called.
	 *
	 * This will not invoke `shouldComponentUpdate`, but it will invoke
	 * `componentWillUpdate` and `componentDidUpdate`.
	 *
	 * @param {?function} callback Called after update is complete.
	 * @final
	 * @protected
	 */
	ReactComponent.prototype.forceUpdate = function (callback) {
	  this.updater.enqueueForceUpdate(this);
	  if (callback) {
	    this.updater.enqueueCallback(this, callback);
	  }
	};
	
	/**
	 * Deprecated APIs. These APIs used to exist on classic React classes but since
	 * we would like to deprecate them, we're not going to move them over to this
	 * modern base class. Instead, we define a getter that warns if it's accessed.
	 */
	if (process.env.NODE_ENV !== 'production') {
	  var deprecatedAPIs = {
	    getDOMNode: ['getDOMNode', 'Use ReactDOM.findDOMNode(component) instead.'],
	    isMounted: ['isMounted', 'Instead, make sure to clean up subscriptions and pending requests in ' + 'componentWillUnmount to prevent memory leaks.'],
	    replaceProps: ['replaceProps', 'Instead, call render again at the top level.'],
	    replaceState: ['replaceState', 'Refactor your code to use setState instead (see ' + 'https://github.com/facebook/react/issues/3236).'],
	    setProps: ['setProps', 'Instead, call render again at the top level.']
	  };
	  var defineDeprecationWarning = function defineDeprecationWarning(methodName, info) {
	    if (canDefineProperty) {
	      Object.defineProperty(ReactComponent.prototype, methodName, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? warning(false, '%s(...) is deprecated in plain JavaScript React classes. %s', info[0], info[1]) : undefined;
	          return undefined;
	        }
	      });
	    }
	  };
	  for (var fnName in deprecatedAPIs) {
	    if (deprecatedAPIs.hasOwnProperty(fnName)) {
	      defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
	    }
	  }
	}
	
	module.exports = ReactComponent;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactNoopUpdateQueue
	 */
	
	'use strict';
	
	var warning = __webpack_require__(32);
	
	function warnTDZ(publicInstance, callerName) {
	  if (process.env.NODE_ENV !== 'production') {
	    process.env.NODE_ENV !== 'production' ? warning(false, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor && publicInstance.constructor.displayName || '') : undefined;
	  }
	}
	
	/**
	 * This is the abstract API for an update queue.
	 */
	var ReactNoopUpdateQueue = {
	
	  /**
	   * Checks whether or not this composite component is mounted.
	   * @param {ReactClass} publicInstance The instance we want to test.
	   * @return {boolean} True if mounted, false otherwise.
	   * @protected
	   * @final
	   */
	  isMounted: function isMounted(publicInstance) {
	    return false;
	  },
	
	  /**
	   * Enqueue a callback that will be executed after all the pending updates
	   * have processed.
	   *
	   * @param {ReactClass} publicInstance The instance to use as `this` context.
	   * @param {?function} callback Called after state is updated.
	   * @internal
	   */
	  enqueueCallback: function enqueueCallback(publicInstance, callback) {},
	
	  /**
	   * Forces an update. This should only be invoked when it is known with
	   * certainty that we are **not** in a DOM transaction.
	   *
	   * You may want to call this when you know that some deeper aspect of the
	   * component's state has changed but `setState` was not called.
	   *
	   * This will not invoke `shouldComponentUpdate`, but it will invoke
	   * `componentWillUpdate` and `componentDidUpdate`.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @internal
	   */
	  enqueueForceUpdate: function enqueueForceUpdate(publicInstance) {
	    warnTDZ(publicInstance, 'forceUpdate');
	  },
	
	  /**
	   * Replaces all of the state. Always use this or `setState` to mutate state.
	   * You should treat `this.state` as immutable.
	   *
	   * There is no guarantee that `this.state` will be immediately updated, so
	   * accessing `this.state` after calling this method may return the old value.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} completeState Next state.
	   * @internal
	   */
	  enqueueReplaceState: function enqueueReplaceState(publicInstance, completeState) {
	    warnTDZ(publicInstance, 'replaceState');
	  },
	
	  /**
	   * Sets a subset of the state. This only exists because _pendingState is
	   * internal. This provides a merging strategy that is not available to deep
	   * properties which is confusing. TODO: Expose pendingState or don't use it
	   * during the merge.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialState Next partial state to be merged with state.
	   * @internal
	   */
	  enqueueSetState: function enqueueSetState(publicInstance, partialState) {
	    warnTDZ(publicInstance, 'setState');
	  },
	
	  /**
	   * Sets a subset of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} partialProps Subset of the next props.
	   * @internal
	   */
	  enqueueSetProps: function enqueueSetProps(publicInstance, partialProps) {
	    warnTDZ(publicInstance, 'setProps');
	  },
	
	  /**
	   * Replaces all of the props.
	   *
	   * @param {ReactClass} publicInstance The instance that should rerender.
	   * @param {object} props New props.
	   * @internal
	   */
	  enqueueReplaceProps: function enqueueReplaceProps(publicInstance, props) {
	    warnTDZ(publicInstance, 'replaceProps');
	  }
	
	};
	
	module.exports = ReactNoopUpdateQueue;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactReconcileTransaction
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var CallbackQueue = __webpack_require__(62);
	var PooledClass = __webpack_require__(63);
	var ReactBrowserEventEmitter = __webpack_require__(36);
	var ReactDOMFeatureFlags = __webpack_require__(48);
	var ReactInputSelection = __webpack_require__(133);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	
	/**
	 * Ensures that, when possible, the selection range (currently selected text
	 * input) is not disturbed by performing the transaction.
	 */
	var SELECTION_RESTORATION = {
	  /**
	   * @return {Selection} Selection information.
	   */
	  initialize: ReactInputSelection.getSelectionInformation,
	  /**
	   * @param {Selection} sel Selection information returned from `initialize`.
	   */
	  close: ReactInputSelection.restoreSelection
	};
	
	/**
	 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
	 * high level DOM manipulations (like temporarily removing a text input from the
	 * DOM).
	 */
	var EVENT_SUPPRESSION = {
	  /**
	   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
	   * the reconciliation.
	   */
	  initialize: function initialize() {
	    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
	    ReactBrowserEventEmitter.setEnabled(false);
	    return currentlyEnabled;
	  },
	
	  /**
	   * @param {boolean} previouslyEnabled Enabled status of
	   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
	   *   restores the previous value.
	   */
	  close: function close(previouslyEnabled) {
	    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
	  }
	};
	
	/**
	 * Provides a queue for collecting `componentDidMount` and
	 * `componentDidUpdate` callbacks during the the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  /**
	   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
	   */
	  close: function close() {
	    this.reactMountReady.notifyAll();
	  }
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];
	
	/**
	 * Currently:
	 * - The order that these are listed in the transaction is critical:
	 * - Suppresses events.
	 * - Restores selection range.
	 *
	 * Future:
	 * - Restore document/overflow scroll positions that were unintentionally
	 *   modified via DOM insertions above the top viewport boundary.
	 * - Implement/integrate with customized constraint based layout system and keep
	 *   track of which dimensions must be remeasured.
	 *
	 * @class ReactReconcileTransaction
	 */
	function ReactReconcileTransaction(forceHTML) {
	  this.reinitializeTransaction();
	  // Only server-side rendering really needs this option (see
	  // `ReactServerRendering`), but server-side uses
	  // `ReactServerRenderingTransaction` instead. This option is here so that it's
	  // accessible and defaults to false when `ReactDOMComponent` and
	  // `ReactTextComponent` checks it in `mountComponent`.`
	  this.renderToStaticMarkup = false;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = !forceHTML && ReactDOMFeatureFlags.useCreateElement;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array<object>} List of operation wrap procedures.
	   *   TODO: convert to array<TransactionWrapper>
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactReconcileTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactReconcileTransaction);
	
	module.exports = ReactReconcileTransaction;

/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactInputSelection
	 */
	
	'use strict';
	
	var ReactDOMSelection = __webpack_require__(134);
	
	var containsNode = __webpack_require__(66);
	var focusNode = __webpack_require__(102);
	var getActiveElement = __webpack_require__(136);
	
	function isInDocument(node) {
	  return containsNode(document.documentElement, node);
	}
	
	/**
	 * @ReactInputSelection: React input selection module. Based on Selection.js,
	 * but modified to be suitable for react and has a couple of bug fixes (doesn't
	 * assume buttons have range selections allowed).
	 * Input selection module for React.
	 */
	var ReactInputSelection = {
	
	  hasSelectionCapabilities: function hasSelectionCapabilities(elem) {
	    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
	    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
	  },
	
	  getSelectionInformation: function getSelectionInformation() {
	    var focusedElem = getActiveElement();
	    return {
	      focusedElem: focusedElem,
	      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
	    };
	  },
	
	  /**
	   * @restoreSelection: If any selection information was potentially lost,
	   * restore it. This is useful when performing operations that could remove dom
	   * nodes and place them back in, resulting in focus being lost.
	   */
	  restoreSelection: function restoreSelection(priorSelectionInformation) {
	    var curFocusedElem = getActiveElement();
	    var priorFocusedElem = priorSelectionInformation.focusedElem;
	    var priorSelectionRange = priorSelectionInformation.selectionRange;
	    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
	      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
	        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
	      }
	      focusNode(priorFocusedElem);
	    }
	  },
	
	  /**
	   * @getSelection: Gets the selection bounds of a focused textarea, input or
	   * contentEditable node.
	   * -@input: Look up selection bounds of this input
	   * -@return {start: selectionStart, end: selectionEnd}
	   */
	  getSelection: function getSelection(input) {
	    var selection;
	
	    if ('selectionStart' in input) {
	      // Modern browser with input or textarea.
	      selection = {
	        start: input.selectionStart,
	        end: input.selectionEnd
	      };
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      // IE8 input.
	      var range = document.selection.createRange();
	      // There can only be one selection per document in IE, so it must
	      // be in our element.
	      if (range.parentElement() === input) {
	        selection = {
	          start: -range.moveStart('character', -input.value.length),
	          end: -range.moveEnd('character', -input.value.length)
	        };
	      }
	    } else {
	      // Content editable or old IE textarea.
	      selection = ReactDOMSelection.getOffsets(input);
	    }
	
	    return selection || { start: 0, end: 0 };
	  },
	
	  /**
	   * @setSelection: Sets the selection bounds of a textarea or input and focuses
	   * the input.
	   * -@input     Set selection bounds of this input or textarea
	   * -@offsets   Object of same form that is returned from get*
	   */
	  setSelection: function setSelection(input, offsets) {
	    var start = offsets.start;
	    var end = offsets.end;
	    if (typeof end === 'undefined') {
	      end = start;
	    }
	
	    if ('selectionStart' in input) {
	      input.selectionStart = start;
	      input.selectionEnd = Math.min(end, input.value.length);
	    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
	      var range = input.createTextRange();
	      range.collapse(true);
	      range.moveStart('character', start);
	      range.moveEnd('character', end - start);
	      range.select();
	    } else {
	      ReactDOMSelection.setOffsets(input, offsets);
	    }
	  }
	};
	
	module.exports = ReactInputSelection;

/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMSelection
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var getNodeForCharacterOffset = __webpack_require__(135);
	var getTextContentAccessor = __webpack_require__(82);
	
	/**
	 * While `isCollapsed` is available on the Selection object and `collapsed`
	 * is available on the Range object, IE11 sometimes gets them wrong.
	 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
	 */
	function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
	  return anchorNode === focusNode && anchorOffset === focusOffset;
	}
	
	/**
	 * Get the appropriate anchor and focus node/offset pairs for IE.
	 *
	 * The catch here is that IE's selection API doesn't provide information
	 * about whether the selection is forward or backward, so we have to
	 * behave as though it's always forward.
	 *
	 * IE text differs from modern selection in that it behaves as though
	 * block elements end with a new line. This means character offsets will
	 * differ between the two APIs.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getIEOffsets(node) {
	  var selection = document.selection;
	  var selectedRange = selection.createRange();
	  var selectedLength = selectedRange.text.length;
	
	  // Duplicate selection so we can move range without breaking user selection.
	  var fromStart = selectedRange.duplicate();
	  fromStart.moveToElementText(node);
	  fromStart.setEndPoint('EndToStart', selectedRange);
	
	  var startOffset = fromStart.text.length;
	  var endOffset = startOffset + selectedLength;
	
	  return {
	    start: startOffset,
	    end: endOffset
	  };
	}
	
	/**
	 * @param {DOMElement} node
	 * @return {?object}
	 */
	function getModernOffsets(node) {
	  var selection = window.getSelection && window.getSelection();
	
	  if (!selection || selection.rangeCount === 0) {
	    return null;
	  }
	
	  var anchorNode = selection.anchorNode;
	  var anchorOffset = selection.anchorOffset;
	  var focusNode = selection.focusNode;
	  var focusOffset = selection.focusOffset;
	
	  var currentRange = selection.getRangeAt(0);
	
	  // In Firefox, range.startContainer and range.endContainer can be "anonymous
	  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
	  // divs do not seem to expose properties, triggering a "Permission denied
	  // error" if any of its properties are accessed. The only seemingly possible
	  // way to avoid erroring is to access a property that typically works for
	  // non-anonymous divs and catch any error that may otherwise arise. See
	  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
	  try {
	    /* eslint-disable no-unused-expressions */
	    currentRange.startContainer.nodeType;
	    currentRange.endContainer.nodeType;
	    /* eslint-enable no-unused-expressions */
	  } catch (e) {
	    return null;
	  }
	
	  // If the node and offset values are the same, the selection is collapsed.
	  // `Selection.isCollapsed` is available natively, but IE sometimes gets
	  // this value wrong.
	  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);
	
	  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;
	
	  var tempRange = currentRange.cloneRange();
	  tempRange.selectNodeContents(node);
	  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);
	
	  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);
	
	  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
	  var end = start + rangeLength;
	
	  // Detect whether the selection is backward.
	  var detectionRange = document.createRange();
	  detectionRange.setStart(anchorNode, anchorOffset);
	  detectionRange.setEnd(focusNode, focusOffset);
	  var isBackward = detectionRange.collapsed;
	
	  return {
	    start: isBackward ? end : start,
	    end: isBackward ? start : end
	  };
	}
	
	/**
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setIEOffsets(node, offsets) {
	  var range = document.selection.createRange().duplicate();
	  var start, end;
	
	  if (typeof offsets.end === 'undefined') {
	    start = offsets.start;
	    end = start;
	  } else if (offsets.start > offsets.end) {
	    start = offsets.end;
	    end = offsets.start;
	  } else {
	    start = offsets.start;
	    end = offsets.end;
	  }
	
	  range.moveToElementText(node);
	  range.moveStart('character', start);
	  range.setEndPoint('EndToStart', range);
	  range.moveEnd('character', end - start);
	  range.select();
	}
	
	/**
	 * In modern non-IE browsers, we can support both forward and backward
	 * selections.
	 *
	 * Note: IE10+ supports the Selection object, but it does not support
	 * the `extend` method, which means that even in modern IE, it's not possible
	 * to programatically create a backward selection. Thus, for all IE
	 * versions, we use the old IE API to create our selections.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @param {object} offsets
	 */
	function setModernOffsets(node, offsets) {
	  if (!window.getSelection) {
	    return;
	  }
	
	  var selection = window.getSelection();
	  var length = node[getTextContentAccessor()].length;
	  var start = Math.min(offsets.start, length);
	  var end = typeof offsets.end === 'undefined' ? start : Math.min(offsets.end, length);
	
	  // IE 11 uses modern selection, but doesn't support the extend method.
	  // Flip backward selections, so we can set with a single range.
	  if (!selection.extend && start > end) {
	    var temp = end;
	    end = start;
	    start = temp;
	  }
	
	  var startMarker = getNodeForCharacterOffset(node, start);
	  var endMarker = getNodeForCharacterOffset(node, end);
	
	  if (startMarker && endMarker) {
	    var range = document.createRange();
	    range.setStart(startMarker.node, startMarker.offset);
	    selection.removeAllRanges();
	
	    if (start > end) {
	      selection.addRange(range);
	      selection.extend(endMarker.node, endMarker.offset);
	    } else {
	      range.setEnd(endMarker.node, endMarker.offset);
	      selection.addRange(range);
	    }
	  }
	}
	
	var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);
	
	var ReactDOMSelection = {
	  /**
	   * @param {DOMElement} node
	   */
	  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,
	
	  /**
	   * @param {DOMElement|DOMTextNode} node
	   * @param {object} offsets
	   */
	  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
	};
	
	module.exports = ReactDOMSelection;

/***/ },
/* 135 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getNodeForCharacterOffset
	 */
	
	'use strict';
	
	/**
	 * Given any node return the first leaf node without children.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {DOMElement|DOMTextNode}
	 */
	
	function getLeafNode(node) {
	  while (node && node.firstChild) {
	    node = node.firstChild;
	  }
	  return node;
	}
	
	/**
	 * Get the next sibling within a container. This will walk up the
	 * DOM if a node's siblings have been exhausted.
	 *
	 * @param {DOMElement|DOMTextNode} node
	 * @return {?DOMElement|DOMTextNode}
	 */
	function getSiblingNode(node) {
	  while (node) {
	    if (node.nextSibling) {
	      return node.nextSibling;
	    }
	    node = node.parentNode;
	  }
	}
	
	/**
	 * Get object describing the nodes which contain characters at offset.
	 *
	 * @param {DOMElement|DOMTextNode} root
	 * @param {number} offset
	 * @return {?object}
	 */
	function getNodeForCharacterOffset(root, offset) {
	  var node = getLeafNode(root);
	  var nodeStart = 0;
	  var nodeEnd = 0;
	
	  while (node) {
	    if (node.nodeType === 3) {
	      nodeEnd = nodeStart + node.textContent.length;
	
	      if (nodeStart <= offset && nodeEnd >= offset) {
	        return {
	          node: node,
	          offset: offset - nodeStart
	        };
	      }
	
	      nodeStart = nodeEnd;
	    }
	
	    node = getLeafNode(getSiblingNode(node));
	  }
	}
	
	module.exports = getNodeForCharacterOffset;

/***/ },
/* 136 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getActiveElement
	 * @typechecks
	 */
	
	/* eslint-disable fb-www/typeof-undefined */
	
	/**
	 * Same as document.activeElement but wraps in a try-catch block. In IE it is
	 * not safe to call document.activeElement if there is nothing focused.
	 *
	 * The activeElement will be null only if the document or document body is not
	 * yet defined.
	 */
	'use strict';
	
	function getActiveElement() /*?DOMElement*/{
	  if (typeof document === 'undefined') {
	    return null;
	  }
	  try {
	    return document.activeElement || document.body;
	  } catch (e) {
	    return document.body;
	  }
	}
	
	module.exports = getActiveElement;

/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SelectEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventPropagators = __webpack_require__(80);
	var ExecutionEnvironment = __webpack_require__(16);
	var ReactInputSelection = __webpack_require__(133);
	var SyntheticEvent = __webpack_require__(84);
	
	var getActiveElement = __webpack_require__(136);
	var isTextInputElement = __webpack_require__(89);
	var keyOf = __webpack_require__(86);
	var shallowEqual = __webpack_require__(124);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;
	
	var eventTypes = {
	  select: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSelect: null }),
	      captured: keyOf({ onSelectCapture: null })
	    },
	    dependencies: [topLevelTypes.topBlur, topLevelTypes.topContextMenu, topLevelTypes.topFocus, topLevelTypes.topKeyDown, topLevelTypes.topMouseDown, topLevelTypes.topMouseUp, topLevelTypes.topSelectionChange]
	  }
	};
	
	var activeElement = null;
	var activeElementID = null;
	var lastSelection = null;
	var mouseDown = false;
	
	// Track whether a listener exists for this plugin. If none exist, we do
	// not extract events.
	var hasListener = false;
	var ON_SELECT_KEY = keyOf({ onSelect: null });
	
	/**
	 * Get an object which is a unique representation of the current selection.
	 *
	 * The return value will not be consistent across nodes or browsers, but
	 * two identical selections on the same node will return identical objects.
	 *
	 * @param {DOMElement} node
	 * @return {object}
	 */
	function getSelection(node) {
	  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
	    return {
	      start: node.selectionStart,
	      end: node.selectionEnd
	    };
	  } else if (window.getSelection) {
	    var selection = window.getSelection();
	    return {
	      anchorNode: selection.anchorNode,
	      anchorOffset: selection.anchorOffset,
	      focusNode: selection.focusNode,
	      focusOffset: selection.focusOffset
	    };
	  } else if (document.selection) {
	    var range = document.selection.createRange();
	    return {
	      parentElement: range.parentElement(),
	      text: range.text,
	      top: range.boundingTop,
	      left: range.boundingLeft
	    };
	  }
	}
	
	/**
	 * Poll selection to see whether it's changed.
	 *
	 * @param {object} nativeEvent
	 * @return {?SyntheticEvent}
	 */
	function constructSelectEvent(nativeEvent, nativeEventTarget) {
	  // Ensure we have the right element, and that the user is not dragging a
	  // selection (this matches native `select` event behavior). In HTML5, select
	  // fires only on input and textarea thus if there's no focused element we
	  // won't dispatch.
	  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
	    return null;
	  }
	
	  // Only fire when selection has actually changed.
	  var currentSelection = getSelection(activeElement);
	  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
	    lastSelection = currentSelection;
	
	    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementID, nativeEvent, nativeEventTarget);
	
	    syntheticEvent.type = 'select';
	    syntheticEvent.target = activeElement;
	
	    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);
	
	    return syntheticEvent;
	  }
	
	  return null;
	}
	
	/**
	 * This plugin creates an `onSelect` event that normalizes select events
	 * across form elements.
	 *
	 * Supported elements are:
	 * - input (see `isTextInputElement`)
	 * - textarea
	 * - contentEditable
	 *
	 * This differs from native browser implementations in the following ways:
	 * - Fires on contentEditable fields as well as inputs.
	 * - Fires for collapsed selection.
	 * - Fires after user input.
	 */
	var SelectEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    if (!hasListener) {
	      return null;
	    }
	
	    switch (topLevelType) {
	      // Track the input node that has focus.
	      case topLevelTypes.topFocus:
	        if (isTextInputElement(topLevelTarget) || topLevelTarget.contentEditable === 'true') {
	          activeElement = topLevelTarget;
	          activeElementID = topLevelTargetID;
	          lastSelection = null;
	        }
	        break;
	      case topLevelTypes.topBlur:
	        activeElement = null;
	        activeElementID = null;
	        lastSelection = null;
	        break;
	
	      // Don't fire the event while the user is dragging. This matches the
	      // semantics of the native select event.
	      case topLevelTypes.topMouseDown:
	        mouseDown = true;
	        break;
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topMouseUp:
	        mouseDown = false;
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	
	      // Chrome and IE fire non-standard event when selection is changed (and
	      // sometimes when it hasn't). IE's event fires out of order with respect
	      // to key and input events on deletion, so we discard it.
	      //
	      // Firefox doesn't support selectionchange, so check selection status
	      // after each key entry. The selection changes after keydown and before
	      // keyup, but we check on keydown as well in the case of holding down a
	      // key, when multiple keydown events are fired but only one keyup is.
	      // This is also our approach for IE handling, for the reason above.
	      case topLevelTypes.topSelectionChange:
	        if (skipSelectionChangeEvent) {
	          break;
	        }
	      // falls through
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        return constructSelectEvent(nativeEvent, nativeEventTarget);
	    }
	
	    return null;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    if (registrationName === ON_SELECT_KEY) {
	      hasListener = true;
	    }
	  }
	};
	
	module.exports = SelectEventPlugin;

/***/ },
/* 138 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ServerReactRootIndex
	 * @typechecks
	 */
	
	'use strict';
	
	/**
	 * Size of the reactRoot ID space. We generate random numbers for React root
	 * IDs and if there's a collision the events and DOM update system will
	 * get confused. In the future we need a way to generate GUIDs but for
	 * now this will work on a smaller scale.
	 */
	
	var GLOBAL_MOUNT_POINT_MAX = Math.pow(2, 53);
	
	var ServerReactRootIndex = {
	  createReactRootIndex: function createReactRootIndex() {
	    return Math.ceil(Math.random() * GLOBAL_MOUNT_POINT_MAX);
	  }
	};
	
	module.exports = ServerReactRootIndex;

/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SimpleEventPlugin
	 */
	
	'use strict';
	
	var EventConstants = __webpack_require__(37);
	var EventListener = __webpack_require__(126);
	var EventPropagators = __webpack_require__(80);
	var ReactMount = __webpack_require__(35);
	var SyntheticClipboardEvent = __webpack_require__(140);
	var SyntheticEvent = __webpack_require__(84);
	var SyntheticFocusEvent = __webpack_require__(141);
	var SyntheticKeyboardEvent = __webpack_require__(142);
	var SyntheticMouseEvent = __webpack_require__(93);
	var SyntheticDragEvent = __webpack_require__(145);
	var SyntheticTouchEvent = __webpack_require__(146);
	var SyntheticUIEvent = __webpack_require__(94);
	var SyntheticWheelEvent = __webpack_require__(147);
	
	var emptyFunction = __webpack_require__(22);
	var getEventCharCode = __webpack_require__(143);
	var invariant = __webpack_require__(20);
	var keyOf = __webpack_require__(86);
	
	var topLevelTypes = EventConstants.topLevelTypes;
	
	var eventTypes = {
	  abort: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onAbort: true }),
	      captured: keyOf({ onAbortCapture: true })
	    }
	  },
	  blur: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onBlur: true }),
	      captured: keyOf({ onBlurCapture: true })
	    }
	  },
	  canPlay: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlay: true }),
	      captured: keyOf({ onCanPlayCapture: true })
	    }
	  },
	  canPlayThrough: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCanPlayThrough: true }),
	      captured: keyOf({ onCanPlayThroughCapture: true })
	    }
	  },
	  click: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onClick: true }),
	      captured: keyOf({ onClickCapture: true })
	    }
	  },
	  contextMenu: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onContextMenu: true }),
	      captured: keyOf({ onContextMenuCapture: true })
	    }
	  },
	  copy: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCopy: true }),
	      captured: keyOf({ onCopyCapture: true })
	    }
	  },
	  cut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onCut: true }),
	      captured: keyOf({ onCutCapture: true })
	    }
	  },
	  doubleClick: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDoubleClick: true }),
	      captured: keyOf({ onDoubleClickCapture: true })
	    }
	  },
	  drag: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrag: true }),
	      captured: keyOf({ onDragCapture: true })
	    }
	  },
	  dragEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnd: true }),
	      captured: keyOf({ onDragEndCapture: true })
	    }
	  },
	  dragEnter: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragEnter: true }),
	      captured: keyOf({ onDragEnterCapture: true })
	    }
	  },
	  dragExit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragExit: true }),
	      captured: keyOf({ onDragExitCapture: true })
	    }
	  },
	  dragLeave: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragLeave: true }),
	      captured: keyOf({ onDragLeaveCapture: true })
	    }
	  },
	  dragOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragOver: true }),
	      captured: keyOf({ onDragOverCapture: true })
	    }
	  },
	  dragStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDragStart: true }),
	      captured: keyOf({ onDragStartCapture: true })
	    }
	  },
	  drop: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDrop: true }),
	      captured: keyOf({ onDropCapture: true })
	    }
	  },
	  durationChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onDurationChange: true }),
	      captured: keyOf({ onDurationChangeCapture: true })
	    }
	  },
	  emptied: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEmptied: true }),
	      captured: keyOf({ onEmptiedCapture: true })
	    }
	  },
	  encrypted: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEncrypted: true }),
	      captured: keyOf({ onEncryptedCapture: true })
	    }
	  },
	  ended: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onEnded: true }),
	      captured: keyOf({ onEndedCapture: true })
	    }
	  },
	  error: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onError: true }),
	      captured: keyOf({ onErrorCapture: true })
	    }
	  },
	  focus: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onFocus: true }),
	      captured: keyOf({ onFocusCapture: true })
	    }
	  },
	  input: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onInput: true }),
	      captured: keyOf({ onInputCapture: true })
	    }
	  },
	  keyDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyDown: true }),
	      captured: keyOf({ onKeyDownCapture: true })
	    }
	  },
	  keyPress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyPress: true }),
	      captured: keyOf({ onKeyPressCapture: true })
	    }
	  },
	  keyUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onKeyUp: true }),
	      captured: keyOf({ onKeyUpCapture: true })
	    }
	  },
	  load: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoad: true }),
	      captured: keyOf({ onLoadCapture: true })
	    }
	  },
	  loadedData: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedData: true }),
	      captured: keyOf({ onLoadedDataCapture: true })
	    }
	  },
	  loadedMetadata: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadedMetadata: true }),
	      captured: keyOf({ onLoadedMetadataCapture: true })
	    }
	  },
	  loadStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onLoadStart: true }),
	      captured: keyOf({ onLoadStartCapture: true })
	    }
	  },
	  // Note: We do not allow listening to mouseOver events. Instead, use the
	  // onMouseEnter/onMouseLeave created by `EnterLeaveEventPlugin`.
	  mouseDown: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseDown: true }),
	      captured: keyOf({ onMouseDownCapture: true })
	    }
	  },
	  mouseMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseMove: true }),
	      captured: keyOf({ onMouseMoveCapture: true })
	    }
	  },
	  mouseOut: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOut: true }),
	      captured: keyOf({ onMouseOutCapture: true })
	    }
	  },
	  mouseOver: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseOver: true }),
	      captured: keyOf({ onMouseOverCapture: true })
	    }
	  },
	  mouseUp: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onMouseUp: true }),
	      captured: keyOf({ onMouseUpCapture: true })
	    }
	  },
	  paste: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPaste: true }),
	      captured: keyOf({ onPasteCapture: true })
	    }
	  },
	  pause: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPause: true }),
	      captured: keyOf({ onPauseCapture: true })
	    }
	  },
	  play: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlay: true }),
	      captured: keyOf({ onPlayCapture: true })
	    }
	  },
	  playing: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onPlaying: true }),
	      captured: keyOf({ onPlayingCapture: true })
	    }
	  },
	  progress: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onProgress: true }),
	      captured: keyOf({ onProgressCapture: true })
	    }
	  },
	  rateChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onRateChange: true }),
	      captured: keyOf({ onRateChangeCapture: true })
	    }
	  },
	  reset: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onReset: true }),
	      captured: keyOf({ onResetCapture: true })
	    }
	  },
	  scroll: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onScroll: true }),
	      captured: keyOf({ onScrollCapture: true })
	    }
	  },
	  seeked: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeked: true }),
	      captured: keyOf({ onSeekedCapture: true })
	    }
	  },
	  seeking: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSeeking: true }),
	      captured: keyOf({ onSeekingCapture: true })
	    }
	  },
	  stalled: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onStalled: true }),
	      captured: keyOf({ onStalledCapture: true })
	    }
	  },
	  submit: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSubmit: true }),
	      captured: keyOf({ onSubmitCapture: true })
	    }
	  },
	  suspend: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onSuspend: true }),
	      captured: keyOf({ onSuspendCapture: true })
	    }
	  },
	  timeUpdate: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTimeUpdate: true }),
	      captured: keyOf({ onTimeUpdateCapture: true })
	    }
	  },
	  touchCancel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchCancel: true }),
	      captured: keyOf({ onTouchCancelCapture: true })
	    }
	  },
	  touchEnd: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchEnd: true }),
	      captured: keyOf({ onTouchEndCapture: true })
	    }
	  },
	  touchMove: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchMove: true }),
	      captured: keyOf({ onTouchMoveCapture: true })
	    }
	  },
	  touchStart: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onTouchStart: true }),
	      captured: keyOf({ onTouchStartCapture: true })
	    }
	  },
	  volumeChange: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onVolumeChange: true }),
	      captured: keyOf({ onVolumeChangeCapture: true })
	    }
	  },
	  waiting: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWaiting: true }),
	      captured: keyOf({ onWaitingCapture: true })
	    }
	  },
	  wheel: {
	    phasedRegistrationNames: {
	      bubbled: keyOf({ onWheel: true }),
	      captured: keyOf({ onWheelCapture: true })
	    }
	  }
	};
	
	var topLevelEventsToDispatchConfig = {
	  topAbort: eventTypes.abort,
	  topBlur: eventTypes.blur,
	  topCanPlay: eventTypes.canPlay,
	  topCanPlayThrough: eventTypes.canPlayThrough,
	  topClick: eventTypes.click,
	  topContextMenu: eventTypes.contextMenu,
	  topCopy: eventTypes.copy,
	  topCut: eventTypes.cut,
	  topDoubleClick: eventTypes.doubleClick,
	  topDrag: eventTypes.drag,
	  topDragEnd: eventTypes.dragEnd,
	  topDragEnter: eventTypes.dragEnter,
	  topDragExit: eventTypes.dragExit,
	  topDragLeave: eventTypes.dragLeave,
	  topDragOver: eventTypes.dragOver,
	  topDragStart: eventTypes.dragStart,
	  topDrop: eventTypes.drop,
	  topDurationChange: eventTypes.durationChange,
	  topEmptied: eventTypes.emptied,
	  topEncrypted: eventTypes.encrypted,
	  topEnded: eventTypes.ended,
	  topError: eventTypes.error,
	  topFocus: eventTypes.focus,
	  topInput: eventTypes.input,
	  topKeyDown: eventTypes.keyDown,
	  topKeyPress: eventTypes.keyPress,
	  topKeyUp: eventTypes.keyUp,
	  topLoad: eventTypes.load,
	  topLoadedData: eventTypes.loadedData,
	  topLoadedMetadata: eventTypes.loadedMetadata,
	  topLoadStart: eventTypes.loadStart,
	  topMouseDown: eventTypes.mouseDown,
	  topMouseMove: eventTypes.mouseMove,
	  topMouseOut: eventTypes.mouseOut,
	  topMouseOver: eventTypes.mouseOver,
	  topMouseUp: eventTypes.mouseUp,
	  topPaste: eventTypes.paste,
	  topPause: eventTypes.pause,
	  topPlay: eventTypes.play,
	  topPlaying: eventTypes.playing,
	  topProgress: eventTypes.progress,
	  topRateChange: eventTypes.rateChange,
	  topReset: eventTypes.reset,
	  topScroll: eventTypes.scroll,
	  topSeeked: eventTypes.seeked,
	  topSeeking: eventTypes.seeking,
	  topStalled: eventTypes.stalled,
	  topSubmit: eventTypes.submit,
	  topSuspend: eventTypes.suspend,
	  topTimeUpdate: eventTypes.timeUpdate,
	  topTouchCancel: eventTypes.touchCancel,
	  topTouchEnd: eventTypes.touchEnd,
	  topTouchMove: eventTypes.touchMove,
	  topTouchStart: eventTypes.touchStart,
	  topVolumeChange: eventTypes.volumeChange,
	  topWaiting: eventTypes.waiting,
	  topWheel: eventTypes.wheel
	};
	
	for (var type in topLevelEventsToDispatchConfig) {
	  topLevelEventsToDispatchConfig[type].dependencies = [type];
	}
	
	var ON_CLICK_KEY = keyOf({ onClick: null });
	var onClickListeners = {};
	
	var SimpleEventPlugin = {
	
	  eventTypes: eventTypes,
	
	  /**
	   * @param {string} topLevelType Record from `EventConstants`.
	   * @param {DOMEventTarget} topLevelTarget The listening component root node.
	   * @param {string} topLevelTargetID ID of `topLevelTarget`.
	   * @param {object} nativeEvent Native browser event.
	   * @return {*} An accumulation of synthetic events.
	   * @see {EventPluginHub.extractEvents}
	   */
	  extractEvents: function extractEvents(topLevelType, topLevelTarget, topLevelTargetID, nativeEvent, nativeEventTarget) {
	    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
	    if (!dispatchConfig) {
	      return null;
	    }
	    var EventConstructor;
	    switch (topLevelType) {
	      case topLevelTypes.topAbort:
	      case topLevelTypes.topCanPlay:
	      case topLevelTypes.topCanPlayThrough:
	      case topLevelTypes.topDurationChange:
	      case topLevelTypes.topEmptied:
	      case topLevelTypes.topEncrypted:
	      case topLevelTypes.topEnded:
	      case topLevelTypes.topError:
	      case topLevelTypes.topInput:
	      case topLevelTypes.topLoad:
	      case topLevelTypes.topLoadedData:
	      case topLevelTypes.topLoadedMetadata:
	      case topLevelTypes.topLoadStart:
	      case topLevelTypes.topPause:
	      case topLevelTypes.topPlay:
	      case topLevelTypes.topPlaying:
	      case topLevelTypes.topProgress:
	      case topLevelTypes.topRateChange:
	      case topLevelTypes.topReset:
	      case topLevelTypes.topSeeked:
	      case topLevelTypes.topSeeking:
	      case topLevelTypes.topStalled:
	      case topLevelTypes.topSubmit:
	      case topLevelTypes.topSuspend:
	      case topLevelTypes.topTimeUpdate:
	      case topLevelTypes.topVolumeChange:
	      case topLevelTypes.topWaiting:
	        // HTML Events
	        // @see http://www.w3.org/TR/html5/index.html#events-0
	        EventConstructor = SyntheticEvent;
	        break;
	      case topLevelTypes.topKeyPress:
	        // FireFox creates a keypress event for function keys too. This removes
	        // the unwanted keypress events. Enter is however both printable and
	        // non-printable. One would expect Tab to be as well (but it isn't).
	        if (getEventCharCode(nativeEvent) === 0) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topKeyDown:
	      case topLevelTypes.topKeyUp:
	        EventConstructor = SyntheticKeyboardEvent;
	        break;
	      case topLevelTypes.topBlur:
	      case topLevelTypes.topFocus:
	        EventConstructor = SyntheticFocusEvent;
	        break;
	      case topLevelTypes.topClick:
	        // Firefox creates a click event on right mouse clicks. This removes the
	        // unwanted click events.
	        if (nativeEvent.button === 2) {
	          return null;
	        }
	      /* falls through */
	      case topLevelTypes.topContextMenu:
	      case topLevelTypes.topDoubleClick:
	      case topLevelTypes.topMouseDown:
	      case topLevelTypes.topMouseMove:
	      case topLevelTypes.topMouseOut:
	      case topLevelTypes.topMouseOver:
	      case topLevelTypes.topMouseUp:
	        EventConstructor = SyntheticMouseEvent;
	        break;
	      case topLevelTypes.topDrag:
	      case topLevelTypes.topDragEnd:
	      case topLevelTypes.topDragEnter:
	      case topLevelTypes.topDragExit:
	      case topLevelTypes.topDragLeave:
	      case topLevelTypes.topDragOver:
	      case topLevelTypes.topDragStart:
	      case topLevelTypes.topDrop:
	        EventConstructor = SyntheticDragEvent;
	        break;
	      case topLevelTypes.topTouchCancel:
	      case topLevelTypes.topTouchEnd:
	      case topLevelTypes.topTouchMove:
	      case topLevelTypes.topTouchStart:
	        EventConstructor = SyntheticTouchEvent;
	        break;
	      case topLevelTypes.topScroll:
	        EventConstructor = SyntheticUIEvent;
	        break;
	      case topLevelTypes.topWheel:
	        EventConstructor = SyntheticWheelEvent;
	        break;
	      case topLevelTypes.topCopy:
	      case topLevelTypes.topCut:
	      case topLevelTypes.topPaste:
	        EventConstructor = SyntheticClipboardEvent;
	        break;
	    }
	    !EventConstructor ? process.env.NODE_ENV !== 'production' ? invariant(false, 'SimpleEventPlugin: Unhandled event type, `%s`.', topLevelType) : invariant(false) : undefined;
	    var event = EventConstructor.getPooled(dispatchConfig, topLevelTargetID, nativeEvent, nativeEventTarget);
	    EventPropagators.accumulateTwoPhaseDispatches(event);
	    return event;
	  },
	
	  didPutListener: function didPutListener(id, registrationName, listener) {
	    // Mobile Safari does not fire properly bubble click events on
	    // non-interactive elements, which means delegated click listeners do not
	    // fire. The workaround for this bug involves attaching an empty click
	    // listener on the target node.
	    if (registrationName === ON_CLICK_KEY) {
	      var node = ReactMount.getNode(id);
	      if (!onClickListeners[id]) {
	        onClickListeners[id] = EventListener.listen(node, 'click', emptyFunction);
	      }
	    }
	  },
	
	  willDeleteListener: function willDeleteListener(id, registrationName) {
	    if (registrationName === ON_CLICK_KEY) {
	      onClickListeners[id].remove();
	      delete onClickListeners[id];
	    }
	  }
	
	};
	
	module.exports = SimpleEventPlugin;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticClipboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticEvent = __webpack_require__(84);
	
	/**
	 * @interface Event
	 * @see http://www.w3.org/TR/clipboard-apis/
	 */
	var ClipboardEventInterface = {
	  clipboardData: function clipboardData(event) {
	    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);
	
	module.exports = SyntheticClipboardEvent;

/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticFocusEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	/**
	 * @interface FocusEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var FocusEventInterface = {
	  relatedTarget: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);
	
	module.exports = SyntheticFocusEvent;

/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticKeyboardEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventCharCode = __webpack_require__(143);
	var getEventKey = __webpack_require__(144);
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface KeyboardEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var KeyboardEventInterface = {
	  key: getEventKey,
	  location: null,
	  ctrlKey: null,
	  shiftKey: null,
	  altKey: null,
	  metaKey: null,
	  repeat: null,
	  locale: null,
	  getModifierState: getEventModifierState,
	  // Legacy Interface
	  charCode: function charCode(event) {
	    // `charCode` is the result of a KeyPress event and represents the value of
	    // the actual printable character.
	
	    // KeyPress is deprecated, but its replacement is not yet final and not
	    // implemented in any major browser. Only KeyPress has charCode.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    return 0;
	  },
	  keyCode: function keyCode(event) {
	    // `keyCode` is the result of a KeyDown/Up event and represents the value of
	    // physical keyboard key.
	
	    // The actual meaning of the value depends on the users' keyboard layout
	    // which cannot be detected. Assuming that it is a US keyboard layout
	    // provides a surprisingly accurate mapping for US and European users.
	    // Due to this, it is left to the user to implement at this time.
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  },
	  which: function which(event) {
	    // `which` is an alias for either `keyCode` or `charCode` depending on the
	    // type of the event.
	    if (event.type === 'keypress') {
	      return getEventCharCode(event);
	    }
	    if (event.type === 'keydown' || event.type === 'keyup') {
	      return event.keyCode;
	    }
	    return 0;
	  }
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);
	
	module.exports = SyntheticKeyboardEvent;

/***/ },
/* 143 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventCharCode
	 * @typechecks static-only
	 */
	
	'use strict';
	
	/**
	 * `charCode` represents the actual "character code" and is safe to use with
	 * `String.fromCharCode`. As such, only keys that correspond to printable
	 * characters produce a valid `charCode`, the only exception to this is Enter.
	 * The Tab-key is considered non-printable and does not have a `charCode`,
	 * presumably because it does not produce a tab-character in browsers.
	 *
	 * @param {object} nativeEvent Native browser event.
	 * @return {number} Normalized `charCode` property.
	 */
	
	function getEventCharCode(nativeEvent) {
	  var charCode;
	  var keyCode = nativeEvent.keyCode;
	
	  if ('charCode' in nativeEvent) {
	    charCode = nativeEvent.charCode;
	
	    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
	    if (charCode === 0 && keyCode === 13) {
	      charCode = 13;
	    }
	  } else {
	    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
	    charCode = keyCode;
	  }
	
	  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
	  // Must not discard the (non-)printable Enter-key.
	  if (charCode >= 32 || charCode === 13) {
	    return charCode;
	  }
	
	  return 0;
	}
	
	module.exports = getEventCharCode;

/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule getEventKey
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var getEventCharCode = __webpack_require__(143);
	
	/**
	 * Normalization of deprecated HTML5 `key` values
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var normalizeKey = {
	  'Esc': 'Escape',
	  'Spacebar': ' ',
	  'Left': 'ArrowLeft',
	  'Up': 'ArrowUp',
	  'Right': 'ArrowRight',
	  'Down': 'ArrowDown',
	  'Del': 'Delete',
	  'Win': 'OS',
	  'Menu': 'ContextMenu',
	  'Apps': 'ContextMenu',
	  'Scroll': 'ScrollLock',
	  'MozPrintableKey': 'Unidentified'
	};
	
	/**
	 * Translation from legacy `keyCode` to HTML5 `key`
	 * Only special keys supported, all others depend on keyboard layout or browser
	 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
	 */
	var translateToKey = {
	  8: 'Backspace',
	  9: 'Tab',
	  12: 'Clear',
	  13: 'Enter',
	  16: 'Shift',
	  17: 'Control',
	  18: 'Alt',
	  19: 'Pause',
	  20: 'CapsLock',
	  27: 'Escape',
	  32: ' ',
	  33: 'PageUp',
	  34: 'PageDown',
	  35: 'End',
	  36: 'Home',
	  37: 'ArrowLeft',
	  38: 'ArrowUp',
	  39: 'ArrowRight',
	  40: 'ArrowDown',
	  45: 'Insert',
	  46: 'Delete',
	  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
	  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
	  144: 'NumLock',
	  145: 'ScrollLock',
	  224: 'Meta'
	};
	
	/**
	 * @param {object} nativeEvent Native browser event.
	 * @return {string} Normalized `key` property.
	 */
	function getEventKey(nativeEvent) {
	  if (nativeEvent.key) {
	    // Normalize inconsistent values reported by browsers due to
	    // implementations of a working draft specification.
	
	    // FireFox implements `key` but returns `MozPrintableKey` for all
	    // printable characters (normalized to `Unidentified`), ignore it.
	    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
	    if (key !== 'Unidentified') {
	      return key;
	    }
	  }
	
	  // Browser does not implement `key`, polyfill as much of it as we can.
	  if (nativeEvent.type === 'keypress') {
	    var charCode = getEventCharCode(nativeEvent);
	
	    // The enter-key is technically both printable and non-printable and can
	    // thus be captured by `keypress`, no other non-printable key should.
	    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
	  }
	  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
	    // While user keyboard layout determines the actual meaning of each
	    // `keyCode` value, almost all function keys have a universal value.
	    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
	  }
	  return '';
	}
	
	module.exports = getEventKey;

/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticDragEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface DragEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var DragEventInterface = {
	  dataTransfer: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);
	
	module.exports = SyntheticDragEvent;

/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticTouchEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticUIEvent = __webpack_require__(94);
	
	var getEventModifierState = __webpack_require__(95);
	
	/**
	 * @interface TouchEvent
	 * @see http://www.w3.org/TR/touch-events/
	 */
	var TouchEventInterface = {
	  touches: null,
	  targetTouches: null,
	  changedTouches: null,
	  altKey: null,
	  metaKey: null,
	  ctrlKey: null,
	  shiftKey: null,
	  getModifierState: getEventModifierState
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticUIEvent}
	 */
	function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);
	
	module.exports = SyntheticTouchEvent;

/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SyntheticWheelEvent
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var SyntheticMouseEvent = __webpack_require__(93);
	
	/**
	 * @interface WheelEvent
	 * @see http://www.w3.org/TR/DOM-Level-3-Events/
	 */
	var WheelEventInterface = {
	  deltaX: function deltaX(event) {
	    return 'deltaX' in event ? event.deltaX :
	    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
	    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
	  },
	  deltaY: function deltaY(event) {
	    return 'deltaY' in event ? event.deltaY :
	    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
	    'wheelDeltaY' in event ? -event.wheelDeltaY :
	    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
	    'wheelDelta' in event ? -event.wheelDelta : 0;
	  },
	  deltaZ: null,
	
	  // Browsers without "deltaMode" is reporting in raw wheel delta where one
	  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
	  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
	  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
	  deltaMode: null
	};
	
	/**
	 * @param {object} dispatchConfig Configuration used to dispatch this event.
	 * @param {string} dispatchMarker Marker identifying the event target.
	 * @param {object} nativeEvent Native browser event.
	 * @extends {SyntheticMouseEvent}
	 */
	function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
	  SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
	}
	
	SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);
	
	module.exports = SyntheticWheelEvent;

/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule SVGDOMPropertyConfig
	 */
	
	'use strict';
	
	var DOMProperty = __webpack_require__(30);
	
	var MUST_USE_ATTRIBUTE = DOMProperty.injection.MUST_USE_ATTRIBUTE;
	
	var NS = {
	  xlink: 'http://www.w3.org/1999/xlink',
	  xml: 'http://www.w3.org/XML/1998/namespace'
	};
	
	var SVGDOMPropertyConfig = {
	  Properties: {
	    clipPath: MUST_USE_ATTRIBUTE,
	    cx: MUST_USE_ATTRIBUTE,
	    cy: MUST_USE_ATTRIBUTE,
	    d: MUST_USE_ATTRIBUTE,
	    dx: MUST_USE_ATTRIBUTE,
	    dy: MUST_USE_ATTRIBUTE,
	    fill: MUST_USE_ATTRIBUTE,
	    fillOpacity: MUST_USE_ATTRIBUTE,
	    fontFamily: MUST_USE_ATTRIBUTE,
	    fontSize: MUST_USE_ATTRIBUTE,
	    fx: MUST_USE_ATTRIBUTE,
	    fy: MUST_USE_ATTRIBUTE,
	    gradientTransform: MUST_USE_ATTRIBUTE,
	    gradientUnits: MUST_USE_ATTRIBUTE,
	    markerEnd: MUST_USE_ATTRIBUTE,
	    markerMid: MUST_USE_ATTRIBUTE,
	    markerStart: MUST_USE_ATTRIBUTE,
	    offset: MUST_USE_ATTRIBUTE,
	    opacity: MUST_USE_ATTRIBUTE,
	    patternContentUnits: MUST_USE_ATTRIBUTE,
	    patternUnits: MUST_USE_ATTRIBUTE,
	    points: MUST_USE_ATTRIBUTE,
	    preserveAspectRatio: MUST_USE_ATTRIBUTE,
	    r: MUST_USE_ATTRIBUTE,
	    rx: MUST_USE_ATTRIBUTE,
	    ry: MUST_USE_ATTRIBUTE,
	    spreadMethod: MUST_USE_ATTRIBUTE,
	    stopColor: MUST_USE_ATTRIBUTE,
	    stopOpacity: MUST_USE_ATTRIBUTE,
	    stroke: MUST_USE_ATTRIBUTE,
	    strokeDasharray: MUST_USE_ATTRIBUTE,
	    strokeLinecap: MUST_USE_ATTRIBUTE,
	    strokeOpacity: MUST_USE_ATTRIBUTE,
	    strokeWidth: MUST_USE_ATTRIBUTE,
	    textAnchor: MUST_USE_ATTRIBUTE,
	    transform: MUST_USE_ATTRIBUTE,
	    version: MUST_USE_ATTRIBUTE,
	    viewBox: MUST_USE_ATTRIBUTE,
	    x1: MUST_USE_ATTRIBUTE,
	    x2: MUST_USE_ATTRIBUTE,
	    x: MUST_USE_ATTRIBUTE,
	    xlinkActuate: MUST_USE_ATTRIBUTE,
	    xlinkArcrole: MUST_USE_ATTRIBUTE,
	    xlinkHref: MUST_USE_ATTRIBUTE,
	    xlinkRole: MUST_USE_ATTRIBUTE,
	    xlinkShow: MUST_USE_ATTRIBUTE,
	    xlinkTitle: MUST_USE_ATTRIBUTE,
	    xlinkType: MUST_USE_ATTRIBUTE,
	    xmlBase: MUST_USE_ATTRIBUTE,
	    xmlLang: MUST_USE_ATTRIBUTE,
	    xmlSpace: MUST_USE_ATTRIBUTE,
	    y1: MUST_USE_ATTRIBUTE,
	    y2: MUST_USE_ATTRIBUTE,
	    y: MUST_USE_ATTRIBUTE
	  },
	  DOMAttributeNamespaces: {
	    xlinkActuate: NS.xlink,
	    xlinkArcrole: NS.xlink,
	    xlinkHref: NS.xlink,
	    xlinkRole: NS.xlink,
	    xlinkShow: NS.xlink,
	    xlinkTitle: NS.xlink,
	    xlinkType: NS.xlink,
	    xmlBase: NS.xml,
	    xmlLang: NS.xml,
	    xmlSpace: NS.xml
	  },
	  DOMAttributeNames: {
	    clipPath: 'clip-path',
	    fillOpacity: 'fill-opacity',
	    fontFamily: 'font-family',
	    fontSize: 'font-size',
	    gradientTransform: 'gradientTransform',
	    gradientUnits: 'gradientUnits',
	    markerEnd: 'marker-end',
	    markerMid: 'marker-mid',
	    markerStart: 'marker-start',
	    patternContentUnits: 'patternContentUnits',
	    patternUnits: 'patternUnits',
	    preserveAspectRatio: 'preserveAspectRatio',
	    spreadMethod: 'spreadMethod',
	    stopColor: 'stop-color',
	    stopOpacity: 'stop-opacity',
	    strokeDasharray: 'stroke-dasharray',
	    strokeLinecap: 'stroke-linecap',
	    strokeOpacity: 'stroke-opacity',
	    strokeWidth: 'stroke-width',
	    textAnchor: 'text-anchor',
	    viewBox: 'viewBox',
	    xlinkActuate: 'xlink:actuate',
	    xlinkArcrole: 'xlink:arcrole',
	    xlinkHref: 'xlink:href',
	    xlinkRole: 'xlink:role',
	    xlinkShow: 'xlink:show',
	    xlinkTitle: 'xlink:title',
	    xlinkType: 'xlink:type',
	    xmlBase: 'xml:base',
	    xmlLang: 'xml:lang',
	    xmlSpace: 'xml:space'
	  }
	};
	
	module.exports = SVGDOMPropertyConfig;

/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerf
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var DOMProperty = __webpack_require__(30);
	var ReactDefaultPerfAnalysis = __webpack_require__(150);
	var ReactMount = __webpack_require__(35);
	var ReactPerf = __webpack_require__(25);
	
	var performanceNow = __webpack_require__(151);
	
	function roundFloat(val) {
	  return Math.floor(val * 100) / 100;
	}
	
	function addValue(obj, key, val) {
	  obj[key] = (obj[key] || 0) + val;
	}
	
	var ReactDefaultPerf = {
	  _allMeasurements: [], // last item in the list is the current one
	  _mountStack: [0],
	  _injected: false,
	
	  start: function start() {
	    if (!ReactDefaultPerf._injected) {
	      ReactPerf.injection.injectMeasure(ReactDefaultPerf.measure);
	    }
	
	    ReactDefaultPerf._allMeasurements.length = 0;
	    ReactPerf.enableMeasure = true;
	  },
	
	  stop: function stop() {
	    ReactPerf.enableMeasure = false;
	  },
	
	  getLastMeasurements: function getLastMeasurements() {
	    return ReactDefaultPerf._allMeasurements;
	  },
	
	  printExclusive: function printExclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getExclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Component class name': item.componentName,
	        'Total inclusive time (ms)': roundFloat(item.inclusive),
	        'Exclusive mount time (ms)': roundFloat(item.exclusive),
	        'Exclusive render time (ms)': roundFloat(item.render),
	        'Mount time per instance (ms)': roundFloat(item.exclusive / item.count),
	        'Render time per instance (ms)': roundFloat(item.render / item.count),
	        'Instances': item.count
	      };
	    }));
	    // TODO: ReactDefaultPerfAnalysis.getTotalTime() does not return the correct
	    // number.
	  },
	
	  printInclusive: function printInclusive(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements);
	    console.table(summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Inclusive time (ms)': roundFloat(item.time),
	        'Instances': item.count
	      };
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  getMeasurementsSummaryMap: function getMeasurementsSummaryMap(measurements) {
	    var summary = ReactDefaultPerfAnalysis.getInclusiveSummary(measurements, true);
	    return summary.map(function (item) {
	      return {
	        'Owner > component': item.componentName,
	        'Wasted time (ms)': item.time,
	        'Instances': item.count
	      };
	    });
	  },
	
	  printWasted: function printWasted(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    console.table(ReactDefaultPerf.getMeasurementsSummaryMap(measurements));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  printDOM: function printDOM(measurements) {
	    measurements = measurements || ReactDefaultPerf._allMeasurements;
	    var summary = ReactDefaultPerfAnalysis.getDOMSummary(measurements);
	    console.table(summary.map(function (item) {
	      var result = {};
	      result[DOMProperty.ID_ATTRIBUTE_NAME] = item.id;
	      result.type = item.type;
	      result.args = JSON.stringify(item.args);
	      return result;
	    }));
	    console.log('Total time:', ReactDefaultPerfAnalysis.getTotalTime(measurements).toFixed(2) + ' ms');
	  },
	
	  _recordWrite: function _recordWrite(id, fnName, totalTime, args) {
	    // TODO: totalTime isn't that useful since it doesn't count paints/reflows
	    var writes = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].writes;
	    writes[id] = writes[id] || [];
	    writes[id].push({
	      type: fnName,
	      time: totalTime,
	      args: args
	    });
	  },
	
	  measure: function measure(moduleName, fnName, func) {
	    return function () {
	      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	        args[_key] = arguments[_key];
	      }
	
	      var totalTime;
	      var rv;
	      var start;
	
	      if (fnName === '_renderNewRootComponent' || fnName === 'flushBatchedUpdates') {
	        // A "measurement" is a set of metrics recorded for each flush. We want
	        // to group the metrics for a given flush together so we can look at the
	        // components that rendered and the DOM operations that actually
	        // happened to determine the amount of "wasted work" performed.
	        ReactDefaultPerf._allMeasurements.push({
	          exclusive: {},
	          inclusive: {},
	          render: {},
	          counts: {},
	          writes: {},
	          displayNames: {},
	          totalTime: 0,
	          created: {}
	        });
	        start = performanceNow();
	        rv = func.apply(this, args);
	        ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1].totalTime = performanceNow() - start;
	        return rv;
	      } else if (fnName === '_mountImageIntoNode' || moduleName === 'ReactBrowserEventEmitter' || moduleName === 'ReactDOMIDOperations' || moduleName === 'CSSPropertyOperations' || moduleName === 'DOMChildrenOperations' || moduleName === 'DOMPropertyOperations') {
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (fnName === '_mountImageIntoNode') {
	          var mountID = ReactMount.getID(args[1]);
	          ReactDefaultPerf._recordWrite(mountID, fnName, totalTime, args[0]);
	        } else if (fnName === 'dangerouslyProcessChildrenUpdates') {
	          // special format
	          args[0].forEach(function (update) {
	            var writeArgs = {};
	            if (update.fromIndex !== null) {
	              writeArgs.fromIndex = update.fromIndex;
	            }
	            if (update.toIndex !== null) {
	              writeArgs.toIndex = update.toIndex;
	            }
	            if (update.textContent !== null) {
	              writeArgs.textContent = update.textContent;
	            }
	            if (update.markupIndex !== null) {
	              writeArgs.markup = args[1][update.markupIndex];
	            }
	            ReactDefaultPerf._recordWrite(update.parentID, update.type, totalTime, writeArgs);
	          });
	        } else {
	          // basic format
	          var id = args[0];
	          if ((typeof id === 'undefined' ? 'undefined' : _typeof(id)) === 'object') {
	            id = ReactMount.getID(args[0]);
	          }
	          ReactDefaultPerf._recordWrite(id, fnName, totalTime, Array.prototype.slice.call(args, 1));
	        }
	        return rv;
	      } else if (moduleName === 'ReactCompositeComponent' && (fnName === 'mountComponent' || fnName === 'updateComponent' || // TODO: receiveComponent()?
	      fnName === '_renderValidatedComponent')) {
	
	        if (this._currentElement.type === ReactMount.TopLevelWrapper) {
	          return func.apply(this, args);
	        }
	
	        var rootNodeID = fnName === 'mountComponent' ? args[0] : this._rootNodeID;
	        var isRender = fnName === '_renderValidatedComponent';
	        var isMount = fnName === 'mountComponent';
	
	        var mountStack = ReactDefaultPerf._mountStack;
	        var entry = ReactDefaultPerf._allMeasurements[ReactDefaultPerf._allMeasurements.length - 1];
	
	        if (isRender) {
	          addValue(entry.counts, rootNodeID, 1);
	        } else if (isMount) {
	          entry.created[rootNodeID] = true;
	          mountStack.push(0);
	        }
	
	        start = performanceNow();
	        rv = func.apply(this, args);
	        totalTime = performanceNow() - start;
	
	        if (isRender) {
	          addValue(entry.render, rootNodeID, totalTime);
	        } else if (isMount) {
	          var subMountTime = mountStack.pop();
	          mountStack[mountStack.length - 1] += totalTime;
	          addValue(entry.exclusive, rootNodeID, totalTime - subMountTime);
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        } else {
	          addValue(entry.inclusive, rootNodeID, totalTime);
	        }
	
	        entry.displayNames[rootNodeID] = {
	          current: this.getName(),
	          owner: this._currentElement._owner ? this._currentElement._owner.getName() : '<root>'
	        };
	
	        return rv;
	      } else {
	        return func.apply(this, args);
	      }
	    };
	  }
	};
	
	module.exports = ReactDefaultPerf;

/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDefaultPerfAnalysis
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	
	// Don't try to save users less than 1.2ms (a number I made up)
	var DONT_CARE_THRESHOLD = 1.2;
	var DOM_OPERATION_TYPES = {
	  '_mountImageIntoNode': 'set innerHTML',
	  INSERT_MARKUP: 'set innerHTML',
	  MOVE_EXISTING: 'move',
	  REMOVE_NODE: 'remove',
	  SET_MARKUP: 'set innerHTML',
	  TEXT_CONTENT: 'set textContent',
	  'setValueForProperty': 'update attribute',
	  'setValueForAttribute': 'update attribute',
	  'deleteValueForProperty': 'remove attribute',
	  'setValueForStyles': 'update styles',
	  'replaceNodeWithMarkup': 'replace',
	  'updateTextContent': 'set textContent'
	};
	
	function getTotalTime(measurements) {
	  // TODO: return number of DOM ops? could be misleading.
	  // TODO: measure dropped frames after reconcile?
	  // TODO: log total time of each reconcile and the top-level component
	  // class that triggered it.
	  var totalTime = 0;
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    totalTime += measurement.totalTime;
	  }
	  return totalTime;
	}
	
	function getDOMSummary(measurements) {
	  var items = [];
	  measurements.forEach(function (measurement) {
	    Object.keys(measurement.writes).forEach(function (id) {
	      measurement.writes[id].forEach(function (write) {
	        items.push({
	          id: id,
	          type: DOM_OPERATION_TYPES[write.type] || write.type,
	          args: write.args
	        });
	      });
	    });
	  });
	  return items;
	}
	
	function getExclusiveSummary(measurements) {
	  var candidates = {};
	  var displayName;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	    for (var id in allIDs) {
	      displayName = measurement.displayNames[id].current;
	
	      candidates[displayName] = candidates[displayName] || {
	        componentName: displayName,
	        inclusive: 0,
	        exclusive: 0,
	        render: 0,
	        count: 0
	      };
	      if (measurement.render[id]) {
	        candidates[displayName].render += measurement.render[id];
	      }
	      if (measurement.exclusive[id]) {
	        candidates[displayName].exclusive += measurement.exclusive[id];
	      }
	      if (measurement.inclusive[id]) {
	        candidates[displayName].inclusive += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[displayName].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (displayName in candidates) {
	    if (candidates[displayName].exclusive >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[displayName]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.exclusive - a.exclusive;
	  });
	
	  return arr;
	}
	
	function getInclusiveSummary(measurements, onlyClean) {
	  var candidates = {};
	  var inclusiveKey;
	
	  for (var i = 0; i < measurements.length; i++) {
	    var measurement = measurements[i];
	    var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	    var cleanComponents;
	
	    if (onlyClean) {
	      cleanComponents = getUnchangedComponents(measurement);
	    }
	
	    for (var id in allIDs) {
	      if (onlyClean && !cleanComponents[id]) {
	        continue;
	      }
	
	      var displayName = measurement.displayNames[id];
	
	      // Inclusive time is not useful for many components without knowing where
	      // they are instantiated. So we aggregate inclusive time with both the
	      // owner and current displayName as the key.
	      inclusiveKey = displayName.owner + ' > ' + displayName.current;
	
	      candidates[inclusiveKey] = candidates[inclusiveKey] || {
	        componentName: inclusiveKey,
	        time: 0,
	        count: 0
	      };
	
	      if (measurement.inclusive[id]) {
	        candidates[inclusiveKey].time += measurement.inclusive[id];
	      }
	      if (measurement.counts[id]) {
	        candidates[inclusiveKey].count += measurement.counts[id];
	      }
	    }
	  }
	
	  // Now make a sorted array with the results.
	  var arr = [];
	  for (inclusiveKey in candidates) {
	    if (candidates[inclusiveKey].time >= DONT_CARE_THRESHOLD) {
	      arr.push(candidates[inclusiveKey]);
	    }
	  }
	
	  arr.sort(function (a, b) {
	    return b.time - a.time;
	  });
	
	  return arr;
	}
	
	function getUnchangedComponents(measurement) {
	  // For a given reconcile, look at which components did not actually
	  // render anything to the DOM and return a mapping of their ID to
	  // the amount of time it took to render the entire subtree.
	  var cleanComponents = {};
	  var dirtyLeafIDs = Object.keys(measurement.writes);
	  var allIDs = assign({}, measurement.exclusive, measurement.inclusive);
	
	  for (var id in allIDs) {
	    var isDirty = false;
	    // For each component that rendered, see if a component that triggered
	    // a DOM op is in its subtree.
	    for (var i = 0; i < dirtyLeafIDs.length; i++) {
	      if (dirtyLeafIDs[i].indexOf(id) === 0) {
	        isDirty = true;
	        break;
	      }
	    }
	    // check if component newly created
	    if (measurement.created[id]) {
	      isDirty = true;
	    }
	    if (!isDirty && measurement.counts[id] > 0) {
	      cleanComponents[id] = true;
	    }
	  }
	  return cleanComponents;
	}
	
	var ReactDefaultPerfAnalysis = {
	  getExclusiveSummary: getExclusiveSummary,
	  getInclusiveSummary: getInclusiveSummary,
	  getDOMSummary: getDOMSummary,
	  getTotalTime: getTotalTime
	};
	
	module.exports = ReactDefaultPerfAnalysis;

/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performanceNow
	 * @typechecks
	 */
	
	'use strict';
	
	var performance = __webpack_require__(152);
	
	var performanceNow;
	
	/**
	 * Detect if we can use `window.performance.now()` and gracefully fallback to
	 * `Date.now()` if it doesn't exist. We need to support Firefox < 15 for now
	 * because of Facebook's testing infrastructure.
	 */
	if (performance.now) {
	  performanceNow = function performanceNow() {
	    return performance.now();
	  };
	} else {
	  performanceNow = function performanceNow() {
	    return Date.now();
	  };
	}
	
	module.exports = performanceNow;

/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule performance
	 * @typechecks
	 */
	
	'use strict';
	
	var ExecutionEnvironment = __webpack_require__(16);
	
	var performance;
	
	if (ExecutionEnvironment.canUseDOM) {
	  performance = window.performance || window.msPerformance || window.webkitPerformance;
	}
	
	module.exports = performance || {};

/***/ },
/* 153 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactVersion
	 */
	
	'use strict';
	
	module.exports = '0.14.8';

/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	* @providesModule renderSubtreeIntoContainer
	*/
	
	'use strict';
	
	var ReactMount = __webpack_require__(35);
	
	module.exports = ReactMount.renderSubtreeIntoContainer;

/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMServer
	 */
	
	'use strict';
	
	var ReactDefaultInjection = __webpack_require__(78);
	var ReactServerRendering = __webpack_require__(156);
	var ReactVersion = __webpack_require__(153);
	
	ReactDefaultInjection.inject();
	
	var ReactDOMServer = {
	  renderToString: ReactServerRendering.renderToString,
	  renderToStaticMarkup: ReactServerRendering.renderToStaticMarkup,
	  version: ReactVersion
	};
	
	module.exports = ReactDOMServer;

/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @typechecks static-only
	 * @providesModule ReactServerRendering
	 */
	'use strict';
	
	var ReactDefaultBatchingStrategy = __webpack_require__(99);
	var ReactElement = __webpack_require__(49);
	var ReactInstanceHandles = __webpack_require__(52);
	var ReactMarkupChecksum = __webpack_require__(55);
	var ReactServerBatchingStrategy = __webpack_require__(157);
	var ReactServerRenderingTransaction = __webpack_require__(158);
	var ReactUpdates = __webpack_require__(61);
	
	var emptyObject = __webpack_require__(65);
	var instantiateReactComponent = __webpack_require__(69);
	var invariant = __webpack_require__(20);
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup
	 */
	function renderToString(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToString(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(false);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      var markup = componentInstance.mountComponent(id, transaction, emptyObject);
	      return ReactMarkupChecksum.addChecksumToMarkup(markup);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	/**
	 * @param {ReactElement} element
	 * @return {string} the HTML markup, without the extra React ID and checksum
	 * (for generating static pages)
	 */
	function renderToStaticMarkup(element) {
	  !ReactElement.isValidElement(element) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'renderToStaticMarkup(): You must pass a valid ReactElement.') : invariant(false) : undefined;
	
	  var transaction;
	  try {
	    ReactUpdates.injection.injectBatchingStrategy(ReactServerBatchingStrategy);
	
	    var id = ReactInstanceHandles.createReactRootID();
	    transaction = ReactServerRenderingTransaction.getPooled(true);
	
	    return transaction.perform(function () {
	      var componentInstance = instantiateReactComponent(element, null);
	      return componentInstance.mountComponent(id, transaction, emptyObject);
	    }, null);
	  } finally {
	    ReactServerRenderingTransaction.release(transaction);
	    // Revert to the DOM batching strategy since these two renderers
	    // currently share these stateful modules.
	    ReactUpdates.injection.injectBatchingStrategy(ReactDefaultBatchingStrategy);
	  }
	}
	
	module.exports = {
	  renderToString: renderToString,
	  renderToStaticMarkup: renderToStaticMarkup
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 157 */
/***/ function(module, exports) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerBatchingStrategy
	 * @typechecks
	 */
	
	'use strict';
	
	var ReactServerBatchingStrategy = {
	  isBatchingUpdates: false,
	  batchedUpdates: function batchedUpdates(callback) {
	    // Don't do anything here. During the server rendering we don't want to
	    // schedule any updates. We will simply ignore them.
	  }
	};
	
	module.exports = ReactServerBatchingStrategy;

/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactServerRenderingTransaction
	 * @typechecks
	 */
	
	'use strict';
	
	var PooledClass = __webpack_require__(63);
	var CallbackQueue = __webpack_require__(62);
	var Transaction = __webpack_require__(64);
	
	var assign = __webpack_require__(46);
	var emptyFunction = __webpack_require__(22);
	
	/**
	 * Provides a `CallbackQueue` queue for collecting `onDOMReady` callbacks
	 * during the performing of the transaction.
	 */
	var ON_DOM_READY_QUEUEING = {
	  /**
	   * Initializes the internal `onDOMReady` queue.
	   */
	  initialize: function initialize() {
	    this.reactMountReady.reset();
	  },
	
	  close: emptyFunction
	};
	
	/**
	 * Executed within the scope of the `Transaction` instance. Consider these as
	 * being member methods, but with an implied ordering while being isolated from
	 * each other.
	 */
	var TRANSACTION_WRAPPERS = [ON_DOM_READY_QUEUEING];
	
	/**
	 * @class ReactServerRenderingTransaction
	 * @param {boolean} renderToStaticMarkup
	 */
	function ReactServerRenderingTransaction(renderToStaticMarkup) {
	  this.reinitializeTransaction();
	  this.renderToStaticMarkup = renderToStaticMarkup;
	  this.reactMountReady = CallbackQueue.getPooled(null);
	  this.useCreateElement = false;
	}
	
	var Mixin = {
	  /**
	   * @see Transaction
	   * @abstract
	   * @final
	   * @return {array} Empty list of operation wrap procedures.
	   */
	  getTransactionWrappers: function getTransactionWrappers() {
	    return TRANSACTION_WRAPPERS;
	  },
	
	  /**
	   * @return {object} The queue to collect `onDOMReady` callbacks with.
	   */
	  getReactMountReady: function getReactMountReady() {
	    return this.reactMountReady;
	  },
	
	  /**
	   * `PooledClass` looks for this, and will invoke this before allowing this
	   * instance to be reused.
	   */
	  destructor: function destructor() {
	    CallbackQueue.release(this.reactMountReady);
	    this.reactMountReady = null;
	  }
	};
	
	assign(ReactServerRenderingTransaction.prototype, Transaction.Mixin, Mixin);
	
	PooledClass.addPoolingTo(ReactServerRenderingTransaction);
	
	module.exports = ReactServerRenderingTransaction;

/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactIsomorphic
	 */
	
	'use strict';
	
	var ReactChildren = __webpack_require__(117);
	var ReactComponent = __webpack_require__(130);
	var ReactClass = __webpack_require__(129);
	var ReactDOMFactories = __webpack_require__(160);
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	var ReactPropTypes = __webpack_require__(114);
	var ReactVersion = __webpack_require__(153);
	
	var assign = __webpack_require__(46);
	var onlyChild = __webpack_require__(163);
	
	var createElement = ReactElement.createElement;
	var createFactory = ReactElement.createFactory;
	var cloneElement = ReactElement.cloneElement;
	
	if (process.env.NODE_ENV !== 'production') {
	  createElement = ReactElementValidator.createElement;
	  createFactory = ReactElementValidator.createFactory;
	  cloneElement = ReactElementValidator.cloneElement;
	}
	
	var React = {
	
	  // Modern
	
	  Children: {
	    map: ReactChildren.map,
	    forEach: ReactChildren.forEach,
	    count: ReactChildren.count,
	    toArray: ReactChildren.toArray,
	    only: onlyChild
	  },
	
	  Component: ReactComponent,
	
	  createElement: createElement,
	  cloneElement: cloneElement,
	  isValidElement: ReactElement.isValidElement,
	
	  // Classic
	
	  PropTypes: ReactPropTypes,
	  createClass: ReactClass.createClass,
	  createFactory: createFactory,
	  createMixin: function createMixin(mixin) {
	    // Currently a noop. Will be used to validate and trace mixins.
	    return mixin;
	  },
	
	  // This looks DOM specific but these are actually isomorphic helpers
	  // since they are just generating DOM strings.
	  DOM: ReactDOMFactories,
	
	  version: ReactVersion,
	
	  // Hook for JSX spread, don't use this for anything else.
	  __spread: assign
	};
	
	module.exports = React;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactDOMFactories
	 * @typechecks static-only
	 */
	
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	var ReactElementValidator = __webpack_require__(161);
	
	var mapObject = __webpack_require__(162);
	
	/**
	 * Create a factory that creates HTML tag elements.
	 *
	 * @param {string} tag Tag name (e.g. `div`).
	 * @private
	 */
	function createDOMFactory(tag) {
	  if (process.env.NODE_ENV !== 'production') {
	    return ReactElementValidator.createFactory(tag);
	  }
	  return ReactElement.createFactory(tag);
	}
	
	/**
	 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
	 * This is also accessible via `React.DOM`.
	 *
	 * @public
	 */
	var ReactDOMFactories = mapObject({
	  a: 'a',
	  abbr: 'abbr',
	  address: 'address',
	  area: 'area',
	  article: 'article',
	  aside: 'aside',
	  audio: 'audio',
	  b: 'b',
	  base: 'base',
	  bdi: 'bdi',
	  bdo: 'bdo',
	  big: 'big',
	  blockquote: 'blockquote',
	  body: 'body',
	  br: 'br',
	  button: 'button',
	  canvas: 'canvas',
	  caption: 'caption',
	  cite: 'cite',
	  code: 'code',
	  col: 'col',
	  colgroup: 'colgroup',
	  data: 'data',
	  datalist: 'datalist',
	  dd: 'dd',
	  del: 'del',
	  details: 'details',
	  dfn: 'dfn',
	  dialog: 'dialog',
	  div: 'div',
	  dl: 'dl',
	  dt: 'dt',
	  em: 'em',
	  embed: 'embed',
	  fieldset: 'fieldset',
	  figcaption: 'figcaption',
	  figure: 'figure',
	  footer: 'footer',
	  form: 'form',
	  h1: 'h1',
	  h2: 'h2',
	  h3: 'h3',
	  h4: 'h4',
	  h5: 'h5',
	  h6: 'h6',
	  head: 'head',
	  header: 'header',
	  hgroup: 'hgroup',
	  hr: 'hr',
	  html: 'html',
	  i: 'i',
	  iframe: 'iframe',
	  img: 'img',
	  input: 'input',
	  ins: 'ins',
	  kbd: 'kbd',
	  keygen: 'keygen',
	  label: 'label',
	  legend: 'legend',
	  li: 'li',
	  link: 'link',
	  main: 'main',
	  map: 'map',
	  mark: 'mark',
	  menu: 'menu',
	  menuitem: 'menuitem',
	  meta: 'meta',
	  meter: 'meter',
	  nav: 'nav',
	  noscript: 'noscript',
	  object: 'object',
	  ol: 'ol',
	  optgroup: 'optgroup',
	  option: 'option',
	  output: 'output',
	  p: 'p',
	  param: 'param',
	  picture: 'picture',
	  pre: 'pre',
	  progress: 'progress',
	  q: 'q',
	  rp: 'rp',
	  rt: 'rt',
	  ruby: 'ruby',
	  s: 's',
	  samp: 'samp',
	  script: 'script',
	  section: 'section',
	  select: 'select',
	  small: 'small',
	  source: 'source',
	  span: 'span',
	  strong: 'strong',
	  style: 'style',
	  sub: 'sub',
	  summary: 'summary',
	  sup: 'sup',
	  table: 'table',
	  tbody: 'tbody',
	  td: 'td',
	  textarea: 'textarea',
	  tfoot: 'tfoot',
	  th: 'th',
	  thead: 'thead',
	  time: 'time',
	  title: 'title',
	  tr: 'tr',
	  track: 'track',
	  u: 'u',
	  ul: 'ul',
	  'var': 'var',
	  video: 'video',
	  wbr: 'wbr',
	
	  // SVG
	  circle: 'circle',
	  clipPath: 'clipPath',
	  defs: 'defs',
	  ellipse: 'ellipse',
	  g: 'g',
	  image: 'image',
	  line: 'line',
	  linearGradient: 'linearGradient',
	  mask: 'mask',
	  path: 'path',
	  pattern: 'pattern',
	  polygon: 'polygon',
	  polyline: 'polyline',
	  radialGradient: 'radialGradient',
	  rect: 'rect',
	  stop: 'stop',
	  svg: 'svg',
	  text: 'text',
	  tspan: 'tspan'
	
	}, createDOMFactory);
	
	module.exports = ReactDOMFactories;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule ReactElementValidator
	 */
	
	/**
	 * ReactElementValidator provides a wrapper around a element factory
	 * which validates the props passed to the element. This is intended to be
	 * used only in DEV and could be replaced by a static type checker for languages
	 * that support it.
	 */
	
	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var ReactElement = __webpack_require__(49);
	var ReactPropTypeLocations = __webpack_require__(72);
	var ReactPropTypeLocationNames = __webpack_require__(73);
	var ReactCurrentOwner = __webpack_require__(12);
	
	var canDefineProperty = __webpack_require__(50);
	var getIteratorFn = __webpack_require__(115);
	var invariant = __webpack_require__(20);
	var warning = __webpack_require__(32);
	
	function getDeclarationErrorAddendum() {
	  if (ReactCurrentOwner.current) {
	    var name = ReactCurrentOwner.current.getName();
	    if (name) {
	      return ' Check the render method of `' + name + '`.';
	    }
	  }
	  return '';
	}
	
	/**
	 * Warn if there's no key explicitly set on dynamic arrays of children or
	 * object keys are not valid. This allows us to keep track of children between
	 * updates.
	 */
	var ownerHasKeyUseWarning = {};
	
	var loggedTypeFailures = {};
	
	/**
	 * Warn if the element doesn't have an explicit key assigned to it.
	 * This element is in an array. The array could grow and shrink or be
	 * reordered. All children that haven't already been validated are required to
	 * have a "key" property assigned to it.
	 *
	 * @internal
	 * @param {ReactElement} element Element that requires a key.
	 * @param {*} parentType element's parent's type.
	 */
	function validateExplicitKey(element, parentType) {
	  if (!element._store || element._store.validated || element.key != null) {
	    return;
	  }
	  element._store.validated = true;
	
	  var addenda = getAddendaForKeyUse('uniqueKey', element, parentType);
	  if (addenda === null) {
	    // we already showed the warning
	    return;
	  }
	  process.env.NODE_ENV !== 'production' ? warning(false, 'Each child in an array or iterator should have a unique "key" prop.' + '%s%s%s', addenda.parentOrOwner || '', addenda.childOwner || '', addenda.url || '') : undefined;
	}
	
	/**
	 * Shared warning and monitoring code for the key warnings.
	 *
	 * @internal
	 * @param {string} messageType A key used for de-duping warnings.
	 * @param {ReactElement} element Component that requires a key.
	 * @param {*} parentType element's parent's type.
	 * @returns {?object} A set of addenda to use in the warning message, or null
	 * if the warning has already been shown before (and shouldn't be shown again).
	 */
	function getAddendaForKeyUse(messageType, element, parentType) {
	  var addendum = getDeclarationErrorAddendum();
	  if (!addendum) {
	    var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;
	    if (parentName) {
	      addendum = ' Check the top-level render call using <' + parentName + '>.';
	    }
	  }
	
	  var memoizer = ownerHasKeyUseWarning[messageType] || (ownerHasKeyUseWarning[messageType] = {});
	  if (memoizer[addendum]) {
	    return null;
	  }
	  memoizer[addendum] = true;
	
	  var addenda = {
	    parentOrOwner: addendum,
	    url: ' See https://fb.me/react-warning-keys for more information.',
	    childOwner: null
	  };
	
	  // Usually the current owner is the offender, but if it accepts children as a
	  // property, it may be the creator of the child that's responsible for
	  // assigning it a key.
	  if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
	    // Give the component that originally created this child.
	    addenda.childOwner = ' It was passed a child from ' + element._owner.getName() + '.';
	  }
	
	  return addenda;
	}
	
	/**
	 * Ensure that every element either is passed in a static location, in an
	 * array with an explicit keys property defined, or in an object literal
	 * with valid key property.
	 *
	 * @internal
	 * @param {ReactNode} node Statically passed child of any type.
	 * @param {*} parentType node's parent's type.
	 */
	function validateChildKeys(node, parentType) {
	  if ((typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') {
	    return;
	  }
	  if (Array.isArray(node)) {
	    for (var i = 0; i < node.length; i++) {
	      var child = node[i];
	      if (ReactElement.isValidElement(child)) {
	        validateExplicitKey(child, parentType);
	      }
	    }
	  } else if (ReactElement.isValidElement(node)) {
	    // This element was passed in a valid location.
	    if (node._store) {
	      node._store.validated = true;
	    }
	  } else if (node) {
	    var iteratorFn = getIteratorFn(node);
	    // Entry iterators provide implicit keys.
	    if (iteratorFn) {
	      if (iteratorFn !== node.entries) {
	        var iterator = iteratorFn.call(node);
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (ReactElement.isValidElement(step.value)) {
	            validateExplicitKey(step.value, parentType);
	          }
	        }
	      }
	    }
	  }
	}
	
	/**
	 * Assert that the props are valid
	 *
	 * @param {string} componentName Name of the component for error messages.
	 * @param {object} propTypes Map of prop name to a ReactPropType
	 * @param {object} props
	 * @param {string} location e.g. "prop", "context", "child context"
	 * @private
	 */
	function checkPropTypes(componentName, propTypes, props, location) {
	  for (var propName in propTypes) {
	    if (propTypes.hasOwnProperty(propName)) {
	      var error;
	      // Prop type validation may throw. In case they do, we don't want to
	      // fail the render phase where it didn't fail before. So we log it.
	      // After these have been cleaned up, we'll let them throw.
	      try {
	        // This is intentionally an invariant that gets caught. It's the same
	        // behavior as without this statement except with a better message.
	        !(typeof propTypes[propName] === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'React.PropTypes.', componentName || 'React class', ReactPropTypeLocationNames[location], propName) : invariant(false) : undefined;
	        error = propTypes[propName](props, propName, componentName, location);
	      } catch (ex) {
	        error = ex;
	      }
	      process.env.NODE_ENV !== 'production' ? warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', ReactPropTypeLocationNames[location], propName, typeof error === 'undefined' ? 'undefined' : _typeof(error)) : undefined;
	      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
	        // Only monitor this failure once because there tends to be a lot of the
	        // same error.
	        loggedTypeFailures[error.message] = true;
	
	        var addendum = getDeclarationErrorAddendum();
	        process.env.NODE_ENV !== 'production' ? warning(false, 'Failed propType: %s%s', error.message, addendum) : undefined;
	      }
	    }
	  }
	}
	
	/**
	 * Given an element, validate that its props follow the propTypes definition,
	 * provided by the type.
	 *
	 * @param {ReactElement} element
	 */
	function validatePropTypes(element) {
	  var componentClass = element.type;
	  if (typeof componentClass !== 'function') {
	    return;
	  }
	  var name = componentClass.displayName || componentClass.name;
	  if (componentClass.propTypes) {
	    checkPropTypes(name, componentClass.propTypes, element.props, ReactPropTypeLocations.prop);
	  }
	  if (typeof componentClass.getDefaultProps === 'function') {
	    process.env.NODE_ENV !== 'production' ? warning(componentClass.getDefaultProps.isReactClassApproved, 'getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.') : undefined;
	  }
	}
	
	var ReactElementValidator = {
	
	  createElement: function createElement(type, props, children) {
	    var validType = typeof type === 'string' || typeof type === 'function';
	    // We warn in this case but don't throw. We expect the element creation to
	    // succeed and there will likely be errors in render.
	    process.env.NODE_ENV !== 'production' ? warning(validType, 'React.createElement: type should not be null, undefined, boolean, or ' + 'number. It should be a string (for DOM elements) or a ReactClass ' + '(for composite components).%s', getDeclarationErrorAddendum()) : undefined;
	
	    var element = ReactElement.createElement.apply(this, arguments);
	
	    // The result can be nullish if a mock or a custom function is used.
	    // TODO: Drop this when these are no longer allowed as the type argument.
	    if (element == null) {
	      return element;
	    }
	
	    // Skip key warning if the type isn't valid since our key validation logic
	    // doesn't expect a non-string/function type and can throw confusing errors.
	    // We don't want exception behavior to differ between dev and prod.
	    // (Rendering will throw with a helpful message and as soon as the type is
	    // fixed, the key warnings will appear.)
	    if (validType) {
	      for (var i = 2; i < arguments.length; i++) {
	        validateChildKeys(arguments[i], type);
	      }
	    }
	
	    validatePropTypes(element);
	
	    return element;
	  },
	
	  createFactory: function createFactory(type) {
	    var validatedFactory = ReactElementValidator.createElement.bind(null, type);
	    // Legacy hook TODO: Warn if this is accessed
	    validatedFactory.type = type;
	
	    if (process.env.NODE_ENV !== 'production') {
	      if (canDefineProperty) {
	        Object.defineProperty(validatedFactory, 'type', {
	          enumerable: false,
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? warning(false, 'Factory.type is deprecated. Access the class directly ' + 'before passing it to createFactory.') : undefined;
	            Object.defineProperty(this, 'type', {
	              value: type
	            });
	            return type;
	          }
	        });
	      }
	    }
	
	    return validatedFactory;
	  },
	
	  cloneElement: function cloneElement(element, props, children) {
	    var newElement = ReactElement.cloneElement.apply(this, arguments);
	    for (var i = 2; i < arguments.length; i++) {
	      validateChildKeys(arguments[i], newElement.type);
	    }
	    validatePropTypes(newElement);
	    return newElement;
	  }
	
	};
	
	module.exports = ReactElementValidator;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 162 */
/***/ function(module, exports) {

	/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule mapObject
	 */
	
	'use strict';
	
	var hasOwnProperty = Object.prototype.hasOwnProperty;
	
	/**
	 * Executes the provided `callback` once for each enumerable own property in the
	 * object and constructs a new object from the results. The `callback` is
	 * invoked with three arguments:
	 *
	 *  - the property value
	 *  - the property name
	 *  - the object being traversed
	 *
	 * Properties that are added after the call to `mapObject` will not be visited
	 * by `callback`. If the values of existing properties are changed, the value
	 * passed to `callback` will be the value at the time `mapObject` visits them.
	 * Properties that are deleted before being visited are not visited.
	 *
	 * @grep function objectMap()
	 * @grep function objMap()
	 *
	 * @param {?object} object
	 * @param {function} callback
	 * @param {*} context
	 * @return {?object}
	 */
	function mapObject(object, callback, context) {
	  if (!object) {
	    return null;
	  }
	  var result = {};
	  for (var name in object) {
	    if (hasOwnProperty.call(object, name)) {
	      result[name] = callback.call(context, object[name], name, object);
	    }
	  }
	  return result;
	}
	
	module.exports = mapObject;

/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule onlyChild
	 */
	'use strict';
	
	var ReactElement = __webpack_require__(49);
	
	var invariant = __webpack_require__(20);
	
	/**
	 * Returns the first child in a collection of children and verifies that there
	 * is only one child in the collection. The current implementation of this
	 * function assumes that a single child gets passed without a wrapper, but the
	 * purpose of this helper function is to abstract away the particular structure
	 * of children.
	 *
	 * @param {?object} children Child collection structure.
	 * @return {ReactComponent} The first and only `ReactComponent` contained in the
	 * structure.
	 */
	function onlyChild(children) {
	  !ReactElement.isValidElement(children) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'onlyChild must be passed a children with exactly one child.') : invariant(false) : undefined;
	  return children;
	}
	
	module.exports = onlyChild;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 *
	 * @providesModule deprecated
	 */
	
	'use strict';
	
	var assign = __webpack_require__(46);
	var warning = __webpack_require__(32);
	
	/**
	 * This will log a single deprecation notice per function and forward the call
	 * on to the new API.
	 *
	 * @param {string} fnName The name of the function
	 * @param {string} newModule The module that fn will exist in
	 * @param {string} newPackage The module that fn will exist in
	 * @param {*} ctx The context this forwarded call should run in
	 * @param {function} fn The function to forward on to
	 * @return {function} The function that will warn once and then call fn
	 */
	function deprecated(fnName, newModule, newPackage, ctx, fn) {
	  var warned = false;
	  if (process.env.NODE_ENV !== 'production') {
	    var newFn = function newFn() {
	      process.env.NODE_ENV !== 'production' ? warning(warned,
	      // Require examples in this string must be split to prevent React's
	      // build tools from mistaking them for real requires.
	      // Otherwise the build tools will attempt to build a '%s' module.
	      'React.%s is deprecated. Please use %s.%s from require' + '(\'%s\') ' + 'instead.', fnName, newModule, fnName, newPackage) : undefined;
	      warned = true;
	      return fn.apply(ctx, arguments);
	    };
	    // We need to make sure all properties of the original fn are copied over.
	    // In particular, this is needed to support PropTypes
	    return assign(newFn, fn);
	  }
	
	  return fn;
	}
	
	module.exports = deprecated;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	module.exports = __webpack_require__(10);

/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.createMemoryHistory = exports.hashHistory = exports.browserHistory = exports.applyRouterMiddleware = exports.formatPattern = exports.useRouterHistory = exports.match = exports.routerShape = exports.locationShape = exports.PropTypes = exports.RoutingContext = exports.RouterContext = exports.createRoutes = exports.useRoutes = exports.RouteContext = exports.Lifecycle = exports.History = exports.Route = exports.Redirect = exports.IndexRoute = exports.IndexRedirect = exports.withRouter = exports.IndexLink = exports.Link = exports.Router = undefined;
	
	var _RouteUtils = __webpack_require__(167);
	
	Object.defineProperty(exports, 'createRoutes', {
	  enumerable: true,
	  get: function get() {
	    return _RouteUtils.createRoutes;
	  }
	});
	
	var _PropTypes2 = __webpack_require__(168);
	
	Object.defineProperty(exports, 'locationShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.locationShape;
	  }
	});
	Object.defineProperty(exports, 'routerShape', {
	  enumerable: true,
	  get: function get() {
	    return _PropTypes2.routerShape;
	  }
	});
	
	var _PatternUtils = __webpack_require__(173);
	
	Object.defineProperty(exports, 'formatPattern', {
	  enumerable: true,
	  get: function get() {
	    return _PatternUtils.formatPattern;
	  }
	});
	
	var _Router2 = __webpack_require__(175);
	
	var _Router3 = _interopRequireDefault(_Router2);
	
	var _Link2 = __webpack_require__(206);
	
	var _Link3 = _interopRequireDefault(_Link2);
	
	var _IndexLink2 = __webpack_require__(207);
	
	var _IndexLink3 = _interopRequireDefault(_IndexLink2);
	
	var _withRouter2 = __webpack_require__(208);
	
	var _withRouter3 = _interopRequireDefault(_withRouter2);
	
	var _IndexRedirect2 = __webpack_require__(210);
	
	var _IndexRedirect3 = _interopRequireDefault(_IndexRedirect2);
	
	var _IndexRoute2 = __webpack_require__(212);
	
	var _IndexRoute3 = _interopRequireDefault(_IndexRoute2);
	
	var _Redirect2 = __webpack_require__(211);
	
	var _Redirect3 = _interopRequireDefault(_Redirect2);
	
	var _Route2 = __webpack_require__(213);
	
	var _Route3 = _interopRequireDefault(_Route2);
	
	var _History2 = __webpack_require__(214);
	
	var _History3 = _interopRequireDefault(_History2);
	
	var _Lifecycle2 = __webpack_require__(215);
	
	var _Lifecycle3 = _interopRequireDefault(_Lifecycle2);
	
	var _RouteContext2 = __webpack_require__(216);
	
	var _RouteContext3 = _interopRequireDefault(_RouteContext2);
	
	var _useRoutes2 = __webpack_require__(217);
	
	var _useRoutes3 = _interopRequireDefault(_useRoutes2);
	
	var _RouterContext2 = __webpack_require__(203);
	
	var _RouterContext3 = _interopRequireDefault(_RouterContext2);
	
	var _RoutingContext2 = __webpack_require__(218);
	
	var _RoutingContext3 = _interopRequireDefault(_RoutingContext2);
	
	var _PropTypes3 = _interopRequireDefault(_PropTypes2);
	
	var _match2 = __webpack_require__(219);
	
	var _match3 = _interopRequireDefault(_match2);
	
	var _useRouterHistory2 = __webpack_require__(223);
	
	var _useRouterHistory3 = _interopRequireDefault(_useRouterHistory2);
	
	var _applyRouterMiddleware2 = __webpack_require__(224);
	
	var _applyRouterMiddleware3 = _interopRequireDefault(_applyRouterMiddleware2);
	
	var _browserHistory2 = __webpack_require__(225);
	
	var _browserHistory3 = _interopRequireDefault(_browserHistory2);
	
	var _hashHistory2 = __webpack_require__(228);
	
	var _hashHistory3 = _interopRequireDefault(_hashHistory2);
	
	var _createMemoryHistory2 = __webpack_require__(220);
	
	var _createMemoryHistory3 = _interopRequireDefault(_createMemoryHistory2);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.Router = _Router3.default; /* components */
	
	exports.Link = _Link3.default;
	exports.IndexLink = _IndexLink3.default;
	exports.withRouter = _withRouter3.default;
	
	/* components (configuration) */
	
	exports.IndexRedirect = _IndexRedirect3.default;
	exports.IndexRoute = _IndexRoute3.default;
	exports.Redirect = _Redirect3.default;
	exports.Route = _Route3.default;
	
	/* mixins */
	
	exports.History = _History3.default;
	exports.Lifecycle = _Lifecycle3.default;
	exports.RouteContext = _RouteContext3.default;
	
	/* utils */
	
	exports.useRoutes = _useRoutes3.default;
	exports.RouterContext = _RouterContext3.default;
	exports.RoutingContext = _RoutingContext3.default;
	exports.PropTypes = _PropTypes3.default;
	exports.match = _match3.default;
	exports.useRouterHistory = _useRouterHistory3.default;
	exports.applyRouterMiddleware = _applyRouterMiddleware3.default;
	
	/* histories */
	
	exports.browserHistory = _browserHistory3.default;
	exports.hashHistory = _hashHistory3.default;
	exports.createMemoryHistory = _createMemoryHistory3.default;

/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.isReactChildren = isReactChildren;
	exports.createRouteFromReactElement = createRouteFromReactElement;
	exports.createRoutesFromReactChildren = createRoutesFromReactChildren;
	exports.createRoutes = createRoutes;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function isValidChild(object) {
	  return object == null || _react2.default.isValidElement(object);
	}
	
	function isReactChildren(object) {
	  return isValidChild(object) || Array.isArray(object) && object.every(isValidChild);
	}
	
	function createRoute(defaultProps, props) {
	  return _extends({}, defaultProps, props);
	}
	
	function createRouteFromReactElement(element) {
	  var type = element.type;
	  var route = createRoute(type.defaultProps, element.props);
	
	  if (route.children) {
	    var childRoutes = createRoutesFromReactChildren(route.children, route);
	
	    if (childRoutes.length) route.childRoutes = childRoutes;
	
	    delete route.children;
	  }
	
	  return route;
	}
	
	/**
	 * Creates and returns a routes object from the given ReactChildren. JSX
	 * provides a convenient way to visualize how routes in the hierarchy are
	 * nested.
	 *
	 *   import { Route, createRoutesFromReactChildren } from 'react-router'
	 *
	 *   const routes = createRoutesFromReactChildren(
	 *     <Route component={App}>
	 *       <Route path="home" component={Dashboard}/>
	 *       <Route path="news" component={NewsFeed}/>
	 *     </Route>
	 *   )
	 *
	 * Note: This method is automatically used when you provide <Route> children
	 * to a <Router> component.
	 */
	function createRoutesFromReactChildren(children, parentRoute) {
	  var routes = [];
	
	  _react2.default.Children.forEach(children, function (element) {
	    if (_react2.default.isValidElement(element)) {
	      // Component classes may have a static create* method.
	      if (element.type.createRouteFromReactElement) {
	        var route = element.type.createRouteFromReactElement(element, parentRoute);
	
	        if (route) routes.push(route);
	      } else {
	        routes.push(createRouteFromReactElement(element));
	      }
	    }
	  });
	
	  return routes;
	}
	
	/**
	 * Creates and returns an array of routes from the given object which
	 * may be a JSX route, a plain object route, or an array of either.
	 */
	function createRoutes(routes) {
	  if (isReactChildren(routes)) {
	    routes = createRoutesFromReactChildren(routes);
	  } else if (routes && !Array.isArray(routes)) {
	    routes = [routes];
	  }
	
	  return routes;
	}

/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.router = exports.routes = exports.route = exports.components = exports.component = exports.location = exports.history = exports.falsy = exports.locationShape = exports.routerShape = undefined;
	
	var _react = __webpack_require__(8);
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	var InternalPropTypes = _interopRequireWildcard(_InternalPropTypes);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireWildcard(obj) {
	  if (obj && obj.__esModule) {
	    return obj;
	  } else {
	    var newObj = {};if (obj != null) {
	      for (var key in obj) {
	        if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key];
	      }
	    }newObj.default = obj;return newObj;
	  }
	}
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	var routerShape = exports.routerShape = shape({
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired,
	  setRouteLeaveHook: func.isRequired,
	  isActive: func.isRequired
	});
	
	var locationShape = exports.locationShape = shape({
	  pathname: string.isRequired,
	  search: string.isRequired,
	  state: object,
	  action: string.isRequired,
	  key: string
	});
	
	// Deprecated stuff below:
	
	var falsy = exports.falsy = InternalPropTypes.falsy;
	var history = exports.history = InternalPropTypes.history;
	var location = exports.location = locationShape;
	var component = exports.component = InternalPropTypes.component;
	var components = exports.components = InternalPropTypes.components;
	var route = exports.route = InternalPropTypes.route;
	var routes = exports.routes = InternalPropTypes.routes;
	var router = exports.router = routerShape;
	
	if (process.env.NODE_ENV !== 'production') {
	  (function () {
	    var deprecatePropType = function deprecatePropType(propType, message) {
	      return function () {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	        return propType.apply(undefined, arguments);
	      };
	    };
	
	    var deprecateInternalPropType = function deprecateInternalPropType(propType) {
	      return deprecatePropType(propType, 'This prop type is not intended for external use, and was previously exported by mistake. These internal prop types are deprecated for external use, and will be removed in a later version.');
	    };
	
	    var deprecateRenamedPropType = function deprecateRenamedPropType(propType, name) {
	      return deprecatePropType(propType, 'The `' + name + '` prop type is now exported as `' + name + 'Shape` to avoid name conflicts. This export is deprecated and will be removed in a later version.');
	    };
	
	    exports.falsy = falsy = deprecateInternalPropType(falsy);
	    exports.history = history = deprecateInternalPropType(history);
	    exports.component = component = deprecateInternalPropType(component);
	    exports.components = components = deprecateInternalPropType(components);
	    exports.route = route = deprecateInternalPropType(route);
	    exports.routes = routes = deprecateInternalPropType(routes);
	
	    exports.location = location = deprecateRenamedPropType(location, 'location');
	    exports.router = router = deprecateRenamedPropType(router, 'router');
	  })();
	}
	
	var defaultExport = {
	  falsy: falsy,
	  history: history,
	  location: location,
	  component: component,
	  components: components,
	  route: route,
	  // For some reason, routes was never here.
	  router: router
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  defaultExport = (0, _deprecateObjectProperties2.default)(defaultExport, 'The default export from `react-router/lib/PropTypes` is deprecated. Please use the named exports instead.');
	}
	
	exports.default = defaultExport;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.canUseMembrane = undefined;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseMembrane = exports.canUseMembrane = false;
	
	// No-op by default.
	var deprecateObjectProperties = function deprecateObjectProperties(object) {
	  return object;
	};
	
	if (process.env.NODE_ENV !== 'production') {
	  try {
	    if (Object.defineProperty({}, 'x', {
	      get: function get() {
	        return true;
	      }
	    }).x) {
	      exports.canUseMembrane = canUseMembrane = true;
	    }
	    /* eslint-disable no-empty */
	  } catch (e) {}
	  /* eslint-enable no-empty */
	
	  if (canUseMembrane) {
	    deprecateObjectProperties = function deprecateObjectProperties(object, message) {
	      // Wrap the deprecated object in a membrane to warn on property access.
	      var membrane = {};
	
	      var _loop = function _loop(prop) {
	        if (!Object.prototype.hasOwnProperty.call(object, prop)) {
	          return 'continue';
	        }
	
	        if (typeof object[prop] === 'function') {
	          // Can't use fat arrow here because of use of arguments below.
	          membrane[prop] = function () {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop].apply(object, arguments);
	          };
	          return 'continue';
	        }
	
	        // These properties are non-enumerable to prevent React dev tools from
	        // seeing them and causing spurious warnings when accessing them. In
	        // principle this could be done with a proxy, but support for the
	        // ownKeys trap on proxies is not universal, even among browsers that
	        // otherwise support proxies.
	        Object.defineProperty(membrane, prop, {
	          get: function get() {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, message) : void 0;
	            return object[prop];
	          }
	        });
	      };
	
	      for (var prop in object) {
	        var _ret = _loop(prop);
	
	        if (_ret === 'continue') continue;
	      }
	
	      return membrane;
	    };
	  }
	}
	
	exports.default = deprecateObjectProperties;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = routerWarning;
	exports._resetWarned = _resetWarned;
	
	var _warning = __webpack_require__(171);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var warned = {};
	
	function routerWarning(falseToWarn, message) {
	  // Only issue deprecation warnings once.
	  if (message.indexOf('deprecated') !== -1) {
	    if (warned[message]) {
	      return;
	    }
	
	    warned[message] = true;
	  }
	
	  message = '[react-router] ' + message;
	
	  for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
	    args[_key - 2] = arguments[_key];
	  }
	
	  _warning2.default.apply(undefined, [falseToWarn, message].concat(args));
	}
	
	function _resetWarned() {
	  warned = {};
	}

/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.routes = exports.route = exports.components = exports.component = exports.history = undefined;
	exports.falsy = falsy;
	
	var _react = __webpack_require__(8);
	
	var func = _react.PropTypes.func;
	var object = _react.PropTypes.object;
	var arrayOf = _react.PropTypes.arrayOf;
	var oneOfType = _react.PropTypes.oneOfType;
	var element = _react.PropTypes.element;
	var shape = _react.PropTypes.shape;
	var string = _react.PropTypes.string;
	function falsy(props, propName, componentName) {
	  if (props[propName]) return new Error('<' + componentName + '> should not have a "' + propName + '" prop');
	}
	
	var history = exports.history = shape({
	  listen: func.isRequired,
	  push: func.isRequired,
	  replace: func.isRequired,
	  go: func.isRequired,
	  goBack: func.isRequired,
	  goForward: func.isRequired
	});
	
	var component = exports.component = oneOfType([func, string]);
	var components = exports.components = oneOfType([component, object]);
	var route = exports.route = oneOfType([object, element]);
	var routes = exports.routes = oneOfType([route, arrayOf(route)]);

/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.compilePattern = compilePattern;
	exports.matchPattern = matchPattern;
	exports.getParamNames = getParamNames;
	exports.getParams = getParams;
	exports.formatPattern = formatPattern;
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function escapeRegExp(string) {
	  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
	}
	
	function _compilePattern(pattern) {
	  var regexpSource = '';
	  var paramNames = [];
	  var tokens = [];
	
	  var match = void 0,
	      lastIndex = 0,
	      matcher = /:([a-zA-Z_$][a-zA-Z0-9_$]*)|\*\*|\*|\(|\)/g;
	  while (match = matcher.exec(pattern)) {
	    if (match.index !== lastIndex) {
	      tokens.push(pattern.slice(lastIndex, match.index));
	      regexpSource += escapeRegExp(pattern.slice(lastIndex, match.index));
	    }
	
	    if (match[1]) {
	      regexpSource += '([^/]+)';
	      paramNames.push(match[1]);
	    } else if (match[0] === '**') {
	      regexpSource += '(.*)';
	      paramNames.push('splat');
	    } else if (match[0] === '*') {
	      regexpSource += '(.*?)';
	      paramNames.push('splat');
	    } else if (match[0] === '(') {
	      regexpSource += '(?:';
	    } else if (match[0] === ')') {
	      regexpSource += ')?';
	    }
	
	    tokens.push(match[0]);
	
	    lastIndex = matcher.lastIndex;
	  }
	
	  if (lastIndex !== pattern.length) {
	    tokens.push(pattern.slice(lastIndex, pattern.length));
	    regexpSource += escapeRegExp(pattern.slice(lastIndex, pattern.length));
	  }
	
	  return {
	    pattern: pattern,
	    regexpSource: regexpSource,
	    paramNames: paramNames,
	    tokens: tokens
	  };
	}
	
	var CompiledPatternsCache = Object.create(null);
	
	function compilePattern(pattern) {
	  if (!CompiledPatternsCache[pattern]) CompiledPatternsCache[pattern] = _compilePattern(pattern);
	
	  return CompiledPatternsCache[pattern];
	}
	
	/**
	 * Attempts to match a pattern on the given pathname. Patterns may use
	 * the following special characters:
	 *
	 * - :paramName     Matches a URL segment up to the next /, ?, or #. The
	 *                  captured string is considered a "param"
	 * - ()             Wraps a segment of the URL that is optional
	 * - *              Consumes (non-greedy) all characters up to the next
	 *                  character in the pattern, or to the end of the URL if
	 *                  there is none
	 * - **             Consumes (greedy) all characters up to the next character
	 *                  in the pattern, or to the end of the URL if there is none
	 *
	 *  The function calls callback(error, matched) when finished.
	 * The return value is an object with the following properties:
	 *
	 * - remainingPathname
	 * - paramNames
	 * - paramValues
	 */
	function matchPattern(pattern, pathname) {
	  // Ensure pattern starts with leading slash for consistency with pathname.
	  if (pattern.charAt(0) !== '/') {
	    pattern = '/' + pattern;
	  }
	
	  var _compilePattern2 = compilePattern(pattern);
	
	  var regexpSource = _compilePattern2.regexpSource;
	  var paramNames = _compilePattern2.paramNames;
	  var tokens = _compilePattern2.tokens;
	
	  if (pattern.charAt(pattern.length - 1) !== '/') {
	    regexpSource += '/?'; // Allow optional path separator at end.
	  }
	
	  // Special-case patterns like '*' for catch-all routes.
	  if (tokens[tokens.length - 1] === '*') {
	    regexpSource += '$';
	  }
	
	  var match = pathname.match(new RegExp('^' + regexpSource, 'i'));
	  if (match == null) {
	    return null;
	  }
	
	  var matchedPath = match[0];
	  var remainingPathname = pathname.substr(matchedPath.length);
	
	  if (remainingPathname) {
	    // Require that the match ends at a path separator, if we didn't match
	    // the full path, so any remaining pathname is a new path segment.
	    if (matchedPath.charAt(matchedPath.length - 1) !== '/') {
	      return null;
	    }
	
	    // If there is a remaining pathname, treat the path separator as part of
	    // the remaining pathname for properly continuing the match.
	    remainingPathname = '/' + remainingPathname;
	  }
	
	  return {
	    remainingPathname: remainingPathname,
	    paramNames: paramNames,
	    paramValues: match.slice(1).map(function (v) {
	      return v && decodeURIComponent(v);
	    })
	  };
	}
	
	function getParamNames(pattern) {
	  return compilePattern(pattern).paramNames;
	}
	
	function getParams(pattern, pathname) {
	  var match = matchPattern(pattern, pathname);
	  if (!match) {
	    return null;
	  }
	
	  var paramNames = match.paramNames;
	  var paramValues = match.paramValues;
	
	  var params = {};
	
	  paramNames.forEach(function (paramName, index) {
	    params[paramName] = paramValues[index];
	  });
	
	  return params;
	}
	
	/**
	 * Returns a version of the given pattern with params interpolated. Throws
	 * if there is a dynamic segment of the pattern for which there is no param.
	 */
	function formatPattern(pattern, params) {
	  params = params || {};
	
	  var _compilePattern3 = compilePattern(pattern);
	
	  var tokens = _compilePattern3.tokens;
	
	  var parenCount = 0,
	      pathname = '',
	      splatIndex = 0;
	
	  var token = void 0,
	      paramName = void 0,
	      paramValue = void 0;
	  for (var i = 0, len = tokens.length; i < len; ++i) {
	    token = tokens[i];
	
	    if (token === '*' || token === '**') {
	      paramValue = Array.isArray(params.splat) ? params.splat[splatIndex++] : params.splat;
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing splat #%s for path "%s"', splatIndex, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURI(paramValue);
	    } else if (token === '(') {
	      parenCount += 1;
	    } else if (token === ')') {
	      parenCount -= 1;
	    } else if (token.charAt(0) === ':') {
	      paramName = token.substring(1);
	      paramValue = params[paramName];
	
	      !(paramValue != null || parenCount > 0) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'Missing "%s" parameter for path "%s"', paramName, pattern) : (0, _invariant2.default)(false) : void 0;
	
	      if (paramValue != null) pathname += encodeURIComponent(paramValue);
	    } else {
	      pathname += token;
	    }
	  }
	
	  return pathname.replace(/\/+/g, '/');
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2013-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Use invariant() to assert state which your program assumes to be true.
	 *
	 * Provide sprintf-style format (only %s is supported) and arguments
	 * to provide information about what broke and what you were
	 * expecting.
	 *
	 * The invariant message will be stripped in production, but the invariant
	 * will remain to ensure logic does not differ in production.
	 */
	
	var invariant = function invariant(condition, format, a, b, c, d, e, f) {
	  if (process.env.NODE_ENV !== 'production') {
	    if (format === undefined) {
	      throw new Error('invariant requires an error message argument');
	    }
	  }
	
	  if (!condition) {
	    var error;
	    if (format === undefined) {
	      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
	    } else {
	      var args = [a, b, c, d, e, f];
	      var argIndex = 0;
	      error = new Error(format.replace(/%s/g, function () {
	        return args[argIndex++];
	      }));
	      error.name = 'Invariant Violation';
	    }
	
	    error.framesToPop = 1; // we don't care about invariant's own frame
	    throw error;
	  }
	};
	
	module.exports = invariant;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _createHashHistory = __webpack_require__(176);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _RouterUtils = __webpack_require__(205);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	function isDeprecatedHistory(history) {
	  return !history || !history.__v2_compatible__;
	}
	
	/* istanbul ignore next: sanity check */
	function isUnsupportedHistory(history) {
	  // v3 histories expose getCurrentLocation, but aren't currently supported.
	  return history && history.getCurrentLocation;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Router> is a high-level API for automatically setting up
	 * a router that renders a <RouterContext> with all the props
	 * it needs each time the URL changes.
	 */
	
	var Router = _react2.default.createClass({
	  displayName: 'Router',
	
	  propTypes: {
	    history: object,
	    children: _InternalPropTypes.routes,
	    routes: _InternalPropTypes.routes, // alias for children
	    render: func,
	    createElement: func,
	    onError: func,
	    onUpdate: func,
	
	    // Deprecated:
	    parseQueryString: func,
	    stringifyQuery: func,
	
	    // PRIVATE: For client-side rehydration of server match.
	    matchContext: object
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      render: function render(props) {
	        return _react2.default.createElement(_RouterContext2.default, props);
	      }
	    };
	  },
	  getInitialState: function getInitialState() {
	    return {
	      location: null,
	      routes: null,
	      params: null,
	      components: null
	    };
	  },
	  handleError: function handleError(error) {
	    if (this.props.onError) {
	      this.props.onError.call(this, error);
	    } else {
	      // Throw errors by default so we don't silently swallow them!
	      throw error; // This error probably occurred in getChildRoutes or getComponents.
	    }
	  },
	  componentWillMount: function componentWillMount() {
	    var _this = this;
	
	    var _props = this.props;
	    var parseQueryString = _props.parseQueryString;
	    var stringifyQuery = _props.stringifyQuery;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(parseQueryString || stringifyQuery), '`parseQueryString` and `stringifyQuery` are deprecated. Please create a custom history. http://tiny.cc/router-customquerystring') : void 0;
	
	    var _createRouterObjects = this.createRouterObjects();
	
	    var history = _createRouterObjects.history;
	    var transitionManager = _createRouterObjects.transitionManager;
	    var router = _createRouterObjects.router;
	
	    this._unlisten = transitionManager.listen(function (error, state) {
	      if (error) {
	        _this.handleError(error);
	      } else {
	        _this.setState(state, _this.props.onUpdate);
	      }
	    });
	
	    this.history = history;
	    this.router = router;
	  },
	  createRouterObjects: function createRouterObjects() {
	    var matchContext = this.props.matchContext;
	
	    if (matchContext) {
	      return matchContext;
	    }
	
	    var history = this.props.history;
	    var _props2 = this.props;
	    var routes = _props2.routes;
	    var children = _props2.children;
	
	    !!isUnsupportedHistory(history) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'You have provided a history object created with history v3.x. ' + 'This version of React Router is not compatible with v3 history ' + 'objects. Please use history v2.x instead.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isDeprecatedHistory(history)) {
	      history = this.wrapDeprecatedHistory(history);
	    }
	
	    var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes || children));
	    var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	    var routingHistory = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	    return { history: routingHistory, transitionManager: transitionManager, router: router };
	  },
	  wrapDeprecatedHistory: function wrapDeprecatedHistory(history) {
	    var _props3 = this.props;
	    var parseQueryString = _props3.parseQueryString;
	    var stringifyQuery = _props3.stringifyQuery;
	
	    var createHistory = void 0;
	    if (history) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'It appears you have provided a deprecated history object to `<Router/>`, please use a history provided by ' + 'React Router with `import { browserHistory } from \'react-router\'` or `import { hashHistory } from \'react-router\'`. ' + 'If you are using a custom history please create it with `useRouterHistory`, see http://tiny.cc/router-usinghistory for details.') : void 0;
	      createHistory = function createHistory() {
	        return history;
	      };
	    } else {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`Router` no longer defaults the history prop to hash history. Please use the `hashHistory` singleton instead. http://tiny.cc/router-defaulthistory') : void 0;
	      createHistory = _createHashHistory2.default;
	    }
	
	    return (0, _useQueries2.default)(createHistory)({ parseQueryString: parseQueryString, stringifyQuery: stringifyQuery });
	  },
	
	  /* istanbul ignore next: sanity check */
	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(nextProps.history === this.props.history, 'You cannot change <Router history>; it will be ignored') : void 0;
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)((nextProps.routes || nextProps.children) === (this.props.routes || this.props.children), 'You cannot change <Router routes>; it will be ignored') : void 0;
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlisten) this._unlisten();
	  },
	  render: function render() {
	    var _state = this.state;
	    var location = _state.location;
	    var routes = _state.routes;
	    var params = _state.params;
	    var components = _state.components;
	    var _props4 = this.props;
	    var createElement = _props4.createElement;
	    var render = _props4.render;
	
	    var props = _objectWithoutProperties(_props4, ['createElement', 'render']);
	
	    if (location == null) return null; // Async match
	
	    // Only forward non-Router-specific props to routing context, as those are
	    // the only ones that might be custom routing context props.
	    Object.keys(Router.propTypes).forEach(function (propType) {
	      return delete props[propType];
	    });
	
	    return render(_extends({}, props, {
	      history: this.history,
	      router: this.router,
	      location: location,
	      routes: routes,
	      params: params,
	      components: components,
	      createElement: createElement
	    }));
	  }
	});
	
	exports.default = Router;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _DOMStateStorage = __webpack_require__(182);
	
	var _createDOMHistory = __webpack_require__(183);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	function isAbsolutePath(path) {
	  return typeof path === 'string' && path.charAt(0) === '/';
	}
	
	function ensureSlash() {
	  var path = _DOMUtils.getHashPath();
	
	  if (isAbsolutePath(path)) return true;
	
	  _DOMUtils.replaceHashPath('/' + path);
	
	  return false;
	}
	
	function addQueryStringValueToPath(path, key, value) {
	  return path + (path.indexOf('?') === -1 ? '?' : '&') + (key + '=' + value);
	}
	
	function stripQueryStringValueFromPath(path, key) {
	  return path.replace(new RegExp('[?&]?' + key + '=[a-zA-Z0-9]+'), '');
	}
	
	function getQueryStringValueFromPath(path, key) {
	  var match = path.match(new RegExp('\\?.*?\\b' + key + '=(.+?)\\b'));
	  return match && match[1];
	}
	
	var DefaultQueryKey = '_k';
	
	function createHashHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Hash history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var queryKey = options.queryKey;
	
	  if (queryKey === undefined || !!queryKey) queryKey = typeof queryKey === 'string' ? queryKey : DefaultQueryKey;
	
	  function getCurrentLocation() {
	    var path = _DOMUtils.getHashPath();
	
	    var key = undefined,
	        state = undefined;
	    if (queryKey) {
	      key = getQueryStringValueFromPath(path, queryKey);
	      path = stripQueryStringValueFromPath(path, queryKey);
	
	      if (key) {
	        state = _DOMStateStorage.readState(key);
	      } else {
	        state = null;
	        key = history.createKey();
	        _DOMUtils.replaceHashPath(addQueryStringValueToPath(path, queryKey, key));
	      }
	    } else {
	      key = state = null;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startHashChangeListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function hashChangeListener() {
	      if (!ensureSlash()) return; // Always make sure hashes are preceeded with a /.
	
	      transitionTo(getCurrentLocation());
	    }
	
	    ensureSlash();
	    _DOMUtils.addEventListener(window, 'hashchange', hashChangeListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'hashchange', hashChangeListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    var path = (basename || '') + pathname + search;
	
	    if (queryKey) {
	      path = addQueryStringValueToPath(path, queryKey, key);
	      _DOMStateStorage.saveState(key, state);
	    } else {
	      // Drop key and state.
	      location.key = location.state = null;
	    }
	
	    var currentHash = _DOMUtils.getHashPath();
	
	    if (action === _Actions.PUSH) {
	      if (currentHash !== path) {
	        window.location.hash = path;
	      } else {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'You cannot PUSH the same path using hash history') : undefined;
	      }
	    } else if (currentHash !== path) {
	      // REPLACE
	      _DOMUtils.replaceHashPath(path);
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopHashChangeListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopHashChangeListener();
	    };
	  }
	
	  function push(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.push(location);
	  }
	
	  function replace(location) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || location.state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replace(location);
	  }
	
	  var goIsSupportedWithoutReload = _DOMUtils.supportsGoWithoutReloadUsingHash();
	
	  function go(n) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](goIsSupportedWithoutReload, 'Hash history go(n) causes a full page reload in this browser') : undefined;
	
	    history.go(n);
	  }
	
	  function createHref(path) {
	    return '#' + history.createHref(path);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopHashChangeListener = startHashChangeListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopHashChangeListener();
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.pushState(state, path);
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](queryKey || state == null, 'You cannot use state without a queryKey it will be dropped') : undefined;
	
	    history.replaceState(state, path);
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    push: push,
	    replace: replace,
	    go: go,
	    createHref: createHref,
	
	    registerTransitionHook: registerTransitionHook, // deprecated - warning is in createHistory
	    unregisterTransitionHook: unregisterTransitionHook, // deprecated - warning is in createHistory
	    pushState: pushState, // deprecated - warning is in createHistory
	    replaceState: replaceState // deprecated - warning is in createHistory
	  });
	}
	
	exports['default'] = createHashHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/**
	 * Copyright 2014-2015, Facebook, Inc.
	 * All rights reserved.
	 *
	 * This source code is licensed under the BSD-style license found in the
	 * LICENSE file in the root directory of this source tree. An additional grant
	 * of patent rights can be found in the PATENTS file in the same directory.
	 */
	
	'use strict';
	
	/**
	 * Similar to invariant but only logs a warning if the condition is not met.
	 * This can be used to log issues in development environments in critical
	 * paths. Removing the logging code for production environments will keep the
	 * same logic and follow the same code paths.
	 */
	
	var warning = function warning() {};
	
	if (process.env.NODE_ENV !== 'production') {
	  warning = function warning(condition, format, args) {
	    var len = arguments.length;
	    args = new Array(len > 2 ? len - 2 : 0);
	    for (var key = 2; key < len; key++) {
	      args[key - 2] = arguments[key];
	    }
	    if (format === undefined) {
	      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
	    }
	
	    if (format.length < 10 || /^[s\W]*$/.test(format)) {
	      throw new Error('The warning format should be able to uniquely identify this ' + 'warning. Please, use a more descriptive format than: ' + format);
	    }
	
	    if (!condition) {
	      var argIndex = 0;
	      var message = 'Warning: ' + format.replace(/%s/g, function () {
	        return args[argIndex++];
	      });
	      if (typeof console !== 'undefined') {
	        console.error(message);
	      }
	      try {
	        // This error was thrown as a convenience so that you can use this stack
	        // to find the callsite that caused this warning to fire.
	        throw new Error(message);
	      } catch (x) {}
	    }
	  };
	}
	
	module.exports = warning;
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 178 */
/***/ function(module, exports) {

	/**
	 * Indicates that navigation was caused by a call to history.push.
	 */
	'use strict';
	
	exports.__esModule = true;
	var PUSH = 'PUSH';
	
	exports.PUSH = PUSH;
	/**
	 * Indicates that navigation was caused by a call to history.replace.
	 */
	var REPLACE = 'REPLACE';
	
	exports.REPLACE = REPLACE;
	/**
	 * Indicates that navigation was caused by some other action such
	 * as using a browser's back/forward buttons and/or manually manipulating
	 * the URL in a browser's location bar. This is the default.
	 *
	 * See https://developer.mozilla.org/en-US/docs/Web/API/WindowEventHandlers/onpopstate
	 * for more information.
	 */
	var POP = 'POP';
	
	exports.POP = POP;
	exports['default'] = {
	  PUSH: PUSH,
	  REPLACE: REPLACE,
	  POP: POP
	};

/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.extractPath = extractPath;
	exports.parsePath = parsePath;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function extractPath(string) {
	  var match = string.match(/^https?:\/\/[^\/]*/);
	
	  if (match == null) return string;
	
	  return string.substring(match[0].length);
	}
	
	function parsePath(path) {
	  var pathname = extractPath(path);
	  var search = '';
	  var hash = '';
	
	  process.env.NODE_ENV !== 'production' ? _warning2['default'](path === pathname, 'A path must be pathname + search + hash only, not a fully qualified URL like "%s"', path) : undefined;
	
	  var hashIndex = pathname.indexOf('#');
	  if (hashIndex !== -1) {
	    hash = pathname.substring(hashIndex);
	    pathname = pathname.substring(0, hashIndex);
	  }
	
	  var searchIndex = pathname.indexOf('?');
	  if (searchIndex !== -1) {
	    search = pathname.substring(searchIndex);
	    pathname = pathname.substring(0, searchIndex);
	  }
	
	  if (pathname === '') pathname = '/';
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash
	  };
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 180 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	exports.canUseDOM = canUseDOM;

/***/ },
/* 181 */
/***/ function(module, exports) {

	'use strict';
	
	exports.__esModule = true;
	exports.addEventListener = addEventListener;
	exports.removeEventListener = removeEventListener;
	exports.getHashPath = getHashPath;
	exports.replaceHashPath = replaceHashPath;
	exports.getWindowPath = getWindowPath;
	exports.go = go;
	exports.getUserConfirmation = getUserConfirmation;
	exports.supportsHistory = supportsHistory;
	exports.supportsGoWithoutReloadUsingHash = supportsGoWithoutReloadUsingHash;
	
	function addEventListener(node, event, listener) {
	  if (node.addEventListener) {
	    node.addEventListener(event, listener, false);
	  } else {
	    node.attachEvent('on' + event, listener);
	  }
	}
	
	function removeEventListener(node, event, listener) {
	  if (node.removeEventListener) {
	    node.removeEventListener(event, listener, false);
	  } else {
	    node.detachEvent('on' + event, listener);
	  }
	}
	
	function getHashPath() {
	  // We can't use window.location.hash here because it's not
	  // consistent across browsers - Firefox will pre-decode it!
	  return window.location.href.split('#')[1] || '';
	}
	
	function replaceHashPath(path) {
	  window.location.replace(window.location.pathname + window.location.search + '#' + path);
	}
	
	function getWindowPath() {
	  return window.location.pathname + window.location.search + window.location.hash;
	}
	
	function go(n) {
	  if (n) window.history.go(n);
	}
	
	function getUserConfirmation(message, callback) {
	  callback(window.confirm(message));
	}
	
	/**
	 * Returns true if the HTML5 history API is supported. Taken from Modernizr.
	 *
	 * https://github.com/Modernizr/Modernizr/blob/master/LICENSE
	 * https://github.com/Modernizr/Modernizr/blob/master/feature-detects/history.js
	 * changed to avoid false negatives for Windows Phones: https://github.com/rackt/react-router/issues/586
	 */
	
	function supportsHistory() {
	  var ua = navigator.userAgent;
	  if ((ua.indexOf('Android 2.') !== -1 || ua.indexOf('Android 4.0') !== -1) && ua.indexOf('Mobile Safari') !== -1 && ua.indexOf('Chrome') === -1 && ua.indexOf('Windows Phone') === -1) {
	    return false;
	  }
	  return window.history && 'pushState' in window.history;
	}
	
	/**
	 * Returns false if using go(n) with hash history causes a full page reload.
	 */
	
	function supportsGoWithoutReloadUsingHash() {
	  var ua = navigator.userAgent;
	  return ua.indexOf('Firefox') === -1;
	}

/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {/*eslint-disable no-empty */
	'use strict';
	
	exports.__esModule = true;
	exports.saveState = saveState;
	exports.readState = readState;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var KeyPrefix = '@@History/';
	var QuotaExceededErrors = ['QuotaExceededError', 'QUOTA_EXCEEDED_ERR'];
	
	var SecurityError = 'SecurityError';
	
	function createKey(key) {
	  return KeyPrefix + key;
	}
	
	function saveState(key, state) {
	  try {
	    if (state == null) {
	      window.sessionStorage.removeItem(createKey(key));
	    } else {
	      window.sessionStorage.setItem(createKey(key), JSON.stringify(state));
	    }
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available due to security settings') : undefined;
	
	      return;
	    }
	
	    if (QuotaExceededErrors.indexOf(error.name) >= 0 && window.sessionStorage.length === 0) {
	      // Safari "private mode" throws QuotaExceededError.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to save state; sessionStorage is not available in Safari private mode') : undefined;
	
	      return;
	    }
	
	    throw error;
	  }
	}
	
	function readState(key) {
	  var json = undefined;
	  try {
	    json = window.sessionStorage.getItem(createKey(key));
	  } catch (error) {
	    if (error.name === SecurityError) {
	      // Blocking cookies in Chrome/Firefox/Safari throws SecurityError on any
	      // attempt to access window.sessionStorage.
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] Unable to read state; sessionStorage is not available due to security settings') : undefined;
	
	      return null;
	    }
	  }
	
	  if (json) {
	    try {
	      return JSON.parse(json);
	    } catch (error) {
	      // Ignore invalid JSON.
	    }
	  }
	
	  return null;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _createHistory = __webpack_require__(184);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createDOMHistory(options) {
	  var history = _createHistory2['default'](_extends({
	    getUserConfirmation: _DOMUtils.getUserConfirmation
	  }, options, {
	    go: _DOMUtils.go
	  }));
	
	  function listen(listener) {
	    !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'DOM history needs a DOM') : _invariant2['default'](false) : undefined;
	
	    return history.listen(listener);
	  }
	
	  return _extends({}, history, {
	    listen: listen
	  });
	}
	
	exports['default'] = createDOMHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _deepEqual = __webpack_require__(185);
	
	var _deepEqual2 = _interopRequireDefault(_deepEqual);
	
	var _PathUtils = __webpack_require__(179);
	
	var _AsyncUtils = __webpack_require__(188);
	
	var _Actions = __webpack_require__(178);
	
	var _createLocation2 = __webpack_require__(189);
	
	var _createLocation3 = _interopRequireDefault(_createLocation2);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function createRandomKey(length) {
	  return Math.random().toString(36).substr(2, length);
	}
	
	function locationsAreEqual(a, b) {
	  return a.pathname === b.pathname && a.search === b.search &&
	  //a.action === b.action && // Different action !== location change.
	  a.key === b.key && _deepEqual2['default'](a.state, b.state);
	}
	
	var DefaultKeyLength = 6;
	
	function createHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	  var getCurrentLocation = options.getCurrentLocation;
	  var finishTransition = options.finishTransition;
	  var saveState = options.saveState;
	  var go = options.go;
	  var getUserConfirmation = options.getUserConfirmation;
	  var keyLength = options.keyLength;
	
	  if (typeof keyLength !== 'number') keyLength = DefaultKeyLength;
	
	  var transitionHooks = [];
	
	  function listenBefore(hook) {
	    transitionHooks.push(hook);
	
	    return function () {
	      transitionHooks = transitionHooks.filter(function (item) {
	        return item !== hook;
	      });
	    };
	  }
	
	  var allKeys = [];
	  var changeListeners = [];
	  var location = undefined;
	
	  function getCurrent() {
	    if (pendingLocation && pendingLocation.action === _Actions.POP) {
	      return allKeys.indexOf(pendingLocation.key);
	    } else if (location) {
	      return allKeys.indexOf(location.key);
	    } else {
	      return -1;
	    }
	  }
	
	  function updateLocation(newLocation) {
	    var current = getCurrent();
	
	    location = newLocation;
	
	    if (location.action === _Actions.PUSH) {
	      allKeys = [].concat(allKeys.slice(0, current + 1), [location.key]);
	    } else if (location.action === _Actions.REPLACE) {
	      allKeys[current] = location.key;
	    }
	
	    changeListeners.forEach(function (listener) {
	      listener(location);
	    });
	  }
	
	  function listen(listener) {
	    changeListeners.push(listener);
	
	    if (location) {
	      listener(location);
	    } else {
	      var _location = getCurrentLocation();
	      allKeys = [_location.key];
	      updateLocation(_location);
	    }
	
	    return function () {
	      changeListeners = changeListeners.filter(function (item) {
	        return item !== listener;
	      });
	    };
	  }
	
	  function confirmTransitionTo(location, callback) {
	    _AsyncUtils.loopAsync(transitionHooks.length, function (index, next, done) {
	      _runTransitionHook2['default'](transitionHooks[index], location, function (result) {
	        if (result != null) {
	          done(result);
	        } else {
	          next();
	        }
	      });
	    }, function (message) {
	      if (getUserConfirmation && typeof message === 'string') {
	        getUserConfirmation(message, function (ok) {
	          callback(ok !== false);
	        });
	      } else {
	        callback(message !== false);
	      }
	    });
	  }
	
	  var pendingLocation = undefined;
	
	  function transitionTo(nextLocation) {
	    if (location && locationsAreEqual(location, nextLocation)) return; // Nothing to do.
	
	    pendingLocation = nextLocation;
	
	    confirmTransitionTo(nextLocation, function (ok) {
	      if (pendingLocation !== nextLocation) return; // Transition was interrupted.
	
	      if (ok) {
	        // treat PUSH to current path like REPLACE to be consistent with browsers
	        if (nextLocation.action === _Actions.PUSH) {
	          var prevPath = createPath(location);
	          var nextPath = createPath(nextLocation);
	
	          if (nextPath === prevPath && _deepEqual2['default'](location.state, nextLocation.state)) nextLocation.action = _Actions.REPLACE;
	        }
	
	        if (finishTransition(nextLocation) !== false) updateLocation(nextLocation);
	      } else if (location && nextLocation.action === _Actions.POP) {
	        var prevIndex = allKeys.indexOf(location.key);
	        var nextIndex = allKeys.indexOf(nextLocation.key);
	
	        if (prevIndex !== -1 && nextIndex !== -1) go(prevIndex - nextIndex); // Restore the URL.
	      }
	    });
	  }
	
	  function push(location) {
	    transitionTo(createLocation(location, _Actions.PUSH, createKey()));
	  }
	
	  function replace(location) {
	    transitionTo(createLocation(location, _Actions.REPLACE, createKey()));
	  }
	
	  function goBack() {
	    go(-1);
	  }
	
	  function goForward() {
	    go(1);
	  }
	
	  function createKey() {
	    return createRandomKey(keyLength);
	  }
	
	  function createPath(location) {
	    if (location == null || typeof location === 'string') return location;
	
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	
	    var result = pathname;
	
	    if (search) result += search;
	
	    if (hash) result += hash;
	
	    return result;
	  }
	
	  function createHref(location) {
	    return createPath(location);
	  }
	
	  function createLocation(location, action) {
	    var key = arguments.length <= 2 || arguments[2] === undefined ? createKey() : arguments[2];
	
	    if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to history.createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      location = _extends({}, location, { state: action });
	
	      action = key;
	      key = arguments[3] || createKey();
	    }
	
	    return _createLocation3['default'](location, action, key);
	  }
	
	  // deprecated
	  function setState(state) {
	    if (location) {
	      updateLocationState(location, state);
	      updateLocation(location);
	    } else {
	      updateLocationState(getCurrentLocation(), state);
	    }
	  }
	
	  function updateLocationState(location, state) {
	    location.state = _extends({}, location.state, state);
	    saveState(location.key, location.state);
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (transitionHooks.indexOf(hook) === -1) transitionHooks.push(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    transitionHooks = transitionHooks.filter(function (item) {
	      return item !== hook;
	    });
	  }
	
	  // deprecated
	  function pushState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    push(_extends({ state: state }, path));
	  }
	
	  // deprecated
	  function replaceState(state, path) {
	    if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	    replace(_extends({ state: state }, path));
	  }
	
	  return {
	    listenBefore: listenBefore,
	    listen: listen,
	    transitionTo: transitionTo,
	    push: push,
	    replace: replace,
	    go: go,
	    goBack: goBack,
	    goForward: goForward,
	    createKey: createKey,
	    createPath: createPath,
	    createHref: createHref,
	    createLocation: createLocation,
	
	    setState: _deprecate2['default'](setState, 'setState is deprecated; use location.key to save state instead'),
	    registerTransitionHook: _deprecate2['default'](registerTransitionHook, 'registerTransitionHook is deprecated; use listenBefore instead'),
	    unregisterTransitionHook: _deprecate2['default'](unregisterTransitionHook, 'unregisterTransitionHook is deprecated; use the callback returned from listenBefore instead'),
	    pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	    replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	  };
	}
	
	exports['default'] = createHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var pSlice = Array.prototype.slice;
	var objectKeys = __webpack_require__(186);
	var isArguments = __webpack_require__(187);
	
	var deepEqual = module.exports = function (actual, expected, opts) {
	  if (!opts) opts = {};
	  // 7.1. All identical values are equivalent, as determined by ===.
	  if (actual === expected) {
	    return true;
	  } else if (actual instanceof Date && expected instanceof Date) {
	    return actual.getTime() === expected.getTime();
	
	    // 7.3. Other pairs that do not both pass typeof value == 'object',
	    // equivalence is determined by ==.
	  } else if (!actual || !expected || (typeof actual === 'undefined' ? 'undefined' : _typeof(actual)) != 'object' && (typeof expected === 'undefined' ? 'undefined' : _typeof(expected)) != 'object') {
	    return opts.strict ? actual === expected : actual == expected;
	
	    // 7.4. For all other Object pairs, including Array objects, equivalence is
	    // determined by having the same number of owned properties (as verified
	    // with Object.prototype.hasOwnProperty.call), the same set of keys
	    // (although not necessarily the same order), equivalent values for every
	    // corresponding key, and an identical 'prototype' property. Note: this
	    // accounts for both named and indexed properties on Arrays.
	  } else {
	    return objEquiv(actual, expected, opts);
	  }
	};
	
	function isUndefinedOrNull(value) {
	  return value === null || value === undefined;
	}
	
	function isBuffer(x) {
	  if (!x || (typeof x === 'undefined' ? 'undefined' : _typeof(x)) !== 'object' || typeof x.length !== 'number') return false;
	  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
	    return false;
	  }
	  if (x.length > 0 && typeof x[0] !== 'number') return false;
	  return true;
	}
	
	function objEquiv(a, b, opts) {
	  var i, key;
	  if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
	  // an identical 'prototype' property.
	  if (a.prototype !== b.prototype) return false;
	  //~~~I've managed to break Object.keys through screwy arguments passing.
	  //   Converting to array solves the problem.
	  if (isArguments(a)) {
	    if (!isArguments(b)) {
	      return false;
	    }
	    a = pSlice.call(a);
	    b = pSlice.call(b);
	    return deepEqual(a, b, opts);
	  }
	  if (isBuffer(a)) {
	    if (!isBuffer(b)) {
	      return false;
	    }
	    if (a.length !== b.length) return false;
	    for (i = 0; i < a.length; i++) {
	      if (a[i] !== b[i]) return false;
	    }
	    return true;
	  }
	  try {
	    var ka = objectKeys(a),
	        kb = objectKeys(b);
	  } catch (e) {
	    //happens when one is a string literal and the other isn't
	    return false;
	  }
	  // having the same number of owned properties (keys incorporates
	  // hasOwnProperty)
	  if (ka.length != kb.length) return false;
	  //the same set of keys (although not necessarily the same order),
	  ka.sort();
	  kb.sort();
	  //~~~cheap key test
	  for (i = ka.length - 1; i >= 0; i--) {
	    if (ka[i] != kb[i]) return false;
	  }
	  //equivalent values for every corresponding key, and
	  //~~~possibly expensive deep test
	  for (i = ka.length - 1; i >= 0; i--) {
	    key = ka[i];
	    if (!deepEqual(a[key], b[key], opts)) return false;
	  }
	  return (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === (typeof b === 'undefined' ? 'undefined' : _typeof(b));
	}

/***/ },
/* 186 */
/***/ function(module, exports) {

	'use strict';
	
	exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;
	
	exports.shim = shim;
	function shim(obj) {
	  var keys = [];
	  for (var key in obj) {
	    keys.push(key);
	  }return keys;
	}

/***/ },
/* 187 */
/***/ function(module, exports) {

	'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	var supportsArgumentsClass = function () {
	  return Object.prototype.toString.call(arguments);
	}() == '[object Arguments]';
	
	exports = module.exports = supportsArgumentsClass ? supported : unsupported;
	
	exports.supported = supported;
	function supported(object) {
	  return Object.prototype.toString.call(object) == '[object Arguments]';
	};
	
	exports.unsupported = unsupported;
	function unsupported(object) {
	  return object && (typeof object === 'undefined' ? 'undefined' : _typeof(object)) == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
	};

/***/ },
/* 188 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	var _slice = Array.prototype.slice;
	exports.loopAsync = loopAsync;
	
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = undefined;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(_slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}

/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	function createLocation() {
	  var location = arguments.length <= 0 || arguments[0] === undefined ? '/' : arguments[0];
	  var action = arguments.length <= 1 || arguments[1] === undefined ? _Actions.POP : arguments[1];
	  var key = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	  var _fourthArg = arguments.length <= 3 || arguments[3] === undefined ? null : arguments[3];
	
	  if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	  if ((typeof action === 'undefined' ? 'undefined' : _typeof(action)) === 'object') {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'The state (2nd) argument to createLocation is deprecated; use a ' + 'location descriptor instead') : undefined;
	
	    location = _extends({}, location, { state: action });
	
	    action = key || _Actions.POP;
	    key = _fourthArg;
	  }
	
	  var pathname = location.pathname || '/';
	  var search = location.search || '';
	  var hash = location.hash || '';
	  var state = location.state || null;
	
	  return {
	    pathname: pathname,
	    search: search,
	    hash: hash,
	    state: state,
	    action: action,
	    key: key
	  };
	}
	
	exports['default'] = createLocation;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function runTransitionHook(hook, location, callback) {
	  var result = hook(location, callback);
	
	  if (hook.length < 2) {
	    // Assume the hook runs synchronously and automatically
	    // call the callback with the return value.
	    callback(result);
	  } else {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](result === undefined, 'You should not "return" in a transition hook with a callback argument; call the callback instead') : undefined;
	  }
	}
	
	exports['default'] = runTransitionHook;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	function deprecate(fn, message) {
	  return function () {
	    process.env.NODE_ENV !== 'production' ? _warning2['default'](false, '[history] ' + message) : undefined;
	    return fn.apply(this, arguments);
	  };
	}
	
	exports['default'] = deprecate;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _queryString = __webpack_require__(193);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _PathUtils = __webpack_require__(179);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	var SEARCH_BASE_KEY = '$searchBase';
	
	function defaultStringifyQuery(query) {
	  return _queryString.stringify(query).replace(/%20/g, '+');
	}
	
	var defaultParseQueryString = _queryString.parse;
	
	function isNestedObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p) && _typeof(object[p]) === 'object' && !Array.isArray(object[p]) && object[p] !== null) return true;
	  }return false;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know how to handle URL queries.
	 */
	function useQueries(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var stringifyQuery = options.stringifyQuery;
	    var parseQueryString = options.parseQueryString;
	
	    if (typeof stringifyQuery !== 'function') stringifyQuery = defaultStringifyQuery;
	
	    if (typeof parseQueryString !== 'function') parseQueryString = defaultParseQueryString;
	
	    function addQuery(location) {
	      if (location.query == null) {
	        var search = location.search;
	
	        location.query = parseQueryString(search.substring(1));
	        location[SEARCH_BASE_KEY] = { search: search, searchBase: '' };
	      }
	
	      // TODO: Instead of all the book-keeping here, this should just strip the
	      // stringified query from the search.
	
	      return location;
	    }
	
	    function appendQuery(location, query) {
	      var _extends2;
	
	      var searchBaseSpec = location[SEARCH_BASE_KEY];
	      var queryString = query ? stringifyQuery(query) : '';
	      if (!searchBaseSpec && !queryString) {
	        return location;
	      }
	
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](stringifyQuery !== defaultStringifyQuery || !isNestedObject(query), 'useQueries does not stringify nested query objects by default; ' + 'use a custom stringifyQuery function') : undefined;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var searchBase = undefined;
	      if (searchBaseSpec && location.search === searchBaseSpec.search) {
	        searchBase = searchBaseSpec.searchBase;
	      } else {
	        searchBase = location.search || '';
	      }
	
	      var search = searchBase;
	      if (queryString) {
	        search += (search ? '&' : '?') + queryString;
	      }
	
	      return _extends({}, location, (_extends2 = {
	        search: search
	      }, _extends2[SEARCH_BASE_KEY] = { search: search, searchBase: searchBase }, _extends2));
	    }
	
	    // Override all read methods with query-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addQuery(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addQuery(location));
	      });
	    }
	
	    // Override all write methods with query-aware versions.
	    function push(location) {
	      history.push(appendQuery(location, location.query));
	    }
	
	    function replace(location) {
	      history.replace(appendQuery(location, location.query));
	    }
	
	    function createPath(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createPath is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createPath(appendQuery(location, query || location.query));
	    }
	
	    function createHref(location, query) {
	      process.env.NODE_ENV !== 'production' ? _warning2['default'](!query, 'the query argument to createHref is deprecated; use a location descriptor instead') : undefined;
	
	      return history.createHref(appendQuery(location, query || location.query));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      var fullLocation = history.createLocation.apply(history, [appendQuery(location, location.query)].concat(args));
	      if (location.query) {
	        fullLocation.query = location.query;
	      }
	      return addQuery(fullLocation);
	    }
	
	    // deprecated
	    function pushState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path, { query: query }));
	    }
	
	    // deprecated
	    function replaceState(state, path, query) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path, { query: query }));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useQueries;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var strictUriEncode = __webpack_require__(194);
	
	exports.extract = function (str) {
		return str.split('?')[1] || '';
	};
	
	exports.parse = function (str) {
		if (typeof str !== 'string') {
			return {};
		}
	
		str = str.trim().replace(/^(\?|#|&)/, '');
	
		if (!str) {
			return {};
		}
	
		return str.split('&').reduce(function (ret, param) {
			var parts = param.replace(/\+/g, ' ').split('=');
			// Firefox (pre 40) decodes `%3D` to `=`
			// https://github.com/sindresorhus/query-string/pull/37
			var key = parts.shift();
			var val = parts.length > 0 ? parts.join('=') : undefined;
	
			key = decodeURIComponent(key);
	
			// missing `=` should be `null`:
			// http://w3.org/TR/2012/WD-url-20120524/#collect-url-parameters
			val = val === undefined ? null : decodeURIComponent(val);
	
			if (!ret.hasOwnProperty(key)) {
				ret[key] = val;
			} else if (Array.isArray(ret[key])) {
				ret[key].push(val);
			} else {
				ret[key] = [ret[key], val];
			}
	
			return ret;
		}, {});
	};
	
	exports.stringify = function (obj) {
		return obj ? Object.keys(obj).sort().map(function (key) {
			var val = obj[key];
	
			if (val === undefined) {
				return '';
			}
	
			if (val === null) {
				return key;
			}
	
			if (Array.isArray(val)) {
				return val.slice().sort().map(function (val2) {
					return strictUriEncode(key) + '=' + strictUriEncode(val2);
				}).join('&');
			}
	
			return strictUriEncode(key) + '=' + strictUriEncode(val);
		}).filter(function (x) {
			return x.length > 0;
		}).join('&') : '';
	};

/***/ },
/* 194 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = function (str) {
		return encodeURIComponent(str).replace(/[!'()*]/g, function (c) {
			return '%' + c.charCodeAt(0).toString(16).toUpperCase();
		});
	};

/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = createTransitionManager;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _computeChangedRoutes2 = __webpack_require__(196);
	
	var _computeChangedRoutes3 = _interopRequireDefault(_computeChangedRoutes2);
	
	var _TransitionUtils = __webpack_require__(197);
	
	var _isActive2 = __webpack_require__(199);
	
	var _isActive3 = _interopRequireDefault(_isActive2);
	
	var _getComponents = __webpack_require__(200);
	
	var _getComponents2 = _interopRequireDefault(_getComponents);
	
	var _matchRoutes = __webpack_require__(202);
	
	var _matchRoutes2 = _interopRequireDefault(_matchRoutes);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function hasAnyProperties(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return true;
	  }return false;
	}
	
	function createTransitionManager(history, routes) {
	  var state = {};
	
	  // Signature should be (location, indexOnly), but needs to support (path,
	  // query, indexOnly)
	  function isActive(location) {
	    var indexOnlyOrDeprecatedQuery = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
	    var deprecatedIndexOnly = arguments.length <= 2 || arguments[2] === undefined ? null : arguments[2];
	
	    var indexOnly = void 0;
	    if (indexOnlyOrDeprecatedQuery && indexOnlyOrDeprecatedQuery !== true || deprecatedIndexOnly !== null) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`isActive(pathname, query, indexOnly) is deprecated; use `isActive(location, indexOnly)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      location = { pathname: location, query: indexOnlyOrDeprecatedQuery };
	      indexOnly = deprecatedIndexOnly || false;
	    } else {
	      location = history.createLocation(location);
	      indexOnly = indexOnlyOrDeprecatedQuery;
	    }
	
	    return (0, _isActive3.default)(location, indexOnly, state.location, state.routes, state.params);
	  }
	
	  var partialNextState = void 0;
	
	  function match(location, callback) {
	    if (partialNextState && partialNextState.location === location) {
	      // Continue from where we left off.
	      finishMatch(partialNextState, callback);
	    } else {
	      (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	        if (error) {
	          callback(error);
	        } else if (nextState) {
	          finishMatch(_extends({}, nextState, { location: location }), callback);
	        } else {
	          callback();
	        }
	      });
	    }
	  }
	
	  function finishMatch(nextState, callback) {
	    var _computeChangedRoutes = (0, _computeChangedRoutes3.default)(state, nextState);
	
	    var leaveRoutes = _computeChangedRoutes.leaveRoutes;
	    var changeRoutes = _computeChangedRoutes.changeRoutes;
	    var enterRoutes = _computeChangedRoutes.enterRoutes;
	
	    (0, _TransitionUtils.runLeaveHooks)(leaveRoutes, state);
	
	    // Tear down confirmation hooks for left routes
	    leaveRoutes.filter(function (route) {
	      return enterRoutes.indexOf(route) === -1;
	    }).forEach(removeListenBeforeHooksForRoute);
	
	    // change and enter hooks are run in series
	    (0, _TransitionUtils.runChangeHooks)(changeRoutes, state, nextState, function (error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      (0, _TransitionUtils.runEnterHooks)(enterRoutes, nextState, finishEnterHooks);
	    });
	
	    function finishEnterHooks(error, redirectInfo) {
	      if (error || redirectInfo) return handleErrorOrRedirect(error, redirectInfo);
	
	      // TODO: Fetch components after state is updated.
	      (0, _getComponents2.default)(nextState, function (error, components) {
	        if (error) {
	          callback(error);
	        } else {
	          // TODO: Make match a pure function and have some other API
	          // for "match and update state".
	          callback(null, null, state = _extends({}, nextState, { components: components }));
	        }
	      });
	    }
	
	    function handleErrorOrRedirect(error, redirectInfo) {
	      if (error) callback(error);else callback(null, redirectInfo);
	    }
	  }
	
	  var RouteGuid = 1;
	
	  function getRouteID(route) {
	    var create = arguments.length <= 1 || arguments[1] === undefined ? true : arguments[1];
	
	    return route.__id__ || create && (route.__id__ = RouteGuid++);
	  }
	
	  var RouteHooks = Object.create(null);
	
	  function getRouteHooksForRoutes(routes) {
	    return routes.reduce(function (hooks, route) {
	      hooks.push.apply(hooks, RouteHooks[getRouteID(route)]);
	      return hooks;
	    }, []);
	  }
	
	  function transitionHook(location, callback) {
	    (0, _matchRoutes2.default)(routes, location, function (error, nextState) {
	      if (nextState == null) {
	        // TODO: We didn't actually match anything, but hang
	        // onto error/nextState so we don't have to matchRoutes
	        // again in the listen callback.
	        callback();
	        return;
	      }
	
	      // Cache some state here so we don't have to
	      // matchRoutes() again in the listen callback.
	      partialNextState = _extends({}, nextState, { location: location });
	
	      var hooks = getRouteHooksForRoutes((0, _computeChangedRoutes3.default)(state, partialNextState).leaveRoutes);
	
	      var result = void 0;
	      for (var i = 0, len = hooks.length; result == null && i < len; ++i) {
	        // Passing the location arg here indicates to
	        // the user that this is a transition hook.
	        result = hooks[i](location);
	      }
	
	      callback(result);
	    });
	  }
	
	  /* istanbul ignore next: untestable with Karma */
	  function beforeUnloadHook() {
	    // Synchronously check to see if any route hooks want
	    // to prevent the current window/tab from closing.
	    if (state.routes) {
	      var hooks = getRouteHooksForRoutes(state.routes);
	
	      var message = void 0;
	      for (var i = 0, len = hooks.length; typeof message !== 'string' && i < len; ++i) {
	        // Passing no args indicates to the user that this is a
	        // beforeunload hook. We don't know the next location.
	        message = hooks[i]();
	      }
	
	      return message;
	    }
	  }
	
	  var unlistenBefore = void 0,
	      unlistenBeforeUnload = void 0;
	
	  function removeListenBeforeHooksForRoute(route) {
	    var routeID = getRouteID(route, false);
	    if (!routeID) {
	      return;
	    }
	
	    delete RouteHooks[routeID];
	
	    if (!hasAnyProperties(RouteHooks)) {
	      // teardown transition & beforeunload hooks
	      if (unlistenBefore) {
	        unlistenBefore();
	        unlistenBefore = null;
	      }
	
	      if (unlistenBeforeUnload) {
	        unlistenBeforeUnload();
	        unlistenBeforeUnload = null;
	      }
	    }
	  }
	
	  /**
	   * Registers the given hook function to run before leaving the given route.
	   *
	   * During a normal transition, the hook function receives the next location
	   * as its only argument and can return either a prompt message (string) to show the user,
	   * to make sure they want to leave the page; or `false`, to prevent the transition.
	   * Any other return value will have no effect.
	   *
	   * During the beforeunload event (in browsers) the hook receives no arguments.
	   * In this case it must return a prompt message to prevent the transition.
	   *
	   * Returns a function that may be used to unbind the listener.
	   */
	  function listenBeforeLeavingRoute(route, hook) {
	    // TODO: Warn if they register for a route that isn't currently
	    // active. They're probably doing something wrong, like re-creating
	    // route objects on every location change.
	    var routeID = getRouteID(route);
	    var hooks = RouteHooks[routeID];
	
	    if (!hooks) {
	      var thereWereNoRouteHooks = !hasAnyProperties(RouteHooks);
	
	      RouteHooks[routeID] = [hook];
	
	      if (thereWereNoRouteHooks) {
	        // setup transition & beforeunload hooks
	        unlistenBefore = history.listenBefore(transitionHook);
	
	        if (history.listenBeforeUnload) unlistenBeforeUnload = history.listenBeforeUnload(beforeUnloadHook);
	      }
	    } else {
	      if (hooks.indexOf(hook) === -1) {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'adding multiple leave hooks for the same route is deprecated; manage multiple confirmations in your own code instead') : void 0;
	
	        hooks.push(hook);
	      }
	    }
	
	    return function () {
	      var hooks = RouteHooks[routeID];
	
	      if (hooks) {
	        var newHooks = hooks.filter(function (item) {
	          return item !== hook;
	        });
	
	        if (newHooks.length === 0) {
	          removeListenBeforeHooksForRoute(route);
	        } else {
	          RouteHooks[routeID] = newHooks;
	        }
	      }
	    };
	  }
	
	  /**
	   * This is the API for stateful environments. As the location
	   * changes, we update state and call the listener. We can also
	   * gracefully handle errors and redirects.
	   */
	  function listen(listener) {
	    // TODO: Only use a single history listener. Otherwise we'll
	    // end up with multiple concurrent calls to match.
	    return history.listen(function (location) {
	      if (state.location === location) {
	        listener(null, state);
	      } else {
	        match(location, function (error, redirectLocation, nextState) {
	          if (error) {
	            listener(error);
	          } else if (redirectLocation) {
	            history.replace(redirectLocation);
	          } else if (nextState) {
	            listener(null, nextState);
	          } else {
	            process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Location "%s" did not match any routes', location.pathname + location.search + location.hash) : void 0;
	          }
	        });
	      }
	    });
	  }
	
	  return {
	    isActive: isActive,
	    match: match,
	    listenBeforeLeavingRoute: listenBeforeLeavingRoute,
	    listen: listen
	  };
	}
	
	//export default useRoutes
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(173);
	
	function routeParamsChanged(route, prevState, nextState) {
	  if (!route.path) return false;
	
	  var paramNames = (0, _PatternUtils.getParamNames)(route.path);
	
	  return paramNames.some(function (paramName) {
	    return prevState.params[paramName] !== nextState.params[paramName];
	  });
	}
	
	/**
	 * Returns an object of { leaveRoutes, changeRoutes, enterRoutes } determined by
	 * the change from prevState to nextState. We leave routes if either
	 * 1) they are not in the next state or 2) they are in the next state
	 * but their params have changed (i.e. /users/123 => /users/456).
	 *
	 * leaveRoutes are ordered starting at the leaf route of the tree
	 * we're leaving up to the common parent route. enterRoutes are ordered
	 * from the top of the tree we're entering down to the leaf route.
	 *
	 * changeRoutes are any routes that didn't leave or enter during
	 * the transition.
	 */
	function computeChangedRoutes(prevState, nextState) {
	  var prevRoutes = prevState && prevState.routes;
	  var nextRoutes = nextState.routes;
	
	  var leaveRoutes = void 0,
	      changeRoutes = void 0,
	      enterRoutes = void 0;
	  if (prevRoutes) {
	    (function () {
	      var parentIsLeaving = false;
	      leaveRoutes = prevRoutes.filter(function (route) {
	        if (parentIsLeaving) {
	          return true;
	        } else {
	          var isLeaving = nextRoutes.indexOf(route) === -1 || routeParamsChanged(route, prevState, nextState);
	          if (isLeaving) parentIsLeaving = true;
	          return isLeaving;
	        }
	      });
	
	      // onLeave hooks start at the leaf route.
	      leaveRoutes.reverse();
	
	      enterRoutes = [];
	      changeRoutes = [];
	
	      nextRoutes.forEach(function (route) {
	        var isNew = prevRoutes.indexOf(route) === -1;
	        var paramsChanged = leaveRoutes.indexOf(route) !== -1;
	
	        if (isNew || paramsChanged) enterRoutes.push(route);else changeRoutes.push(route);
	      });
	    })();
	  } else {
	    leaveRoutes = [];
	    changeRoutes = [];
	    enterRoutes = nextRoutes;
	  }
	
	  return {
	    leaveRoutes: leaveRoutes,
	    changeRoutes: changeRoutes,
	    enterRoutes: enterRoutes
	  };
	}
	
	exports.default = computeChangedRoutes;
	module.exports = exports['default'];

/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	exports.runEnterHooks = runEnterHooks;
	exports.runChangeHooks = runChangeHooks;
	exports.runLeaveHooks = runLeaveHooks;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createTransitionHook(hook, route, asyncArity) {
	  return function () {
	    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
	      args[_key] = arguments[_key];
	    }
	
	    hook.apply(route, args);
	
	    if (hook.length < asyncArity) {
	      var callback = args[args.length - 1];
	      // Assume hook executes synchronously and
	      // automatically call the callback.
	      callback();
	    }
	  };
	}
	
	function getEnterHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onEnter) hooks.push(createTransitionHook(route.onEnter, route, 3));
	
	    return hooks;
	  }, []);
	}
	
	function getChangeHooks(routes) {
	  return routes.reduce(function (hooks, route) {
	    if (route.onChange) hooks.push(createTransitionHook(route.onChange, route, 4));
	    return hooks;
	  }, []);
	}
	
	function runTransitionHooks(length, iter, callback) {
	  if (!length) {
	    callback();
	    return;
	  }
	
	  var redirectInfo = void 0;
	  function replace(location, deprecatedPathname, deprecatedQuery) {
	    if (deprecatedPathname) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`replaceState(state, pathname, query) is deprecated; use `replace(location)` with a location descriptor instead. http://tiny.cc/router-isActivedeprecated') : void 0;
	      redirectInfo = {
	        pathname: deprecatedPathname,
	        query: deprecatedQuery,
	        state: location
	      };
	
	      return;
	    }
	
	    redirectInfo = location;
	  }
	
	  (0, _AsyncUtils.loopAsync)(length, function (index, next, done) {
	    iter(index, replace, function (error) {
	      if (error || redirectInfo) {
	        done(error, redirectInfo); // No need to continue.
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	
	/**
	 * Runs all onEnter hooks in the given array of routes in order
	 * with onEnter(nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runEnterHooks(routes, nextState, callback) {
	  var hooks = getEnterHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onChange hooks in the given array of routes in order
	 * with onChange(prevState, nextState, replace, callback) and calls
	 * callback(error, redirectInfo) when finished. The first hook
	 * to use replace short-circuits the loop.
	 *
	 * If a hook needs to run asynchronously, it may use the callback
	 * function. However, doing so will cause the transition to pause,
	 * which could lead to a non-responsive UI if the hook is slow.
	 */
	function runChangeHooks(routes, state, nextState, callback) {
	  var hooks = getChangeHooks(routes);
	  return runTransitionHooks(hooks.length, function (index, replace, next) {
	    hooks[index](state, nextState, replace, next);
	  }, callback);
	}
	
	/**
	 * Runs all onLeave hooks in the given array of routes in order.
	 */
	function runLeaveHooks(routes, prevState) {
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    if (routes[i].onLeave) routes[i].onLeave.call(routes[i], prevState);
	  }
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 198 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	exports.loopAsync = loopAsync;
	exports.mapAsync = mapAsync;
	function loopAsync(turns, work, callback) {
	  var currentTurn = 0,
	      isDone = false;
	  var sync = false,
	      hasNext = false,
	      doneArgs = void 0;
	
	  function done() {
	    isDone = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      doneArgs = [].concat(Array.prototype.slice.call(arguments));
	      return;
	    }
	
	    callback.apply(this, arguments);
	  }
	
	  function next() {
	    if (isDone) {
	      return;
	    }
	
	    hasNext = true;
	    if (sync) {
	      // Iterate instead of recursing if possible.
	      return;
	    }
	
	    sync = true;
	
	    while (!isDone && currentTurn < turns && hasNext) {
	      hasNext = false;
	      work.call(this, currentTurn++, next, done);
	    }
	
	    sync = false;
	
	    if (isDone) {
	      // This means the loop finished synchronously.
	      callback.apply(this, doneArgs);
	      return;
	    }
	
	    if (currentTurn >= turns && hasNext) {
	      isDone = true;
	      callback();
	    }
	  }
	
	  next();
	}
	
	function mapAsync(array, work, callback) {
	  var length = array.length;
	  var values = [];
	
	  if (length === 0) return callback(null, values);
	
	  var isDone = false,
	      doneCount = 0;
	
	  function done(index, error, value) {
	    if (isDone) return;
	
	    if (error) {
	      isDone = true;
	      callback(error);
	    } else {
	      values[index] = value;
	
	      isDone = ++doneCount === length;
	
	      if (isDone) callback(null, values);
	    }
	  }
	
	  array.forEach(function (item, index) {
	    work(item, index, function (error, value) {
	      done(index, error, value);
	    });
	  });
	}

/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = isActive;
	
	var _PatternUtils = __webpack_require__(173);
	
	function deepEqual(a, b) {
	  if (a == b) return true;
	
	  if (a == null || b == null) return false;
	
	  if (Array.isArray(a)) {
	    return Array.isArray(b) && a.length === b.length && a.every(function (item, index) {
	      return deepEqual(item, b[index]);
	    });
	  }
	
	  if ((typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object') {
	    for (var p in a) {
	      if (!Object.prototype.hasOwnProperty.call(a, p)) {
	        continue;
	      }
	
	      if (a[p] === undefined) {
	        if (b[p] !== undefined) {
	          return false;
	        }
	      } else if (!Object.prototype.hasOwnProperty.call(b, p)) {
	        return false;
	      } else if (!deepEqual(a[p], b[p])) {
	        return false;
	      }
	    }
	
	    return true;
	  }
	
	  return String(a) === String(b);
	}
	
	/**
	 * Returns true if the current pathname matches the supplied one, net of
	 * leading and trailing slash normalization. This is sufficient for an
	 * indexOnly route match.
	 */
	function pathIsActive(pathname, currentPathname) {
	  // Normalize leading slash for consistency. Leading slash on pathname has
	  // already been normalized in isActive. See caveat there.
	  if (currentPathname.charAt(0) !== '/') {
	    currentPathname = '/' + currentPathname;
	  }
	
	  // Normalize the end of both path names too. Maybe `/foo/` shouldn't show
	  // `/foo` as active, but in this case, we would already have failed the
	  // match.
	  if (pathname.charAt(pathname.length - 1) !== '/') {
	    pathname += '/';
	  }
	  if (currentPathname.charAt(currentPathname.length - 1) !== '/') {
	    currentPathname += '/';
	  }
	
	  return currentPathname === pathname;
	}
	
	/**
	 * Returns true if the given pathname matches the active routes and params.
	 */
	function routeIsActive(pathname, routes, params) {
	  var remainingPathname = pathname,
	      paramNames = [],
	      paramValues = [];
	
	  // for...of would work here but it's probably slower post-transpilation.
	  for (var i = 0, len = routes.length; i < len; ++i) {
	    var route = routes[i];
	    var pattern = route.path || '';
	
	    if (pattern.charAt(0) === '/') {
	      remainingPathname = pathname;
	      paramNames = [];
	      paramValues = [];
	    }
	
	    if (remainingPathname !== null && pattern) {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	
	      if (remainingPathname === '') {
	        // We have an exact match on the route. Just check that all the params
	        // match.
	        // FIXME: This doesn't work on repeated params.
	        return paramNames.every(function (paramName, index) {
	          return String(paramValues[index]) === String(params[paramName]);
	        });
	      }
	    }
	  }
	
	  return false;
	}
	
	/**
	 * Returns true if all key/value pairs in the given query are
	 * currently active.
	 */
	function queryIsActive(query, activeQuery) {
	  if (activeQuery == null) return query == null;
	
	  if (query == null) return true;
	
	  return deepEqual(query, activeQuery);
	}
	
	/**
	 * Returns true if a <Link> to the given pathname/query combination is
	 * currently active.
	 */
	function isActive(_ref, indexOnly, currentLocation, routes, params) {
	  var pathname = _ref.pathname;
	  var query = _ref.query;
	
	  if (currentLocation == null) return false;
	
	  // TODO: This is a bit ugly. It keeps around support for treating pathnames
	  // without preceding slashes as absolute paths, but possibly also works
	  // around the same quirks with basenames as in matchRoutes.
	  if (pathname.charAt(0) !== '/') {
	    pathname = '/' + pathname;
	  }
	
	  if (!pathIsActive(pathname, currentLocation.pathname)) {
	    // The path check is necessary and sufficient for indexOnly, but otherwise
	    // we still need to check the routes.
	    if (indexOnly || !routeIsActive(pathname, routes, params)) {
	      return false;
	    }
	  }
	
	  return queryIsActive(query, currentLocation.query);
	}
	module.exports = exports['default'];

/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _makeStateWithLocation = __webpack_require__(201);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getComponentsForRoute(nextState, route, callback) {
	  if (route.component || route.components) {
	    callback(null, route.component || route.components);
	    return;
	  }
	
	  var getComponent = route.getComponent || route.getComponents;
	  if (!getComponent) {
	    callback();
	    return;
	  }
	
	  var location = nextState.location;
	
	  var nextStateWithLocation = (0, _makeStateWithLocation2.default)(nextState, location);
	
	  getComponent.call(route, nextStateWithLocation, callback);
	}
	
	/**
	 * Asynchronously fetches all components needed for the given router
	 * state and calls callback(error, components) when finished.
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getComponents method.
	 */
	function getComponents(nextState, callback) {
	  (0, _AsyncUtils.mapAsync)(nextState.routes, function (route, index, callback) {
	    getComponentsForRoute(nextState, route, callback);
	  }, callback);
	}
	
	exports.default = getComponents;
	module.exports = exports['default'];

/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = makeStateWithLocation;
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function makeStateWithLocation(state, location) {
	  if (process.env.NODE_ENV !== 'production' && _deprecateObjectProperties.canUseMembrane) {
	    var stateWithLocation = _extends({}, state);
	
	    // I don't use deprecateObjectProperties here because I want to keep the
	    // same code path between development and production, in that we just
	    // assign extra properties to the copy of the state object in both cases.
	
	    var _loop = function _loop(prop) {
	      if (!Object.prototype.hasOwnProperty.call(location, prop)) {
	        return 'continue';
	      }
	
	      Object.defineProperty(stateWithLocation, prop, {
	        get: function get() {
	          process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'Accessing location properties directly from the first argument to `getComponent`, `getComponents`, `getChildRoutes`, and `getIndexRoute` is deprecated. That argument is now the router state (`nextState` or `partialNextState`) rather than the location. To access the location, use `nextState.location` or `partialNextState.location`.') : void 0;
	          return location[prop];
	        }
	      });
	    };
	
	    for (var prop in location) {
	      var _ret = _loop(prop);
	
	      if (_ret === 'continue') continue;
	    }
	
	    return stateWithLocation;
	  }
	
	  return _extends({}, state, location);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	exports.default = matchRoutes;
	
	var _AsyncUtils = __webpack_require__(198);
	
	var _makeStateWithLocation = __webpack_require__(201);
	
	var _makeStateWithLocation2 = _interopRequireDefault(_makeStateWithLocation);
	
	var _PatternUtils = __webpack_require__(173);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _RouteUtils = __webpack_require__(167);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getChildRoutes(route, location, paramNames, paramValues, callback) {
	  if (route.childRoutes) {
	    return [null, route.childRoutes];
	  }
	  if (!route.getChildRoutes) {
	    return [];
	  }
	
	  var sync = true,
	      result = void 0;
	
	  var partialNextState = {
	    location: location,
	    params: createParams(paramNames, paramValues)
	  };
	
	  var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	  route.getChildRoutes(partialNextStateWithLocation, function (error, childRoutes) {
	    childRoutes = !error && (0, _RouteUtils.createRoutes)(childRoutes);
	    if (sync) {
	      result = [error, childRoutes];
	      return;
	    }
	
	    callback(error, childRoutes);
	  });
	
	  sync = false;
	  return result; // Might be undefined.
	}
	
	function getIndexRoute(route, location, paramNames, paramValues, callback) {
	  if (route.indexRoute) {
	    callback(null, route.indexRoute);
	  } else if (route.getIndexRoute) {
	    var partialNextState = {
	      location: location,
	      params: createParams(paramNames, paramValues)
	    };
	
	    var partialNextStateWithLocation = (0, _makeStateWithLocation2.default)(partialNextState, location);
	
	    route.getIndexRoute(partialNextStateWithLocation, function (error, indexRoute) {
	      callback(error, !error && (0, _RouteUtils.createRoutes)(indexRoute)[0]);
	    });
	  } else if (route.childRoutes) {
	    (function () {
	      var pathless = route.childRoutes.filter(function (childRoute) {
	        return !childRoute.path;
	      });
	
	      (0, _AsyncUtils.loopAsync)(pathless.length, function (index, next, done) {
	        getIndexRoute(pathless[index], location, paramNames, paramValues, function (error, indexRoute) {
	          if (error || indexRoute) {
	            var routes = [pathless[index]].concat(Array.isArray(indexRoute) ? indexRoute : [indexRoute]);
	            done(error, routes);
	          } else {
	            next();
	          }
	        });
	      }, function (err, routes) {
	        callback(null, routes);
	      });
	    })();
	  } else {
	    callback();
	  }
	}
	
	function assignParams(params, paramNames, paramValues) {
	  return paramNames.reduce(function (params, paramName, index) {
	    var paramValue = paramValues && paramValues[index];
	
	    if (Array.isArray(params[paramName])) {
	      params[paramName].push(paramValue);
	    } else if (paramName in params) {
	      params[paramName] = [params[paramName], paramValue];
	    } else {
	      params[paramName] = paramValue;
	    }
	
	    return params;
	  }, params);
	}
	
	function createParams(paramNames, paramValues) {
	  return assignParams({}, paramNames, paramValues);
	}
	
	function matchRouteDeep(route, location, remainingPathname, paramNames, paramValues, callback) {
	  var pattern = route.path || '';
	
	  if (pattern.charAt(0) === '/') {
	    remainingPathname = location.pathname;
	    paramNames = [];
	    paramValues = [];
	  }
	
	  // Only try to match the path if the route actually has a pattern, and if
	  // we're not just searching for potential nested absolute paths.
	  if (remainingPathname !== null && pattern) {
	    try {
	      var matched = (0, _PatternUtils.matchPattern)(pattern, remainingPathname);
	      if (matched) {
	        remainingPathname = matched.remainingPathname;
	        paramNames = [].concat(paramNames, matched.paramNames);
	        paramValues = [].concat(paramValues, matched.paramValues);
	      } else {
	        remainingPathname = null;
	      }
	    } catch (error) {
	      callback(error);
	    }
	
	    // By assumption, pattern is non-empty here, which is the prerequisite for
	    // actually terminating a match.
	    if (remainingPathname === '') {
	      var _ret2 = function () {
	        var match = {
	          routes: [route],
	          params: createParams(paramNames, paramValues)
	        };
	
	        getIndexRoute(route, location, paramNames, paramValues, function (error, indexRoute) {
	          if (error) {
	            callback(error);
	          } else {
	            if (Array.isArray(indexRoute)) {
	              var _match$routes;
	
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(indexRoute.every(function (route) {
	                return !route.path;
	              }), 'Index routes should not have paths') : void 0;
	              (_match$routes = match.routes).push.apply(_match$routes, indexRoute);
	            } else if (indexRoute) {
	              process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!indexRoute.path, 'Index routes should not have paths') : void 0;
	              match.routes.push(indexRoute);
	            }
	
	            callback(null, match);
	          }
	        });
	
	        return {
	          v: void 0
	        };
	      }();
	
	      if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
	    }
	  }
	
	  if (remainingPathname != null || route.childRoutes) {
	    // Either a) this route matched at least some of the path or b)
	    // we don't have to load this route's children asynchronously. In
	    // either case continue checking for matches in the subtree.
	    var onChildRoutes = function onChildRoutes(error, childRoutes) {
	      if (error) {
	        callback(error);
	      } else if (childRoutes) {
	        // Check the child routes to see if any of them match.
	        matchRoutes(childRoutes, location, function (error, match) {
	          if (error) {
	            callback(error);
	          } else if (match) {
	            // A child route matched! Augment the match and pass it up the stack.
	            match.routes.unshift(route);
	            callback(null, match);
	          } else {
	            callback();
	          }
	        }, remainingPathname, paramNames, paramValues);
	      } else {
	        callback();
	      }
	    };
	
	    var result = getChildRoutes(route, location, paramNames, paramValues, onChildRoutes);
	    if (result) {
	      onChildRoutes.apply(undefined, result);
	    }
	  } else {
	    callback();
	  }
	}
	
	/**
	 * Asynchronously matches the given location to a set of routes and calls
	 * callback(error, state) when finished. The state object will have the
	 * following properties:
	 *
	 * - routes       An array of routes that matched, in hierarchical order
	 * - params       An object of URL parameters
	 *
	 * Note: This operation may finish synchronously if no routes have an
	 * asynchronous getChildRoutes method.
	 */
	function matchRoutes(routes, location, callback, remainingPathname) {
	  var paramNames = arguments.length <= 4 || arguments[4] === undefined ? [] : arguments[4];
	  var paramValues = arguments.length <= 5 || arguments[5] === undefined ? [] : arguments[5];
	
	  if (remainingPathname === undefined) {
	    // TODO: This is a little bit ugly, but it works around a quirk in history
	    // that strips the leading slash from pathnames when using basenames with
	    // trailing slashes.
	    if (location.pathname.charAt(0) !== '/') {
	      location = _extends({}, location, {
	        pathname: '/' + location.pathname
	      });
	    }
	    remainingPathname = location.pathname;
	  }
	
	  (0, _AsyncUtils.loopAsync)(routes.length, function (index, next, done) {
	    matchRouteDeep(routes[index], location, remainingPathname, paramNames, paramValues, function (error, match) {
	      if (error || match) {
	        done(error, match);
	      } else {
	        next();
	      }
	    });
	  }, callback);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	} : function (obj) {
	  return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof2(obj);
	};
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	var _getRouteParams = __webpack_require__(204);
	
	var _getRouteParams2 = _interopRequireDefault(_getRouteParams);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var array = _React$PropTypes.array;
	var func = _React$PropTypes.func;
	var object = _React$PropTypes.object;
	
	/**
	 * A <RouterContext> renders the component tree for a given router state
	 * and sets the history object and the current location in context.
	 */
	
	var RouterContext = _react2.default.createClass({
	  displayName: 'RouterContext',
	
	  propTypes: {
	    history: object,
	    router: object.isRequired,
	    location: object.isRequired,
	    routes: array.isRequired,
	    params: object.isRequired,
	    components: array.isRequired,
	    createElement: func.isRequired
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      createElement: _react2.default.createElement
	    };
	  },
	
	  childContextTypes: {
	    history: object,
	    location: object.isRequired,
	    router: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    var _props = this.props;
	    var router = _props.router;
	    var history = _props.history;
	    var location = _props.location;
	
	    if (!router) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`<RouterContext>` expects a `router` rather than a `history`') : void 0;
	
	      router = _extends({}, history, {
	        setRouteLeaveHook: history.listenBeforeLeavingRoute
	      });
	      delete router.listenBeforeLeavingRoute;
	    }
	
	    if (process.env.NODE_ENV !== 'production') {
	      location = (0, _deprecateObjectProperties2.default)(location, '`context.location` is deprecated, please use a route component\'s `props.location` instead. http://tiny.cc/router-accessinglocation');
	    }
	
	    return { history: history, location: location, router: router };
	  },
	  createElement: function createElement(component, props) {
	    return component == null ? null : this.props.createElement(component, props);
	  },
	  render: function render() {
	    var _this = this;
	
	    var _props2 = this.props;
	    var history = _props2.history;
	    var location = _props2.location;
	    var routes = _props2.routes;
	    var params = _props2.params;
	    var components = _props2.components;
	
	    var element = null;
	
	    if (components) {
	      element = components.reduceRight(function (element, components, index) {
	        if (components == null) return element; // Don't create new children; use the grandchildren.
	
	        var route = routes[index];
	        var routeParams = (0, _getRouteParams2.default)(route, params);
	        var props = {
	          history: history,
	          location: location,
	          params: params,
	          route: route,
	          routeParams: routeParams,
	          routes: routes
	        };
	
	        if ((0, _RouteUtils.isReactChildren)(element)) {
	          props.children = element;
	        } else if (element) {
	          for (var prop in element) {
	            if (Object.prototype.hasOwnProperty.call(element, prop)) props[prop] = element[prop];
	          }
	        }
	
	        if ((typeof components === 'undefined' ? 'undefined' : _typeof(components)) === 'object') {
	          var elements = {};
	
	          for (var key in components) {
	            if (Object.prototype.hasOwnProperty.call(components, key)) {
	              // Pass through the key as a prop to createElement to allow
	              // custom createElement functions to know which named component
	              // they're rendering, for e.g. matching up to fetched data.
	              elements[key] = _this.createElement(components[key], _extends({
	                key: key }, props));
	            }
	          }
	
	          return elements;
	        }
	
	        return _this.createElement(components, props);
	      }, element);
	    }
	
	    !(element === null || element === false || _react2.default.isValidElement(element)) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The root route must render a single element') : (0, _invariant2.default)(false) : void 0;
	
	    return element;
	  }
	});
	
	exports.default = RouterContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _PatternUtils = __webpack_require__(173);
	
	/**
	 * Extracts an object of params the given route cares about from
	 * the given params object.
	 */
	function getRouteParams(route, params) {
	  var routeParams = {};
	
	  if (!route.path) return routeParams;
	
	  (0, _PatternUtils.getParamNames)(route.path).forEach(function (p) {
	    if (Object.prototype.hasOwnProperty.call(params, p)) {
	      routeParams[p] = params[p];
	    }
	  });
	
	  return routeParams;
	}
	
	exports.default = getRouteParams;
	module.exports = exports['default'];

/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.createRouterObject = createRouterObject;
	exports.createRoutingHistory = createRoutingHistory;
	
	var _deprecateObjectProperties = __webpack_require__(169);
	
	var _deprecateObjectProperties2 = _interopRequireDefault(_deprecateObjectProperties);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createRouterObject(history, transitionManager) {
	  return _extends({}, history, {
	    setRouteLeaveHook: transitionManager.listenBeforeLeavingRoute,
	    isActive: transitionManager.isActive
	  });
	}
	
	// deprecated
	function createRoutingHistory(history, transitionManager) {
	  history = _extends({}, history, transitionManager);
	
	  if (process.env.NODE_ENV !== 'production') {
	    history = (0, _deprecateObjectProperties2.default)(history, '`props.history` and `context.history` are deprecated. Please use `context.router`. http://tiny.cc/router-contextchanges');
	  }
	
	  return history;
	}
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PropTypes = __webpack_require__(168);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var bool = _React$PropTypes.bool;
	var object = _React$PropTypes.object;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	var oneOfType = _React$PropTypes.oneOfType;
	
	function isLeftClickEvent(event) {
	  return event.button === 0;
	}
	
	function isModifiedEvent(event) {
	  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
	}
	
	// TODO: De-duplicate against hasAnyProperties in createTransitionManager.
	function isEmptyObject(object) {
	  for (var p in object) {
	    if (Object.prototype.hasOwnProperty.call(object, p)) return false;
	  }return true;
	}
	
	function createLocationDescriptor(to, _ref) {
	  var query = _ref.query;
	  var hash = _ref.hash;
	  var state = _ref.state;
	
	  if (query || hash || state) {
	    return { pathname: to, query: query, hash: hash, state: state };
	  }
	
	  return to;
	}
	
	/**
	 * A <Link> is used to create an <a> element that links to a route.
	 * When that route is active, the link gets the value of its
	 * activeClassName prop.
	 *
	 * For example, assuming you have the following route:
	 *
	 *   <Route path="/posts/:postID" component={Post} />
	 *
	 * You could use the following component to link to that route:
	 *
	 *   <Link to={`/posts/${post.id}`} />
	 *
	 * Links may pass along location state and/or query string parameters
	 * in the state/query props, respectively.
	 *
	 *   <Link ... query={{ show: true }} state={{ the: 'state' }} />
	 */
	var Link = _react2.default.createClass({
	  displayName: 'Link',
	
	  contextTypes: {
	    router: _PropTypes.routerShape
	  },
	
	  propTypes: {
	    to: oneOfType([string, object]),
	    query: object,
	    hash: string,
	    state: object,
	    activeStyle: object,
	    activeClassName: string,
	    onlyActiveOnIndex: bool.isRequired,
	    onClick: func,
	    target: string
	  },
	
	  getDefaultProps: function getDefaultProps() {
	    return {
	      onlyActiveOnIndex: false,
	      style: {}
	    };
	  },
	  handleClick: function handleClick(event) {
	    if (this.props.onClick) this.props.onClick(event);
	
	    if (event.defaultPrevented) return;
	
	    !this.context.router ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Link>s rendered outside of a router context cannot navigate.') : (0, _invariant2.default)(false) : void 0;
	
	    if (isModifiedEvent(event) || !isLeftClickEvent(event)) return;
	
	    // If target prop is set (e.g. to "_blank"), let browser handle link.
	    /* istanbul ignore if: untestable with Karma */
	    if (this.props.target) return;
	
	    event.preventDefault();
	
	    var _props = this.props;
	    var to = _props.to;
	    var query = _props.query;
	    var hash = _props.hash;
	    var state = _props.state;
	
	    var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	
	    this.context.router.push(location);
	  },
	  render: function render() {
	    var _props2 = this.props;
	    var to = _props2.to;
	    var query = _props2.query;
	    var hash = _props2.hash;
	    var state = _props2.state;
	    var activeClassName = _props2.activeClassName;
	    var activeStyle = _props2.activeStyle;
	    var onlyActiveOnIndex = _props2.onlyActiveOnIndex;
	
	    var props = _objectWithoutProperties(_props2, ['to', 'query', 'hash', 'state', 'activeClassName', 'activeStyle', 'onlyActiveOnIndex']);
	
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(!(query || hash || state), 'the `query`, `hash`, and `state` props on `<Link>` are deprecated, use `<Link to={{ pathname, query, hash, state }}/>. http://tiny.cc/router-isActivedeprecated') : void 0;
	
	    // Ignore if rendered outside the context of router, simplifies unit testing.
	    var router = this.context.router;
	
	    if (router) {
	      // If user does not specify a `to` prop, return an empty anchor tag.
	      if (to == null) {
	        return _react2.default.createElement('a', props);
	      }
	
	      var location = createLocationDescriptor(to, { query: query, hash: hash, state: state });
	      props.href = router.createHref(location);
	
	      if (activeClassName || activeStyle != null && !isEmptyObject(activeStyle)) {
	        if (router.isActive(location, onlyActiveOnIndex)) {
	          if (activeClassName) {
	            if (props.className) {
	              props.className += ' ' + activeClassName;
	            } else {
	              props.className = activeClassName;
	            }
	          }
	
	          if (activeStyle) props.style = _extends({}, props.style, activeStyle);
	        }
	      }
	    }
	
	    return _react2.default.createElement('a', _extends({}, props, { onClick: this.handleClick }));
	  }
	});
	
	exports.default = Link;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _Link = __webpack_require__(206);
	
	var _Link2 = _interopRequireDefault(_Link);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * An <IndexLink> is used to link to an <IndexRoute>.
	 */
	var IndexLink = _react2.default.createClass({
	  displayName: 'IndexLink',
	  render: function render() {
	    return _react2.default.createElement(_Link2.default, _extends({}, this.props, { onlyActiveOnIndex: true }));
	  }
	});
	
	exports.default = IndexLink;
	module.exports = exports['default'];

/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	exports.default = withRouter;
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _hoistNonReactStatics = __webpack_require__(209);
	
	var _hoistNonReactStatics2 = _interopRequireDefault(_hoistNonReactStatics);
	
	var _PropTypes = __webpack_require__(168);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function getDisplayName(WrappedComponent) {
	  return WrappedComponent.displayName || WrappedComponent.name || 'Component';
	}
	
	function withRouter(WrappedComponent, options) {
	  var withRef = options && options.withRef;
	
	  var WithRouter = _react2.default.createClass({
	    displayName: 'WithRouter',
	
	    contextTypes: { router: _PropTypes.routerShape },
	    propTypes: { router: _PropTypes.routerShape },
	
	    getWrappedInstance: function getWrappedInstance() {
	      !withRef ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'To access the wrapped instance, you need to specify ' + '`{ withRef: true }` as the second argument of the withRouter() call.') : (0, _invariant2.default)(false) : void 0;
	
	      return this.wrappedInstance;
	    },
	    render: function render() {
	      var _this = this;
	
	      var router = this.props.router || this.context.router;
	      var props = _extends({}, this.props, { router: router });
	
	      if (withRef) {
	        props.ref = function (c) {
	          _this.wrappedInstance = c;
	        };
	      }
	
	      return _react2.default.createElement(WrappedComponent, props);
	    }
	  });
	
	  WithRouter.displayName = 'withRouter(' + getDisplayName(WrappedComponent) + ')';
	  WithRouter.WrappedComponent = WrappedComponent;
	
	  return (0, _hoistNonReactStatics2.default)(WithRouter, WrappedComponent);
	}
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 209 */
/***/ function(module, exports) {

	/**
	 * Copyright 2015, Yahoo! Inc.
	 * Copyrights licensed under the New BSD License. See the accompanying LICENSE file for terms.
	 */
	'use strict';
	
	var REACT_STATICS = {
	    childContextTypes: true,
	    contextTypes: true,
	    defaultProps: true,
	    displayName: true,
	    getDefaultProps: true,
	    mixins: true,
	    propTypes: true,
	    type: true
	};
	
	var KNOWN_STATICS = {
	    name: true,
	    length: true,
	    prototype: true,
	    caller: true,
	    arguments: true,
	    arity: true
	};
	
	var isGetOwnPropertySymbolsAvailable = typeof Object.getOwnPropertySymbols === 'function';
	
	module.exports = function hoistNonReactStatics(targetComponent, sourceComponent, customStatics) {
	    if (typeof sourceComponent !== 'string') {
	        // don't hoist over string (html) components
	        var keys = Object.getOwnPropertyNames(sourceComponent);
	
	        /* istanbul ignore else */
	        if (isGetOwnPropertySymbolsAvailable) {
	            keys = keys.concat(Object.getOwnPropertySymbols(sourceComponent));
	        }
	
	        for (var i = 0; i < keys.length; ++i) {
	            if (!REACT_STATICS[keys[i]] && !KNOWN_STATICS[keys[i]] && (!customStatics || !customStatics[keys[i]])) {
	                try {
	                    targetComponent[keys[i]] = sourceComponent[keys[i]];
	                } catch (error) {}
	            }
	        }
	    }
	
	    return targetComponent;
	};

/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Redirect = __webpack_require__(211);
	
	var _Redirect2 = _interopRequireDefault(_Redirect);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * An <IndexRedirect> is used to redirect from an indexRoute.
	 */
	
	var IndexRedirect = _react2.default.createClass({
	  displayName: 'IndexRedirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = _Redirect2.default.createRouteFromReactElement(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRedirect> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRedirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRedirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _PatternUtils = __webpack_require__(173);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var object = _React$PropTypes.object;
	
	/**
	 * A <Redirect> is used to declare another URL path a client should
	 * be sent to when they request a given URL.
	 *
	 * Redirects are placed alongside routes in the route configuration
	 * and are traversed in the same manner.
	 */
	
	var Redirect = _react2.default.createClass({
	  displayName: 'Redirect',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element) {
	      var route = (0, _RouteUtils.createRouteFromReactElement)(element);
	
	      if (route.from) route.path = route.from;
	
	      route.onEnter = function (nextState, replace) {
	        var location = nextState.location;
	        var params = nextState.params;
	
	        var pathname = void 0;
	        if (route.to.charAt(0) === '/') {
	          pathname = (0, _PatternUtils.formatPattern)(route.to, params);
	        } else if (!route.to) {
	          pathname = location.pathname;
	        } else {
	          var routeIndex = nextState.routes.indexOf(route);
	          var parentPattern = Redirect.getRoutePattern(nextState.routes, routeIndex - 1);
	          var pattern = parentPattern.replace(/\/*$/, '/') + route.to;
	          pathname = (0, _PatternUtils.formatPattern)(pattern, params);
	        }
	
	        replace({
	          pathname: pathname,
	          query: route.query || location.query,
	          state: route.state || location.state
	        });
	      };
	
	      return route;
	    },
	    getRoutePattern: function getRoutePattern(routes, routeIndex) {
	      var parentPattern = '';
	
	      for (var i = routeIndex; i >= 0; i--) {
	        var route = routes[i];
	        var pattern = route.path || '';
	
	        parentPattern = pattern.replace(/\/*$/, '/') + parentPattern;
	
	        if (pattern.indexOf('/') === 0) break;
	      }
	
	      return '/' + parentPattern;
	    }
	  },
	
	  propTypes: {
	    path: string,
	    from: string, // Alias for path
	    to: string.isRequired,
	    query: object,
	    state: object,
	    onEnter: _InternalPropTypes.falsy,
	    children: _InternalPropTypes.falsy
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Redirect> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Redirect;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 212 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var func = _react2.default.PropTypes.func;
	
	/**
	 * An <IndexRoute> is used to specify its parent's <Route indexRoute> in
	 * a JSX route config.
	 */
	
	var IndexRoute = _react2.default.createClass({
	  displayName: 'IndexRoute',
	
	  statics: {
	    createRouteFromReactElement: function createRouteFromReactElement(element, parentRoute) {
	      /* istanbul ignore else: sanity check */
	      if (parentRoute) {
	        parentRoute.indexRoute = (0, _RouteUtils.createRouteFromReactElement)(element);
	      } else {
	        process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'An <IndexRoute> does not make sense at the root of your route config') : void 0;
	      }
	    }
	  },
	
	  propTypes: {
	    path: _InternalPropTypes.falsy,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<IndexRoute> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = IndexRoute;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var _React$PropTypes = _react2.default.PropTypes;
	var string = _React$PropTypes.string;
	var func = _React$PropTypes.func;
	
	/**
	 * A <Route> is used to declare which components are rendered to the
	 * page when the URL matches a given pattern.
	 *
	 * Routes are arranged in a nested tree structure. When a new URL is
	 * requested, the tree is searched depth-first to find a route whose
	 * path matches the URL.  When one is found, all routes in the tree
	 * that lead to it are considered "active" and their components are
	 * rendered into the DOM, nested in the same order as in the tree.
	 */
	
	var Route = _react2.default.createClass({
	  displayName: 'Route',
	
	  statics: {
	    createRouteFromReactElement: _RouteUtils.createRouteFromReactElement
	  },
	
	  propTypes: {
	    path: string,
	    component: _InternalPropTypes.component,
	    components: _InternalPropTypes.components,
	    getComponent: func,
	    getComponents: func
	  },
	
	  /* istanbul ignore next: sanity check */
	  render: function render() {
	     true ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, '<Route> elements are for router configuration only and should not be rendered') : (0, _invariant2.default)(false) : void 0;
	  }
	});
	
	exports.default = Route;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _InternalPropTypes = __webpack_require__(172);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	/**
	 * A mixin that adds the "history" instance variable to components.
	 */
	var History = {
	
	  contextTypes: {
	    history: _InternalPropTypes.history
	  },
	
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `History` mixin is deprecated, please access `context.router` with your own `contextTypes`. http://tiny.cc/router-historymixin') : void 0;
	    this.history = this.context.history;
	  }
	};
	
	exports.default = History;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The Lifecycle mixin adds the routerWillLeave lifecycle method to a
	 * component that may be used to cancel a transition or prompt the user
	 * for confirmation.
	 *
	 * On standard transitions, routerWillLeave receives a single argument: the
	 * location we're transitioning to. To cancel the transition, return false.
	 * To prompt the user for confirmation, return a prompt message (string).
	 *
	 * During the beforeunload event (assuming you're using the useBeforeUnload
	 * history enhancer), routerWillLeave does not receive a location object
	 * because it isn't possible for us to know the location we're transitioning
	 * to. In this case routerWillLeave must return a prompt message to prevent
	 * the user from closing the window/tab.
	 */
	
	var Lifecycle = {
	
	  contextTypes: {
	    history: object.isRequired,
	    // Nested children receive the route as context, either
	    // set by the route component using the RouteContext mixin
	    // or by some other ancestor.
	    route: object
	  },
	
	  propTypes: {
	    // Route components receive the route object as a prop.
	    route: object
	  },
	
	  componentDidMount: function componentDidMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'the `Lifecycle` mixin is deprecated, please use `context.router.setRouteLeaveHook(route, hook)`. http://tiny.cc/router-lifecyclemixin') : void 0;
	    !this.routerWillLeave ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin requires you to define a routerWillLeave method') : (0, _invariant2.default)(false) : void 0;
	
	    var route = this.props.route || this.context.route;
	
	    !route ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'The Lifecycle mixin must be used on either a) a <Route component> or ' + 'b) a descendant of a <Route component> that uses the RouteContext mixin') : (0, _invariant2.default)(false) : void 0;
	
	    this._unlistenBeforeLeavingRoute = this.context.history.listenBeforeLeavingRoute(route, this.routerWillLeave);
	  },
	  componentWillUnmount: function componentWillUnmount() {
	    if (this._unlistenBeforeLeavingRoute) this._unlistenBeforeLeavingRoute();
	  }
	};
	
	exports.default = Lifecycle;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var object = _react2.default.PropTypes.object;
	
	/**
	 * The RouteContext mixin provides a convenient way for route
	 * components to set the route in context. This is needed for
	 * routes that render elements that want to use the Lifecycle
	 * mixin to prevent transitions.
	 */
	
	var RouteContext = {
	
	  propTypes: {
	    route: object.isRequired
	  },
	
	  childContextTypes: {
	    route: object.isRequired
	  },
	
	  getChildContext: function getChildContext() {
	    return {
	      route: this.props.route
	    };
	  },
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, 'The `RouteContext` mixin is deprecated. You can provide `this.props.route` on context with your own `contextTypes`. http://tiny.cc/router-routecontextmixin') : void 0;
	  }
	};
	
	exports.default = RouteContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * Returns a new createHistory function that may be used to create
	 * history objects that know about routing.
	 *
	 * Enhances history objects with the following methods:
	 *
	 * - listen((error, nextState) => {})
	 * - listenBeforeLeavingRoute(route, (nextLocation) => {})
	 * - match(location, (error, redirectLocation, nextState) => {})
	 * - isActive(pathname, query, indexOnly=false)
	 */
	function useRoutes(createHistory) {
	  process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`useRoutes` is deprecated. Please use `createTransitionManager` instead.') : void 0;
	
	  return function () {
	    var _ref = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var routes = _ref.routes;
	
	    var options = _objectWithoutProperties(_ref, ['routes']);
	
	    var history = (0, _useQueries2.default)(createHistory)(options);
	    var transitionManager = (0, _createTransitionManager2.default)(history, routes);
	    return _extends({}, history, transitionManager);
	  };
	}
	
	exports.default = useRoutes;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var RoutingContext = _react2.default.createClass({
	  displayName: 'RoutingContext',
	  componentWillMount: function componentWillMount() {
	    process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(false, '`RoutingContext` has been renamed to `RouterContext`. Please use `import { RouterContext } from \'react-router\'`. http://tiny.cc/router-routercontext') : void 0;
	  },
	  render: function render() {
	    return _react2.default.createElement(_RouterContext2.default, this.props);
	  }
	});
	
	exports.default = RoutingContext;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _Actions = __webpack_require__(178);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _createMemoryHistory = __webpack_require__(220);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	var _createTransitionManager = __webpack_require__(195);
	
	var _createTransitionManager2 = _interopRequireDefault(_createTransitionManager);
	
	var _RouteUtils = __webpack_require__(167);
	
	var _RouterUtils = __webpack_require__(205);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function _objectWithoutProperties(obj, keys) {
	  var target = {};for (var i in obj) {
	    if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
	  }return target;
	}
	
	/**
	 * A high-level API to be used for server-side rendering.
	 *
	 * This function matches a location to a set of routes and calls
	 * callback(error, redirectLocation, renderProps) when finished.
	 *
	 * Note: You probably don't want to use this in a browser unless you're using
	 * server-side rendering with async routes.
	 */
	function match(_ref, callback) {
	  var history = _ref.history;
	  var routes = _ref.routes;
	  var location = _ref.location;
	
	  var options = _objectWithoutProperties(_ref, ['history', 'routes', 'location']);
	
	  !(history || location) ? process.env.NODE_ENV !== 'production' ? (0, _invariant2.default)(false, 'match needs a history or a location') : (0, _invariant2.default)(false) : void 0;
	
	  history = history ? history : (0, _createMemoryHistory2.default)(options);
	  var transitionManager = (0, _createTransitionManager2.default)(history, (0, _RouteUtils.createRoutes)(routes));
	
	  var unlisten = void 0;
	
	  if (location) {
	    // Allow match({ location: '/the/path', ... })
	    location = history.createLocation(location);
	  } else {
	    // Pick up the location from the history via synchronous history.listen
	    // call if needed.
	    unlisten = history.listen(function (historyLocation) {
	      location = historyLocation;
	    });
	  }
	
	  var router = (0, _RouterUtils.createRouterObject)(history, transitionManager);
	  history = (0, _RouterUtils.createRoutingHistory)(history, transitionManager);
	
	  transitionManager.match(location, function (error, redirectLocation, nextState) {
	    callback(error, redirectLocation && router.createLocation(redirectLocation, _Actions.REPLACE), nextState && _extends({}, nextState, {
	      history: history,
	      router: router,
	      matchContext: { history: history, transitionManager: transitionManager, router: router }
	    }));
	
	    // Defer removing the listener to here to prevent DOM histories from having
	    // to unwind DOM event listeners unnecessarily, in case callback renders a
	    // <Router> and attaches another history listener.
	    if (unlisten) {
	      unlisten();
	    }
	  });
	}
	
	exports.default = match;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = createMemoryHistory;
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(221);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	var _createMemoryHistory = __webpack_require__(222);
	
	var _createMemoryHistory2 = _interopRequireDefault(_createMemoryHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function createMemoryHistory(options) {
	  // signatures and type checking differ between `useRoutes` and
	  // `createMemoryHistory`, have to create `memoryHistory` first because
	  // `useQueries` doesn't understand the signature
	  var memoryHistory = (0, _createMemoryHistory2.default)(options);
	  var createHistory = function createHistory() {
	    return memoryHistory;
	  };
	  var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	  history.__v2_compatible__ = true;
	  return history;
	}
	module.exports = exports['default'];

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _PathUtils = __webpack_require__(179);
	
	var _runTransitionHook = __webpack_require__(190);
	
	var _runTransitionHook2 = _interopRequireDefault(_runTransitionHook);
	
	var _deprecate = __webpack_require__(191);
	
	var _deprecate2 = _interopRequireDefault(_deprecate);
	
	function useBasename(createHistory) {
	  return function () {
	    var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	    var history = createHistory(options);
	
	    var basename = options.basename;
	
	    var checkedBaseHref = false;
	
	    function checkBaseHref() {
	      if (checkedBaseHref) {
	        return;
	      }
	
	      // Automatically use the value of <base href> in HTML
	      // documents as basename if it's not explicitly given.
	      if (basename == null && _ExecutionEnvironment.canUseDOM) {
	        var base = document.getElementsByTagName('base')[0];
	        var baseHref = base && base.getAttribute('href');
	
	        if (baseHref != null) {
	          basename = baseHref;
	
	          process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Automatically setting basename using <base href> is deprecated and will ' + 'be removed in the next major release. The semantics of <base href> are ' + 'subtly different from basename. Please pass the basename explicitly in ' + 'the options to createHistory') : undefined;
	        }
	      }
	
	      checkedBaseHref = true;
	    }
	
	    function addBasename(location) {
	      checkBaseHref();
	
	      if (basename && location.basename == null) {
	        if (location.pathname.indexOf(basename) === 0) {
	          location.pathname = location.pathname.substring(basename.length);
	          location.basename = basename;
	
	          if (location.pathname === '') location.pathname = '/';
	        } else {
	          location.basename = '';
	        }
	      }
	
	      return location;
	    }
	
	    function prependBasename(location) {
	      checkBaseHref();
	
	      if (!basename) return location;
	
	      if (typeof location === 'string') location = _PathUtils.parsePath(location);
	
	      var pname = location.pathname;
	      var normalizedBasename = basename.slice(-1) === '/' ? basename : basename + '/';
	      var normalizedPathname = pname.charAt(0) === '/' ? pname.slice(1) : pname;
	      var pathname = normalizedBasename + normalizedPathname;
	
	      return _extends({}, location, {
	        pathname: pathname
	      });
	    }
	
	    // Override all read methods with basename-aware versions.
	    function listenBefore(hook) {
	      return history.listenBefore(function (location, callback) {
	        _runTransitionHook2['default'](hook, addBasename(location), callback);
	      });
	    }
	
	    function listen(listener) {
	      return history.listen(function (location) {
	        listener(addBasename(location));
	      });
	    }
	
	    // Override all write methods with basename-aware versions.
	    function push(location) {
	      history.push(prependBasename(location));
	    }
	
	    function replace(location) {
	      history.replace(prependBasename(location));
	    }
	
	    function createPath(location) {
	      return history.createPath(prependBasename(location));
	    }
	
	    function createHref(location) {
	      return history.createHref(prependBasename(location));
	    }
	
	    function createLocation(location) {
	      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        args[_key - 1] = arguments[_key];
	      }
	
	      return addBasename(history.createLocation.apply(history, [prependBasename(location)].concat(args)));
	    }
	
	    // deprecated
	    function pushState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      push(_extends({ state: state }, path));
	    }
	
	    // deprecated
	    function replaceState(state, path) {
	      if (typeof path === 'string') path = _PathUtils.parsePath(path);
	
	      replace(_extends({ state: state }, path));
	    }
	
	    return _extends({}, history, {
	      listenBefore: listenBefore,
	      listen: listen,
	      push: push,
	      replace: replace,
	      createPath: createPath,
	      createHref: createHref,
	      createLocation: createLocation,
	
	      pushState: _deprecate2['default'](pushState, 'pushState is deprecated; use push instead'),
	      replaceState: _deprecate2['default'](replaceState, 'replaceState is deprecated; use replace instead')
	    });
	  };
	}
	
	exports['default'] = useBasename;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _warning = __webpack_require__(177);
	
	var _warning2 = _interopRequireDefault(_warning);
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _PathUtils = __webpack_require__(179);
	
	var _Actions = __webpack_require__(178);
	
	var _createHistory = __webpack_require__(184);
	
	var _createHistory2 = _interopRequireDefault(_createHistory);
	
	function createStateStorage(entries) {
	  return entries.filter(function (entry) {
	    return entry.state;
	  }).reduce(function (memo, entry) {
	    memo[entry.key] = entry.state;
	    return memo;
	  }, {});
	}
	
	function createMemoryHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  if (Array.isArray(options)) {
	    options = { entries: options };
	  } else if (typeof options === 'string') {
	    options = { entries: [options] };
	  }
	
	  var history = _createHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: saveState,
	    go: go
	  }));
	
	  var _options = options;
	  var entries = _options.entries;
	  var current = _options.current;
	
	  if (typeof entries === 'string') {
	    entries = [entries];
	  } else if (!Array.isArray(entries)) {
	    entries = ['/'];
	  }
	
	  entries = entries.map(function (entry) {
	    var key = history.createKey();
	
	    if (typeof entry === 'string') return { pathname: entry, key: key };
	
	    if ((typeof entry === 'undefined' ? 'undefined' : _typeof(entry)) === 'object' && entry) return _extends({}, entry, { key: key });
	
	     true ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Unable to create history entry from %s', entry) : _invariant2['default'](false) : undefined;
	  });
	
	  if (current == null) {
	    current = entries.length - 1;
	  } else {
	    !(current >= 0 && current < entries.length) ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Current index must be >= 0 and < %s, was %s', entries.length, current) : _invariant2['default'](false) : undefined;
	  }
	
	  var storage = createStateStorage(entries);
	
	  function saveState(key, state) {
	    storage[key] = state;
	  }
	
	  function readState(key) {
	    return storage[key];
	  }
	
	  function getCurrentLocation() {
	    var entry = entries[current];
	    var basename = entry.basename;
	    var pathname = entry.pathname;
	    var search = entry.search;
	
	    var path = (basename || '') + pathname + (search || '');
	
	    var key = undefined,
	        state = undefined;
	    if (entry.key) {
	      key = entry.key;
	      state = readState(key);
	    } else {
	      key = history.createKey();
	      state = null;
	      entry.key = key;
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function canGo(n) {
	    var index = current + n;
	    return index >= 0 && index < entries.length;
	  }
	
	  function go(n) {
	    if (n) {
	      if (!canGo(n)) {
	        process.env.NODE_ENV !== 'production' ? _warning2['default'](false, 'Cannot go(%s) there is not enough history', n) : undefined;
	        return;
	      }
	
	      current += n;
	
	      var currentLocation = getCurrentLocation();
	
	      // change action to POP
	      history.transitionTo(_extends({}, currentLocation, { action: _Actions.POP }));
	    }
	  }
	
	  function finishTransition(location) {
	    switch (location.action) {
	      case _Actions.PUSH:
	        current += 1;
	
	        // if we are not on the top of stack
	        // remove rest and push new
	        if (current < entries.length) entries.splice(current);
	
	        entries.push(location);
	        saveState(location.key, location.state);
	        break;
	      case _Actions.REPLACE:
	        entries[current] = location;
	        saveState(location.key, location.state);
	        break;
	    }
	  }
	
	  return history;
	}
	
	exports['default'] = createMemoryHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	exports.default = useRouterHistory;
	
	var _useQueries = __webpack_require__(192);
	
	var _useQueries2 = _interopRequireDefault(_useQueries);
	
	var _useBasename = __webpack_require__(221);
	
	var _useBasename2 = _interopRequireDefault(_useBasename);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	function useRouterHistory(createHistory) {
	  return function (options) {
	    var history = (0, _useQueries2.default)((0, _useBasename2.default)(createHistory))(options);
	    history.__v2_compatible__ = true;
	    return history;
	  };
	}
	module.exports = exports['default'];

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	var _react = __webpack_require__(8);
	
	var _react2 = _interopRequireDefault(_react);
	
	var _RouterContext = __webpack_require__(203);
	
	var _RouterContext2 = _interopRequireDefault(_RouterContext);
	
	var _routerWarning = __webpack_require__(170);
	
	var _routerWarning2 = _interopRequireDefault(_routerWarning);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = function () {
	  for (var _len = arguments.length, middlewares = Array(_len), _key = 0; _key < _len; _key++) {
	    middlewares[_key] = arguments[_key];
	  }
	
	  if (process.env.NODE_ENV !== 'production') {
	    middlewares.forEach(function (middleware, index) {
	      process.env.NODE_ENV !== 'production' ? (0, _routerWarning2.default)(middleware.renderRouterContext || middleware.renderRouteComponent, 'The middleware specified at index ' + index + ' does not appear to be ' + 'a valid React Router middleware.') : void 0;
	    });
	  }
	
	  var withContext = middlewares.map(function (middleware) {
	    return middleware.renderRouterContext;
	  }).filter(Boolean);
	  var withComponent = middlewares.map(function (middleware) {
	    return middleware.renderRouteComponent;
	  }).filter(Boolean);
	
	  var makeCreateElement = function makeCreateElement() {
	    var baseCreateElement = arguments.length <= 0 || arguments[0] === undefined ? _react.createElement : arguments[0];
	    return function (Component, props) {
	      return withComponent.reduceRight(function (previous, renderRouteComponent) {
	        return renderRouteComponent(previous, props);
	      }, baseCreateElement(Component, props));
	    };
	  };
	
	  return function (renderProps) {
	    return withContext.reduceRight(function (previous, renderRouterContext) {
	      return renderRouterContext(previous, renderProps);
	    }, _react2.default.createElement(_RouterContext2.default, _extends({}, renderProps, {
	      createElement: makeCreateElement(renderProps.createElement)
	    })));
	  };
	};
	
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createBrowserHistory = __webpack_require__(226);
	
	var _createBrowserHistory2 = _interopRequireDefault(_createBrowserHistory);
	
	var _createRouterHistory = __webpack_require__(227);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createBrowserHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process) {'use strict';
	
	exports.__esModule = true;
	
	var _extends = Object.assign || function (target) {
	  for (var i = 1; i < arguments.length; i++) {
	    var source = arguments[i];for (var key in source) {
	      if (Object.prototype.hasOwnProperty.call(source, key)) {
	        target[key] = source[key];
	      }
	    }
	  }return target;
	};
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { 'default': obj };
	}
	
	var _invariant = __webpack_require__(174);
	
	var _invariant2 = _interopRequireDefault(_invariant);
	
	var _Actions = __webpack_require__(178);
	
	var _PathUtils = __webpack_require__(179);
	
	var _ExecutionEnvironment = __webpack_require__(180);
	
	var _DOMUtils = __webpack_require__(181);
	
	var _DOMStateStorage = __webpack_require__(182);
	
	var _createDOMHistory = __webpack_require__(183);
	
	var _createDOMHistory2 = _interopRequireDefault(_createDOMHistory);
	
	/**
	 * Creates and returns a history object that uses HTML5's history API
	 * (pushState, replaceState, and the popstate event) to manage history.
	 * This is the recommended method of managing history in browsers because
	 * it provides the cleanest URLs.
	 *
	 * Note: In browsers that do not support the HTML5 history API full
	 * page reloads will be used to preserve URLs.
	 */
	function createBrowserHistory() {
	  var options = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];
	
	  !_ExecutionEnvironment.canUseDOM ? process.env.NODE_ENV !== 'production' ? _invariant2['default'](false, 'Browser history needs a DOM') : _invariant2['default'](false) : undefined;
	
	  var forceRefresh = options.forceRefresh;
	
	  var isSupported = _DOMUtils.supportsHistory();
	  var useRefresh = !isSupported || forceRefresh;
	
	  function getCurrentLocation(historyState) {
	    try {
	      historyState = historyState || window.history.state || {};
	    } catch (e) {
	      historyState = {};
	    }
	
	    var path = _DOMUtils.getWindowPath();
	    var _historyState = historyState;
	    var key = _historyState.key;
	
	    var state = undefined;
	    if (key) {
	      state = _DOMStateStorage.readState(key);
	    } else {
	      state = null;
	      key = history.createKey();
	
	      if (isSupported) window.history.replaceState(_extends({}, historyState, { key: key }), null);
	    }
	
	    var location = _PathUtils.parsePath(path);
	
	    return history.createLocation(_extends({}, location, { state: state }), undefined, key);
	  }
	
	  function startPopStateListener(_ref) {
	    var transitionTo = _ref.transitionTo;
	
	    function popStateListener(event) {
	      if (event.state === undefined) return; // Ignore extraneous popstate events in WebKit.
	
	      transitionTo(getCurrentLocation(event.state));
	    }
	
	    _DOMUtils.addEventListener(window, 'popstate', popStateListener);
	
	    return function () {
	      _DOMUtils.removeEventListener(window, 'popstate', popStateListener);
	    };
	  }
	
	  function finishTransition(location) {
	    var basename = location.basename;
	    var pathname = location.pathname;
	    var search = location.search;
	    var hash = location.hash;
	    var state = location.state;
	    var action = location.action;
	    var key = location.key;
	
	    if (action === _Actions.POP) return; // Nothing to do.
	
	    _DOMStateStorage.saveState(key, state);
	
	    var path = (basename || '') + pathname + search + hash;
	    var historyState = {
	      key: key
	    };
	
	    if (action === _Actions.PUSH) {
	      if (useRefresh) {
	        window.location.href = path;
	        return false; // Prevent location update.
	      } else {
	        window.history.pushState(historyState, null, path);
	      }
	    } else {
	      // REPLACE
	      if (useRefresh) {
	        window.location.replace(path);
	        return false; // Prevent location update.
	      } else {
	        window.history.replaceState(historyState, null, path);
	      }
	    }
	  }
	
	  var history = _createDOMHistory2['default'](_extends({}, options, {
	    getCurrentLocation: getCurrentLocation,
	    finishTransition: finishTransition,
	    saveState: _DOMStateStorage.saveState
	  }));
	
	  var listenerCount = 0,
	      stopPopStateListener = undefined;
	
	  function listenBefore(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listenBefore(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  function listen(listener) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    var unlisten = history.listen(listener);
	
	    return function () {
	      unlisten();
	
	      if (--listenerCount === 0) stopPopStateListener();
	    };
	  }
	
	  // deprecated
	  function registerTransitionHook(hook) {
	    if (++listenerCount === 1) stopPopStateListener = startPopStateListener(history);
	
	    history.registerTransitionHook(hook);
	  }
	
	  // deprecated
	  function unregisterTransitionHook(hook) {
	    history.unregisterTransitionHook(hook);
	
	    if (--listenerCount === 0) stopPopStateListener();
	  }
	
	  return _extends({}, history, {
	    listenBefore: listenBefore,
	    listen: listen,
	    registerTransitionHook: registerTransitionHook,
	    unregisterTransitionHook: unregisterTransitionHook
	  });
	}
	
	exports['default'] = createBrowserHistory;
	module.exports = exports['default'];
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(11)))

/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	exports.default = function (createHistory) {
	  var history = void 0;
	  if (canUseDOM) history = (0, _useRouterHistory2.default)(createHistory)();
	  return history;
	};
	
	var _useRouterHistory = __webpack_require__(223);
	
	var _useRouterHistory2 = _interopRequireDefault(_useRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
	
	module.exports = exports['default'];

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.__esModule = true;
	
	var _createHashHistory = __webpack_require__(176);
	
	var _createHashHistory2 = _interopRequireDefault(_createHashHistory);
	
	var _createRouterHistory = __webpack_require__(227);
	
	var _createRouterHistory2 = _interopRequireDefault(_createRouterHistory);
	
	function _interopRequireDefault(obj) {
	  return obj && obj.__esModule ? obj : { default: obj };
	}
	
	exports.default = (0, _createRouterHistory2.default)(_createHashHistory2.default);
	module.exports = exports['default'];

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	//komponente
	var Navigation = __webpack_require__(230);
	
	var Main = function Main(props) {
	    return React.createElement(
	        'div',
	        null,
	        React.createElement(Navigation, null),
	        React.createElement(
	            'div',
	            { className: 'row' },
	            React.createElement(
	                'div',
	                { className: 'column small-centered medium-6 large-4' },
	                props.children
	            )
	        )
	    );
	};
	
	module.exports = Main;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var _require = __webpack_require__(166),
	    Link = _require.Link,
	    IndexLink = _require.IndexLink;
	
	var Navigation = function Navigation() {
	    return React.createElement(
	        'div',
	        { className: 'top-bar' },
	        React.createElement(
	            'div',
	            { className: 'top-bar-left' },
	            React.createElement(
	                'ul',
	                { className: 'menu' },
	                React.createElement(
	                    'li',
	                    { className: 'menu-text' },
	                    'React - TimerApp'
	                ),
	                React.createElement(
	                    'li',
	                    null,
	                    React.createElement(
	                        IndexLink,
	                        { to: '/', activeClassName: 'active-link' },
	                        'Timer'
	                    )
	                ),
	                React.createElement(
	                    'li',
	                    null,
	                    React.createElement(
	                        IndexLink,
	                        { to: '/countdown', activeClassName: 'active-link' },
	                        'Odbrojavanje'
	                    )
	                )
	            )
	        ),
	        React.createElement(
	            'div',
	            { className: 'top-bar-right' },
	            React.createElement(
	                'ul',
	                { className: 'menu' },
	                React.createElement(
	                    'li',
	                    { className: 'menu-text' },
	                    'Naprevljeno od: ',
	                    React.createElement(
	                        'a',
	                        { href: 'https://github.com/blevajac', target: '_blank' },
	                        'Boris Levajac'
	                    )
	                )
	            )
	        )
	    );
	};
	
	module.exports = Navigation;

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var Timer = React.createClass({
	    displayName: 'Timer',
	
	    render: function render() {
	        return React.createElement(
	            'p',
	            null,
	            'timer.jsx'
	        );
	    }
	});
	
	module.exports = Timer;

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var Clock = __webpack_require__(233);
	var CountdownForm = __webpack_require__(234);
	var Controls = __webpack_require__(241);
	
	var Countdown = React.createClass({
	    displayName: 'Countdown',
	
	    getInitialState: function getInitialState() {
	        return {
	            count: 0,
	            countdownStatus: 'stopped'
	        };
	    },
	    componentDidUpdate: function componentDidUpdate(prevProps, prevState) {
	        if (this.state.countdownStatus !== prevState.countdownStatus) {
	            switch (this.state.countdownStatus) {
	                case 'started':
	                    this.startTimer();
	                    break;
	                case 'stopped':
	                    this.setState({ count: 0 });
	                case 'paused':
	                    clearInterval(this.timer);
	                    this.timer = undefined;
	                    break;
	            };
	        };
	    },
	    startTimer: function startTimer() {
	        var _this = this;
	
	        this.timer = setInterval(function () {
	            var newCount = _this.state.count - 1;
	            _this.setState({
	                count: newCount >= 0 ? newCount : 0
	            });
	        }, 1000);
	    },
	    handleSetCountdown: function handleSetCountdown(seconds) {
	        this.setState({
	            count: seconds,
	            countdownStatus: 'started'
	        });
	    },
	    handleStatusChange: function handleStatusChange(newStatus) {
	        this.setState({ countdownStatus: newStatus });
	    },
	    render: function render() {
	        var _this2 = this;
	
	        var _state = this.state,
	            count = _state.count,
	            countdownStatus = _state.countdownStatus;
	
	        var renderControlArea = function renderControlArea() {
	            if (countdownStatus !== 'stopped') {
	                return React.createElement(Controls, { countdownStatus: countdownStatus, onStatusChange: _this2.handleStatusChange });
	            } else {
	                return React.createElement(CountdownForm, { onSetCountdown: _this2.handleSetCountdown });
	            }
	        };
	
	        return React.createElement(
	            'div',
	            null,
	            React.createElement(Clock, { totalSeconds: count }),
	            renderControlArea()
	        );
	    }
	});
	
	module.exports = Countdown;

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var Clock = React.createClass({
	    displayName: 'Clock',
	
	    getDefaultProps: function getDefaultProps() {
	        totalSeconds: 0;
	    },
	    propTypes: {
	        totalSeconds: React.PropTypes.number
	    },
	    formatSeconds: function formatSeconds(totalSeconds) {
	        var seconds = totalSeconds % 60;
	        var minutes = Math.floor(totalSeconds / 60);
	
	        if (seconds < 10) {
	            seconds = '0' + seconds;
	        }
	
	        if (minutes < 10) {
	            minutes = '0' + minutes;
	        }
	
	        return minutes + ':' + seconds;
	    },
	    render: function render() {
	        var totalSeconds = this.props.totalSeconds;
	
	
	        return React.createElement(
	            'div',
	            { className: 'clock' },
	            React.createElement(
	                'span',
	                { className: 'clock-text' },
	                this.formatSeconds(totalSeconds)
	            )
	        );
	    }
	});
	
	module.exports = Clock;

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var CountdownForm = React.createClass({
	    displayName: 'CountdownForm',
	
	    onSubmit: function onSubmit(e) {
	        e.preventDefault();
	
	        var strSeconds = this.refs.seconds.value;
	
	        if (strSeconds.match(/^[0-9]*$/)) {
	            this.refs.seconds.value = '';
	            this.props.onSetCountdown(parseInt(strSeconds, 10));
	        };
	    },
	    render: function render() {
	        return React.createElement(
	            'div',
	            null,
	            React.createElement(
	                'form',
	                { ref: 'form', onSubmit: this.onSubmit, className: 'countdown-form' },
	                React.createElement('input', { type: 'text', ref: 'seconds', placeholder: 'Unesite vrijeme u sekundama' }),
	                React.createElement(
	                    'button',
	                    { className: 'button expanded' },
	                    'Start'
	                )
	            )
	        );
	    }
	});
	
	module.exports = CountdownForm;

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(236);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(238)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../css-loader/index.js!./foundation.min.css", function() {
				var newContent = require("!!./../../css-loader/index.js!./foundation.min.css");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(237)();
	// imports
	
	
	// module
	exports.push([module.id, "@charset \"UTF-8\";\n/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{box-sizing:content-box;height:0}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:not-allowed}button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}input{line-height:normal}input[type=checkbox],input[type=radio]{box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-appearance:textfield;box-sizing:content-box}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}legend{border:0;padding:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-collapse:collapse;border-spacing:0}td,th{padding:0}.foundation-mq{font-family:\"small=0em&medium=40em&large=64em&xlarge=75em&xxlarge=90em\"}html{font-size:100%;box-sizing:border-box}*,:after,:before{box-sizing:inherit}body{padding:0;margin:0;font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;line-height:1.5;color:#0a0a0a;background:#fefefe;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}img{max-width:100%;height:auto;-ms-interpolation-mode:bicubic;display:inline-block;vertical-align:middle}textarea{height:auto;min-height:50px;border-radius:0}select{width:100%;border-radius:0}#map_canvas embed,#map_canvas img,#map_canvas object,.map_canvas embed,.map_canvas img,.map_canvas object,.mqa-display embed,.mqa-display img,.mqa-display object{max-width:none!important}button{-webkit-appearance:none;-moz-appearance:none;background:transparent;padding:0;border:0;border-radius:0;line-height:1}[data-whatinput=mouse] button{outline:0}.is-visible{display:block!important}.is-hidden{display:none!important}.row{max-width:75rem;margin-left:auto;margin-right:auto}.row:after,.row:before{content:' ';display:table}.row:after{clear:both}.row.collapse>.column,.row.collapse>.columns{padding-left:0;padding-right:0}.row .row{margin-left:-.625rem;margin-right:-.625rem}@media screen and (min-width:40em){.row .row{margin-left:-.9375rem;margin-right:-.9375rem}}.row .row.collapse{margin-left:0;margin-right:0}.row.expanded{max-width:none}.row.expanded .row{margin-left:auto;margin-right:auto}.column,.columns{width:100%;float:left;padding-left:.625rem;padding-right:.625rem}@media screen and (min-width:40em){.column,.columns{padding-left:.9375rem;padding-right:.9375rem}}.column:last-child:not(:first-child),.columns:last-child:not(:first-child){float:right}.column.end:last-child:last-child,.end.columns:last-child:last-child{float:left}.column.row.row,.row.row.columns{float:none}.row .column.row.row,.row .row.row.columns{padding-left:0;padding-right:0;margin-left:0;margin-right:0}.small-1{width:8.33333%}.small-push-1{position:relative;left:8.33333%}.small-pull-1{position:relative;left:-8.33333%}.small-offset-0{margin-left:0}.small-2{width:16.66667%}.small-push-2{position:relative;left:16.66667%}.small-pull-2{position:relative;left:-16.66667%}.small-offset-1{margin-left:8.33333%}.small-3{width:25%}.small-push-3{position:relative;left:25%}.small-pull-3{position:relative;left:-25%}.small-offset-2{margin-left:16.66667%}.small-4{width:33.33333%}.small-push-4{position:relative;left:33.33333%}.small-pull-4{position:relative;left:-33.33333%}.small-offset-3{margin-left:25%}.small-5{width:41.66667%}.small-push-5{position:relative;left:41.66667%}.small-pull-5{position:relative;left:-41.66667%}.small-offset-4{margin-left:33.33333%}.small-6{width:50%}.small-push-6{position:relative;left:50%}.small-pull-6{position:relative;left:-50%}.small-offset-5{margin-left:41.66667%}.small-7{width:58.33333%}.small-push-7{position:relative;left:58.33333%}.small-pull-7{position:relative;left:-58.33333%}.small-offset-6{margin-left:50%}.small-8{width:66.66667%}.small-push-8{position:relative;left:66.66667%}.small-pull-8{position:relative;left:-66.66667%}.small-offset-7{margin-left:58.33333%}.small-9{width:75%}.small-push-9{position:relative;left:75%}.small-pull-9{position:relative;left:-75%}.small-offset-8{margin-left:66.66667%}.small-10{width:83.33333%}.small-push-10{position:relative;left:83.33333%}.small-pull-10{position:relative;left:-83.33333%}.small-offset-9{margin-left:75%}.small-11{width:91.66667%}.small-push-11{position:relative;left:91.66667%}.small-pull-11{position:relative;left:-91.66667%}.small-offset-10{margin-left:83.33333%}.small-12{width:100%}.small-offset-11{margin-left:91.66667%}.small-up-1>.column,.small-up-1>.columns{width:100%;float:left}.small-up-1>.column:nth-of-type(1n),.small-up-1>.columns:nth-of-type(1n){clear:none}.small-up-1>.column:nth-of-type(1n+1),.small-up-1>.columns:nth-of-type(1n+1){clear:both}.small-up-1>.column:last-child,.small-up-1>.columns:last-child{float:left}.small-up-2>.column,.small-up-2>.columns{width:50%;float:left}.small-up-2>.column:nth-of-type(1n),.small-up-2>.columns:nth-of-type(1n){clear:none}.small-up-2>.column:nth-of-type(2n+1),.small-up-2>.columns:nth-of-type(2n+1){clear:both}.small-up-2>.column:last-child,.small-up-2>.columns:last-child{float:left}.small-up-3>.column,.small-up-3>.columns{width:33.33333%;float:left}.small-up-3>.column:nth-of-type(1n),.small-up-3>.columns:nth-of-type(1n){clear:none}.small-up-3>.column:nth-of-type(3n+1),.small-up-3>.columns:nth-of-type(3n+1){clear:both}.small-up-3>.column:last-child,.small-up-3>.columns:last-child{float:left}.small-up-4>.column,.small-up-4>.columns{width:25%;float:left}.small-up-4>.column:nth-of-type(1n),.small-up-4>.columns:nth-of-type(1n){clear:none}.small-up-4>.column:nth-of-type(4n+1),.small-up-4>.columns:nth-of-type(4n+1){clear:both}.small-up-4>.column:last-child,.small-up-4>.columns:last-child{float:left}.small-up-5>.column,.small-up-5>.columns{width:20%;float:left}.small-up-5>.column:nth-of-type(1n),.small-up-5>.columns:nth-of-type(1n){clear:none}.small-up-5>.column:nth-of-type(5n+1),.small-up-5>.columns:nth-of-type(5n+1){clear:both}.small-up-5>.column:last-child,.small-up-5>.columns:last-child{float:left}.small-up-6>.column,.small-up-6>.columns{width:16.66667%;float:left}.small-up-6>.column:nth-of-type(1n),.small-up-6>.columns:nth-of-type(1n){clear:none}.small-up-6>.column:nth-of-type(6n+1),.small-up-6>.columns:nth-of-type(6n+1){clear:both}.small-up-6>.column:last-child,.small-up-6>.columns:last-child{float:left}.small-up-7>.column,.small-up-7>.columns{width:14.28571%;float:left}.small-up-7>.column:nth-of-type(1n),.small-up-7>.columns:nth-of-type(1n){clear:none}.small-up-7>.column:nth-of-type(7n+1),.small-up-7>.columns:nth-of-type(7n+1){clear:both}.small-up-7>.column:last-child,.small-up-7>.columns:last-child{float:left}.small-up-8>.column,.small-up-8>.columns{width:12.5%;float:left}.small-up-8>.column:nth-of-type(1n),.small-up-8>.columns:nth-of-type(1n){clear:none}.small-up-8>.column:nth-of-type(8n+1),.small-up-8>.columns:nth-of-type(8n+1){clear:both}.small-up-8>.column:last-child,.small-up-8>.columns:last-child{float:left}.small-collapse>.column,.small-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .small-collapse.row,.small-collapse .row{margin-left:0;margin-right:0}.small-uncollapse>.column,.small-uncollapse>.columns{padding-left:.625rem;padding-right:.625rem}.small-centered{margin-left:auto;margin-right:auto}.small-centered,.small-centered:last-child:not(:first-child){float:none;clear:both}.small-pull-0,.small-push-0,.small-uncentered{position:static;margin-left:0;margin-right:0;float:left}@media screen and (min-width:40em){.medium-1{width:8.33333%}.medium-push-1{position:relative;left:8.33333%}.medium-pull-1{position:relative;left:-8.33333%}.medium-offset-0{margin-left:0}.medium-2{width:16.66667%}.medium-push-2{position:relative;left:16.66667%}.medium-pull-2{position:relative;left:-16.66667%}.medium-offset-1{margin-left:8.33333%}.medium-3{width:25%}.medium-push-3{position:relative;left:25%}.medium-pull-3{position:relative;left:-25%}.medium-offset-2{margin-left:16.66667%}.medium-4{width:33.33333%}.medium-push-4{position:relative;left:33.33333%}.medium-pull-4{position:relative;left:-33.33333%}.medium-offset-3{margin-left:25%}.medium-5{width:41.66667%}.medium-push-5{position:relative;left:41.66667%}.medium-pull-5{position:relative;left:-41.66667%}.medium-offset-4{margin-left:33.33333%}.medium-6{width:50%}.medium-push-6{position:relative;left:50%}.medium-pull-6{position:relative;left:-50%}.medium-offset-5{margin-left:41.66667%}.medium-7{width:58.33333%}.medium-push-7{position:relative;left:58.33333%}.medium-pull-7{position:relative;left:-58.33333%}.medium-offset-6{margin-left:50%}.medium-8{width:66.66667%}.medium-push-8{position:relative;left:66.66667%}.medium-pull-8{position:relative;left:-66.66667%}.medium-offset-7{margin-left:58.33333%}.medium-9{width:75%}.medium-push-9{position:relative;left:75%}.medium-pull-9{position:relative;left:-75%}.medium-offset-8{margin-left:66.66667%}.medium-10{width:83.33333%}.medium-push-10{position:relative;left:83.33333%}.medium-pull-10{position:relative;left:-83.33333%}.medium-offset-9{margin-left:75%}.medium-11{width:91.66667%}.medium-push-11{position:relative;left:91.66667%}.medium-pull-11{position:relative;left:-91.66667%}.medium-offset-10{margin-left:83.33333%}.medium-12{width:100%}.medium-offset-11{margin-left:91.66667%}.medium-up-1>.column,.medium-up-1>.columns{width:100%;float:left}.medium-up-1>.column:nth-of-type(1n),.medium-up-1>.columns:nth-of-type(1n){clear:none}.medium-up-1>.column:nth-of-type(1n+1),.medium-up-1>.columns:nth-of-type(1n+1){clear:both}.medium-up-1>.column:last-child,.medium-up-1>.columns:last-child{float:left}.medium-up-2>.column,.medium-up-2>.columns{width:50%;float:left}.medium-up-2>.column:nth-of-type(1n),.medium-up-2>.columns:nth-of-type(1n){clear:none}.medium-up-2>.column:nth-of-type(2n+1),.medium-up-2>.columns:nth-of-type(2n+1){clear:both}.medium-up-2>.column:last-child,.medium-up-2>.columns:last-child{float:left}.medium-up-3>.column,.medium-up-3>.columns{width:33.33333%;float:left}.medium-up-3>.column:nth-of-type(1n),.medium-up-3>.columns:nth-of-type(1n){clear:none}.medium-up-3>.column:nth-of-type(3n+1),.medium-up-3>.columns:nth-of-type(3n+1){clear:both}.medium-up-3>.column:last-child,.medium-up-3>.columns:last-child{float:left}.medium-up-4>.column,.medium-up-4>.columns{width:25%;float:left}.medium-up-4>.column:nth-of-type(1n),.medium-up-4>.columns:nth-of-type(1n){clear:none}.medium-up-4>.column:nth-of-type(4n+1),.medium-up-4>.columns:nth-of-type(4n+1){clear:both}.medium-up-4>.column:last-child,.medium-up-4>.columns:last-child{float:left}.medium-up-5>.column,.medium-up-5>.columns{width:20%;float:left}.medium-up-5>.column:nth-of-type(1n),.medium-up-5>.columns:nth-of-type(1n){clear:none}.medium-up-5>.column:nth-of-type(5n+1),.medium-up-5>.columns:nth-of-type(5n+1){clear:both}.medium-up-5>.column:last-child,.medium-up-5>.columns:last-child{float:left}.medium-up-6>.column,.medium-up-6>.columns{width:16.66667%;float:left}.medium-up-6>.column:nth-of-type(1n),.medium-up-6>.columns:nth-of-type(1n){clear:none}.medium-up-6>.column:nth-of-type(6n+1),.medium-up-6>.columns:nth-of-type(6n+1){clear:both}.medium-up-6>.column:last-child,.medium-up-6>.columns:last-child{float:left}.medium-up-7>.column,.medium-up-7>.columns{width:14.28571%;float:left}.medium-up-7>.column:nth-of-type(1n),.medium-up-7>.columns:nth-of-type(1n){clear:none}.medium-up-7>.column:nth-of-type(7n+1),.medium-up-7>.columns:nth-of-type(7n+1){clear:both}.medium-up-7>.column:last-child,.medium-up-7>.columns:last-child{float:left}.medium-up-8>.column,.medium-up-8>.columns{width:12.5%;float:left}.medium-up-8>.column:nth-of-type(1n),.medium-up-8>.columns:nth-of-type(1n){clear:none}.medium-up-8>.column:nth-of-type(8n+1),.medium-up-8>.columns:nth-of-type(8n+1){clear:both}.medium-up-8>.column:last-child,.medium-up-8>.columns:last-child{float:left}.medium-collapse>.column,.medium-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .medium-collapse.row,.medium-collapse .row{margin-left:0;margin-right:0}.medium-uncollapse>.column,.medium-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.medium-centered{margin-left:auto;margin-right:auto}.medium-centered,.medium-centered:last-child:not(:first-child){float:none;clear:both}.medium-pull-0,.medium-push-0,.medium-uncentered{position:static;margin-left:0;margin-right:0;float:left}}@media screen and (min-width:64em){.large-1{width:8.33333%}.large-push-1{position:relative;left:8.33333%}.large-pull-1{position:relative;left:-8.33333%}.large-offset-0{margin-left:0}.large-2{width:16.66667%}.large-push-2{position:relative;left:16.66667%}.large-pull-2{position:relative;left:-16.66667%}.large-offset-1{margin-left:8.33333%}.large-3{width:25%}.large-push-3{position:relative;left:25%}.large-pull-3{position:relative;left:-25%}.large-offset-2{margin-left:16.66667%}.large-4{width:33.33333%}.large-push-4{position:relative;left:33.33333%}.large-pull-4{position:relative;left:-33.33333%}.large-offset-3{margin-left:25%}.large-5{width:41.66667%}.large-push-5{position:relative;left:41.66667%}.large-pull-5{position:relative;left:-41.66667%}.large-offset-4{margin-left:33.33333%}.large-6{width:50%}.large-push-6{position:relative;left:50%}.large-pull-6{position:relative;left:-50%}.large-offset-5{margin-left:41.66667%}.large-7{width:58.33333%}.large-push-7{position:relative;left:58.33333%}.large-pull-7{position:relative;left:-58.33333%}.large-offset-6{margin-left:50%}.large-8{width:66.66667%}.large-push-8{position:relative;left:66.66667%}.large-pull-8{position:relative;left:-66.66667%}.large-offset-7{margin-left:58.33333%}.large-9{width:75%}.large-push-9{position:relative;left:75%}.large-pull-9{position:relative;left:-75%}.large-offset-8{margin-left:66.66667%}.large-10{width:83.33333%}.large-push-10{position:relative;left:83.33333%}.large-pull-10{position:relative;left:-83.33333%}.large-offset-9{margin-left:75%}.large-11{width:91.66667%}.large-push-11{position:relative;left:91.66667%}.large-pull-11{position:relative;left:-91.66667%}.large-offset-10{margin-left:83.33333%}.large-12{width:100%}.large-offset-11{margin-left:91.66667%}.large-up-1>.column,.large-up-1>.columns{width:100%;float:left}.large-up-1>.column:nth-of-type(1n),.large-up-1>.columns:nth-of-type(1n){clear:none}.large-up-1>.column:nth-of-type(1n+1),.large-up-1>.columns:nth-of-type(1n+1){clear:both}.large-up-1>.column:last-child,.large-up-1>.columns:last-child{float:left}.large-up-2>.column,.large-up-2>.columns{width:50%;float:left}.large-up-2>.column:nth-of-type(1n),.large-up-2>.columns:nth-of-type(1n){clear:none}.large-up-2>.column:nth-of-type(2n+1),.large-up-2>.columns:nth-of-type(2n+1){clear:both}.large-up-2>.column:last-child,.large-up-2>.columns:last-child{float:left}.large-up-3>.column,.large-up-3>.columns{width:33.33333%;float:left}.large-up-3>.column:nth-of-type(1n),.large-up-3>.columns:nth-of-type(1n){clear:none}.large-up-3>.column:nth-of-type(3n+1),.large-up-3>.columns:nth-of-type(3n+1){clear:both}.large-up-3>.column:last-child,.large-up-3>.columns:last-child{float:left}.large-up-4>.column,.large-up-4>.columns{width:25%;float:left}.large-up-4>.column:nth-of-type(1n),.large-up-4>.columns:nth-of-type(1n){clear:none}.large-up-4>.column:nth-of-type(4n+1),.large-up-4>.columns:nth-of-type(4n+1){clear:both}.large-up-4>.column:last-child,.large-up-4>.columns:last-child{float:left}.large-up-5>.column,.large-up-5>.columns{width:20%;float:left}.large-up-5>.column:nth-of-type(1n),.large-up-5>.columns:nth-of-type(1n){clear:none}.large-up-5>.column:nth-of-type(5n+1),.large-up-5>.columns:nth-of-type(5n+1){clear:both}.large-up-5>.column:last-child,.large-up-5>.columns:last-child{float:left}.large-up-6>.column,.large-up-6>.columns{width:16.66667%;float:left}.large-up-6>.column:nth-of-type(1n),.large-up-6>.columns:nth-of-type(1n){clear:none}.large-up-6>.column:nth-of-type(6n+1),.large-up-6>.columns:nth-of-type(6n+1){clear:both}.large-up-6>.column:last-child,.large-up-6>.columns:last-child{float:left}.large-up-7>.column,.large-up-7>.columns{width:14.28571%;float:left}.large-up-7>.column:nth-of-type(1n),.large-up-7>.columns:nth-of-type(1n){clear:none}.large-up-7>.column:nth-of-type(7n+1),.large-up-7>.columns:nth-of-type(7n+1){clear:both}.large-up-7>.column:last-child,.large-up-7>.columns:last-child{float:left}.large-up-8>.column,.large-up-8>.columns{width:12.5%;float:left}.large-up-8>.column:nth-of-type(1n),.large-up-8>.columns:nth-of-type(1n){clear:none}.large-up-8>.column:nth-of-type(8n+1),.large-up-8>.columns:nth-of-type(8n+1){clear:both}.large-up-8>.column:last-child,.large-up-8>.columns:last-child{float:left}.large-collapse>.column,.large-collapse>.columns{padding-left:0;padding-right:0}.expanded.row .large-collapse.row,.large-collapse .row{margin-left:0;margin-right:0}.large-uncollapse>.column,.large-uncollapse>.columns{padding-left:.9375rem;padding-right:.9375rem}.large-centered{margin-left:auto;margin-right:auto}.large-centered,.large-centered:last-child:not(:first-child){float:none;clear:both}.large-pull-0,.large-push-0,.large-uncentered{position:static;margin-left:0;margin-right:0;float:left}}blockquote,dd,div,dl,dt,form,h1,h2,h3,h4,h5,h6,li,ol,p,pre,td,th,ul{margin:0;padding:0}p{font-size:inherit;line-height:1.6;margin-bottom:1rem;text-rendering:optimizeLegibility}em,i{font-style:italic}b,em,i,strong{line-height:inherit}b,strong{font-weight:700}small{font-size:80%;line-height:inherit}h1,h2,h3,h4,h5,h6{font-family:Helvetica Neue,Helvetica,Roboto,Arial,sans-serif;font-weight:400;font-style:normal;color:inherit;text-rendering:optimizeLegibility;margin-top:0;margin-bottom:.5rem;line-height:1.4}h1 small,h2 small,h3 small,h4 small,h5 small,h6 small{color:#cacaca;line-height:0}h1{font-size:1.5rem}h2{font-size:1.25rem}h3{font-size:1.1875rem}h4{font-size:1.125rem}h5{font-size:1.0625rem}h6{font-size:1rem}@media screen and (min-width:40em){h1{font-size:3rem}h2{font-size:2.5rem}h3{font-size:1.9375rem}h4{font-size:1.5625rem}h5{font-size:1.25rem}h6{font-size:1rem}}a{color:#2199e8;text-decoration:none;line-height:inherit;cursor:pointer}a:focus,a:hover{color:#1585cf}a img{border:0}hr{max-width:75rem;height:0;border-right:0;border-top:0;border-bottom:1px solid #cacaca;border-left:0;margin:1.25rem auto;clear:both}dl,ol,ul{line-height:1.6;margin-bottom:1rem;list-style-position:outside}li{font-size:inherit}ul{list-style-type:disc}ol,ul{margin-left:1.25rem}ol ol,ol ul,ul ol,ul ul{margin-left:1.25rem;margin-bottom:0}dl{margin-bottom:1rem}dl dt{margin-bottom:.3rem;font-weight:700}blockquote{margin:0 0 1rem;padding:.5625rem 1.25rem 0 1.1875rem;border-left:1px solid #cacaca}blockquote,blockquote p{line-height:1.6;color:#8a8a8a}cite{display:block;font-size:.8125rem;color:#8a8a8a}cite:before{content:'\\2014    '}abbr{color:#0a0a0a;cursor:help;border-bottom:1px dotted #0a0a0a}code{font-weight:400;border:1px solid #cacaca;padding:.125rem .3125rem .0625rem}code,kbd{font-family:Consolas,Liberation Mono,Courier,monospace;color:#0a0a0a;background-color:#e6e6e6}kbd{padding:.125rem .25rem 0;margin:0}.subheader{margin-top:.2rem;margin-bottom:.5rem;font-weight:400;line-height:1.4;color:#8a8a8a}.lead{font-size:125%;line-height:1.6}.stat{font-size:2.5rem;line-height:1}p+.stat{margin-top:-1rem}.no-bullet{margin-left:0;list-style:none}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}@media screen and (min-width:40em){.medium-text-left{text-align:left}.medium-text-right{text-align:right}.medium-text-center{text-align:center}.medium-text-justify{text-align:justify}}@media screen and (min-width:64em){.large-text-left{text-align:left}.large-text-right{text-align:right}.large-text-center{text-align:center}.large-text-justify{text-align:justify}}.show-for-print{display:none!important}@media print{*{background:transparent!important;color:#000!important;box-shadow:none!important;text-shadow:none!important}.show-for-print{display:block!important}.hide-for-print{display:none!important}table.show-for-print{display:table!important}thead.show-for-print{display:table-header-group!important}tbody.show-for-print{display:table-row-group!important}tr.show-for-print{display:table-row!important}td.show-for-print,th.show-for-print{display:table-cell!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}.ir a:after,a[href^='#']:after,a[href^='javascript:']:after{content:''}abbr[title]:after{content:\" (\" attr(title) \")\"}blockquote,pre{border:1px solid #8a8a8a;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}@page{margin:.5cm}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}}[type=color],[type=date],[type=datetime-local],[type=datetime],[type=email],[type=month],[type=number],[type=password],[type=search],[type=tel],[type=text],[type=time],[type=url],[type=week],textarea{display:block;box-sizing:border-box;width:100%;height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-family:inherit;font-size:1rem;color:#0a0a0a;background-color:#fefefe;box-shadow:inset 0 1px 2px hsla(0,0%,4%,.1);border-radius:0;-webkit-transition:-webkit-box-shadow .5s,border-color .25s ease-in-out;transition:box-shadow .5s,border-color .25s ease-in-out;-webkit-appearance:none;-moz-appearance:none}[type=color]:focus,[type=date]:focus,[type=datetime-local]:focus,[type=datetime]:focus,[type=email]:focus,[type=month]:focus,[type=number]:focus,[type=password]:focus,[type=search]:focus,[type=tel]:focus,[type=text]:focus,[type=time]:focus,[type=url]:focus,[type=week]:focus,textarea:focus{border:1px solid #8a8a8a;background-color:#fefefe;outline:none;box-shadow:0 0 5px #cacaca;-webkit-transition:-webkit-box-shadow .5s,border-color .25s ease-in-out;transition:box-shadow .5s,border-color .25s ease-in-out}textarea{max-width:100%}textarea[rows]{height:auto}input::-webkit-input-placeholder,textarea::-webkit-input-placeholder{color:#cacaca}input::-moz-placeholder,textarea::-moz-placeholder{color:#cacaca}input:-ms-input-placeholder,textarea:-ms-input-placeholder{color:#cacaca}input::placeholder,textarea::placeholder{color:#cacaca}input:disabled,input[readonly],textarea:disabled,textarea[readonly]{background-color:#e6e6e6;cursor:not-allowed}[type=button],[type=submit]{border-radius:0;-webkit-appearance:none;-moz-appearance:none}input[type=search]{box-sizing:border-box}[type=checkbox],[type=file],[type=radio]{margin:0 0 1rem}[type=checkbox]+label,[type=radio]+label{display:inline-block;margin-left:.5rem;margin-right:1rem;margin-bottom:0;vertical-align:baseline}[type=checkbox]+label[for],[type=radio]+label[for]{cursor:pointer}label>[type=checkbox],label>[type=radio]{margin-right:.5rem}[type=file]{width:100%}label{display:block;margin:0;font-size:.875rem;font-weight:400;line-height:1.8;color:#0a0a0a}label.middle{margin:0 0 1rem;padding:.5625rem 0}.help-text{margin-top:-.5rem;font-size:.8125rem;font-style:italic;color:#0a0a0a}.input-group{display:table;width:100%;margin-bottom:1rem}.input-group>:first-child,.input-group>:last-child>*{border-radius:0 0 0 0}.input-group-button,.input-group-field,.input-group-label{margin:0;white-space:nowrap;display:table-cell;vertical-align:middle}.input-group-label{text-align:center;padding:0 1rem;background:#e6e6e6;color:#0a0a0a;border:1px solid #cacaca;white-space:nowrap;width:1%;height:100%}.input-group-label:first-child{border-right:0}.input-group-label:last-child{border-left:0}.input-group-field{border-radius:0;height:2.5rem}.input-group-button{padding-top:0;padding-bottom:0;text-align:center;height:100%;width:1%}.input-group-button a,.input-group-button button,.input-group-button input{margin:0}.input-group .input-group-button{display:table-cell}fieldset{border:0;padding:0;margin:0}legend{margin-bottom:.5rem;max-width:100%}.fieldset{border:1px solid #cacaca;padding:1.25rem;margin:1.125rem 0}.fieldset legend{background:#fefefe;padding:0 .1875rem;margin:0;margin-left:-.1875rem}select{height:2.4375rem;padding:.5rem;border:1px solid #cacaca;margin:0 0 1rem;font-size:1rem;font-family:inherit;line-height:normal;color:#0a0a0a;background-color:#fefefe;border-radius:0;-webkit-appearance:none;-moz-appearance:none;background-image:url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' version='1.1' width='32' height='24' viewBox='0 0 32 24'><polygon points='0,0 32,0 16,24' style='fill: rgb%28138, 138, 138%29'></polygon></svg>\");background-size:9px 6px;background-position:right -1rem center;background-origin:content-box;background-repeat:no-repeat;padding-right:1.5rem}@media screen and (min-width:0\\0){select{background-image:url(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYCAYAAACbU/80AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAIpJREFUeNrEkckNgDAMBBfRkEt0ObRBBdsGXUDgmQfK4XhH2m8czQAAy27R3tsw4Qfe2x8uOO6oYLb6GlOor3GF+swURAOmUJ+RwtEJs9WvTGEYxBXqI1MQAZhCfUQKRzDMVj+TwrAIV6jvSUEkYAr1LSkcyTBb/V+KYfX7xAeusq3sLDtGH3kEGACPWIflNZfhRQAAAABJRU5ErkJggg==\")}}select:disabled{background-color:#e6e6e6;cursor:not-allowed}select::-ms-expand{display:none}select[multiple]{height:auto;background-image:none}.is-invalid-input:not(:focus){background-color:rgba(236,88,64,.1);border-color:#ec5840}.form-error,.is-invalid-label{color:#ec5840}.form-error{display:none;margin-top:-.5rem;margin-bottom:1rem;font-size:.75rem;font-weight:700}.form-error.is-visible{display:block}.button{display:inline-block;text-align:center;line-height:1;cursor:pointer;-webkit-appearance:none;-webkit-transition:background-color .25s ease-out,color .25s ease-out;transition:background-color .25s ease-out,color .25s ease-out;vertical-align:middle;border:1px solid transparent;border-radius:0;padding:.85em 1em;margin:0 0 1rem;font-size:.9rem;background-color:#2199e8;color:#fefefe}[data-whatinput=mouse] .button{outline:0}.button:focus,.button:hover{background-color:#1583cc;color:#fefefe}.button.tiny{font-size:.6rem}.button.small{font-size:.75rem}.button.large{font-size:1.25rem}.button.expanded{display:block;width:100%;margin-left:0;margin-right:0}.button.primary{background-color:#2199e8;color:#fefefe}.button.primary:focus,.button.primary:hover{background-color:#147cc0;color:#fefefe}.button.secondary{background-color:#777;color:#fefefe}.button.secondary:focus,.button.secondary:hover{background-color:#5f5f5f;color:#fefefe}.button.success{background-color:#3adb76;color:#fefefe}.button.success:focus,.button.success:hover{background-color:#22bb5b;color:#fefefe}.button.warning{background-color:#ffae00;color:#fefefe}.button.warning:focus,.button.warning:hover{background-color:#cc8b00;color:#fefefe}.button.alert{background-color:#ec5840;color:#fefefe}.button.alert:focus,.button.alert:hover{background-color:#da3116;color:#fefefe}.button.hollow{border:1px solid #2199e8;color:#2199e8}.button.hollow,.button.hollow:focus,.button.hollow:hover{background-color:transparent}.button.hollow:focus,.button.hollow:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.primary{border:1px solid #2199e8;color:#2199e8}.button.hollow.primary:focus,.button.hollow.primary:hover{border-color:#0c4d78;color:#0c4d78}.button.hollow.secondary{border:1px solid #777;color:#777}.button.hollow.secondary:focus,.button.hollow.secondary:hover{border-color:#3c3c3c;color:#3c3c3c}.button.hollow.success{border:1px solid #3adb76;color:#3adb76}.button.hollow.success:focus,.button.hollow.success:hover{border-color:#157539;color:#157539}.button.hollow.warning{border:1px solid #ffae00;color:#ffae00}.button.hollow.warning:focus,.button.hollow.warning:hover{border-color:#805700;color:#805700}.button.hollow.alert{border:1px solid #ec5840;color:#ec5840}.button.hollow.alert:focus,.button.hollow.alert:hover{border-color:#881f0e;color:#881f0e}.button.disabled,.button[disabled]{opacity:.25;cursor:not-allowed}.button.disabled:focus,.button.disabled:hover,.button[disabled]:focus,.button[disabled]:hover{background-color:#2199e8;color:#fefefe}.button.disabled.primary,.button[disabled].primary{opacity:.25;cursor:not-allowed}.button.disabled.primary:focus,.button.disabled.primary:hover,.button[disabled].primary:focus,.button[disabled].primary:hover{background-color:#2199e8;color:#fefefe}.button.disabled.secondary,.button[disabled].secondary{opacity:.25;cursor:not-allowed}.button.disabled.secondary:focus,.button.disabled.secondary:hover,.button[disabled].secondary:focus,.button[disabled].secondary:hover{background-color:#777;color:#fefefe}.button.disabled.success,.button[disabled].success{opacity:.25;cursor:not-allowed}.button.disabled.success:focus,.button.disabled.success:hover,.button[disabled].success:focus,.button[disabled].success:hover{background-color:#3adb76;color:#fefefe}.button.disabled.warning,.button[disabled].warning{opacity:.25;cursor:not-allowed}.button.disabled.warning:focus,.button.disabled.warning:hover,.button[disabled].warning:focus,.button[disabled].warning:hover{background-color:#ffae00;color:#fefefe}.button.disabled.alert,.button[disabled].alert{opacity:.25;cursor:not-allowed}.button.disabled.alert:focus,.button.disabled.alert:hover,.button[disabled].alert:focus,.button[disabled].alert:hover{background-color:#ec5840;color:#fefefe}.button.dropdown:after{content:'';display:block;width:0;height:0;border:.4em inset;border-color:#fefefe transparent transparent;border-top-style:solid;border-bottom-width:0;position:relative;top:.4em;float:right;margin-left:1em;display:inline-block}.button.arrow-only:after{margin-left:0;float:none;top:-.1em}.accordion{list-style-type:none;background:#fefefe;margin-left:0}.accordion-item:first-child>:first-child,.accordion-item:last-child>:last-child{border-radius:0 0 0 0}.accordion-title{display:block;padding:1.25rem 1rem;line-height:1;font-size:.75rem;color:#2199e8;position:relative;border:1px solid #e6e6e6;border-bottom:0}:last-child:not(.is-active)>.accordion-title{border-radius:0 0 0 0;border-bottom:1px solid #e6e6e6}.accordion-title:focus,.accordion-title:hover{background-color:#e6e6e6}.accordion-title:before{content:'+';position:absolute;right:1rem;top:50%;margin-top:-.5rem}.is-active>.accordion-title:before{content:'\\2013'}.accordion-content{padding:1rem;display:none;border:1px solid #e6e6e6;border-bottom:0;background-color:#fefefe;color:#0a0a0a}:last-child>.accordion-content:last-child{border-bottom:1px solid #e6e6e6}.is-accordion-submenu-parent>a{position:relative}.is-accordion-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;position:absolute;top:50%;margin-top:-4px;right:1rem}.is-accordion-submenu-parent[aria-expanded=true]>a:after{-webkit-transform-origin:50% 50%;transform-origin:50% 50%;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.badge{display:inline-block;padding:.3em;min-width:2.1em;font-size:.6rem;text-align:center;border-radius:50%;background:#2199e8;color:#fefefe}.badge.secondary{background:#777;color:#fefefe}.badge.success{background:#3adb76;color:#fefefe}.badge.warning{background:#ffae00;color:#fefefe}.badge.alert{background:#ec5840;color:#fefefe}.breadcrumbs{list-style:none;margin:0 0 1rem}.breadcrumbs:after,.breadcrumbs:before{content:' ';display:table}.breadcrumbs:after{clear:both}.breadcrumbs li{float:left;color:#0a0a0a;font-size:.6875rem;cursor:default;text-transform:uppercase}.breadcrumbs li:not(:last-child):after{color:#cacaca;content:\"/\";margin:0 .75rem;position:relative;top:1px;opacity:1}.breadcrumbs a{color:#2199e8}.breadcrumbs a:hover{text-decoration:underline}.breadcrumbs .disabled{color:#cacaca;cursor:not-allowed}.button-group{margin-bottom:1rem;font-size:0}.button-group:after,.button-group:before{content:' ';display:table}.button-group:after{clear:both}.button-group .button{margin:0;margin-right:1px;margin-bottom:1px;font-size:.9rem}.button-group .button:last-child{margin-right:0}.button-group.tiny .button{font-size:.6rem}.button-group.small .button{font-size:.75rem}.button-group.large .button{font-size:1.25rem}.button-group.expanded{margin-right:-1px}.button-group.expanded:after,.button-group.expanded:before{display:none}.button-group.expanded .button:first-child:nth-last-child(2),.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button{display:inline-block;width:calc(50% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(2):first-child:nth-last-child(2)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(2):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(3),.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button{display:inline-block;width:calc(33.33333% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(3):first-child:nth-last-child(3)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(3):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(4),.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button{display:inline-block;width:calc(25% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(4):first-child:nth-last-child(4)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(4):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(5),.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button{display:inline-block;width:calc(20% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(5):first-child:nth-last-child(5)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(5):last-child{margin-right:-6px}.button-group.expanded .button:first-child:nth-last-child(6),.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button{display:inline-block;width:calc(16.66667% - 1px);margin-right:1px}.button-group.expanded .button:first-child:nth-last-child(6):first-child:nth-last-child(6)~.button:last-child,.button-group.expanded .button:first-child:nth-last-child(6):last-child{margin-right:-6px}.button-group.primary .button{background-color:#2199e8;color:#fefefe}.button-group.primary .button:focus,.button-group.primary .button:hover{background-color:#147cc0;color:#fefefe}.button-group.secondary .button{background-color:#777;color:#fefefe}.button-group.secondary .button:focus,.button-group.secondary .button:hover{background-color:#5f5f5f;color:#fefefe}.button-group.success .button{background-color:#3adb76;color:#fefefe}.button-group.success .button:focus,.button-group.success .button:hover{background-color:#22bb5b;color:#fefefe}.button-group.warning .button{background-color:#ffae00;color:#fefefe}.button-group.warning .button:focus,.button-group.warning .button:hover{background-color:#cc8b00;color:#fefefe}.button-group.alert .button{background-color:#ec5840;color:#fefefe}.button-group.alert .button:focus,.button-group.alert .button:hover{background-color:#da3116;color:#fefefe}.button-group.stacked-for-medium .button,.button-group.stacked-for-small .button,.button-group.stacked .button{width:100%}.button-group.stacked-for-medium .button:last-child,.button-group.stacked-for-small .button:last-child,.button-group.stacked .button:last-child{margin-bottom:0}@media screen and (min-width:40em){.button-group.stacked-for-small .button{width:auto;margin-bottom:0}}@media screen and (min-width:64em){.button-group.stacked-for-medium .button{width:auto;margin-bottom:0}}@media screen and (max-width:39.9375em){.button-group.stacked-for-small.expanded{display:block}.button-group.stacked-for-small.expanded .button{display:block;margin-right:0}}.callout{margin:0 0 1rem;padding:1rem;border:1px solid hsla(0,0%,4%,.25);border-radius:0;position:relative;color:#0a0a0a;background-color:#fff}.callout>:first-child{margin-top:0}.callout>:last-child{margin-bottom:0}.callout.primary{background-color:#def0fc}.callout.secondary{background-color:#ebebeb}.callout.success{background-color:#e1faea}.callout.warning{background-color:#fff3d9}.callout.alert{background-color:#fce6e2}.callout.small{padding:.5rem}.callout.large{padding:3rem}.close-button{position:absolute;color:#8a8a8a;right:1rem;top:.5rem;font-size:2em;line-height:1;cursor:pointer}[data-whatinput=mouse] .close-button{outline:0}.close-button:focus,.close-button:hover{color:#0a0a0a}.menu{margin:0;list-style-type:none}.menu>li{display:table-cell;vertical-align:middle}[data-whatinput=mouse] .menu>li{outline:0}.menu>li>a{display:block;padding:.7rem 1rem;line-height:1}.menu a,.menu button,.menu input{margin-bottom:0}.menu>li>a i,.menu>li>a i+span,.menu>li>a img,.menu>li>a img+span,.menu>li>a svg,.menu>li>a svg+span{vertical-align:middle}.menu>li>a i,.menu>li>a img,.menu>li>a svg{margin-right:.25rem;display:inline-block}.menu>li{display:table-cell}.menu.vertical>li{display:block}@media screen and (min-width:40em){.menu.medium-horizontal>li{display:table-cell}.menu.medium-vertical>li{display:block}}@media screen and (min-width:64em){.menu.large-horizontal>li{display:table-cell}.menu.large-vertical>li{display:block}}.menu.simple li{line-height:1;display:inline-block;margin-right:1rem}.menu.simple a{padding:0}.menu.align-right:after,.menu.align-right:before{content:' ';display:table}.menu.align-right:after{clear:both}.menu.align-right>li{float:right}.menu.expanded{width:100%;display:table;table-layout:fixed}.menu.expanded>li:first-child:last-child{width:100%}.menu.icon-top>li>a{text-align:center}.menu.icon-top>li>a i,.menu.icon-top>li>a img,.menu.icon-top>li>a svg{display:block;margin:0 auto .25rem}.menu.nested{margin-left:1rem}.menu .active>a{color:#fefefe;background:#2199e8}.menu-text{font-weight:700;color:inherit;line-height:1;padding-top:0;padding-bottom:0;padding:.7rem 1rem}.menu-centered{text-align:center}.menu-centered>.menu{display:inline-block}.no-js [data-responsive-menu] ul{display:none}.menu-icon{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#fefefe;top:0;left:0;box-shadow:0 7px 0 #fefefe,0 14px 0 #fefefe}.menu-icon:hover:after{background:#cacaca;box-shadow:0 7px 0 #cacaca,0 14px 0 #cacaca}.menu-icon.dark{position:relative;display:inline-block;vertical-align:middle;cursor:pointer;width:20px;height:16px}.menu-icon.dark:after{content:'';position:absolute;display:block;width:100%;height:2px;background:#0a0a0a;top:0;left:0;box-shadow:0 7px 0 #0a0a0a,0 14px 0 #0a0a0a}.menu-icon.dark:hover:after{background:#8a8a8a;box-shadow:0 7px 0 #8a8a8a,0 14px 0 #8a8a8a}.is-drilldown{position:relative;overflow:hidden}.is-drilldown li{display:block!important}.is-drilldown-submenu{position:absolute;top:0;left:100%;z-index:-1;width:100%;background:#fefefe;-webkit-transition:-webkit-transform .15s linear;transition:transform .15s linear}.is-drilldown-submenu.is-active{z-index:1;display:block;-webkit-transform:translateX(-100%);transform:translateX(-100%)}.is-drilldown-submenu.is-closing{-webkit-transform:translateX(100%);transform:translateX(100%)}.is-drilldown-submenu-parent>a{position:relative}.is-drilldown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0;position:absolute;top:50%;margin-top:-6px;right:1rem}.js-drilldown-back>a:before{content:'';display:block;width:0;height:0;border:6px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0;display:inline-block;vertical-align:middle;margin-right:.75rem}.dropdown-pane{background-color:#fefefe;border:1px solid #cacaca;border-radius:0;display:block;font-size:1rem;padding:1rem;position:absolute;visibility:hidden;width:300px;z-index:10}.dropdown-pane.is-open{visibility:visible}.dropdown-pane.tiny{width:100px}.dropdown-pane.small{width:200px}.dropdown-pane.large{width:400px}.dropdown.menu>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}[data-whatinput=mouse] .dropdown.menu a{outline:0}.no-js .dropdown.menu ul{display:none}.dropdown.menu.vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}@media screen and (min-width:40em){.dropdown.menu.medium-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.medium-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.medium-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.medium-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.medium-vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.medium-vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.medium-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.medium-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.medium-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}@media screen and (min-width:64em){.dropdown.menu.large-horizontal>li.opens-left>.is-dropdown-submenu{left:auto;right:0;top:100%}.dropdown.menu.large-horizontal>li.opens-right>.is-dropdown-submenu{right:auto;left:0;top:100%}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a{padding-right:1.5rem;position:relative}.dropdown.menu.large-horizontal>li.is-dropdown-submenu-parent>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:#2199e8 transparent transparent;border-top-style:solid;border-bottom-width:0;right:5px;margin-top:-2px}.dropdown.menu.large-vertical>li .is-dropdown-submenu{top:0}.dropdown.menu.large-vertical>li.opens-left>.is-dropdown-submenu{left:auto;right:100%}.dropdown.menu.large-vertical>li.opens-right>.is-dropdown-submenu{right:auto;left:100%}.dropdown.menu.large-vertical>li>a:after{right:14px;margin-top:-3px}.dropdown.menu.large-vertical>li.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.dropdown.menu.large-vertical>li.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}}.dropdown.menu.align-right .is-dropdown-submenu.first-sub{top:100%;left:auto;right:0}.is-dropdown-menu.vertical{width:100px}.is-dropdown-menu.vertical.align-right{float:right}.is-dropdown-submenu-parent{position:relative}.is-dropdown-submenu-parent a:after{position:absolute;top:50%;right:5px;margin-top:-2px}.is-dropdown-submenu-parent.opens-inner>.is-dropdown-submenu{top:100%;left:auto}.is-dropdown-submenu-parent.opens-left>.is-dropdown-submenu{left:auto;right:100%}.is-dropdown-submenu-parent.opens-right>.is-dropdown-submenu{right:auto;left:100%}.is-dropdown-submenu{display:none;position:absolute;top:0;left:100%;min-width:200px;z-index:1;background:#fefefe;border:1px solid #cacaca}.is-dropdown-submenu .is-dropdown-submenu-parent>a:after{right:14px;margin-top:-3px}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-left>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent #2199e8 transparent transparent;border-right-style:solid;border-left-width:0}.is-dropdown-submenu .is-dropdown-submenu-parent.opens-right>a:after{content:'';display:block;width:0;height:0;border:5px inset;border-color:transparent transparent transparent #2199e8;border-left-style:solid;border-right-width:0}.is-dropdown-submenu .is-dropdown-submenu{margin-top:-1px}.is-dropdown-submenu>li{width:100%}.is-dropdown-submenu.js-dropdown-active{display:block}.flex-video{position:relative;height:0;padding-bottom:75%;margin-bottom:1rem;overflow:hidden}.flex-video embed,.flex-video iframe,.flex-video object,.flex-video video{position:absolute;top:0;left:0;width:100%;height:100%}.flex-video.widescreen{padding-bottom:56.25%}.flex-video.vimeo{padding-top:0}.label{display:inline-block;padding:.33333rem .5rem;font-size:.8rem;line-height:1;white-space:nowrap;cursor:default;border-radius:0;background:#2199e8;color:#fefefe}.label.secondary{background:#777;color:#fefefe}.label.success{background:#3adb76;color:#fefefe}.label.warning{background:#ffae00;color:#fefefe}.label.alert{background:#ec5840;color:#fefefe}.media-object{margin-bottom:1rem;display:block}.media-object img{max-width:none}@media screen and (max-width:39.9375em){.media-object.stack-for-small .media-object-section{padding:0;padding-bottom:1rem;display:block}.media-object.stack-for-small .media-object-section img{width:100%}}.media-object-section{display:table-cell;vertical-align:top}.media-object-section:first-child{padding-right:1rem}.media-object-section:last-child:not(:nth-child(2)){padding-left:1rem}.media-object-section>:last-child{margin-bottom:0}.media-object-section.middle{vertical-align:middle}.media-object-section.bottom{vertical-align:bottom}body,html{height:100%}.off-canvas-wrapper{width:100%;overflow-x:hidden;position:relative;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-overflow-scrolling:auto}.off-canvas-wrapper-inner{position:relative;width:100%;min-height:100%;-webkit-transition:-webkit-transform .5s ease;transition:transform .5s ease}.off-canvas-wrapper-inner:after,.off-canvas-wrapper-inner:before{content:' ';display:table}.off-canvas-wrapper-inner:after{clear:both}.off-canvas-content{min-height:100%;background:#fefefe;-webkit-transition:-webkit-transform .5s ease;transition:transform .5s ease;-webkit-backface-visibility:hidden;backface-visibility:hidden;z-index:1;padding-bottom:.1px;box-shadow:0 0 10px hsla(0,0%,4%,.5)}.js-off-canvas-exit{display:none;position:absolute;top:0;left:0;width:100%;height:100%;background:hsla(0,0%,100%,.25);cursor:pointer;-webkit-transition:background .5s ease;transition:background .5s ease}.off-canvas{position:absolute;background:#e6e6e6;z-index:-1;max-height:100%;overflow-y:auto;-webkit-transform:translateX(0);transform:translateX(0)}[data-whatinput=mouse] .off-canvas{outline:0}.off-canvas.position-left{left:-250px;top:0;width:250px}.is-open-left{-webkit-transform:translateX(250px);transform:translateX(250px)}.off-canvas.position-right{right:-250px;top:0;width:250px}.is-open-right{-webkit-transform:translateX(-250px);transform:translateX(-250px)}@media screen and (min-width:40em){.position-left.reveal-for-medium{left:0;z-index:auto;position:fixed}.position-left.reveal-for-medium~.off-canvas-content{margin-left:250px}.position-right.reveal-for-medium{right:0;z-index:auto;position:fixed}.position-right.reveal-for-medium~.off-canvas-content{margin-right:250px}}@media screen and (min-width:64em){.position-left.reveal-for-large{left:0;z-index:auto;position:fixed}.position-left.reveal-for-large~.off-canvas-content{margin-left:250px}.position-right.reveal-for-large{right:0;z-index:auto;position:fixed}.position-right.reveal-for-large~.off-canvas-content{margin-right:250px}}.orbit,.orbit-container{position:relative}.orbit-container{margin:0;overflow:hidden;list-style:none}.orbit-slide{width:100%;max-height:100%}.orbit-slide.no-motionui.is-active{top:0;left:0}.orbit-figure{margin:0}.orbit-image{margin:0;width:100%;max-width:100%}.orbit-caption{bottom:0;width:100%;margin-bottom:0;background-color:hsla(0,0%,4%,.5)}.orbit-caption,.orbit-next,.orbit-previous{position:absolute;padding:1rem;color:#fefefe}.orbit-next,.orbit-previous{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);z-index:10}[data-whatinput=mouse] .orbit-next,[data-whatinput=mouse] .orbit-previous{outline:0}.orbit-next:active,.orbit-next:focus,.orbit-next:hover,.orbit-previous:active,.orbit-previous:focus,.orbit-previous:hover{background-color:hsla(0,0%,4%,.5)}.orbit-previous{left:0}.orbit-next{left:auto;right:0}.orbit-bullets{position:relative;margin-top:.8rem;margin-bottom:.8rem;text-align:center}[data-whatinput=mouse] .orbit-bullets{outline:0}.orbit-bullets button{width:1.2rem;height:1.2rem;margin:.1rem;background-color:#cacaca;border-radius:50%}.orbit-bullets button.is-active,.orbit-bullets button:hover{background-color:#8a8a8a}.pagination{margin-left:0;margin-bottom:1rem}.pagination:after,.pagination:before{content:' ';display:table}.pagination:after{clear:both}.pagination li{font-size:.875rem;margin-right:.0625rem;border-radius:0;display:none}.pagination li:first-child,.pagination li:last-child{display:inline-block}@media screen and (min-width:40em){.pagination li{display:inline-block}}.pagination a,.pagination button{color:#0a0a0a;display:block;padding:.1875rem .625rem;border-radius:0}.pagination a:hover,.pagination button:hover{background:#e6e6e6}.pagination .current{padding:.1875rem .625rem;background:#2199e8;color:#fefefe;cursor:default}.pagination .disabled{padding:.1875rem .625rem;color:#cacaca;cursor:not-allowed}.pagination .disabled:hover{background:transparent}.pagination .ellipsis:after{content:'\\2026';padding:.1875rem .625rem;color:#0a0a0a}.pagination-previous.disabled:before,.pagination-previous a:before{content:'\\AB';display:inline-block;margin-right:.5rem}.pagination-next.disabled:after,.pagination-next a:after{content:'\\BB';display:inline-block;margin-left:.5rem}.progress{background-color:#cacaca;height:1rem;margin-bottom:1rem;border-radius:0}.progress.primary .progress-meter{background-color:#2199e8}.progress.secondary .progress-meter{background-color:#777}.progress.success .progress-meter{background-color:#3adb76}.progress.warning .progress-meter{background-color:#ffae00}.progress.alert .progress-meter{background-color:#ec5840}.progress-meter{position:relative;display:block;width:0;height:100%;background-color:#2199e8}.progress-meter-text{top:50%;left:50%;-webkit-transform:translate(-50%,-50%);transform:translate(-50%,-50%);position:absolute;margin:0;font-size:.75rem;font-weight:700;color:#fefefe;white-space:nowrap}.slider{position:relative;height:.5rem;margin-top:1.25rem;margin-bottom:2.25rem;background-color:#e6e6e6;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-ms-touch-action:none;touch-action:none}.slider-fill{position:absolute;top:0;left:0;display:inline-block;max-width:100%;height:.5rem;background-color:#cacaca;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.slider-fill.is-dragging{-webkit-transition:all 0s linear;transition:all 0s linear}.slider-handle{top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%);position:absolute;left:0;z-index:1;display:inline-block;width:1.4rem;height:1.4rem;background-color:#2199e8;-webkit-transition:all .2s ease-in-out;transition:all .2s ease-in-out;-ms-touch-action:manipulation;touch-action:manipulation;border-radius:0}[data-whatinput=mouse] .slider-handle{outline:0}.slider-handle:hover{background-color:#1583cc}.slider-handle.is-dragging{-webkit-transition:all 0s linear;transition:all 0s linear}.slider.disabled,.slider[disabled]{opacity:.25;cursor:not-allowed}.slider.vertical{display:inline-block;width:.5rem;height:12.5rem;margin:0 1.25rem;-webkit-transform:scaleY(-1);transform:scaleY(-1)}.slider.vertical .slider-fill{top:0;width:.5rem;max-height:100%}.slider.vertical .slider-handle{position:absolute;top:0;left:50%;width:1.4rem;height:1.4rem;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.sticky-container{position:relative}.sticky{position:absolute;z-index:0;-webkit-transform:translateZ(0);transform:translateZ(0)}.sticky.is-stuck{position:fixed;z-index:5}.sticky.is-stuck.is-at-top{top:0}.sticky.is-stuck.is-at-bottom{bottom:0}.sticky.is-anchored{position:absolute;left:auto;right:auto}.sticky.is-anchored.is-at-bottom{bottom:0}body.is-reveal-open{overflow:hidden}html.is-reveal-open,html.is-reveal-open body{min-height:100%;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.reveal-overlay{display:none;position:fixed;top:0;bottom:0;left:0;right:0;z-index:1005;background-color:hsla(0,0%,4%,.45);overflow-y:scroll}.reveal{display:none;z-index:1006;padding:1rem;border:1px solid #cacaca;background-color:#fefefe;border-radius:0;position:relative;top:100px;margin-left:auto;margin-right:auto;overflow-y:auto}[data-whatinput=mouse] .reveal{outline:0}@media screen and (min-width:40em){.reveal{min-height:0}}.reveal .column,.reveal .columns{min-width:0}.reveal>:last-child{margin-bottom:0}@media screen and (min-width:40em){.reveal{width:600px;max-width:75rem}}@media screen and (min-width:40em){.reveal .reveal{left:auto;right:auto;margin:0 auto}}.reveal.collapse{padding:0}@media screen and (min-width:40em){.reveal.tiny{width:30%;max-width:75rem}}@media screen and (min-width:40em){.reveal.small{width:50%;max-width:75rem}}@media screen and (min-width:40em){.reveal.large{width:90%;max-width:75rem}}.reveal.full{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0;border-radius:0}@media screen and (max-width:39.9375em){.reveal{top:0;left:0;width:100%;height:100%;height:100vh;min-height:100vh;max-width:none;margin-left:0;border:0;border-radius:0}}.reveal.without-overlay{position:fixed}.switch{height:2rem;margin-bottom:1rem;outline:0;position:relative;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;color:#fefefe;font-weight:700;font-size:.875rem}.switch-input{opacity:0;position:absolute;margin-bottom:0}.switch-paddle{background:#cacaca;cursor:pointer;display:block;position:relative;width:4rem;height:2rem;-webkit-transition:all .25s ease-out;transition:all .25s ease-out;border-radius:0;color:inherit;font-weight:inherit}input+.switch-paddle{margin:0}.switch-paddle:after{background:#fefefe;content:'';display:block;position:absolute;height:1.5rem;left:.25rem;top:.25rem;width:1.5rem;-webkit-transition:all .25s ease-out;transition:all .25s ease-out;-webkit-transform:translateZ(0);transform:translateZ(0);border-radius:0}input:checked~.switch-paddle{background:#2199e8}input:checked~.switch-paddle:after{left:2.25rem}[data-whatinput=mouse] input:focus~.switch-paddle{outline:0}.switch-active,.switch-inactive{position:absolute;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.switch-active{left:8%;display:none}input:checked+label>.switch-active{display:block}.switch-inactive{right:15%}input:checked+label>.switch-inactive{display:none}.switch.tiny{height:1.5rem}.switch.tiny .switch-paddle{width:3rem;height:1.5rem;font-size:.625rem}.switch.tiny .switch-paddle:after{width:1rem;height:1rem}.switch.tiny input:checked~.switch-paddle:after{left:1.75rem}.switch.small{height:1.75rem}.switch.small .switch-paddle{width:3.5rem;height:1.75rem;font-size:.75rem}.switch.small .switch-paddle:after{width:1.25rem;height:1.25rem}.switch.small input:checked~.switch-paddle:after{left:2rem}.switch.large{height:2.5rem}.switch.large .switch-paddle{width:5rem;height:2.5rem;font-size:1rem}.switch.large .switch-paddle:after{width:2rem;height:2rem}.switch.large input:checked~.switch-paddle:after{left:2.75rem}table{width:100%;margin-bottom:1rem;border-radius:0}table tbody,table tfoot,table thead{border:1px solid #f1f1f1;background-color:#fefefe}table caption{font-weight:700;padding:.5rem .625rem .625rem}table thead{background:#f8f8f8;color:#0a0a0a}table tfoot{background:#f1f1f1;color:#0a0a0a}table tfoot tr,table thead tr{background:transparent}table tfoot td,table tfoot th,table thead td,table thead th{padding:.5rem .625rem .625rem;font-weight:700;text-align:left}table tbody tr:nth-child(even){background-color:#f1f1f1}table tbody td,table tbody th{padding:.5rem .625rem .625rem}@media screen and (max-width:63.9375em){table.stack tfoot,table.stack thead{display:none}table.stack td,table.stack th,table.stack tr{display:block}table.stack td{border-top:0}}table.scroll{display:block;width:100%;overflow-x:auto}table.hover thead tr:hover{background-color:#f3f3f3}table.hover tfoot tr:hover{background-color:#ececec}table.hover tbody tr:hover{background-color:#f9f9f9}table.hover tbody tr:nth-of-type(even):hover{background-color:#ececec}.table-scroll{overflow-x:auto}.table-scroll table{width:auto}.tabs{margin:0;list-style-type:none;background:#fefefe;border:1px solid #e6e6e6}.tabs:after,.tabs:before{content:' ';display:table}.tabs:after{clear:both}.tabs.vertical>li{width:auto;float:none;display:block}.tabs.simple>li>a{padding:0}.tabs.simple>li>a:hover{background:transparent}.tabs.primary{background:#2199e8}.tabs.primary>li>a{color:#fefefe}.tabs.primary>li>a:focus,.tabs.primary>li>a:hover{background:#1893e4}.tabs-title{float:left}.tabs-title>a{display:block;padding:1.25rem 1.5rem;line-height:1;font-size:.75rem}.tabs-title>a:hover{background:#fefefe}.tabs-title>a:focus,.tabs-title>a[aria-selected=true]{background:#e6e6e6}.tabs-content{background:#fefefe;-webkit-transition:all .5s ease;transition:all .5s ease;border:1px solid #e6e6e6;border-top:0}.tabs-content.vertical{border:1px solid #e6e6e6;border-left:0}.tabs-panel{display:none;padding:1rem}.tabs-panel.is-active{display:block}.thumbnail{border:4px solid #fefefe;box-shadow:0 0 0 1px hsla(0,0%,4%,.2);display:inline-block;line-height:0;max-width:100%;-webkit-transition:-webkit-box-shadow .2s ease-out;transition:box-shadow .2s ease-out;border-radius:0;margin-bottom:1rem}.thumbnail:focus,.thumbnail:hover{box-shadow:0 0 6px 1px rgba(33,153,232,.5)}.title-bar{background:#0a0a0a;color:#fefefe;padding:.5rem}.title-bar:after,.title-bar:before{content:' ';display:table}.title-bar:after{clear:both}.title-bar .menu-icon{margin-left:.25rem;margin-right:.25rem}.title-bar-left{float:left}.title-bar-right{float:right;text-align:right}.title-bar-title{vertical-align:middle}.has-tip,.title-bar-title{font-weight:700;display:inline-block}.has-tip{border-bottom:1px dotted #8a8a8a;position:relative;cursor:help}.tooltip{background-color:#0a0a0a;color:#fefefe;font-size:80%;padding:.75rem;position:absolute;z-index:10;top:calc(100% + .6495rem);max-width:10rem!important;border-radius:0}.tooltip:before{border:.75rem inset;border-color:transparent transparent #0a0a0a;border-bottom-style:solid;border-top-width:0;bottom:100%;position:absolute;left:50%;-webkit-transform:translateX(-50%);transform:translateX(-50%)}.tooltip.top:before,.tooltip:before{content:'';display:block;width:0;height:0}.tooltip.top:before{border:.75rem inset;border-color:#0a0a0a transparent transparent;border-top-style:solid;border-bottom-width:0;top:100%;bottom:auto}.tooltip.left:before{border:.75rem inset;border-color:transparent transparent transparent #0a0a0a;border-left-style:solid;border-right-width:0;left:100%}.tooltip.left:before,.tooltip.right:before{content:'';display:block;width:0;height:0;bottom:auto;top:50%;-webkit-transform:translateY(-50%);transform:translateY(-50%)}.tooltip.right:before{border:.75rem inset;border-color:transparent #0a0a0a transparent transparent;border-right-style:solid;border-left-width:0;left:auto;right:100%}.top-bar{padding:.5rem}.top-bar:after,.top-bar:before{content:' ';display:table}.top-bar:after{clear:both}.top-bar,.top-bar ul{background-color:#e6e6e6}.top-bar input{max-width:200px;margin-right:1rem}.top-bar .input-group-field{width:100%;margin-right:0}.top-bar input.button{width:auto}.top-bar .top-bar-left,.top-bar .top-bar-right{width:100%}@media screen and (min-width:40em){.top-bar .top-bar-left,.top-bar .top-bar-right{width:auto}}@media screen and (max-width:63.9375em){.top-bar.stacked-for-medium .top-bar-left,.top-bar.stacked-for-medium .top-bar-right{width:100%}}@media screen and (max-width:74.9375em){.top-bar.stacked-for-large .top-bar-left,.top-bar.stacked-for-large .top-bar-right{width:100%}}.top-bar-title{float:left;margin-right:1rem}.top-bar-left{float:left}.top-bar-right{float:right}.hide{display:none!important}.invisible{visibility:hidden}@media screen and (max-width:39.9375em){.hide-for-small-only{display:none!important}}@media screen and (max-width:0em),screen and (min-width:40em){.show-for-small-only{display:none!important}}@media screen and (min-width:40em){.hide-for-medium{display:none!important}}@media screen and (max-width:39.9375em){.show-for-medium{display:none!important}}@media screen and (min-width:40em) and (max-width:63.9375em){.hide-for-medium-only{display:none!important}}@media screen and (max-width:39.9375em),screen and (min-width:64em){.show-for-medium-only{display:none!important}}@media screen and (min-width:64em){.hide-for-large{display:none!important}}@media screen and (max-width:63.9375em){.show-for-large{display:none!important}}@media screen and (min-width:64em) and (max-width:74.9375em){.hide-for-large-only{display:none!important}}@media screen and (max-width:63.9375em),screen and (min-width:75em){.show-for-large-only{display:none!important}}.show-for-sr,.show-on-focus{position:absolute!important;width:1px;height:1px;overflow:hidden;clip:rect(0,0,0,0)}.show-on-focus:active,.show-on-focus:focus{position:static!important;height:auto;width:auto;overflow:visible;clip:auto}.hide-for-portrait,.show-for-landscape{display:block!important}@media screen and (orientation:landscape){.hide-for-portrait,.show-for-landscape{display:block!important}}@media screen and (orientation:portrait){.hide-for-portrait,.show-for-landscape{display:none!important}}.hide-for-landscape,.show-for-portrait{display:none!important}@media screen and (orientation:landscape){.hide-for-landscape,.show-for-portrait{display:none!important}}@media screen and (orientation:portrait){.hide-for-landscape,.show-for-portrait{display:block!important}}.float-left{float:left!important}.float-right{float:right!important}.float-center{display:block;margin-left:auto;margin-right:auto}.clearfix:after,.clearfix:before{content:' ';display:table}.clearfix:after{clear:both}", ""]);
	
	// exports


/***/ },
/* 237 */
/***/ function(module, exports) {

	"use strict";
	
	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	// css base code, injected by the css-loader
	module.exports = function () {
		var list = [];
	
		// return the list of modules as css string
		list.toString = function toString() {
			var result = [];
			for (var i = 0; i < this.length; i++) {
				var item = this[i];
				if (item[2]) {
					result.push("@media " + item[2] + "{" + item[1] + "}");
				} else {
					result.push(item[1]);
				}
			}
			return result.join("");
		};
	
		// import a list of modules into the list
		list.i = function (modules, mediaQuery) {
			if (typeof modules === "string") modules = [[null, modules, ""]];
			var alreadyImportedModules = {};
			for (var i = 0; i < this.length; i++) {
				var id = this[i][0];
				if (typeof id === "number") alreadyImportedModules[id] = true;
			}
			for (i = 0; i < modules.length; i++) {
				var item = modules[i];
				// skip already imported module
				// this implementation is not 100% perfect for weird media query combinations
				//  when a module is imported multiple times with different media queries.
				//  I hope this will never occur (Hey this way we have smaller bundles)
				if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
					if (mediaQuery && !item[2]) {
						item[2] = mediaQuery;
					} else if (mediaQuery) {
						item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
					}
					list.push(item);
				}
			}
		};
		return list;
	};

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	/*
		MIT License http://www.opensource.org/licenses/mit-license.php
		Author Tobias Koppers @sokra
	*/
	var stylesInDom = {},
		memoize = function(fn) {
			var memo;
			return function () {
				if (typeof memo === "undefined") memo = fn.apply(this, arguments);
				return memo;
			};
		},
		isOldIE = memoize(function() {
			return /msie [6-9]\b/.test(window.navigator.userAgent.toLowerCase());
		}),
		getHeadElement = memoize(function () {
			return document.head || document.getElementsByTagName("head")[0];
		}),
		singletonElement = null,
		singletonCounter = 0,
		styleElementsInsertedAtTop = [];
	
	module.exports = function(list, options) {
		if(false) {
			if(typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
		}
	
		options = options || {};
		// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
		// tags it will allow on a page
		if (typeof options.singleton === "undefined") options.singleton = isOldIE();
	
		// By default, add <style> tags to the bottom of <head>.
		if (typeof options.insertAt === "undefined") options.insertAt = "bottom";
	
		var styles = listToStyles(list);
		addStylesToDom(styles, options);
	
		return function update(newList) {
			var mayRemove = [];
			for(var i = 0; i < styles.length; i++) {
				var item = styles[i];
				var domStyle = stylesInDom[item.id];
				domStyle.refs--;
				mayRemove.push(domStyle);
			}
			if(newList) {
				var newStyles = listToStyles(newList);
				addStylesToDom(newStyles, options);
			}
			for(var i = 0; i < mayRemove.length; i++) {
				var domStyle = mayRemove[i];
				if(domStyle.refs === 0) {
					for(var j = 0; j < domStyle.parts.length; j++)
						domStyle.parts[j]();
					delete stylesInDom[domStyle.id];
				}
			}
		};
	}
	
	function addStylesToDom(styles, options) {
		for(var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];
			if(domStyle) {
				domStyle.refs++;
				for(var j = 0; j < domStyle.parts.length; j++) {
					domStyle.parts[j](item.parts[j]);
				}
				for(; j < item.parts.length; j++) {
					domStyle.parts.push(addStyle(item.parts[j], options));
				}
			} else {
				var parts = [];
				for(var j = 0; j < item.parts.length; j++) {
					parts.push(addStyle(item.parts[j], options));
				}
				stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
			}
		}
	}
	
	function listToStyles(list) {
		var styles = [];
		var newStyles = {};
		for(var i = 0; i < list.length; i++) {
			var item = list[i];
			var id = item[0];
			var css = item[1];
			var media = item[2];
			var sourceMap = item[3];
			var part = {css: css, media: media, sourceMap: sourceMap};
			if(!newStyles[id])
				styles.push(newStyles[id] = {id: id, parts: [part]});
			else
				newStyles[id].parts.push(part);
		}
		return styles;
	}
	
	function insertStyleElement(options, styleElement) {
		var head = getHeadElement();
		var lastStyleElementInsertedAtTop = styleElementsInsertedAtTop[styleElementsInsertedAtTop.length - 1];
		if (options.insertAt === "top") {
			if(!lastStyleElementInsertedAtTop) {
				head.insertBefore(styleElement, head.firstChild);
			} else if(lastStyleElementInsertedAtTop.nextSibling) {
				head.insertBefore(styleElement, lastStyleElementInsertedAtTop.nextSibling);
			} else {
				head.appendChild(styleElement);
			}
			styleElementsInsertedAtTop.push(styleElement);
		} else if (options.insertAt === "bottom") {
			head.appendChild(styleElement);
		} else {
			throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
		}
	}
	
	function removeStyleElement(styleElement) {
		styleElement.parentNode.removeChild(styleElement);
		var idx = styleElementsInsertedAtTop.indexOf(styleElement);
		if(idx >= 0) {
			styleElementsInsertedAtTop.splice(idx, 1);
		}
	}
	
	function createStyleElement(options) {
		var styleElement = document.createElement("style");
		styleElement.type = "text/css";
		insertStyleElement(options, styleElement);
		return styleElement;
	}
	
	function createLinkElement(options) {
		var linkElement = document.createElement("link");
		linkElement.rel = "stylesheet";
		insertStyleElement(options, linkElement);
		return linkElement;
	}
	
	function addStyle(obj, options) {
		var styleElement, update, remove;
	
		if (options.singleton) {
			var styleIndex = singletonCounter++;
			styleElement = singletonElement || (singletonElement = createStyleElement(options));
			update = applyToSingletonTag.bind(null, styleElement, styleIndex, false);
			remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true);
		} else if(obj.sourceMap &&
			typeof URL === "function" &&
			typeof URL.createObjectURL === "function" &&
			typeof URL.revokeObjectURL === "function" &&
			typeof Blob === "function" &&
			typeof btoa === "function") {
			styleElement = createLinkElement(options);
			update = updateLink.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
				if(styleElement.href)
					URL.revokeObjectURL(styleElement.href);
			};
		} else {
			styleElement = createStyleElement(options);
			update = applyToTag.bind(null, styleElement);
			remove = function() {
				removeStyleElement(styleElement);
			};
		}
	
		update(obj);
	
		return function updateStyle(newObj) {
			if(newObj) {
				if(newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap)
					return;
				update(obj = newObj);
			} else {
				remove();
			}
		};
	}
	
	var replaceText = (function () {
		var textStore = [];
	
		return function (index, replacement) {
			textStore[index] = replacement;
			return textStore.filter(Boolean).join('\n');
		};
	})();
	
	function applyToSingletonTag(styleElement, index, remove, obj) {
		var css = remove ? "" : obj.css;
	
		if (styleElement.styleSheet) {
			styleElement.styleSheet.cssText = replaceText(index, css);
		} else {
			var cssNode = document.createTextNode(css);
			var childNodes = styleElement.childNodes;
			if (childNodes[index]) styleElement.removeChild(childNodes[index]);
			if (childNodes.length) {
				styleElement.insertBefore(cssNode, childNodes[index]);
			} else {
				styleElement.appendChild(cssNode);
			}
		}
	}
	
	function applyToTag(styleElement, obj) {
		var css = obj.css;
		var media = obj.media;
	
		if(media) {
			styleElement.setAttribute("media", media)
		}
	
		if(styleElement.styleSheet) {
			styleElement.styleSheet.cssText = css;
		} else {
			while(styleElement.firstChild) {
				styleElement.removeChild(styleElement.firstChild);
			}
			styleElement.appendChild(document.createTextNode(css));
		}
	}
	
	function updateLink(linkElement, obj) {
		var css = obj.css;
		var sourceMap = obj.sourceMap;
	
		if(sourceMap) {
			// http://stackoverflow.com/a/26603875
			css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
		}
	
		var blob = new Blob([css], { type: "text/css" });
	
		var oldSrc = linkElement.href;
	
		linkElement.href = URL.createObjectURL(blob);
	
		if(oldSrc)
			URL.revokeObjectURL(oldSrc);
	}


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	// style-loader: Adds some css to the DOM by adding a <style> tag
	
	// load the styles
	var content = __webpack_require__(240);
	if(typeof content === 'string') content = [[module.id, content, '']];
	// add the styles to the DOM
	var update = __webpack_require__(238)(content, {});
	if(content.locals) module.exports = content.locals;
	// Hot Module Replacement
	if(false) {
		// When the styles change, update the <style> tags
		if(!content.locals) {
			module.hot.accept("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss", function() {
				var newContent = require("!!./../../node_modules/css-loader/index.js!./../../node_modules/sass-loader/index.js!./app.scss");
				if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
				update(newContent);
			});
		}
		// When the module is disposed, remove the <style> tags
		module.hot.dispose(function() { update(); });
	}

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	exports = module.exports = __webpack_require__(237)();
	// imports
	
	
	// module
	exports.push([module.id, ".top-bar, .top-bar ul {\n  background-color: #333333; }\n\n.top-bar .menu-text {\n  color: white; }\n\n.top-bar .menu > .menu-text > a {\n  display: inline;\n  padding: 0; }\n\n.top-bar .active-link {\n  font-weight: bold; }\n\n.clock {\n  align-items: center;\n  background-color: #B5D0E2;\n  border: 2px solid #2099E8;\n  border-radius: 50%;\n  display: flex;\n  height: 14rem;\n  justify-content: center;\n  margin: 4rem auto;\n  width: 14rem; }\n\n.clock-text {\n  color: white;\n  font-size: 2.25rem;\n  font-weight: 300; }\n\n.controls {\n  display: flex;\n  justify-content: center; }\n  .controls .button {\n    padding: .75rem 3rem; }\n  .controls .button:first-child {\n    margin-right: 1.5rem; }\n", ""]);
	
	// exports


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	var React = __webpack_require__(8);
	
	var Controls = React.createClass({
	    displayName: 'Controls',
	
	    propTypes: {
	        countdownStatus: React.PropTypes.string.isRequired,
	        onStatusChange: React.PropTypes.func.isRequired
	    },
	    onStatusChange: function onStatusChange(newStatus) {
	        var _this = this;
	
	        return function () {
	            _this.props.onStatusChange(newStatus);
	        };
	    },
	    render: function render() {
	        var _this2 = this;
	
	        var countdownStatus = this.props.countdownStatus;
	
	        var renderStartStopButton = function renderStartStopButton() {
	            if (countdownStatus === 'started') {
	                return React.createElement(
	                    'button',
	                    { className: 'button secondary', onClick: _this2.onStatusChange('paused') },
	                    'Pauziraj'
	                );
	            } else if (countdownStatus === 'paused') {
	                return React.createElement(
	                    'button',
	                    { className: 'button primary', onClick: _this2.onStatusChange('started') },
	                    'Start'
	                );
	            }
	        };
	
	        return React.createElement(
	            'div',
	            { className: 'controls' },
	            renderStartStopButton(),
	            React.createElement(
	                'button',
	                { className: 'button alert hollow', onClick: this.onStatusChange('stopped') },
	                'O\u0107istit'
	            )
	        );
	    }
	});
	
	module.exports = Controls;

/***/ }
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgOGI1YTI3NzBlOTE3MjQyM2Y5Y2IiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzIiwid2VicGFjazovLy8uL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzPzYyMDgiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanM/Y2Y5NyIsIndlYnBhY2s6Ly8vLi9hcHAvYXBwLmpzeCIsIndlYnBhY2s6Ly8vZXh0ZXJuYWwgXCJqUXVlcnlcIiIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L3JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NLmpzIiwid2VicGFjazovLy8od2VicGFjaykvfi9ub2RlLWxpYnMtYnJvd3Nlci9+L3Byb2Nlc3MvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEN1cnJlbnRPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVRleHRDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0Rhbmdlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NyZWF0ZU5vZGVzRnJvbU1hcmt1cC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY3JlYXRlQXJyYXlGcm9tTWl4ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3RvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2ludmFyaWFudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIva2V5TWlycm9yLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UGVyZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9zZXRJbm5lckhUTUwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0RPTVByb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9xdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvd2FybmluZy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE1vdW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudENvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpbkh1Yi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFcnJvclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2FjY3VtdWxhdGVJbnRvLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2ZvckVhY2hBY2N1bXVsYXRlZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9PYmplY3QuYXNzaWduLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzRXZlbnRTdXBwb3J0ZWQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01GZWF0dXJlRmxhZ3MuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlSGFuZGxlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJvb3RJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluc3RhbmNlTWFwLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0TWFya3VwQ2hlY2tzdW0uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvYWRsZXIzMi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RPd25lci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DYWxsYmFja1F1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1Bvb2xlZENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1RyYW5zYWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9pc05vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE5hdGl2ZUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi92YWxpZGF0ZURPTU5lc3RpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvRXZlbnRQcm9wYWdhdG9ycy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9GYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0VGV4dENvbnRlbnRBY2Nlc3Nvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0V2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2tleU9mLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NoYW5nZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50VGFyZ2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2lzVGV4dElucHV0RWxlbWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DbGllbnRSZWFjdFJvb3RJbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9EZWZhdWx0RXZlbnRQbHVnaW5PcmRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljTW91c2VFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNVSUV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9IVE1MRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUNvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvZm9jdXNOb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9DU1NQcm9wZXJ0eS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvY2FtZWxpemVTdHlsZU5hbWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvaHlwaGVuYXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9tZW1vaXplU3RyaW5nT25seS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlucHV0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL0xpbmtlZFZhbHVlVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZ2V0SXRlcmF0b3JGbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTU9wdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL3RyYXZlcnNlQWxsQ2hpbGRyZW4uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdE11bHRpQ2hpbGQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvZmxhdHRlbkNoaWxkcmVuLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9zaGFsbG93RXF1YWwuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdEluamVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Q29tcG9uZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJbnB1dFNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERPTVNlbGVjdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NlcnZlclJlYWN0Um9vdEluZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1NpbXBsZUV2ZW50UGx1Z2luLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0NsaXBib2FyZEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL2dldEV2ZW50S2V5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY0RyYWdFdmVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNUb3VjaEV2ZW50LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1N5bnRoZXRpY1doZWVsRXZlbnQuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvU1ZHRE9NUHJvcGVydHlDb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9+L2ZianMvbGliL3BlcmZvcm1hbmNlTm93LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9SZWFjdFZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvcmVuZGVyU3VidHJlZUludG9Db250YWluZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC9saWIvUmVhY3RJc29tb3JwaGljLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RE9NRmFjdG9yaWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL1JlYWN0RWxlbWVudFZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L34vZmJqcy9saWIvbWFwT2JqZWN0LmpzIiwid2VicGFjazovLy8uL34vcmVhY3QvbGliL29ubHlDaGlsZC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0L2xpYi9kZXByZWNhdGVkLmpzIiwid2VicGFjazovLy8uL34vcmVhY3QtZG9tL2luZGV4LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVVdGlscy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vd2FybmluZy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbnRlcm5hbFByb3BUeXBlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUGF0dGVyblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaW52YXJpYW50L2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhhc2hIaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L3dhcm5pbmcvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FjdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0RPTVV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NU3RhdGVTdG9yYWdlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlRE9NSGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vZGVlcC1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2lzX2FyZ3VtZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL0FzeW5jVXRpbHMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVMb2NhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL3J1blRyYW5zaXRpb25Ib29rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvZGVwcmVjYXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvdXNlUXVlcmllcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9xdWVyeS1zdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9jb21wdXRlQ2hhbmdlZFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9pc0FjdGl2ZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9tYXRjaFJvdXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvZ2V0Um91dGVQYXJhbXMuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlclV0aWxzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9JbmRleExpbmsuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3dpdGhSb3V0ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhSZWRpcmVjdC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9MaWZlY3ljbGUuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRlQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvdXNlUm91dGVzLmpzIiwid2VicGFjazovLy8uL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0aW5nQ29udGV4dC5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VCYXNlbmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL3VzZVJvdXRlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvbGliL2FwcGx5Um91dGVyTWlkZGxld2FyZS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvYnJvd3Nlckhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlUm91dGVySGlzdG9yeS5qcyIsIndlYnBhY2s6Ly8vLi9+L3JlYWN0LXJvdXRlci9saWIvaGFzaEhpc3RvcnkuanMiLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvTWFpbi5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvTmF2aWdhdGlvbi5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvVGltZXIuanN4Iiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL0NvdW50ZG93bi5qc3giLCJ3ZWJwYWNrOi8vLy4vYXBwL2NvbXBvbmVudHMvQ2xvY2suanN4Iiwid2VicGFjazovLy8uL2FwcC9jb21wb25lbnRzL0NvdW50ZG93bkZvcm0uanN4Iiwid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzcz81ZDBlIiwid2VicGFjazovLy8uL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzcyIsIndlYnBhY2s6Ly8vLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9hcHAvc3R5bGVzL2FwcC5zY3NzP2IyOWYiLCJ3ZWJwYWNrOi8vLy4vYXBwL3N0eWxlcy9hcHAuc2NzcyIsIndlYnBhY2s6Ly8vLi9hcHAvY29tcG9uZW50cy9Db250cm9scy5qc3giXSwibmFtZXMiOlsiUmVhY3QiLCJyZXF1aXJlIiwiUmVhY3RET00iLCJSb3V0ZSIsIlJvdXRlciIsIkluZGV4Um91dGUiLCJoYXNoSGlzdG9yeSIsIk1haW4iLCJUaW1lciIsIkNvdW50ZG93biIsIiQiLCJkb2N1bWVudCIsImZvdW5kYXRpb24iLCJyZW5kZXIiLCJnZXRFbGVtZW50QnlJZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJSZWFjdERPTVNlcnZlciIsIlJlYWN0SXNvbW9ycGhpYyIsImFzc2lnbiIsImRlcHJlY2F0ZWQiLCJmaW5kRE9NTm9kZSIsInVubW91bnRDb21wb25lbnRBdE5vZGUiLCJyZW5kZXJUb1N0cmluZyIsInJlbmRlclRvU3RhdGljTWFya3VwIiwiX19TRUNSRVRfRE9NX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJfX1NFQ1JFVF9ET01fU0VSVkVSX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQiLCJSZWFjdEN1cnJlbnRPd25lciIsIlJlYWN0RE9NVGV4dENvbXBvbmVudCIsIlJlYWN0RGVmYXVsdEluamVjdGlvbiIsIlJlYWN0SW5zdGFuY2VIYW5kbGVzIiwiUmVhY3RNb3VudCIsIlJlYWN0UGVyZiIsIlJlYWN0UmVjb25jaWxlciIsIlJlYWN0VXBkYXRlcyIsIlJlYWN0VmVyc2lvbiIsInJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwid2FybmluZyIsImluamVjdCIsIm1lYXN1cmUiLCJ2ZXJzaW9uIiwidW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMiLCJiYXRjaGVkVXBkYXRlcyIsInVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyIiwiX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fIiwiQ3VycmVudE93bmVyIiwiSW5zdGFuY2VIYW5kbGVzIiwiTW91bnQiLCJSZWNvbmNpbGVyIiwiVGV4dENvbXBvbmVudCIsInByb2Nlc3MiLCJlbnYiLCJOT0RFX0VOViIsIkV4ZWN1dGlvbkVudmlyb25tZW50IiwiY2FuVXNlRE9NIiwid2luZG93IiwidG9wIiwic2VsZiIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsImluZGV4T2YiLCJjb25zb2xlIiwiZGVidWciLCJpZUNvbXBhdGliaWxpdHlNb2RlIiwiZG9jdW1lbnRNb2RlIiwidW5kZWZpbmVkIiwiZXhwZWN0ZWRGZWF0dXJlcyIsIkFycmF5IiwiaXNBcnJheSIsInByb3RvdHlwZSIsImV2ZXJ5IiwiZm9yRWFjaCIsIm1hcCIsIkRhdGUiLCJub3ciLCJGdW5jdGlvbiIsImJpbmQiLCJPYmplY3QiLCJrZXlzIiwiU3RyaW5nIiwic3BsaXQiLCJ0cmltIiwiY3JlYXRlIiwiZnJlZXplIiwiaSIsImxlbmd0aCIsImVycm9yIiwiY2FjaGVkU2V0VGltZW91dCIsImNhY2hlZENsZWFyVGltZW91dCIsImRlZmF1bHRTZXRUaW1vdXQiLCJFcnJvciIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiZSIsImNsZWFyVGltZW91dCIsInJ1blRpbWVvdXQiLCJmdW4iLCJjYWxsIiwicnVuQ2xlYXJUaW1lb3V0IiwibWFya2VyIiwicXVldWUiLCJkcmFpbmluZyIsImN1cnJlbnRRdWV1ZSIsInF1ZXVlSW5kZXgiLCJjbGVhblVwTmV4dFRpY2siLCJjb25jYXQiLCJkcmFpblF1ZXVlIiwidGltZW91dCIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiYXJncyIsImFyZ3VtZW50cyIsInB1c2giLCJJdGVtIiwiYXJyYXkiLCJhcHBseSIsInRpdGxlIiwiYnJvd3NlciIsImFyZ3YiLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwiZW1pdCIsImJpbmRpbmciLCJuYW1lIiwiY3dkIiwiY2hkaXIiLCJkaXIiLCJ1bWFzayIsImN1cnJlbnQiLCJET01DaGlsZHJlbk9wZXJhdGlvbnMiLCJET01Qcm9wZXJ0eU9wZXJhdGlvbnMiLCJSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCIsImVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciIsInNldFRleHRDb250ZW50IiwidmFsaWRhdGVET01OZXN0aW5nIiwicHJvcHMiLCJjb25zdHJ1Y3QiLCJ0ZXh0IiwiX2N1cnJlbnRFbGVtZW50IiwiX3N0cmluZ1RleHQiLCJfcm9vdE5vZGVJRCIsIl9tb3VudEluZGV4IiwibW91bnRDb21wb25lbnQiLCJyb290SUQiLCJ0cmFuc2FjdGlvbiIsImNvbnRleHQiLCJhbmNlc3RvckluZm9Db250ZXh0S2V5IiwidXNlQ3JlYXRlRWxlbWVudCIsIm93bmVyRG9jdW1lbnQiLCJvd25lckRvY3VtZW50Q29udGV4dEtleSIsImVsIiwiY3JlYXRlRWxlbWVudCIsInNldEF0dHJpYnV0ZUZvcklEIiwiZ2V0SUQiLCJlc2NhcGVkVGV4dCIsImNyZWF0ZU1hcmt1cEZvcklEIiwicmVjZWl2ZUNvbXBvbmVudCIsIm5leHRUZXh0IiwibmV4dFN0cmluZ1RleHQiLCJub2RlIiwiZ2V0Tm9kZSIsInVwZGF0ZVRleHRDb250ZW50IiwidW5tb3VudENvbXBvbmVudCIsInVubW91bnRJREZyb21FbnZpcm9ubWVudCIsIkRhbmdlciIsIlJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzIiwic2V0SW5uZXJIVE1MIiwiaW52YXJpYW50IiwiaW5zZXJ0Q2hpbGRBdCIsInBhcmVudE5vZGUiLCJjaGlsZE5vZGUiLCJpbmRleCIsImJlZm9yZUNoaWxkIiwiY2hpbGROb2RlcyIsIml0ZW0iLCJpbnNlcnRCZWZvcmUiLCJkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCIsInByb2Nlc3NVcGRhdGVzIiwidXBkYXRlcyIsIm1hcmt1cExpc3QiLCJ1cGRhdGUiLCJpbml0aWFsQ2hpbGRyZW4iLCJ1cGRhdGVkQ2hpbGRyZW4iLCJ0eXBlIiwiTU9WRV9FWElTVElORyIsIlJFTU9WRV9OT0RFIiwidXBkYXRlZEluZGV4IiwiZnJvbUluZGV4IiwidXBkYXRlZENoaWxkIiwicGFyZW50SUQiLCJyZW5kZXJlZE1hcmt1cCIsImRhbmdlcm91c2x5UmVuZGVyTWFya3VwIiwiaiIsInJlbW92ZUNoaWxkIiwiayIsIklOU0VSVF9NQVJLVVAiLCJtYXJrdXBJbmRleCIsInRvSW5kZXgiLCJTRVRfTUFSS1VQIiwiY29udGVudCIsIlRFWFRfQ09OVEVOVCIsIm1lYXN1cmVNZXRob2RzIiwiY3JlYXRlTm9kZXNGcm9tTWFya3VwIiwiZW1wdHlGdW5jdGlvbiIsImdldE1hcmt1cFdyYXAiLCJPUEVOX1RBR19OQU1FX0VYUCIsIlJFU1VMVF9JTkRFWF9BVFRSIiwiZ2V0Tm9kZU5hbWUiLCJtYXJrdXAiLCJzdWJzdHJpbmciLCJub2RlTmFtZSIsIm1hcmt1cEJ5Tm9kZU5hbWUiLCJyZXN1bHRMaXN0IiwicmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCIsImhhc093blByb3BlcnR5IiwibWFya3VwTGlzdEJ5Tm9kZU5hbWUiLCJyZXN1bHRJbmRleCIsInJlcGxhY2UiLCJyZW5kZXJOb2RlcyIsImpvaW4iLCJyZW5kZXJOb2RlIiwiaGFzQXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwib2xkQ2hpbGQiLCJ0YWdOYW1lIiwidG9Mb3dlckNhc2UiLCJuZXdDaGlsZCIsInJlcGxhY2VDaGlsZCIsImNhblVzZVdvcmtlcnMiLCJXb3JrZXIiLCJjYW5Vc2VFdmVudExpc3RlbmVycyIsImFkZEV2ZW50TGlzdGVuZXIiLCJhdHRhY2hFdmVudCIsImNhblVzZVZpZXdwb3J0Iiwic2NyZWVuIiwiaXNJbldvcmtlciIsImNyZWF0ZUFycmF5RnJvbU1peGVkIiwiZHVtbXlOb2RlIiwibm9kZU5hbWVQYXR0ZXJuIiwibm9kZU5hbWVNYXRjaCIsIm1hdGNoIiwiaGFuZGxlU2NyaXB0Iiwid3JhcCIsImlubmVySFRNTCIsIndyYXBEZXB0aCIsImxhc3RDaGlsZCIsInNjcmlwdHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsIm5vZGVzIiwidG9BcnJheSIsImhhc0FycmF5TmF0dXJlIiwib2JqIiwibm9kZVR5cGUiLCJzbGljZSIsInJldCIsImlpIiwiY29uZGl0aW9uIiwiZm9ybWF0IiwiYSIsImIiLCJjIiwiZCIsImYiLCJhcmdJbmRleCIsImZyYW1lc1RvUG9wIiwic2hvdWxkV3JhcCIsInNlbGVjdFdyYXAiLCJ0YWJsZVdyYXAiLCJ0cldyYXAiLCJzdmdXcmFwIiwibWFya3VwV3JhcCIsInN2Z0VsZW1lbnRzIiwiZmlyc3RDaGlsZCIsIm1ha2VFbXB0eUZ1bmN0aW9uIiwiYXJnIiwidGhhdFJldHVybnMiLCJ0aGF0UmV0dXJuc0ZhbHNlIiwidGhhdFJldHVybnNUcnVlIiwidGhhdFJldHVybnNOdWxsIiwidGhhdFJldHVybnNUaGlzIiwidGhhdFJldHVybnNBcmd1bWVudCIsImtleU1pcnJvciIsImtleSIsImVuYWJsZU1lYXN1cmUiLCJzdG9yZWRNZWFzdXJlIiwiX25vTWVhc3VyZSIsIm9iamVjdCIsIm9iamVjdE5hbWUiLCJtZXRob2ROYW1lcyIsIm9iak5hbWUiLCJmbk5hbWUiLCJmdW5jIiwibWVhc3VyZWRGdW5jIiwid3JhcHBlciIsImRpc3BsYXlOYW1lIiwiaW5qZWN0aW9uIiwiaW5qZWN0TWVhc3VyZSIsIldISVRFU1BBQ0VfVEVTVCIsIk5PTlZJU0lCTEVfVEVTVCIsImh0bWwiLCJNU0FwcCIsImV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uIiwidGVzdEVsZW1lbnQiLCJ0ZXN0IiwiZnJvbUNoYXJDb2RlIiwidGV4dE5vZGUiLCJkYXRhIiwiZGVsZXRlRGF0YSIsInRleHRDb250ZW50IiwiZG9jdW1lbnRFbGVtZW50IiwiRVNDQVBFX0xPT0tVUCIsIkVTQ0FQRV9SRUdFWCIsImVzY2FwZXIiLCJET01Qcm9wZXJ0eSIsInF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyIiwiVkFMSURfQVRUUklCVVRFX05BTUVfUkVHRVgiLCJpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlIiwidmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlIiwiaXNBdHRyaWJ1dGVOYW1lU2FmZSIsImF0dHJpYnV0ZU5hbWUiLCJzaG91bGRJZ25vcmVWYWx1ZSIsInByb3BlcnR5SW5mbyIsInZhbHVlIiwiaGFzQm9vbGVhblZhbHVlIiwiaGFzTnVtZXJpY1ZhbHVlIiwiaXNOYU4iLCJoYXNQb3NpdGl2ZU51bWVyaWNWYWx1ZSIsImhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUiLCJyZWFjdFByb3BzIiwiY2hpbGRyZW4iLCJkYW5nZXJvdXNseVNldElubmVySFRNTCIsInJlZiIsIndhcm5lZFByb3BlcnRpZXMiLCJ3YXJuVW5rbm93blByb3BlcnR5IiwibG93ZXJDYXNlZE5hbWUiLCJzdGFuZGFyZE5hbWUiLCJpc0N1c3RvbUF0dHJpYnV0ZSIsImdldFBvc3NpYmxlU3RhbmRhcmROYW1lIiwiaWQiLCJJRF9BVFRSSUJVVEVfTkFNRSIsInNldEF0dHJpYnV0ZSIsImNyZWF0ZU1hcmt1cEZvclByb3BlcnR5IiwicHJvcGVydGllcyIsImNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZSIsInNldFZhbHVlRm9yUHJvcGVydHkiLCJtdXRhdGlvbk1ldGhvZCIsImRlbGV0ZVZhbHVlRm9yUHJvcGVydHkiLCJtdXN0VXNlQXR0cmlidXRlIiwibmFtZXNwYWNlIiwiYXR0cmlidXRlTmFtZXNwYWNlIiwic2V0QXR0cmlidXRlTlMiLCJwcm9wTmFtZSIsInByb3BlcnR5TmFtZSIsImhhc1NpZGVFZmZlY3RzIiwic2V0VmFsdWVGb3JBdHRyaWJ1dGUiLCJkZWZhdWx0VmFsdWUiLCJnZXREZWZhdWx0VmFsdWVGb3JQcm9wZXJ0eSIsImNoZWNrTWFzayIsImJpdG1hc2siLCJET01Qcm9wZXJ0eUluamVjdGlvbiIsIk1VU1RfVVNFX0FUVFJJQlVURSIsIk1VU1RfVVNFX1BST1BFUlRZIiwiSEFTX1NJREVfRUZGRUNUUyIsIkhBU19CT09MRUFOX1ZBTFVFIiwiSEFTX05VTUVSSUNfVkFMVUUiLCJIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSIsIkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUiLCJpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyIsImRvbVByb3BlcnR5Q29uZmlnIiwiSW5qZWN0aW9uIiwiUHJvcGVydGllcyIsIkRPTUF0dHJpYnV0ZU5hbWVzcGFjZXMiLCJET01BdHRyaWJ1dGVOYW1lcyIsIkRPTVByb3BlcnR5TmFtZXMiLCJET01NdXRhdGlvbk1ldGhvZHMiLCJfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMiLCJsb3dlckNhc2VkIiwicHJvcENvbmZpZyIsIm11c3RVc2VQcm9wZXJ0eSIsImRlZmF1bHRWYWx1ZUNhY2hlIiwiaXNDdXN0b21BdHRyaWJ1dGVGbiIsInByb3AiLCJub2RlRGVmYXVsdHMiLCJfbGVuIiwiX2tleSIsIm1lc3NhZ2UiLCJ4IiwiUmVhY3RET01JRE9wZXJhdGlvbnMiLCJwcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwiZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzIiwicmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCIsImRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCIsInJvb3ROb2RlSUQiLCJwdXJnZUlEIiwiSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMiLCJzdHlsZSIsInVwZGF0ZVByb3BlcnR5QnlJRCIsIlJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciIsIlJlYWN0RE9NRmVhdHVyZUZsYWdzIiwiUmVhY3RFbGVtZW50IiwiUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5IiwiUmVhY3RJbnN0YW5jZU1hcCIsIlJlYWN0TWFya3VwQ2hlY2tzdW0iLCJSZWFjdFVwZGF0ZVF1ZXVlIiwiZW1wdHlPYmplY3QiLCJjb250YWluc05vZGUiLCJpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Iiwic2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQiLCJBVFRSX05BTUUiLCJub2RlQ2FjaGUiLCJFTEVNRU5UX05PREVfVFlQRSIsIkRPQ19OT0RFX1RZUEUiLCJET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUiLCJNYXRoIiwicmFuZG9tIiwidG9TdHJpbmciLCJpbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwiY29udGFpbmVyc0J5UmVhY3RSb290SUQiLCJyb290RWxlbWVudHNCeVJlYWN0Um9vdElEIiwiZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5IiwiZmlyc3REaWZmZXJlbmNlSW5kZXgiLCJzdHJpbmcxIiwic3RyaW5nMiIsIm1pbkxlbiIsIm1pbiIsImNoYXJBdCIsImdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lciIsImNvbnRhaW5lciIsImdldFJlYWN0Um9vdElEIiwicm9vdEVsZW1lbnQiLCJpbnRlcm5hbEdldElEIiwiY2FjaGVkIiwiaXNWYWxpZCIsInNldElEIiwib2xkSUQiLCJmaW5kUmVhY3ROb2RlQnlJRCIsImdldE5vZGVGcm9tSW5zdGFuY2UiLCJpbnN0YW5jZSIsImdldCIsImlzTnVsbENvbXBvbmVudElEIiwiZmluZFJlYWN0Q29udGFpbmVyRm9ySUQiLCJkZWVwZXN0Tm9kZVNvRmFyIiwiZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwiLCJhbmNlc3RvcklEIiwiYW5jZXN0b3IiLCJmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yIiwidGFyZ2V0SUQiLCJ0cmF2ZXJzZUFuY2VzdG9ycyIsImZvdW5kTm9kZSIsIm1vdW50Q29tcG9uZW50SW50b05vZGUiLCJjb21wb25lbnRJbnN0YW5jZSIsInNob3VsZFJldXNlTWFya3VwIiwidGFnIiwidXBkYXRlZEFuY2VzdG9ySW5mbyIsIl9yZW5kZXJlZENvbXBvbmVudCIsIl90b3BMZXZlbFdyYXBwZXIiLCJfbW91bnRJbWFnZUludG9Ob2RlIiwiYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUiLCJSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiZ2V0UG9vbGVkIiwicGVyZm9ybSIsInJlbGVhc2UiLCJ1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUiLCJoYXNOb25Sb290UmVhY3RDaGlsZCIsInJlYWN0Um9vdElEIiwiZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEIiwiZmluZEZpcnN0UmVhY3RET01JbXBsIiwibm9kZUlEIiwibGFzdElEIiwiVG9wTGV2ZWxXcmFwcGVyIiwiaXNSZWFjdENvbXBvbmVudCIsIl9pbnN0YW5jZXNCeVJlYWN0Um9vdElEIiwic2Nyb2xsTW9uaXRvciIsInJlbmRlckNhbGxiYWNrIiwiX3VwZGF0ZVJvb3RDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50IiwibmV4dEVsZW1lbnQiLCJjYWxsYmFjayIsImVucXVldWVFbGVtZW50SW50ZXJuYWwiLCJlbnF1ZXVlQ2FsbGJhY2tJbnRlcm5hbCIsIl9yZWdpc3RlckNvbXBvbmVudCIsIm5leHRDb21wb25lbnQiLCJlbnN1cmVTY3JvbGxWYWx1ZU1vbml0b3JpbmciLCJyZWdpc3RlckNvbnRhaW5lciIsIl9yZW5kZXJOZXdSb290Q29tcG9uZW50IiwiZ2V0TmFtZSIsInBhcmVudENvbXBvbmVudCIsIl9yZWFjdEludGVybmFsSW5zdGFuY2UiLCJfcmVuZGVyU3VidHJlZUludG9Db250YWluZXIiLCJpc1ZhbGlkRWxlbWVudCIsInRvVXBwZXJDYXNlIiwibmV4dFdyYXBwZWRFbGVtZW50IiwicHJldldyYXBwZWRFbGVtZW50IiwicHJldkVsZW1lbnQiLCJwdWJsaWNJbnN0IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJ1cGRhdGVkQ2FsbGJhY2siLCJyZWFjdFJvb3RFbGVtZW50IiwiY29udGFpbmVySGFzUmVhY3RNYXJrdXAiLCJjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCIsIm5leHRTaWJsaW5nIiwicm9vdEVsZW1lbnRTaWJsaW5nIiwiY29tcG9uZW50IiwiX3Byb2Nlc3NDaGlsZENvbnRleHQiLCJfY29udGV4dCIsImNyZWF0ZVJlYWN0Um9vdElEIiwiY29udGFpbmVySUQiLCJpc0NvbnRhaW5lclJlYWN0Um9vdCIsImNvbnRhaW5lckNoaWxkIiwicmVhY3RSb290IiwiZmluZENvbXBvbmVudFJvb3QiLCJnZXRGaXJzdFJlYWN0RE9NIiwiYW5jZXN0b3JOb2RlIiwiZmlyc3RDaGlsZHJlbiIsImNoaWxkSW5kZXgiLCJkZWVwZXN0QW5jZXN0b3IiLCJjaGlsZCIsInRhcmdldENoaWxkIiwiY2hpbGRJRCIsImlzQW5jZXN0b3JJRE9mIiwiY2FuUmV1c2VNYXJrdXAiLCJjaGVja3N1bSIsIkNIRUNLU1VNX0FUVFJfTkFNRSIsInJvb3RNYXJrdXAiLCJvdXRlckhUTUwiLCJub3JtYWxpemVkTWFya3VwIiwibm9ybWFsaXplciIsImJvZHkiLCJhcHBlbmRDaGlsZCIsImNvbnRlbnREb2N1bWVudCIsIndyaXRlIiwiZGlmZkluZGV4IiwiZGlmZmVyZW5jZSIsIkV2ZW50Q29uc3RhbnRzIiwiRXZlbnRQbHVnaW5IdWIiLCJFdmVudFBsdWdpblJlZ2lzdHJ5IiwiUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiIsIlZpZXdwb3J0TWV0cmljcyIsImlzRXZlbnRTdXBwb3J0ZWQiLCJhbHJlYWR5TGlzdGVuaW5nVG8iLCJpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSIsInJlYWN0VG9wTGlzdGVuZXJzQ291bnRlciIsInRvcEV2ZW50TWFwcGluZyIsInRvcEFib3J0IiwidG9wQmx1ciIsInRvcENhblBsYXkiLCJ0b3BDYW5QbGF5VGhyb3VnaCIsInRvcENoYW5nZSIsInRvcENsaWNrIiwidG9wQ29tcG9zaXRpb25FbmQiLCJ0b3BDb21wb3NpdGlvblN0YXJ0IiwidG9wQ29tcG9zaXRpb25VcGRhdGUiLCJ0b3BDb250ZXh0TWVudSIsInRvcENvcHkiLCJ0b3BDdXQiLCJ0b3BEb3VibGVDbGljayIsInRvcERyYWciLCJ0b3BEcmFnRW5kIiwidG9wRHJhZ0VudGVyIiwidG9wRHJhZ0V4aXQiLCJ0b3BEcmFnTGVhdmUiLCJ0b3BEcmFnT3ZlciIsInRvcERyYWdTdGFydCIsInRvcERyb3AiLCJ0b3BEdXJhdGlvbkNoYW5nZSIsInRvcEVtcHRpZWQiLCJ0b3BFbmNyeXB0ZWQiLCJ0b3BFbmRlZCIsInRvcEVycm9yIiwidG9wRm9jdXMiLCJ0b3BJbnB1dCIsInRvcEtleURvd24iLCJ0b3BLZXlQcmVzcyIsInRvcEtleVVwIiwidG9wTG9hZGVkRGF0YSIsInRvcExvYWRlZE1ldGFkYXRhIiwidG9wTG9hZFN0YXJ0IiwidG9wTW91c2VEb3duIiwidG9wTW91c2VNb3ZlIiwidG9wTW91c2VPdXQiLCJ0b3BNb3VzZU92ZXIiLCJ0b3BNb3VzZVVwIiwidG9wUGFzdGUiLCJ0b3BQYXVzZSIsInRvcFBsYXkiLCJ0b3BQbGF5aW5nIiwidG9wUHJvZ3Jlc3MiLCJ0b3BSYXRlQ2hhbmdlIiwidG9wU2Nyb2xsIiwidG9wU2Vla2VkIiwidG9wU2Vla2luZyIsInRvcFNlbGVjdGlvbkNoYW5nZSIsInRvcFN0YWxsZWQiLCJ0b3BTdXNwZW5kIiwidG9wVGV4dElucHV0IiwidG9wVGltZVVwZGF0ZSIsInRvcFRvdWNoQ2FuY2VsIiwidG9wVG91Y2hFbmQiLCJ0b3BUb3VjaE1vdmUiLCJ0b3BUb3VjaFN0YXJ0IiwidG9wVm9sdW1lQ2hhbmdlIiwidG9wV2FpdGluZyIsInRvcFdoZWVsIiwidG9wTGlzdGVuZXJzSURLZXkiLCJnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudCIsIm1vdW50QXQiLCJSZWFjdEV2ZW50TGlzdGVuZXIiLCJpbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIiLCJzZXRIYW5kbGVUb3BMZXZlbCIsImhhbmRsZVRvcExldmVsIiwic2V0RW5hYmxlZCIsImVuYWJsZWQiLCJpc0VuYWJsZWQiLCJsaXN0ZW5UbyIsInJlZ2lzdHJhdGlvbk5hbWUiLCJjb250ZW50RG9jdW1lbnRIYW5kbGUiLCJpc0xpc3RlbmluZyIsImRlcGVuZGVuY2llcyIsInJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXMiLCJ0b3BMZXZlbFR5cGVzIiwiZGVwZW5kZW5jeSIsInRyYXBCdWJibGVkRXZlbnQiLCJ0cmFwQ2FwdHVyZWRFdmVudCIsIldJTkRPV19IQU5ETEUiLCJ0b3BMZXZlbFR5cGUiLCJoYW5kbGVyQmFzZU5hbWUiLCJoYW5kbGUiLCJyZWZyZXNoIiwicmVmcmVzaFNjcm9sbFZhbHVlcyIsIm1vbml0b3JTY3JvbGxWYWx1ZSIsImV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyIsInJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzIiwicHV0TGlzdGVuZXIiLCJnZXRMaXN0ZW5lciIsImRlbGV0ZUxpc3RlbmVyIiwiZGVsZXRlQWxsTGlzdGVuZXJzIiwiUHJvcGFnYXRpb25QaGFzZXMiLCJidWJibGVkIiwiY2FwdHVyZWQiLCJ0b3BMb2FkIiwidG9wUmVzZXQiLCJ0b3BTdWJtaXQiLCJFdmVudFBsdWdpblV0aWxzIiwiUmVhY3RFcnJvclV0aWxzIiwiYWNjdW11bGF0ZUludG8iLCJmb3JFYWNoQWNjdW11bGF0ZWQiLCJsaXN0ZW5lckJhbmsiLCJldmVudFF1ZXVlIiwiZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlIiwiZXZlbnQiLCJzaW11bGF0ZWQiLCJleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXIiLCJpc1BlcnNpc3RlbnQiLCJjb25zdHJ1Y3RvciIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCIsImV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsIiwiSW5zdGFuY2VIYW5kbGUiLCJ2YWxpZGF0ZUluc3RhbmNlSGFuZGxlIiwidmFsaWQiLCJ0cmF2ZXJzZVR3b1BoYXNlIiwidHJhdmVyc2VFbnRlckxlYXZlIiwiaW5qZWN0TW91bnQiLCJpbmplY3RJbnN0YW5jZUhhbmRsZSIsIkluamVjdGVkSW5zdGFuY2VIYW5kbGUiLCJnZXRJbnN0YW5jZUhhbmRsZSIsImluamVjdEV2ZW50UGx1Z2luT3JkZXIiLCJpbmplY3RFdmVudFBsdWdpbnNCeU5hbWUiLCJsaXN0ZW5lciIsImJhbmtGb3JSZWdpc3RyYXRpb25OYW1lIiwiUGx1Z2luTW9kdWxlIiwiZGlkUHV0TGlzdGVuZXIiLCJ3aWxsRGVsZXRlTGlzdGVuZXIiLCJleHRyYWN0RXZlbnRzIiwidG9wTGV2ZWxUYXJnZXQiLCJ0b3BMZXZlbFRhcmdldElEIiwibmF0aXZlRXZlbnQiLCJuYXRpdmVFdmVudFRhcmdldCIsImV2ZW50cyIsInBsdWdpbnMiLCJwb3NzaWJsZVBsdWdpbiIsImV4dHJhY3RlZEV2ZW50cyIsImVucXVldWVFdmVudHMiLCJwcm9jZXNzRXZlbnRRdWV1ZSIsInByb2Nlc3NpbmdFdmVudFF1ZXVlIiwicmV0aHJvd0NhdWdodEVycm9yIiwiX19wdXJnZSIsIl9fZ2V0TGlzdGVuZXJCYW5rIiwiRXZlbnRQbHVnaW5PcmRlciIsIm5hbWVzVG9QbHVnaW5zIiwicmVjb21wdXRlUGx1Z2luT3JkZXJpbmciLCJwbHVnaW5OYW1lIiwicGx1Z2luSW5kZXgiLCJwdWJsaXNoZWRFdmVudHMiLCJldmVudFR5cGVzIiwiZXZlbnROYW1lIiwicHVibGlzaEV2ZW50Rm9yUGx1Z2luIiwiZGlzcGF0Y2hDb25maWciLCJwaGFzZWRSZWdpc3RyYXRpb25OYW1lcyIsInBoYXNlTmFtZSIsInBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUiLCJwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZSIsIkluamVjdGVkRXZlbnRQbHVnaW5PcmRlciIsImluamVjdGVkTmFtZXNUb1BsdWdpbnMiLCJpc09yZGVyaW5nRGlydHkiLCJnZXRQbHVnaW5Nb2R1bGVGb3JFdmVudCIsInBoYXNlIiwiX3Jlc2V0RXZlbnRQbHVnaW5zIiwiSW5qZWN0ZWRNb3VudCIsImlzRW5kaXNoIiwiaXNNb3ZlaXNoIiwiaXNTdGFydGlzaCIsInZhbGlkYXRlRXZlbnREaXNwYXRjaGVzIiwiZGlzcGF0Y2hMaXN0ZW5lcnMiLCJfZGlzcGF0Y2hMaXN0ZW5lcnMiLCJkaXNwYXRjaElEcyIsIl9kaXNwYXRjaElEcyIsImxpc3RlbmVyc0lzQXJyIiwiaWRzSXNBcnIiLCJJRHNMZW4iLCJsaXN0ZW5lcnNMZW4iLCJleGVjdXRlRGlzcGF0Y2giLCJkb21JRCIsImN1cnJlbnRUYXJnZXQiLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2giLCJpbnZva2VHdWFyZGVkQ2FsbGJhY2siLCJpc1Byb3BhZ2F0aW9uU3RvcHBlZCIsImV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsIiwiZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSIsImV4ZWN1dGVEaXJlY3REaXNwYXRjaCIsImRpc3BhdGNoTGlzdGVuZXIiLCJkaXNwYXRjaElEIiwicmVzIiwiaGFzRGlzcGF0Y2hlcyIsImNhdWdodEVycm9yIiwiZGlzcGF0Y2hFdmVudCIsImNyZWF0ZUV2ZW50IiwiZmFrZU5vZGUiLCJib3VuZEZ1bmMiLCJldnRUeXBlIiwiZXZ0IiwiaW5pdEV2ZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5leHQiLCJjdXJyZW50SXNBcnJheSIsIm5leHRJc0FycmF5IiwiYXJyIiwiY2IiLCJzY29wZSIsInJ1bkV2ZW50UXVldWVJbkJhdGNoIiwiY3VycmVudFNjcm9sbExlZnQiLCJjdXJyZW50U2Nyb2xsVG9wIiwic2Nyb2xsUG9zaXRpb24iLCJ5IiwidGFyZ2V0Iiwic291cmNlcyIsIlR5cGVFcnJvciIsInRvIiwibmV4dEluZGV4IiwibmV4dFNvdXJjZSIsImZyb20iLCJ1c2VIYXNGZWF0dXJlIiwiaW1wbGVtZW50YXRpb24iLCJoYXNGZWF0dXJlIiwiZXZlbnROYW1lU3VmZml4IiwiY2FwdHVyZSIsImlzU3VwcG9ydGVkIiwiZWxlbWVudCIsImNhbkRlZmluZVByb3BlcnR5IiwiUkVBQ1RfRUxFTUVOVF9UWVBFIiwiU3ltYm9sIiwiUkVTRVJWRURfUFJPUFMiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNvdXJjZSIsIm93bmVyIiwiJCR0eXBlb2YiLCJfb3duZXIiLCJfc3RvcmUiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ3cml0YWJsZSIsInZhbGlkYXRlZCIsIl9zZWxmIiwiX3NvdXJjZSIsImNvbmZpZyIsImNoaWxkcmVuTGVuZ3RoIiwiY2hpbGRBcnJheSIsImRlZmF1bHRQcm9wcyIsImNyZWF0ZUZhY3RvcnkiLCJmYWN0b3J5IiwiY2xvbmVBbmRSZXBsYWNlS2V5Iiwib2xkRWxlbWVudCIsIm5ld0tleSIsIm5ld0VsZW1lbnQiLCJjbG9uZUFuZFJlcGxhY2VQcm9wcyIsIm5ld1Byb3BzIiwiY2xvbmVFbGVtZW50IiwibnVsbENvbXBvbmVudElEc1JlZ2lzdHJ5IiwicmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQiLCJkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEIiwiUmVhY3RSb290SW5kZXgiLCJTRVBBUkFUT1IiLCJTRVBBUkFUT1JfTEVOR1RIIiwiTUFYX1RSRUVfREVQVEgiLCJnZXRSZWFjdFJvb3RJRFN0cmluZyIsImlzQm91bmRhcnkiLCJpc1ZhbGlkSUQiLCJkZXNjZW5kYW50SUQiLCJnZXRQYXJlbnRJRCIsInN1YnN0ciIsImxhc3RJbmRleE9mIiwiZ2V0TmV4dERlc2NlbmRhbnRJRCIsImRlc3RpbmF0aW9uSUQiLCJzdGFydCIsImdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRCIsIm9uZUlEIiwidHdvSUQiLCJtaW5MZW5ndGgiLCJsYXN0Q29tbW9uTWFya2VySW5kZXgiLCJsb25nZXN0Q29tbW9uSUQiLCJ0cmF2ZXJzZVBhcmVudFBhdGgiLCJzdG9wIiwic2tpcEZpcnN0Iiwic2tpcExhc3QiLCJ0cmF2ZXJzZVVwIiwiZGVwdGgiLCJ0cmF2ZXJzZSIsImNyZWF0ZVJlYWN0Um9vdEluZGV4IiwiY3JlYXRlUmVhY3RJRCIsImxlYXZlSUQiLCJlbnRlcklEIiwidXBBcmciLCJkb3duQXJnIiwidHJhdmVyc2VUd29QaGFzZVNraXBUYXJnZXQiLCJfZ2V0TmV4dERlc2NlbmRhbnRJRCIsIlJlYWN0Um9vdEluZGV4SW5qZWN0aW9uIiwiaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgiLCJfY3JlYXRlUmVhY3RSb290SW5kZXgiLCJyZW1vdmUiLCJoYXMiLCJzZXQiLCJhZGxlcjMyIiwiVEFHX0VORCIsImFkZENoZWNrc3VtVG9NYXJrdXAiLCJleGlzdGluZ0NoZWNrc3VtIiwicGFyc2VJbnQiLCJtYXJrdXBDaGVja3N1bSIsIk1PRCIsImwiLCJtIiwiY2hhckNvZGVBdCIsIlJlYWN0UmVmIiwiYXR0YWNoUmVmcyIsImludGVybmFsSW5zdGFuY2UiLCJnZXRSZWFjdE1vdW50UmVhZHkiLCJlbnF1ZXVlIiwiZGV0YWNoUmVmcyIsInJlZnNDaGFuZ2VkIiwic2hvdWxkVXBkYXRlUmVmcyIsInBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeSIsIlJlYWN0T3duZXIiLCJhdHRhY2hSZWYiLCJhZGRDb21wb25lbnRBc1JlZlRvIiwiZGV0YWNoUmVmIiwicmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tIiwicHJldkVtcHR5IiwibmV4dEVtcHR5IiwiaXNWYWxpZE93bmVyIiwicmVmcyIsImVucXVldWVVcGRhdGUiLCJnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUiLCJwdWJsaWNJbnN0YW5jZSIsImNhbGxlck5hbWUiLCJpc01vdW50ZWQiLCJfd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIiLCJlbnF1ZXVlQ2FsbGJhY2siLCJfcGVuZGluZ0NhbGxiYWNrcyIsImVucXVldWVGb3JjZVVwZGF0ZSIsIl9wZW5kaW5nRm9yY2VVcGRhdGUiLCJlbnF1ZXVlUmVwbGFjZVN0YXRlIiwiY29tcGxldGVTdGF0ZSIsIl9wZW5kaW5nU3RhdGVRdWV1ZSIsIl9wZW5kaW5nUmVwbGFjZVN0YXRlIiwiZW5xdWV1ZVNldFN0YXRlIiwicGFydGlhbFN0YXRlIiwiZW5xdWV1ZVNldFByb3BzIiwicGFydGlhbFByb3BzIiwiZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwiLCJ0b3BMZXZlbFdyYXBwZXIiLCJ3cmFwRWxlbWVudCIsIl9wZW5kaW5nRWxlbWVudCIsImVucXVldWVSZXBsYWNlUHJvcHMiLCJlbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWwiLCJDYWxsYmFja1F1ZXVlIiwiUG9vbGVkQ2xhc3MiLCJUcmFuc2FjdGlvbiIsImRpcnR5Q29tcG9uZW50cyIsImFzYXBDYWxsYmFja1F1ZXVlIiwiYXNhcEVucXVldWVkIiwiYmF0Y2hpbmdTdHJhdGVneSIsImVuc3VyZUluamVjdGVkIiwiTkVTVEVEX1VQREFURVMiLCJpbml0aWFsaXplIiwiZGlydHlDb21wb25lbnRzTGVuZ3RoIiwiY2xvc2UiLCJzcGxpY2UiLCJmbHVzaEJhdGNoZWRVcGRhdGVzIiwiVVBEQVRFX1FVRVVFSU5HIiwiY2FsbGJhY2tRdWV1ZSIsInJlc2V0Iiwibm90aWZ5QWxsIiwiVFJBTlNBQ1RJT05fV1JBUFBFUlMiLCJSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uIiwicmVpbml0aWFsaXplVHJhbnNhY3Rpb24iLCJyZWNvbmNpbGVUcmFuc2FjdGlvbiIsIk1peGluIiwiZ2V0VHJhbnNhY3Rpb25XcmFwcGVycyIsImRlc3RydWN0b3IiLCJtZXRob2QiLCJhZGRQb29saW5nVG8iLCJtb3VudE9yZGVyQ29tcGFyYXRvciIsImMxIiwiYzIiLCJfbW91bnRPcmRlciIsInJ1bkJhdGNoZWRVcGRhdGVzIiwic29ydCIsImNhbGxiYWNrcyIsImlzQmF0Y2hpbmdVcGRhdGVzIiwiYXNhcCIsIlJlYWN0VXBkYXRlc0luamVjdGlvbiIsImluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uIiwiUmVjb25jaWxlVHJhbnNhY3Rpb24iLCJpbmplY3RCYXRjaGluZ1N0cmF0ZWd5IiwiX2JhdGNoaW5nU3RyYXRlZ3kiLCJfY2FsbGJhY2tzIiwiX2NvbnRleHRzIiwiY29udGV4dHMiLCJvbmVBcmd1bWVudFBvb2xlciIsImNvcHlGaWVsZHNGcm9tIiwiS2xhc3MiLCJpbnN0YW5jZVBvb2wiLCJwb3AiLCJ0d29Bcmd1bWVudFBvb2xlciIsImExIiwiYTIiLCJ0aHJlZUFyZ3VtZW50UG9vbGVyIiwiYTMiLCJmb3VyQXJndW1lbnRQb29sZXIiLCJhNCIsImZpdmVBcmd1bWVudFBvb2xlciIsImE1Iiwic3RhbmRhcmRSZWxlYXNlciIsInBvb2xTaXplIiwiREVGQVVMVF9QT09MX1NJWkUiLCJERUZBVUxUX1BPT0xFUiIsIkNvcHlDb25zdHJ1Y3RvciIsInBvb2xlciIsIk5ld0tsYXNzIiwidHJhbnNhY3Rpb25XcmFwcGVycyIsIndyYXBwZXJJbml0RGF0YSIsIl9pc0luVHJhbnNhY3Rpb24iLCJpc0luVHJhbnNhY3Rpb24iLCJlcnJvclRocm93biIsImluaXRpYWxpemVBbGwiLCJjbG9zZUFsbCIsImVyciIsInN0YXJ0SW5kZXgiLCJPQlNFUlZFRF9FUlJPUiIsImluaXREYXRhIiwiaXNUZXh0Tm9kZSIsIl94IiwiX3gyIiwiX2FnYWluIiwiX2Z1bmN0aW9uIiwib3V0ZXJOb2RlIiwiaW5uZXJOb2RlIiwiY29udGFpbnMiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsImlzTm9kZSIsIk5vZGUiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCIsIlJlYWN0RW1wdHlDb21wb25lbnQiLCJSZWFjdE5hdGl2ZUNvbXBvbmVudCIsIlJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciIsIl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiaXNJbnRlcm5hbENvbXBvbmVudFR5cGUiLCJjcmVhdGVJbnRlcm5hbENvbXBvbmVudCIsImNyZWF0ZUluc3RhbmNlRm9yVGV4dCIsIl9tb3VudEltYWdlIiwiX2lzT3duZXJOZWNlc3NhcnkiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsIlJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQiLCJSZWFjdFByb3BUeXBlTG9jYXRpb25zIiwiUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMiLCJTdGF0ZWxlc3NDb21wb25lbnQiLCJDb21wb25lbnQiLCJ1cGRhdGVyIiwibmV4dE1vdW50SUQiLCJSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluIiwiX2luc3RhbmNlIiwicHVibGljUHJvcHMiLCJfcHJvY2Vzc1Byb3BzIiwicHVibGljQ29udGV4dCIsIl9wcm9jZXNzQ29udGV4dCIsImluc3QiLCJyZW5kZXJlZEVsZW1lbnQiLCJjYW5JbnN0YW50aWF0ZSIsImdldEluaXRpYWxTdGF0ZSIsImlzUmVhY3RDbGFzc0FwcHJvdmVkIiwiZ2V0RGVmYXVsdFByb3BzIiwicHJvcFR5cGVzIiwiY29udGV4dFR5cGVzIiwiY29tcG9uZW50U2hvdWxkVXBkYXRlIiwiY29tcG9uZW50RGlkVW5tb3VudCIsImNvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMiLCJpbml0aWFsU3RhdGUiLCJzdGF0ZSIsImNvbXBvbmVudFdpbGxNb3VudCIsIl9wcm9jZXNzUGVuZGluZ1N0YXRlIiwiX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJfbWFza0NvbnRleHQiLCJtYXNrZWRDb250ZXh0IiwiY29udGV4dE5hbWUiLCJfY2hlY2tQcm9wVHlwZXMiLCJjdXJyZW50Q29udGV4dCIsImNoaWxkQ29udGV4dCIsImdldENoaWxkQ29udGV4dCIsImNoaWxkQ29udGV4dFR5cGVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiZXgiLCJhZGRlbmR1bSIsIm5leHRDb250ZXh0IiwicHJldkNvbnRleHQiLCJ1cGRhdGVDb21wb25lbnQiLCJwcmV2UGFyZW50RWxlbWVudCIsIm5leHRQYXJlbnRFbGVtZW50IiwicHJldlVubWFza2VkQ29udGV4dCIsIm5leHRVbm1hc2tlZENvbnRleHQiLCJuZXh0UHJvcHMiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwibmV4dFN0YXRlIiwic2hvdWxkVXBkYXRlIiwic2hvdWxkQ29tcG9uZW50VXBkYXRlIiwiX3BlcmZvcm1Db21wb25lbnRVcGRhdGUiLCJwYXJ0aWFsIiwidW5tYXNrZWRDb250ZXh0IiwiaGFzQ29tcG9uZW50RGlkVXBkYXRlIiwiQm9vbGVhbiIsImNvbXBvbmVudERpZFVwZGF0ZSIsInByZXZQcm9wcyIsInByZXZTdGF0ZSIsImNvbXBvbmVudFdpbGxVcGRhdGUiLCJfdXBkYXRlUmVuZGVyZWRDb21wb25lbnQiLCJwcmV2Q29tcG9uZW50SW5zdGFuY2UiLCJwcmV2UmVuZGVyZWRFbGVtZW50IiwibmV4dFJlbmRlcmVkRWxlbWVudCIsInRoaXNJRCIsInByZXZDb21wb25lbnRJRCIsIm5leHRNYXJrdXAiLCJfcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCIsIl9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnRXaXRob3V0T3duZXJPckNvbnRleHQiLCJyZW5kZXJlZENvbXBvbmVudCIsIl9pc01vY2tGdW5jdGlvbiIsInB1YmxpY0NvbXBvbmVudEluc3RhbmNlIiwiaW5qZWN0ZWQiLCJpbmplY3RFbnZpcm9ubWVudCIsImVudmlyb25tZW50IiwicHJldlR5cGUiLCJuZXh0VHlwZSIsInBsYWNlaG9sZGVyRWxlbWVudCIsIlJlYWN0RW1wdHlDb21wb25lbnRJbmplY3Rpb24iLCJpbmplY3RFbXB0eUNvbXBvbmVudCIsImluc3RhbnRpYXRlIiwiYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzIiwiZ2VuZXJpY0NvbXBvbmVudENsYXNzIiwidGFnVG9Db21wb25lbnRDbGFzcyIsInRleHRDb21wb25lbnRDbGFzcyIsIlJlYWN0TmF0aXZlQ29tcG9uZW50SW5qZWN0aW9uIiwiaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzIiwiY29tcG9uZW50Q2xhc3MiLCJpbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MiLCJpbmplY3RDb21wb25lbnRDbGFzc2VzIiwiY29tcG9uZW50Q2xhc3NlcyIsImdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCIsImlzVGV4dENvbXBvbmVudCIsInNwZWNpYWxUYWdzIiwiaW5TY29wZVRhZ3MiLCJidXR0b25TY29wZVRhZ3MiLCJpbXBsaWVkRW5kVGFncyIsImVtcHR5QW5jZXN0b3JJbmZvIiwicGFyZW50VGFnIiwiZm9ybVRhZyIsImFUYWdJblNjb3BlIiwiYnV0dG9uVGFnSW5TY29wZSIsIm5vYnJUYWdJblNjb3BlIiwicFRhZ0luQnV0dG9uU2NvcGUiLCJsaXN0SXRlbVRhZ0F1dG9jbG9zaW5nIiwiZGxJdGVtVGFnQXV0b2Nsb3NpbmciLCJvbGRJbmZvIiwiYW5jZXN0b3JJbmZvIiwiaW5mbyIsImlzVGFnVmFsaWRXaXRoUGFyZW50IiwiZmluZEludmFsaWRBbmNlc3RvckZvclRhZyIsImZpbmRPd25lclN0YWNrIiwic3RhY2siLCJyZXZlcnNlIiwiZGlkV2FybiIsImNoaWxkVGFnIiwiY2hpbGRJbnN0YW5jZSIsInBhcmVudEluZm8iLCJpbnZhbGlkUGFyZW50IiwiaW52YWxpZEFuY2VzdG9yIiwicHJvYmxlbWF0aWMiLCJhbmNlc3RvclRhZyIsImFuY2VzdG9ySW5zdGFuY2UiLCJjaGlsZE93bmVyIiwiYW5jZXN0b3JPd25lciIsImNoaWxkT3duZXJzIiwiYW5jZXN0b3JPd25lcnMiLCJtaW5TdGFja0xlbiIsImRlZXBlc3RDb21tb24iLCJVTktOT1dOIiwiY2hpbGRPd25lck5hbWVzIiwiYW5jZXN0b3JPd25lck5hbWVzIiwib3duZXJJbmZvIiwid2FybktleSIsImlzVGFnVmFsaWRJbkNvbnRleHQiLCJCZWZvcmVJbnB1dEV2ZW50UGx1Z2luIiwiQ2hhbmdlRXZlbnRQbHVnaW4iLCJDbGllbnRSZWFjdFJvb3RJbmRleCIsIkRlZmF1bHRFdmVudFBsdWdpbk9yZGVyIiwiRW50ZXJMZWF2ZUV2ZW50UGx1Z2luIiwiSFRNTERPTVByb3BlcnR5Q29uZmlnIiwiUmVhY3RCcm93c2VyQ29tcG9uZW50TWl4aW4iLCJSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5IiwiUmVhY3RET01Db21wb25lbnQiLCJSZWFjdEluamVjdGlvbiIsIlNlbGVjdEV2ZW50UGx1Z2luIiwiU2VydmVyUmVhY3RSb290SW5kZXgiLCJTaW1wbGVFdmVudFBsdWdpbiIsIlNWR0RPTVByb3BlcnR5Q29uZmlnIiwiYWxyZWFkeUluamVjdGVkIiwiRXZlbnRFbWl0dGVyIiwiTmF0aXZlQ29tcG9uZW50IiwiQ2xhc3MiLCJpbmplY3RNaXhpbiIsIkVtcHR5Q29tcG9uZW50IiwiVXBkYXRlcyIsIlJvb3RJbmRleCIsInVybCIsImhyZWYiLCJSZWFjdERlZmF1bHRQZXJmIiwiRXZlbnRQcm9wYWdhdG9ycyIsIkZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSIsIlN5bnRoZXRpY0NvbXBvc2l0aW9uRXZlbnQiLCJTeW50aGV0aWNJbnB1dEV2ZW50Iiwia2V5T2YiLCJFTkRfS0VZQ09ERVMiLCJTVEFSVF9LRVlDT0RFIiwiY2FuVXNlQ29tcG9zaXRpb25FdmVudCIsImNhblVzZVRleHRJbnB1dEV2ZW50IiwiaXNQcmVzdG8iLCJ1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSIsIm9wZXJhIiwiU1BBQ0VCQVJfQ09ERSIsIlNQQUNFQkFSX0NIQVIiLCJiZWZvcmVJbnB1dCIsIm9uQmVmb3JlSW5wdXQiLCJvbkJlZm9yZUlucHV0Q2FwdHVyZSIsImNvbXBvc2l0aW9uRW5kIiwib25Db21wb3NpdGlvbkVuZCIsIm9uQ29tcG9zaXRpb25FbmRDYXB0dXJlIiwiY29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25TdGFydCIsIm9uQ29tcG9zaXRpb25TdGFydENhcHR1cmUiLCJjb21wb3NpdGlvblVwZGF0ZSIsIm9uQ29tcG9zaXRpb25VcGRhdGUiLCJvbkNvbXBvc2l0aW9uVXBkYXRlQ2FwdHVyZSIsImhhc1NwYWNlS2V5cHJlc3MiLCJpc0tleXByZXNzQ29tbWFuZCIsImN0cmxLZXkiLCJhbHRLZXkiLCJtZXRhS2V5IiwiZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCIsImtleUNvZGUiLCJpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQiLCJnZXREYXRhRnJvbUN1c3RvbUV2ZW50IiwiZGV0YWlsIiwiY3VycmVudENvbXBvc2l0aW9uIiwiZXh0cmFjdENvbXBvc2l0aW9uRXZlbnQiLCJldmVudFR5cGUiLCJmYWxsYmFja0RhdGEiLCJnZXREYXRhIiwiY3VzdG9tRGF0YSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMiLCJnZXROYXRpdmVCZWZvcmVJbnB1dENoYXJzIiwid2hpY2giLCJjaGFycyIsImdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyIsImV4dHJhY3RCZWZvcmVJbnB1dEV2ZW50IiwibGlzdGVuZXJBdFBoYXNlIiwicHJvcGFnYXRpb25QaGFzZSIsImFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMiLCJ1cHdhcmRzIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSIsImRpc3BhdGNoTWFya2VyIiwiYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZVNraXBUYXJnZXQiLCJhY2N1bXVsYXRlRGlzcGF0Y2hlcyIsImlnbm9yZWREaXJlY3Rpb24iLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZSIsImFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0IiwiYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzIiwibGVhdmUiLCJlbnRlciIsImZyb21JRCIsInRvSUQiLCJhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyIsImdldFRleHRDb250ZW50QWNjZXNzb3IiLCJyb290IiwiX3Jvb3QiLCJfc3RhcnRUZXh0IiwiZ2V0VGV4dCIsIl9mYWxsYmFja1RleHQiLCJzdGFydFZhbHVlIiwic3RhcnRMZW5ndGgiLCJlbmQiLCJlbmRWYWx1ZSIsImVuZExlbmd0aCIsIm1pbkVuZCIsInNsaWNlVGFpbCIsImNvbnRlbnRLZXkiLCJTeW50aGV0aWNFdmVudCIsIkNvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UiLCJhdWdtZW50Q2xhc3MiLCJFdmVudEludGVyZmFjZSIsImV2ZW50UGhhc2UiLCJidWJibGVzIiwiY2FuY2VsYWJsZSIsInRpbWVTdGFtcCIsImRlZmF1bHRQcmV2ZW50ZWQiLCJpc1RydXN0ZWQiLCJJbnRlcmZhY2UiLCJub3JtYWxpemUiLCJyZXR1cm5WYWx1ZSIsImlzRGVmYXVsdFByZXZlbnRlZCIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwiY2FuY2VsQnViYmxlIiwicGVyc2lzdCIsIlN1cGVyIiwiSW5wdXRFdmVudEludGVyZmFjZSIsIm9uZUtleU9iaiIsImdldEV2ZW50VGFyZ2V0IiwiaXNUZXh0SW5wdXRFbGVtZW50IiwiY2hhbmdlIiwib25DaGFuZ2UiLCJvbkNoYW5nZUNhcHR1cmUiLCJhY3RpdmVFbGVtZW50IiwiYWN0aXZlRWxlbWVudElEIiwiYWN0aXZlRWxlbWVudFZhbHVlIiwiYWN0aXZlRWxlbWVudFZhbHVlUHJvcCIsInNob3VsZFVzZUNoYW5nZUV2ZW50IiwiZWxlbSIsImRvZXNDaGFuZ2VFdmVudEJ1YmJsZSIsIm1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQiLCJydW5FdmVudEluQmF0Y2giLCJzdGFydFdhdGNoaW5nRm9yQ2hhbmdlRXZlbnRJRTgiLCJzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCIsImRldGFjaEV2ZW50IiwiZ2V0VGFyZ2V0SURGb3JDaGFuZ2VFdmVudCIsImhhbmRsZUV2ZW50c0ZvckNoYW5nZUV2ZW50SUU4IiwiaXNJbnB1dEV2ZW50U3VwcG9ydGVkIiwibmV3VmFsdWVQcm9wIiwidmFsIiwic3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiaGFuZGxlUHJvcGVydHlDaGFuZ2UiLCJzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSIsInNyY0VsZW1lbnQiLCJnZXRUYXJnZXRJREZvcklucHV0RXZlbnQiLCJoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUUiLCJnZXRUYXJnZXRJREZvcklucHV0RXZlbnRJRSIsInNob3VsZFVzZUNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJREZvckNsaWNrRXZlbnQiLCJnZXRUYXJnZXRJREZ1bmMiLCJoYW5kbGVFdmVudEZ1bmMiLCJzdXBwb3J0ZWRJbnB1dFR5cGVzIiwibmV4dFJlYWN0Um9vdEluZGV4IiwiUmVzcG9uZGVyRXZlbnRQbHVnaW4iLCJUYXBFdmVudFBsdWdpbiIsIlN5bnRoZXRpY01vdXNlRXZlbnQiLCJtb3VzZUVudGVyIiwib25Nb3VzZUVudGVyIiwibW91c2VMZWF2ZSIsIm9uTW91c2VMZWF2ZSIsInJlbGF0ZWRUYXJnZXQiLCJmcm9tRWxlbWVudCIsIndpbiIsImRvYyIsImRlZmF1bHRWaWV3IiwicGFyZW50V2luZG93IiwidG9FbGVtZW50IiwiU3ludGhldGljVUlFdmVudCIsImdldEV2ZW50TW9kaWZpZXJTdGF0ZSIsIk1vdXNlRXZlbnRJbnRlcmZhY2UiLCJzY3JlZW5YIiwic2NyZWVuWSIsImNsaWVudFgiLCJjbGllbnRZIiwic2hpZnRLZXkiLCJnZXRNb2RpZmllclN0YXRlIiwiYnV0dG9uIiwiYnV0dG9ucyIsInBhZ2VYIiwicGFnZVkiLCJVSUV2ZW50SW50ZXJmYWNlIiwidmlldyIsIm1vZGlmaWVyS2V5VG9Qcm9wIiwibW9kaWZpZXJTdGF0ZUdldHRlciIsImtleUFyZyIsInN5bnRoZXRpY0V2ZW50Iiwia2V5UHJvcCIsImhhc1NWRyIsIlJlZ0V4cCIsImFjY2VwdCIsImFjY2VwdENoYXJzZXQiLCJhY2Nlc3NLZXkiLCJhY3Rpb24iLCJhbGxvd0Z1bGxTY3JlZW4iLCJhbGxvd1RyYW5zcGFyZW5jeSIsImFsdCIsImFzeW5jIiwiYXV0b0NvbXBsZXRlIiwiYXV0b1BsYXkiLCJjZWxsUGFkZGluZyIsImNlbGxTcGFjaW5nIiwiY2hhclNldCIsImNoYWxsZW5nZSIsImNoZWNrZWQiLCJjbGFzc0lEIiwiY2xhc3NOYW1lIiwiY29scyIsImNvbFNwYW4iLCJjb250ZW50RWRpdGFibGUiLCJjb250ZXh0TWVudSIsImNvbnRyb2xzIiwiY29vcmRzIiwiY3Jvc3NPcmlnaW4iLCJkYXRlVGltZSIsImRlZmVyIiwiZGlzYWJsZWQiLCJkb3dubG9hZCIsImRyYWdnYWJsZSIsImVuY1R5cGUiLCJmb3JtIiwiZm9ybUFjdGlvbiIsImZvcm1FbmNUeXBlIiwiZm9ybU1ldGhvZCIsImZvcm1Ob1ZhbGlkYXRlIiwiZm9ybVRhcmdldCIsImZyYW1lQm9yZGVyIiwiaGVhZGVycyIsImhlaWdodCIsImhpZGRlbiIsImhpZ2giLCJocmVmTGFuZyIsImh0bWxGb3IiLCJodHRwRXF1aXYiLCJpY29uIiwiaW5wdXRNb2RlIiwiaW50ZWdyaXR5IiwiaXMiLCJrZXlQYXJhbXMiLCJrZXlUeXBlIiwia2luZCIsImxhYmVsIiwibGFuZyIsImxpc3QiLCJsb29wIiwibG93IiwibWFuaWZlc3QiLCJtYXJnaW5IZWlnaHQiLCJtYXJnaW5XaWR0aCIsIm1heCIsIm1heExlbmd0aCIsIm1lZGlhIiwibWVkaWFHcm91cCIsIm11bHRpcGxlIiwibXV0ZWQiLCJub25jZSIsIm5vVmFsaWRhdGUiLCJvcGVuIiwib3B0aW11bSIsInBhdHRlcm4iLCJwbGFjZWhvbGRlciIsInBvc3RlciIsInByZWxvYWQiLCJyYWRpb0dyb3VwIiwicmVhZE9ubHkiLCJyZWwiLCJyZXF1aXJlZCIsInJldmVyc2VkIiwicm9sZSIsInJvd3MiLCJyb3dTcGFuIiwic2FuZGJveCIsInNjb3BlZCIsInNjcm9sbGluZyIsInNlYW1sZXNzIiwic2VsZWN0ZWQiLCJzaGFwZSIsInNpemUiLCJzaXplcyIsInNwYW4iLCJzcGVsbENoZWNrIiwic3JjIiwic3JjRG9jIiwic3JjTGFuZyIsInNyY1NldCIsInN0ZXAiLCJzdW1tYXJ5IiwidGFiSW5kZXgiLCJ1c2VNYXAiLCJ3aWR0aCIsIndtb2RlIiwiYWJvdXQiLCJkYXRhdHlwZSIsImlubGlzdCIsInByZWZpeCIsInByb3BlcnR5IiwicmVzb3VyY2UiLCJ2b2NhYiIsImF1dG9DYXBpdGFsaXplIiwiYXV0b0NvcnJlY3QiLCJhdXRvU2F2ZSIsImNvbG9yIiwiaXRlbVByb3AiLCJpdGVtU2NvcGUiLCJpdGVtVHlwZSIsIml0ZW1JRCIsIml0ZW1SZWYiLCJyZXN1bHRzIiwic2VjdXJpdHkiLCJ1bnNlbGVjdGFibGUiLCJhdXRvRm9jdXMiLCJkaWRXYXJuS2V5IiwiZ2V0RE9NTm9kZSIsImNvbXBvbmVudE9yRWxlbWVudCIsIlJFU0VUX0JBVENIRURfVVBEQVRFUyIsIkZMVVNIX0JBVENIRURfVVBEQVRFUyIsIlJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbiIsImFscmVhZHlCYXRjaGluZ1VwZGF0ZXMiLCJBdXRvRm9jdXNVdGlscyIsIkNTU1Byb3BlcnR5T3BlcmF0aW9ucyIsIlJlYWN0RE9NQnV0dG9uIiwiUmVhY3RET01JbnB1dCIsIlJlYWN0RE9NT3B0aW9uIiwiUmVhY3RET01TZWxlY3QiLCJSZWFjdERPTVRleHRhcmVhIiwiUmVhY3RNdWx0aUNoaWxkIiwic2hhbGxvd0VxdWFsIiwiQ09OVEVOVF9UWVBFUyIsIkNISUxEUkVOIiwiU1RZTEUiLCJIVE1MIiwiX19odG1sIiwibGVnYWN5UHJvcHNEZXNjcmlwdG9yIiwiX3JlYWN0SW50ZXJuYWxDb21wb25lbnQiLCJsZWdhY3lHZXRET01Ob2RlIiwibGVnYWN5SXNNb3VudGVkIiwibGVnYWN5U2V0U3RhdGVFdGMiLCJsZWdhY3lTZXRQcm9wcyIsImxlZ2FjeVJlcGxhY2VQcm9wcyIsImZyaWVuZGx5U3RyaW5naWZ5IiwicGFpcnMiLCJrZXlFc2NhcGVkIiwiSlNPTiIsInN0cmluZ2lmeSIsInN0eWxlTXV0YXRpb25XYXJuaW5nIiwiY2hlY2tBbmRXYXJuRm9yTXV0YXRlZFN0eWxlIiwic3R5bGUxIiwic3R5bGUyIiwiX3RhZyIsIm93bmVyTmFtZSIsImhhc2giLCJhc3NlcnRWYWxpZFByb3BzIiwidm9pZEVsZW1lbnRUYWdzIiwiZW5xdWV1ZVB1dExpc3RlbmVyIiwibGlzdGVuZXJUb1B1dCIsIm1lZGlhRXZlbnRzIiwidHJhcEJ1YmJsZWRFdmVudHNMb2NhbCIsIl93cmFwcGVyU3RhdGUiLCJsaXN0ZW5lcnMiLCJtb3VudFJlYWR5SW5wdXRXcmFwcGVyIiwibW91bnRSZWFkeVdyYXBwZXIiLCJwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciIsInBvc3RVcGRhdGVXcmFwcGVyIiwib21pdHRlZENsb3NlVGFncyIsIm5ld2xpbmVFYXRpbmdUYWdzIiwiVkFMSURfVEFHX1JFR0VYIiwidmFsaWRhdGVkVGFnQ2FjaGUiLCJ2YWxpZGF0ZURhbmdlcm91c1RhZyIsInByb2Nlc3NDaGlsZENvbnRleHREZXYiLCJpc0N1c3RvbUNvbXBvbmVudCIsIl9yZW5kZXJlZENoaWxkcmVuIiwiX3ByZXZpb3VzU3R5bGUiLCJfcHJldmlvdXNTdHlsZUNvcHkiLCJfbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzIiwiX3VucHJvY2Vzc2VkQ29udGV4dERldiIsIl9wcm9jZXNzZWRDb250ZXh0RGV2IiwiZ2V0TmF0aXZlUHJvcHMiLCJtb3VudFdyYXBwZXIiLCJwcm9jZXNzQ2hpbGRDb250ZXh0IiwibW91bnRJbWFnZSIsIl91cGRhdGVET01Qcm9wZXJ0aWVzIiwiX2NyZWF0ZUluaXRpYWxDaGlsZHJlbiIsInRhZ09wZW4iLCJfY3JlYXRlT3BlblRhZ01hcmt1cEFuZFB1dExpc3RlbmVycyIsInRhZ0NvbnRlbnQiLCJfY3JlYXRlQ29udGVudE1hcmt1cCIsImZvY3VzRE9NQ29tcG9uZW50IiwicHJvcEtleSIsInByb3BWYWx1ZSIsImNyZWF0ZU1hcmt1cEZvclN0eWxlcyIsIm1hcmt1cEZvcklEIiwiY29udGVudFRvVXNlIiwiY2hpbGRyZW5Ub1VzZSIsIm1vdW50SW1hZ2VzIiwibW91bnRDaGlsZHJlbiIsImxhc3RQcm9wcyIsInVwZGF0ZVdyYXBwZXIiLCJfdXBkYXRlRE9NQ2hpbGRyZW4iLCJzdHlsZU5hbWUiLCJzdHlsZVVwZGF0ZXMiLCJsYXN0U3R5bGUiLCJuZXh0UHJvcCIsImxhc3RQcm9wIiwic2V0VmFsdWVGb3JTdHlsZXMiLCJsYXN0Q29udGVudCIsIm5leHRDb250ZW50IiwibGFzdEh0bWwiLCJuZXh0SHRtbCIsImxhc3RDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsImxhc3RIYXNDb250ZW50T3JIdG1sIiwibmV4dEhhc0NvbnRlbnRPckh0bWwiLCJ1cGRhdGVDaGlsZHJlbiIsInVwZGF0ZU1hcmt1cCIsInVubW91bnRXcmFwcGVyIiwidW5tb3VudENoaWxkcmVuIiwic2V0U3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJmb3JjZVVwZGF0ZSIsInNldFByb3BzIiwicmVwbGFjZVByb3BzIiwiZGVmaW5lUHJvcGVydGllcyIsImZvY3VzTm9kZSIsImZvY3VzIiwiQ1NTUHJvcGVydHkiLCJjYW1lbGl6ZVN0eWxlTmFtZSIsImRhbmdlcm91c1N0eWxlVmFsdWUiLCJoeXBoZW5hdGVTdHlsZU5hbWUiLCJtZW1vaXplU3RyaW5nT25seSIsInByb2Nlc3NTdHlsZU5hbWUiLCJoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyIsInN0eWxlRmxvYXRBY2Nlc3NvciIsInRlbXBTdHlsZSIsImZvbnQiLCJjc3NGbG9hdCIsImJhZFZlbmRvcmVkU3R5bGVOYW1lUGF0dGVybiIsImJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiIsIndhcm5lZFN0eWxlTmFtZXMiLCJ3YXJuZWRTdHlsZVZhbHVlcyIsIndhcm5IeXBoZW5hdGVkU3R5bGVOYW1lIiwid2FybkJhZFZlbmRvcmVkU3R5bGVOYW1lIiwid2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uIiwid2FyblZhbGlkU3R5bGUiLCJzdHlsZXMiLCJzZXJpYWxpemVkIiwic3R5bGVWYWx1ZSIsImV4cGFuc2lvbiIsInNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyIsImluZGl2aWR1YWxTdHlsZU5hbWUiLCJpc1VuaXRsZXNzTnVtYmVyIiwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQiLCJib3hGbGV4IiwiYm94RmxleEdyb3VwIiwiYm94T3JkaW5hbEdyb3VwIiwiY29sdW1uQ291bnQiLCJmbGV4IiwiZmxleEdyb3ciLCJmbGV4UG9zaXRpdmUiLCJmbGV4U2hyaW5rIiwiZmxleE5lZ2F0aXZlIiwiZmxleE9yZGVyIiwiZm9udFdlaWdodCIsImxpbmVDbGFtcCIsImxpbmVIZWlnaHQiLCJvcGFjaXR5Iiwib3JkZXIiLCJvcnBoYW5zIiwidGFiU2l6ZSIsIndpZG93cyIsInpJbmRleCIsInpvb20iLCJmaWxsT3BhY2l0eSIsInN0b3BPcGFjaXR5Iiwic3Ryb2tlRGFzaG9mZnNldCIsInN0cm9rZU9wYWNpdHkiLCJzdHJva2VXaWR0aCIsInByZWZpeEtleSIsInByZWZpeGVzIiwiYmFja2dyb3VuZCIsImJhY2tncm91bmRBdHRhY2htZW50IiwiYmFja2dyb3VuZENvbG9yIiwiYmFja2dyb3VuZEltYWdlIiwiYmFja2dyb3VuZFBvc2l0aW9uWCIsImJhY2tncm91bmRQb3NpdGlvblkiLCJiYWNrZ3JvdW5kUmVwZWF0IiwiYmFja2dyb3VuZFBvc2l0aW9uIiwiYm9yZGVyIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJTdHlsZSIsImJvcmRlckNvbG9yIiwiYm9yZGVyQm90dG9tIiwiYm9yZGVyQm90dG9tV2lkdGgiLCJib3JkZXJCb3R0b21TdHlsZSIsImJvcmRlckJvdHRvbUNvbG9yIiwiYm9yZGVyTGVmdCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlckxlZnRTdHlsZSIsImJvcmRlckxlZnRDb2xvciIsImJvcmRlclJpZ2h0IiwiYm9yZGVyUmlnaHRXaWR0aCIsImJvcmRlclJpZ2h0U3R5bGUiLCJib3JkZXJSaWdodENvbG9yIiwiYm9yZGVyVG9wIiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJUb3BTdHlsZSIsImJvcmRlclRvcENvbG9yIiwiZm9udFN0eWxlIiwiZm9udFZhcmlhbnQiLCJmb250U2l6ZSIsImZvbnRGYW1pbHkiLCJvdXRsaW5lIiwib3V0bGluZVdpZHRoIiwib3V0bGluZVN0eWxlIiwib3V0bGluZUNvbG9yIiwiY2FtZWxpemUiLCJtc1BhdHRlcm4iLCJzdHJpbmciLCJfaHlwaGVuUGF0dGVybiIsIl8iLCJjaGFyYWN0ZXIiLCJpc0VtcHR5IiwiaXNOb25OdW1lcmljIiwiaHlwaGVuYXRlIiwiX3VwcGVyY2FzZVBhdHRlcm4iLCJjYWNoZSIsIm1vdXNlTGlzdGVuZXJOYW1lcyIsIm9uQ2xpY2siLCJvbkRvdWJsZUNsaWNrIiwib25Nb3VzZURvd24iLCJvbk1vdXNlTW92ZSIsIm9uTW91c2VVcCIsIm9uQ2xpY2tDYXB0dXJlIiwib25Eb3VibGVDbGlja0NhcHR1cmUiLCJvbk1vdXNlRG93bkNhcHR1cmUiLCJvbk1vdXNlTW92ZUNhcHR1cmUiLCJvbk1vdXNlVXBDYXB0dXJlIiwibmF0aXZlUHJvcHMiLCJMaW5rZWRWYWx1ZVV0aWxzIiwiaW5zdGFuY2VzQnlSZWFjdElEIiwiZm9yY2VVcGRhdGVJZk1vdW50ZWQiLCJnZXRWYWx1ZSIsImdldENoZWNrZWQiLCJkZWZhdWx0Q2hlY2tlZCIsImluaXRpYWxWYWx1ZSIsImluaXRpYWxDaGVja2VkIiwiY2hlY2tQcm9wVHlwZXMiLCJfaGFuZGxlQ2hhbmdlIiwiZXhlY3V0ZU9uQ2hhbmdlIiwicm9vdE5vZGUiLCJxdWVyeVJvb3QiLCJncm91cCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJvdGhlck5vZGUiLCJvdGhlcklEIiwib3RoZXJJbnN0YW5jZSIsIlJlYWN0UHJvcFR5cGVzIiwiaGFzUmVhZE9ubHlWYWx1ZSIsIl9hc3NlcnRTaW5nbGVMaW5rIiwiaW5wdXRQcm9wcyIsImNoZWNrZWRMaW5rIiwidmFsdWVMaW5rIiwiX2Fzc2VydFZhbHVlTGluayIsIl9hc3NlcnRDaGVja2VkTGluayIsImxvZ2dlZFR5cGVGYWlsdXJlcyIsInJlcXVlc3RDaGFuZ2UiLCJnZXRJdGVyYXRvckZuIiwiQU5PTllNT1VTIiwiY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIiLCJib29sIiwibnVtYmVyIiwiYW55IiwiY3JlYXRlQW55VHlwZUNoZWNrZXIiLCJhcnJheU9mIiwiY3JlYXRlQXJyYXlPZlR5cGVDaGVja2VyIiwiY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyIiwiaW5zdGFuY2VPZiIsImNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIiLCJjcmVhdGVOb2RlQ2hlY2tlciIsIm9iamVjdE9mIiwiY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlciIsIm9uZU9mIiwiY3JlYXRlRW51bVR5cGVDaGVja2VyIiwib25lT2ZUeXBlIiwiY3JlYXRlVW5pb25UeXBlQ2hlY2tlciIsImNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIiLCJjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlciIsInZhbGlkYXRlIiwiY2hlY2tUeXBlIiwiaXNSZXF1aXJlZCIsInByb3BGdWxsTmFtZSIsImxvY2F0aW9uTmFtZSIsImNoYWluZWRDaGVja1R5cGUiLCJleHBlY3RlZFR5cGUiLCJwcm9wVHlwZSIsImdldFByb3BUeXBlIiwicHJlY2lzZVR5cGUiLCJnZXRQcmVjaXNlVHlwZSIsInR5cGVDaGVja2VyIiwiZXhwZWN0ZWRDbGFzcyIsImV4cGVjdGVkQ2xhc3NOYW1lIiwiYWN0dWFsQ2xhc3NOYW1lIiwiZ2V0Q2xhc3NOYW1lIiwiZXhwZWN0ZWRWYWx1ZXMiLCJ2YWx1ZXNTdHJpbmciLCJhcnJheU9mVHlwZUNoZWNrZXJzIiwiY2hlY2tlciIsInNoYXBlVHlwZXMiLCJpdGVyYXRvckZuIiwiaXRlcmF0b3IiLCJlbnRyaWVzIiwiZG9uZSIsImVudHJ5IiwiSVRFUkFUT1JfU1lNQk9MIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJtYXliZUl0ZXJhYmxlIiwiUmVhY3RDaGlsZHJlbiIsInZhbHVlQ29udGV4dEtleSIsInNlbGVjdFZhbHVlIiwidHJhdmVyc2VBbGxDaGlsZHJlbiIsInVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4IiwiZXNjYXBlVXNlclByb3ZpZGVkS2V5IiwiRm9yRWFjaEJvb2tLZWVwaW5nIiwiZm9yRWFjaEZ1bmN0aW9uIiwiZm9yRWFjaENvbnRleHQiLCJjb3VudCIsImZvckVhY2hTaW5nbGVDaGlsZCIsImJvb2tLZWVwaW5nIiwiZm9yRWFjaENoaWxkcmVuIiwiZm9yRWFjaEZ1bmMiLCJ0cmF2ZXJzZUNvbnRleHQiLCJNYXBCb29rS2VlcGluZyIsIm1hcFJlc3VsdCIsImtleVByZWZpeCIsIm1hcEZ1bmN0aW9uIiwibWFwQ29udGV4dCIsInJlc3VsdCIsIm1hcFNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJjaGlsZEtleSIsIm1hcHBlZENoaWxkIiwibWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCIsImVzY2FwZWRQcmVmaXgiLCJtYXBDaGlsZHJlbiIsImZvckVhY2hTaW5nbGVDaGlsZER1bW15IiwiY291bnRDaGlsZHJlbiIsIlNVQlNFUEFSQVRPUiIsInVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXAiLCJkaWRXYXJuQWJvdXRNYXBzIiwidXNlclByb3ZpZGVkS2V5RXNjYXBlciIsImdldENvbXBvbmVudEtleSIsIndyYXBVc2VyUHJvdmlkZWRLZXkiLCJ0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbCIsIm5hbWVTb0ZhciIsIm5leHROYW1lIiwic3VidHJlZUNvdW50IiwibmV4dE5hbWVQcmVmaXgiLCJfaXNSZWFjdEVsZW1lbnQiLCJjaGlsZHJlblN0cmluZyIsInVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkIiwicGVuZGluZ1VwZGF0ZSIsInVwZGF0ZU9wdGlvbnMiLCJ2YWx1ZVByb3BOYW1lcyIsImNoZWNrU2VsZWN0UHJvcFR5cGVzIiwic2VsZWN0ZWRWYWx1ZSIsIm9wdGlvbnMiLCJ3YXNNdWx0aXBsZSIsIlJlYWN0Q2hpbGRSZWNvbmNpbGVyIiwiZmxhdHRlbkNoaWxkcmVuIiwidXBkYXRlRGVwdGgiLCJ1cGRhdGVRdWV1ZSIsIm1hcmt1cFF1ZXVlIiwiZW5xdWV1ZUluc2VydE1hcmt1cCIsImVucXVldWVNb3ZlIiwiZW5xdWV1ZVJlbW92ZSIsImVucXVldWVTZXRNYXJrdXAiLCJlbnF1ZXVlVGV4dENvbnRlbnQiLCJwcm9jZXNzUXVldWUiLCJjbGVhclF1ZXVlIiwiX3JlY29uY2lsZXJJbnN0YW50aWF0ZUNoaWxkcmVuIiwibmVzdGVkQ2hpbGRyZW4iLCJpbnN0YW50aWF0ZUNoaWxkcmVuIiwiX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbiIsInByZXZDaGlsZHJlbiIsIm5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIiwiX3VubW91bnRDaGlsZCIsIl91bm1vdW50Q2hpbGRCeU5hbWUiLCJzZXRNYXJrdXAiLCJfdXBkYXRlQ2hpbGRyZW4iLCJsYXN0SW5kZXgiLCJwcmV2Q2hpbGQiLCJuZXh0Q2hpbGQiLCJtb3ZlQ2hpbGQiLCJfbW91bnRDaGlsZEJ5TmFtZUF0SW5kZXgiLCJyZW5kZXJlZENoaWxkcmVuIiwiY3JlYXRlQ2hpbGQiLCJpbnN0YW50aWF0ZUNoaWxkIiwiY2hpbGRJbnN0YW5jZXMiLCJrZXlVbmlxdWUiLCJuZXN0ZWRDaGlsZE5vZGVzIiwibmV4dENoaWxkSW5zdGFuY2UiLCJyZW5kZXJlZENoaWxkIiwiZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQiLCJvYmpBIiwib2JqQiIsImtleXNBIiwia2V5c0IiLCJiSGFzT3duUHJvcGVydHkiLCJFdmVudExpc3RlbmVyIiwiZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb24iLCJmaW5kUGFyZW50IiwicGFyZW50IiwiVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nIiwiYW5jZXN0b3JzIiwiaGFuZGxlVG9wTGV2ZWxJbXBsIiwiaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aCIsImhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgiLCJfaGFuZGxlVG9wTGV2ZWwiLCJwYXRoIiwiY3VycmVudE5hdGl2ZVRhcmdldCIsImV2ZW50c0ZpcmVkIiwiY3VycmVudFBhdGhFbGVtZW50IiwicmVhY3RQYXJlbnQiLCJjdXJyZW50UGF0aEVsZW1lbnRJRCIsIm5ld1Jvb3RJRCIsInNjcm9sbFZhbHVlTW9uaXRvciIsIl9lbmFibGVkIiwibGlzdGVuIiwicmVnaXN0ZXJEZWZhdWx0Iiwic2Nyb2xsYWJsZSIsInBhZ2VYT2Zmc2V0Iiwic2Nyb2xsTGVmdCIsInBhZ2VZT2Zmc2V0Iiwic2Nyb2xsVG9wIiwiUmVhY3RDbGFzcyIsIlBlcmYiLCJSZWFjdENvbXBvbmVudCIsIlJlYWN0Tm9vcFVwZGF0ZVF1ZXVlIiwiTUlYSU5TX0tFWSIsIm1peGlucyIsIlNwZWNQb2xpY3kiLCJERUZJTkVfT05DRSIsIkRFRklORV9NQU5ZIiwiT1ZFUlJJREVfQkFTRSIsIkRFRklORV9NQU5ZX01FUkdFRCIsImluamVjdGVkTWl4aW5zIiwid2FybmVkU2V0UHJvcHMiLCJ3YXJuU2V0UHJvcHMiLCJSZWFjdENsYXNzSW50ZXJmYWNlIiwic3RhdGljcyIsIlJFU0VSVkVEX1NQRUNfS0VZUyIsIkNvbnN0cnVjdG9yIiwibWl4U3BlY0ludG9Db21wb25lbnQiLCJ2YWxpZGF0ZVR5cGVEZWYiLCJjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbiIsIm1peFN0YXRpY1NwZWNJbnRvQ29tcG9uZW50IiwiYXV0b2JpbmQiLCJ0eXBlRGVmIiwidmFsaWRhdGVNZXRob2RPdmVycmlkZSIsInByb3RvIiwic3BlY1BvbGljeSIsIlJlYWN0Q2xhc3NNaXhpbiIsInNwZWMiLCJpc1JlYWN0Q2xhc3NNZXRob2QiLCJpc0FscmVhZHlEZWZpbmVkIiwiaXNGdW5jdGlvbiIsInNob3VsZEF1dG9CaW5kIiwiX19yZWFjdEF1dG9CaW5kTWFwIiwiY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uIiwiaXNSZXNlcnZlZCIsImlzSW5oZXJpdGVkIiwibWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyIsIm9uZSIsInR3byIsIm1lcmdlZFJlc3VsdCIsImNoYWluZWRGdW5jdGlvbiIsImJpbmRBdXRvQmluZE1ldGhvZCIsImJvdW5kTWV0aG9kIiwiX19yZWFjdEJvdW5kQ29udGV4dCIsIl9fcmVhY3RCb3VuZE1ldGhvZCIsIl9fcmVhY3RCb3VuZEFyZ3VtZW50cyIsIl9iaW5kIiwibmV3VGhpcyIsInJlYm91bmRNZXRob2QiLCJiaW5kQXV0b0JpbmRNZXRob2RzIiwiYXV0b0JpbmRLZXkiLCJuZXdTdGF0ZSIsIlJlYWN0Q2xhc3NDb21wb25lbnQiLCJjcmVhdGVDbGFzcyIsIm1ldGhvZE5hbWUiLCJtaXhpbiIsImRlcHJlY2F0ZWRBUElzIiwiZGVmaW5lRGVwcmVjYXRpb25XYXJuaW5nIiwid2FyblREWiIsIlJlYWN0SW5wdXRTZWxlY3Rpb24iLCJTRUxFQ1RJT05fUkVTVE9SQVRJT04iLCJnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbiIsInJlc3RvcmVTZWxlY3Rpb24iLCJFVkVOVF9TVVBQUkVTU0lPTiIsImN1cnJlbnRseUVuYWJsZWQiLCJwcmV2aW91c2x5RW5hYmxlZCIsIk9OX0RPTV9SRUFEWV9RVUVVRUlORyIsInJlYWN0TW91bnRSZWFkeSIsImZvcmNlSFRNTCIsIlJlYWN0RE9NU2VsZWN0aW9uIiwiZ2V0QWN0aXZlRWxlbWVudCIsImlzSW5Eb2N1bWVudCIsImhhc1NlbGVjdGlvbkNhcGFiaWxpdGllcyIsImZvY3VzZWRFbGVtIiwic2VsZWN0aW9uUmFuZ2UiLCJnZXRTZWxlY3Rpb24iLCJwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uIiwiY3VyRm9jdXNlZEVsZW0iLCJwcmlvckZvY3VzZWRFbGVtIiwicHJpb3JTZWxlY3Rpb25SYW5nZSIsInNldFNlbGVjdGlvbiIsImlucHV0Iiwic2VsZWN0aW9uIiwic2VsZWN0aW9uU3RhcnQiLCJzZWxlY3Rpb25FbmQiLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwicGFyZW50RWxlbWVudCIsIm1vdmVTdGFydCIsIm1vdmVFbmQiLCJnZXRPZmZzZXRzIiwib2Zmc2V0cyIsImNyZWF0ZVRleHRSYW5nZSIsImNvbGxhcHNlIiwic2VsZWN0Iiwic2V0T2Zmc2V0cyIsImdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQiLCJpc0NvbGxhcHNlZCIsImFuY2hvck5vZGUiLCJhbmNob3JPZmZzZXQiLCJmb2N1c09mZnNldCIsImdldElFT2Zmc2V0cyIsInNlbGVjdGVkUmFuZ2UiLCJzZWxlY3RlZExlbmd0aCIsImZyb21TdGFydCIsImR1cGxpY2F0ZSIsIm1vdmVUb0VsZW1lbnRUZXh0Iiwic2V0RW5kUG9pbnQiLCJzdGFydE9mZnNldCIsImVuZE9mZnNldCIsImdldE1vZGVybk9mZnNldHMiLCJyYW5nZUNvdW50IiwiY3VycmVudFJhbmdlIiwiZ2V0UmFuZ2VBdCIsInN0YXJ0Q29udGFpbmVyIiwiZW5kQ29udGFpbmVyIiwiaXNTZWxlY3Rpb25Db2xsYXBzZWQiLCJyYW5nZUxlbmd0aCIsInRlbXBSYW5nZSIsImNsb25lUmFuZ2UiLCJzZWxlY3ROb2RlQ29udGVudHMiLCJzZXRFbmQiLCJpc1RlbXBSYW5nZUNvbGxhcHNlZCIsImRldGVjdGlvblJhbmdlIiwic2V0U3RhcnQiLCJpc0JhY2t3YXJkIiwiY29sbGFwc2VkIiwic2V0SUVPZmZzZXRzIiwic2V0TW9kZXJuT2Zmc2V0cyIsImV4dGVuZCIsInRlbXAiLCJzdGFydE1hcmtlciIsImVuZE1hcmtlciIsIm9mZnNldCIsInJlbW92ZUFsbFJhbmdlcyIsImFkZFJhbmdlIiwidXNlSUVPZmZzZXRzIiwiZ2V0TGVhZk5vZGUiLCJnZXRTaWJsaW5nTm9kZSIsIm5vZGVTdGFydCIsIm5vZGVFbmQiLCJza2lwU2VsZWN0aW9uQ2hhbmdlRXZlbnQiLCJvblNlbGVjdCIsIm9uU2VsZWN0Q2FwdHVyZSIsImxhc3RTZWxlY3Rpb24iLCJtb3VzZURvd24iLCJoYXNMaXN0ZW5lciIsIk9OX1NFTEVDVF9LRVkiLCJib3VuZGluZ1RvcCIsImxlZnQiLCJib3VuZGluZ0xlZnQiLCJjb25zdHJ1Y3RTZWxlY3RFdmVudCIsImN1cnJlbnRTZWxlY3Rpb24iLCJHTE9CQUxfTU9VTlRfUE9JTlRfTUFYIiwicG93IiwiY2VpbCIsIlN5bnRoZXRpY0NsaXBib2FyZEV2ZW50IiwiU3ludGhldGljRm9jdXNFdmVudCIsIlN5bnRoZXRpY0tleWJvYXJkRXZlbnQiLCJTeW50aGV0aWNEcmFnRXZlbnQiLCJTeW50aGV0aWNUb3VjaEV2ZW50IiwiU3ludGhldGljV2hlZWxFdmVudCIsImdldEV2ZW50Q2hhckNvZGUiLCJhYm9ydCIsIm9uQWJvcnQiLCJvbkFib3J0Q2FwdHVyZSIsImJsdXIiLCJvbkJsdXIiLCJvbkJsdXJDYXB0dXJlIiwiY2FuUGxheSIsIm9uQ2FuUGxheSIsIm9uQ2FuUGxheUNhcHR1cmUiLCJjYW5QbGF5VGhyb3VnaCIsIm9uQ2FuUGxheVRocm91Z2giLCJvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZSIsImNsaWNrIiwib25Db250ZXh0TWVudSIsIm9uQ29udGV4dE1lbnVDYXB0dXJlIiwiY29weSIsIm9uQ29weSIsIm9uQ29weUNhcHR1cmUiLCJjdXQiLCJvbkN1dCIsIm9uQ3V0Q2FwdHVyZSIsImRvdWJsZUNsaWNrIiwiZHJhZyIsIm9uRHJhZyIsIm9uRHJhZ0NhcHR1cmUiLCJkcmFnRW5kIiwib25EcmFnRW5kIiwib25EcmFnRW5kQ2FwdHVyZSIsImRyYWdFbnRlciIsIm9uRHJhZ0VudGVyIiwib25EcmFnRW50ZXJDYXB0dXJlIiwiZHJhZ0V4aXQiLCJvbkRyYWdFeGl0Iiwib25EcmFnRXhpdENhcHR1cmUiLCJkcmFnTGVhdmUiLCJvbkRyYWdMZWF2ZSIsIm9uRHJhZ0xlYXZlQ2FwdHVyZSIsImRyYWdPdmVyIiwib25EcmFnT3ZlciIsIm9uRHJhZ092ZXJDYXB0dXJlIiwiZHJhZ1N0YXJ0Iiwib25EcmFnU3RhcnQiLCJvbkRyYWdTdGFydENhcHR1cmUiLCJkcm9wIiwib25Ecm9wIiwib25Ecm9wQ2FwdHVyZSIsImR1cmF0aW9uQ2hhbmdlIiwib25EdXJhdGlvbkNoYW5nZSIsIm9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlIiwiZW1wdGllZCIsIm9uRW1wdGllZCIsIm9uRW1wdGllZENhcHR1cmUiLCJlbmNyeXB0ZWQiLCJvbkVuY3J5cHRlZCIsIm9uRW5jcnlwdGVkQ2FwdHVyZSIsImVuZGVkIiwib25FbmRlZCIsIm9uRW5kZWRDYXB0dXJlIiwib25FcnJvciIsIm9uRXJyb3JDYXB0dXJlIiwib25Gb2N1cyIsIm9uRm9jdXNDYXB0dXJlIiwib25JbnB1dCIsIm9uSW5wdXRDYXB0dXJlIiwia2V5RG93biIsIm9uS2V5RG93biIsIm9uS2V5RG93bkNhcHR1cmUiLCJrZXlQcmVzcyIsIm9uS2V5UHJlc3MiLCJvbktleVByZXNzQ2FwdHVyZSIsImtleVVwIiwib25LZXlVcCIsIm9uS2V5VXBDYXB0dXJlIiwibG9hZCIsIm9uTG9hZCIsIm9uTG9hZENhcHR1cmUiLCJsb2FkZWREYXRhIiwib25Mb2FkZWREYXRhIiwib25Mb2FkZWREYXRhQ2FwdHVyZSIsImxvYWRlZE1ldGFkYXRhIiwib25Mb2FkZWRNZXRhZGF0YSIsIm9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlIiwibG9hZFN0YXJ0Iiwib25Mb2FkU3RhcnQiLCJvbkxvYWRTdGFydENhcHR1cmUiLCJtb3VzZU1vdmUiLCJtb3VzZU91dCIsIm9uTW91c2VPdXQiLCJvbk1vdXNlT3V0Q2FwdHVyZSIsIm1vdXNlT3ZlciIsIm9uTW91c2VPdmVyIiwib25Nb3VzZU92ZXJDYXB0dXJlIiwibW91c2VVcCIsInBhc3RlIiwib25QYXN0ZSIsIm9uUGFzdGVDYXB0dXJlIiwicGF1c2UiLCJvblBhdXNlIiwib25QYXVzZUNhcHR1cmUiLCJwbGF5Iiwib25QbGF5Iiwib25QbGF5Q2FwdHVyZSIsInBsYXlpbmciLCJvblBsYXlpbmciLCJvblBsYXlpbmdDYXB0dXJlIiwicHJvZ3Jlc3MiLCJvblByb2dyZXNzIiwib25Qcm9ncmVzc0NhcHR1cmUiLCJyYXRlQ2hhbmdlIiwib25SYXRlQ2hhbmdlIiwib25SYXRlQ2hhbmdlQ2FwdHVyZSIsIm9uUmVzZXQiLCJvblJlc2V0Q2FwdHVyZSIsInNjcm9sbCIsIm9uU2Nyb2xsIiwib25TY3JvbGxDYXB0dXJlIiwic2Vla2VkIiwib25TZWVrZWQiLCJvblNlZWtlZENhcHR1cmUiLCJzZWVraW5nIiwib25TZWVraW5nIiwib25TZWVraW5nQ2FwdHVyZSIsInN0YWxsZWQiLCJvblN0YWxsZWQiLCJvblN0YWxsZWRDYXB0dXJlIiwic3VibWl0Iiwib25TdWJtaXQiLCJvblN1Ym1pdENhcHR1cmUiLCJzdXNwZW5kIiwib25TdXNwZW5kIiwib25TdXNwZW5kQ2FwdHVyZSIsInRpbWVVcGRhdGUiLCJvblRpbWVVcGRhdGUiLCJvblRpbWVVcGRhdGVDYXB0dXJlIiwidG91Y2hDYW5jZWwiLCJvblRvdWNoQ2FuY2VsIiwib25Ub3VjaENhbmNlbENhcHR1cmUiLCJ0b3VjaEVuZCIsIm9uVG91Y2hFbmQiLCJvblRvdWNoRW5kQ2FwdHVyZSIsInRvdWNoTW92ZSIsIm9uVG91Y2hNb3ZlIiwib25Ub3VjaE1vdmVDYXB0dXJlIiwidG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydCIsIm9uVG91Y2hTdGFydENhcHR1cmUiLCJ2b2x1bWVDaGFuZ2UiLCJvblZvbHVtZUNoYW5nZSIsIm9uVm9sdW1lQ2hhbmdlQ2FwdHVyZSIsIndhaXRpbmciLCJvbldhaXRpbmciLCJvbldhaXRpbmdDYXB0dXJlIiwid2hlZWwiLCJvbldoZWVsIiwib25XaGVlbENhcHR1cmUiLCJ0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWciLCJPTl9DTElDS19LRVkiLCJvbkNsaWNrTGlzdGVuZXJzIiwiRXZlbnRDb25zdHJ1Y3RvciIsIkNsaXBib2FyZEV2ZW50SW50ZXJmYWNlIiwiY2xpcGJvYXJkRGF0YSIsIkZvY3VzRXZlbnRJbnRlcmZhY2UiLCJnZXRFdmVudEtleSIsIktleWJvYXJkRXZlbnRJbnRlcmZhY2UiLCJyZXBlYXQiLCJsb2NhbGUiLCJjaGFyQ29kZSIsIm5vcm1hbGl6ZUtleSIsInRyYW5zbGF0ZVRvS2V5IiwiRHJhZ0V2ZW50SW50ZXJmYWNlIiwiZGF0YVRyYW5zZmVyIiwiVG91Y2hFdmVudEludGVyZmFjZSIsInRvdWNoZXMiLCJ0YXJnZXRUb3VjaGVzIiwiY2hhbmdlZFRvdWNoZXMiLCJXaGVlbEV2ZW50SW50ZXJmYWNlIiwiZGVsdGFYIiwid2hlZWxEZWx0YVgiLCJkZWx0YVkiLCJ3aGVlbERlbHRhWSIsIndoZWVsRGVsdGEiLCJkZWx0YVoiLCJkZWx0YU1vZGUiLCJOUyIsInhsaW5rIiwieG1sIiwiY2xpcFBhdGgiLCJjeCIsImN5IiwiZHgiLCJkeSIsImZpbGwiLCJmeCIsImZ5IiwiZ3JhZGllbnRUcmFuc2Zvcm0iLCJncmFkaWVudFVuaXRzIiwibWFya2VyRW5kIiwibWFya2VyTWlkIiwibWFya2VyU3RhcnQiLCJwYXR0ZXJuQ29udGVudFVuaXRzIiwicGF0dGVyblVuaXRzIiwicG9pbnRzIiwicHJlc2VydmVBc3BlY3RSYXRpbyIsInIiLCJyeCIsInJ5Iiwic3ByZWFkTWV0aG9kIiwic3RvcENvbG9yIiwic3Ryb2tlIiwic3Ryb2tlRGFzaGFycmF5Iiwic3Ryb2tlTGluZWNhcCIsInRleHRBbmNob3IiLCJ0cmFuc2Zvcm0iLCJ2aWV3Qm94IiwieDEiLCJ4MiIsInhsaW5rQWN0dWF0ZSIsInhsaW5rQXJjcm9sZSIsInhsaW5rSHJlZiIsInhsaW5rUm9sZSIsInhsaW5rU2hvdyIsInhsaW5rVGl0bGUiLCJ4bGlua1R5cGUiLCJ4bWxCYXNlIiwieG1sTGFuZyIsInhtbFNwYWNlIiwieTEiLCJ5MiIsIlJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyIsInBlcmZvcm1hbmNlTm93Iiwicm91bmRGbG9hdCIsImZsb29yIiwiYWRkVmFsdWUiLCJfYWxsTWVhc3VyZW1lbnRzIiwiX21vdW50U3RhY2siLCJfaW5qZWN0ZWQiLCJnZXRMYXN0TWVhc3VyZW1lbnRzIiwicHJpbnRFeGNsdXNpdmUiLCJtZWFzdXJlbWVudHMiLCJnZXRFeGNsdXNpdmVTdW1tYXJ5IiwidGFibGUiLCJpbmNsdXNpdmUiLCJleGNsdXNpdmUiLCJwcmludEluY2x1c2l2ZSIsImdldEluY2x1c2l2ZVN1bW1hcnkiLCJ0aW1lIiwibG9nIiwiZ2V0VG90YWxUaW1lIiwidG9GaXhlZCIsImdldE1lYXN1cmVtZW50c1N1bW1hcnlNYXAiLCJwcmludFdhc3RlZCIsInByaW50RE9NIiwiZ2V0RE9NU3VtbWFyeSIsIl9yZWNvcmRXcml0ZSIsInRvdGFsVGltZSIsIndyaXRlcyIsIm1vZHVsZU5hbWUiLCJydiIsImNvdW50cyIsImRpc3BsYXlOYW1lcyIsImNyZWF0ZWQiLCJtb3VudElEIiwid3JpdGVBcmdzIiwiaXNSZW5kZXIiLCJpc01vdW50IiwibW91bnRTdGFjayIsInN1Yk1vdW50VGltZSIsIkRPTlRfQ0FSRV9USFJFU0hPTEQiLCJET01fT1BFUkFUSU9OX1RZUEVTIiwibWVhc3VyZW1lbnQiLCJpdGVtcyIsImNhbmRpZGF0ZXMiLCJhbGxJRHMiLCJvbmx5Q2xlYW4iLCJpbmNsdXNpdmVLZXkiLCJjbGVhbkNvbXBvbmVudHMiLCJnZXRVbmNoYW5nZWRDb21wb25lbnRzIiwiZGlydHlMZWFmSURzIiwiaXNEaXJ0eSIsInBlcmZvcm1hbmNlIiwibXNQZXJmb3JtYW5jZSIsIndlYmtpdFBlcmZvcm1hbmNlIiwiUmVhY3RTZXJ2ZXJSZW5kZXJpbmciLCJSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kiLCJSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uIiwiUmVhY3RET01GYWN0b3JpZXMiLCJSZWFjdEVsZW1lbnRWYWxpZGF0b3IiLCJvbmx5Q2hpbGQiLCJDaGlsZHJlbiIsIm9ubHkiLCJQcm9wVHlwZXMiLCJjcmVhdGVNaXhpbiIsIkRPTSIsIl9fc3ByZWFkIiwibWFwT2JqZWN0IiwiY3JlYXRlRE9NRmFjdG9yeSIsImFiYnIiLCJhZGRyZXNzIiwiYXJlYSIsImFydGljbGUiLCJhc2lkZSIsImF1ZGlvIiwiYmFzZSIsImJkaSIsImJkbyIsImJpZyIsImJsb2NrcXVvdGUiLCJiciIsImNhbnZhcyIsImNhcHRpb24iLCJjaXRlIiwiY29kZSIsImNvbCIsImNvbGdyb3VwIiwiZGF0YWxpc3QiLCJkZCIsImRlbCIsImRldGFpbHMiLCJkZm4iLCJkaWFsb2ciLCJkaXYiLCJkbCIsImR0IiwiZW0iLCJlbWJlZCIsImZpZWxkc2V0IiwiZmlnY2FwdGlvbiIsImZpZ3VyZSIsImZvb3RlciIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImhlYWQiLCJoZWFkZXIiLCJoZ3JvdXAiLCJociIsImlmcmFtZSIsImltZyIsImlucyIsImtiZCIsImtleWdlbiIsImxlZ2VuZCIsImxpIiwibGluayIsIm1haW4iLCJtYXJrIiwibWVudSIsIm1lbnVpdGVtIiwibWV0YSIsIm1ldGVyIiwibmF2Iiwibm9zY3JpcHQiLCJvbCIsIm9wdGdyb3VwIiwib3B0aW9uIiwib3V0cHV0IiwicCIsInBhcmFtIiwicGljdHVyZSIsInByZSIsInEiLCJycCIsInJ0IiwicnVieSIsInMiLCJzYW1wIiwic2NyaXB0Iiwic2VjdGlvbiIsInNtYWxsIiwic3Ryb25nIiwic3ViIiwic3VwIiwidGJvZHkiLCJ0ZCIsInRleHRhcmVhIiwidGZvb3QiLCJ0aCIsInRoZWFkIiwidHIiLCJ0cmFjayIsInUiLCJ1bCIsInZpZGVvIiwid2JyIiwiY2lyY2xlIiwiZGVmcyIsImVsbGlwc2UiLCJnIiwiaW1hZ2UiLCJsaW5lIiwibGluZWFyR3JhZGllbnQiLCJtYXNrIiwicG9seWdvbiIsInBvbHlsaW5lIiwicmFkaWFsR3JhZGllbnQiLCJyZWN0Iiwic3ZnIiwidHNwYW4iLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwicGFyZW50VHlwZSIsImFkZGVuZGEiLCJnZXRBZGRlbmRhRm9yS2V5VXNlIiwicGFyZW50T3JPd25lciIsIm1lc3NhZ2VUeXBlIiwicGFyZW50TmFtZSIsIm1lbW9pemVyIiwidmFsaWRhdGVDaGlsZEtleXMiLCJ2YWxpZGF0ZVByb3BUeXBlcyIsInZhbGlkVHlwZSIsInZhbGlkYXRlZEZhY3RvcnkiLCJuZXdNb2R1bGUiLCJuZXdQYWNrYWdlIiwiY3R4IiwiZm4iLCJ3YXJuZWQiLCJuZXdGbiIsIl9fZXNNb2R1bGUiLCJjcmVhdGVNZW1vcnlIaXN0b3J5IiwiYnJvd3Nlckhpc3RvcnkiLCJhcHBseVJvdXRlck1pZGRsZXdhcmUiLCJmb3JtYXRQYXR0ZXJuIiwidXNlUm91dGVySGlzdG9yeSIsInJvdXRlclNoYXBlIiwibG9jYXRpb25TaGFwZSIsIlJvdXRpbmdDb250ZXh0IiwiUm91dGVyQ29udGV4dCIsImNyZWF0ZVJvdXRlcyIsInVzZVJvdXRlcyIsIlJvdXRlQ29udGV4dCIsIkxpZmVjeWNsZSIsIkhpc3RvcnkiLCJSZWRpcmVjdCIsIkluZGV4UmVkaXJlY3QiLCJ3aXRoUm91dGVyIiwiSW5kZXhMaW5rIiwiTGluayIsIl9Sb3V0ZVV0aWxzIiwiX1Byb3BUeXBlczIiLCJfUGF0dGVyblV0aWxzIiwiX1JvdXRlcjIiLCJfUm91dGVyMyIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfTGluazIiLCJfTGluazMiLCJfSW5kZXhMaW5rMiIsIl9JbmRleExpbmszIiwiX3dpdGhSb3V0ZXIyIiwiX3dpdGhSb3V0ZXIzIiwiX0luZGV4UmVkaXJlY3QyIiwiX0luZGV4UmVkaXJlY3QzIiwiX0luZGV4Um91dGUyIiwiX0luZGV4Um91dGUzIiwiX1JlZGlyZWN0MiIsIl9SZWRpcmVjdDMiLCJfUm91dGUyIiwiX1JvdXRlMyIsIl9IaXN0b3J5MiIsIl9IaXN0b3J5MyIsIl9MaWZlY3ljbGUyIiwiX0xpZmVjeWNsZTMiLCJfUm91dGVDb250ZXh0MiIsIl9Sb3V0ZUNvbnRleHQzIiwiX3VzZVJvdXRlczIiLCJfdXNlUm91dGVzMyIsIl9Sb3V0ZXJDb250ZXh0MiIsIl9Sb3V0ZXJDb250ZXh0MyIsIl9Sb3V0aW5nQ29udGV4dDIiLCJfUm91dGluZ0NvbnRleHQzIiwiX1Byb3BUeXBlczMiLCJfbWF0Y2gyIiwiX21hdGNoMyIsIl91c2VSb3V0ZXJIaXN0b3J5MiIsIl91c2VSb3V0ZXJIaXN0b3J5MyIsIl9hcHBseVJvdXRlck1pZGRsZXdhcmUyIiwiX2FwcGx5Um91dGVyTWlkZGxld2FyZTMiLCJfYnJvd3Nlckhpc3RvcnkyIiwiX2Jyb3dzZXJIaXN0b3J5MyIsIl9oYXNoSGlzdG9yeTIiLCJfaGFzaEhpc3RvcnkzIiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkyIiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkzIiwiZGVmYXVsdCIsIl9leHRlbmRzIiwiaXNSZWFjdENoaWxkcmVuIiwiY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50IiwiY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4iLCJfcmVhY3QiLCJfcmVhY3QyIiwiaXNWYWxpZENoaWxkIiwiY3JlYXRlUm91dGUiLCJyb3V0ZSIsImNoaWxkUm91dGVzIiwicGFyZW50Um91dGUiLCJyb3V0ZXMiLCJyb3V0ZXIiLCJjb21wb25lbnRzIiwiaGlzdG9yeSIsImZhbHN5IiwiX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMiLCJfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllczIiLCJfSW50ZXJuYWxQcm9wVHlwZXMiLCJJbnRlcm5hbFByb3BUeXBlcyIsIl9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkIiwiX3JvdXRlcldhcm5pbmciLCJfcm91dGVyV2FybmluZzIiLCJuZXdPYmoiLCJnbyIsImdvQmFjayIsImdvRm9yd2FyZCIsInNldFJvdXRlTGVhdmVIb29rIiwiaXNBY3RpdmUiLCJwYXRobmFtZSIsInNlYXJjaCIsImRlcHJlY2F0ZVByb3BUeXBlIiwiZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZSIsImRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZSIsImRlZmF1bHRFeHBvcnQiLCJjYW5Vc2VNZW1icmFuZSIsImRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMiLCJtZW1icmFuZSIsIl9sb29wIiwiX3JldCIsInJvdXRlcldhcm5pbmciLCJfcmVzZXRXYXJuZWQiLCJfd2FybmluZyIsIl93YXJuaW5nMiIsImZhbHNlVG9XYXJuIiwiY29tcGlsZVBhdHRlcm4iLCJtYXRjaFBhdHRlcm4iLCJnZXRQYXJhbU5hbWVzIiwiZ2V0UGFyYW1zIiwiX2ludmFyaWFudCIsIl9pbnZhcmlhbnQyIiwiZXNjYXBlUmVnRXhwIiwiX2NvbXBpbGVQYXR0ZXJuIiwicmVnZXhwU291cmNlIiwicGFyYW1OYW1lcyIsInRva2VucyIsIm1hdGNoZXIiLCJleGVjIiwiQ29tcGlsZWRQYXR0ZXJuc0NhY2hlIiwiX2NvbXBpbGVQYXR0ZXJuMiIsIm1hdGNoZWRQYXRoIiwicmVtYWluaW5nUGF0aG5hbWUiLCJwYXJhbVZhbHVlcyIsInYiLCJkZWNvZGVVUklDb21wb25lbnQiLCJwYXJhbXMiLCJwYXJhbU5hbWUiLCJfY29tcGlsZVBhdHRlcm4zIiwicGFyZW5Db3VudCIsInNwbGF0SW5kZXgiLCJ0b2tlbiIsInBhcmFtVmFsdWUiLCJzcGxhdCIsImVuY29kZVVSSSIsImVuY29kZVVSSUNvbXBvbmVudCIsIl9jcmVhdGVIYXNoSGlzdG9yeSIsIl9jcmVhdGVIYXNoSGlzdG9yeTIiLCJfdXNlUXVlcmllcyIsIl91c2VRdWVyaWVzMiIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciIsIl9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIiLCJfUm91dGVyQ29udGV4dCIsIl9Sb3V0ZXJVdGlscyIsIl9vYmplY3RXaXRob3V0UHJvcGVydGllcyIsImlzRGVwcmVjYXRlZEhpc3RvcnkiLCJfX3YyX2NvbXBhdGlibGVfXyIsImlzVW5zdXBwb3J0ZWRIaXN0b3J5IiwiZ2V0Q3VycmVudExvY2F0aW9uIiwiX1JlYWN0JFByb3BUeXBlcyIsIm9uVXBkYXRlIiwicGFyc2VRdWVyeVN0cmluZyIsInN0cmluZ2lmeVF1ZXJ5IiwibWF0Y2hDb250ZXh0IiwiaGFuZGxlRXJyb3IiLCJfdGhpcyIsIl9wcm9wcyIsIl9jcmVhdGVSb3V0ZXJPYmplY3RzIiwiY3JlYXRlUm91dGVyT2JqZWN0cyIsInRyYW5zaXRpb25NYW5hZ2VyIiwiX3VubGlzdGVuIiwiX3Byb3BzMiIsIndyYXBEZXByZWNhdGVkSGlzdG9yeSIsImNyZWF0ZVJvdXRlck9iamVjdCIsInJvdXRpbmdIaXN0b3J5IiwiY3JlYXRlUm91dGluZ0hpc3RvcnkiLCJfcHJvcHMzIiwiY3JlYXRlSGlzdG9yeSIsIl9zdGF0ZSIsIl9wcm9wczQiLCJfQWN0aW9ucyIsIl9QYXRoVXRpbHMiLCJfRXhlY3V0aW9uRW52aXJvbm1lbnQiLCJfRE9NVXRpbHMiLCJfRE9NU3RhdGVTdG9yYWdlIiwiX2NyZWF0ZURPTUhpc3RvcnkiLCJfY3JlYXRlRE9NSGlzdG9yeTIiLCJpc0Fic29sdXRlUGF0aCIsImVuc3VyZVNsYXNoIiwiZ2V0SGFzaFBhdGgiLCJyZXBsYWNlSGFzaFBhdGgiLCJhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoIiwic3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgiLCJnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgiLCJEZWZhdWx0UXVlcnlLZXkiLCJjcmVhdGVIYXNoSGlzdG9yeSIsInF1ZXJ5S2V5IiwicmVhZFN0YXRlIiwiY3JlYXRlS2V5IiwicGFyc2VQYXRoIiwiY3JlYXRlTG9jYXRpb24iLCJzdGFydEhhc2hDaGFuZ2VMaXN0ZW5lciIsIl9yZWYiLCJ0cmFuc2l0aW9uVG8iLCJoYXNoQ2hhbmdlTGlzdGVuZXIiLCJmaW5pc2hUcmFuc2l0aW9uIiwiYmFzZW5hbWUiLCJQT1AiLCJzYXZlU3RhdGUiLCJjdXJyZW50SGFzaCIsIlBVU0giLCJsaXN0ZW5lckNvdW50Iiwic3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciIsImxpc3RlbkJlZm9yZSIsInVubGlzdGVuIiwiZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQiLCJzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaCIsIm4iLCJjcmVhdGVIcmVmIiwicmVnaXN0ZXJUcmFuc2l0aW9uSG9vayIsImhvb2siLCJ1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2siLCJwdXNoU3RhdGUiLCJSRVBMQUNFIiwiZXh0cmFjdFBhdGgiLCJoYXNoSW5kZXgiLCJzZWFyY2hJbmRleCIsImdldFdpbmRvd1BhdGgiLCJnZXRVc2VyQ29uZmlybWF0aW9uIiwic3VwcG9ydHNIaXN0b3J5IiwiY29uZmlybSIsInVhIiwiS2V5UHJlZml4IiwiUXVvdGFFeGNlZWRlZEVycm9ycyIsIlNlY3VyaXR5RXJyb3IiLCJzZXNzaW9uU3RvcmFnZSIsInJlbW92ZUl0ZW0iLCJzZXRJdGVtIiwianNvbiIsImdldEl0ZW0iLCJwYXJzZSIsIl9jcmVhdGVIaXN0b3J5IiwiX2NyZWF0ZUhpc3RvcnkyIiwiY3JlYXRlRE9NSGlzdG9yeSIsIl9kZWVwRXF1YWwiLCJfZGVlcEVxdWFsMiIsIl9Bc3luY1V0aWxzIiwiX2NyZWF0ZUxvY2F0aW9uMiIsIl9jcmVhdGVMb2NhdGlvbjMiLCJfcnVuVHJhbnNpdGlvbkhvb2siLCJfcnVuVHJhbnNpdGlvbkhvb2syIiwiX2RlcHJlY2F0ZSIsIl9kZXByZWNhdGUyIiwiY3JlYXRlUmFuZG9tS2V5IiwibG9jYXRpb25zQXJlRXF1YWwiLCJEZWZhdWx0S2V5TGVuZ3RoIiwia2V5TGVuZ3RoIiwidHJhbnNpdGlvbkhvb2tzIiwiZmlsdGVyIiwiYWxsS2V5cyIsImNoYW5nZUxpc3RlbmVycyIsImdldEN1cnJlbnQiLCJwZW5kaW5nTG9jYXRpb24iLCJ1cGRhdGVMb2NhdGlvbiIsIm5ld0xvY2F0aW9uIiwiX2xvY2F0aW9uIiwiY29uZmlybVRyYW5zaXRpb25UbyIsImxvb3BBc3luYyIsIm9rIiwibmV4dExvY2F0aW9uIiwicHJldlBhdGgiLCJjcmVhdGVQYXRoIiwibmV4dFBhdGgiLCJwcmV2SW5kZXgiLCJ1cGRhdGVMb2NhdGlvblN0YXRlIiwicFNsaWNlIiwib2JqZWN0S2V5cyIsImlzQXJndW1lbnRzIiwiZGVlcEVxdWFsIiwiYWN0dWFsIiwiZXhwZWN0ZWQiLCJvcHRzIiwiZ2V0VGltZSIsInN0cmljdCIsIm9iakVxdWl2IiwiaXNVbmRlZmluZWRPck51bGwiLCJpc0J1ZmZlciIsImthIiwia2IiLCJzaGltIiwic3VwcG9ydHNBcmd1bWVudHNDbGFzcyIsInN1cHBvcnRlZCIsInVuc3VwcG9ydGVkIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfc2xpY2UiLCJ0dXJucyIsIndvcmsiLCJjdXJyZW50VHVybiIsImlzRG9uZSIsInN5bmMiLCJoYXNOZXh0IiwiZG9uZUFyZ3MiLCJfZm91cnRoQXJnIiwicnVuVHJhbnNpdGlvbkhvb2siLCJkZXByZWNhdGUiLCJfcXVlcnlTdHJpbmciLCJTRUFSQ0hfQkFTRV9LRVkiLCJkZWZhdWx0U3RyaW5naWZ5UXVlcnkiLCJxdWVyeSIsImRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nIiwiaXNOZXN0ZWRPYmplY3QiLCJ1c2VRdWVyaWVzIiwiYWRkUXVlcnkiLCJzZWFyY2hCYXNlIiwiYXBwZW5kUXVlcnkiLCJfZXh0ZW5kczIiLCJzZWFyY2hCYXNlU3BlYyIsInF1ZXJ5U3RyaW5nIiwiZnVsbExvY2F0aW9uIiwic3RyaWN0VXJpRW5jb2RlIiwiZXh0cmFjdCIsInN0ciIsInJlZHVjZSIsInBhcnRzIiwic2hpZnQiLCJ2YWwyIiwiY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIiLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMyIiwiX2NvbXB1dGVDaGFuZ2VkUm91dGVzMyIsIl9UcmFuc2l0aW9uVXRpbHMiLCJfaXNBY3RpdmUyIiwiX2lzQWN0aXZlMyIsIl9nZXRDb21wb25lbnRzIiwiX2dldENvbXBvbmVudHMyIiwiX21hdGNoUm91dGVzIiwiX21hdGNoUm91dGVzMiIsImhhc0FueVByb3BlcnRpZXMiLCJpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSIsImRlcHJlY2F0ZWRJbmRleE9ubHkiLCJpbmRleE9ubHkiLCJwYXJ0aWFsTmV4dFN0YXRlIiwiZmluaXNoTWF0Y2giLCJfY29tcHV0ZUNoYW5nZWRSb3V0ZXMiLCJsZWF2ZVJvdXRlcyIsImNoYW5nZVJvdXRlcyIsImVudGVyUm91dGVzIiwicnVuTGVhdmVIb29rcyIsInJlbW92ZUxpc3RlbkJlZm9yZUhvb2tzRm9yUm91dGUiLCJydW5DaGFuZ2VIb29rcyIsInJlZGlyZWN0SW5mbyIsImhhbmRsZUVycm9yT3JSZWRpcmVjdCIsInJ1bkVudGVySG9va3MiLCJmaW5pc2hFbnRlckhvb2tzIiwiUm91dGVHdWlkIiwiZ2V0Um91dGVJRCIsIl9faWRfXyIsIlJvdXRlSG9va3MiLCJnZXRSb3V0ZUhvb2tzRm9yUm91dGVzIiwiaG9va3MiLCJ0cmFuc2l0aW9uSG9vayIsImJlZm9yZVVubG9hZEhvb2siLCJ1bmxpc3RlbkJlZm9yZSIsInVubGlzdGVuQmVmb3JlVW5sb2FkIiwicm91dGVJRCIsImxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSIsInRoZXJlV2VyZU5vUm91dGVIb29rcyIsImxpc3RlbkJlZm9yZVVubG9hZCIsIm5ld0hvb2tzIiwicmVkaXJlY3RMb2NhdGlvbiIsInJvdXRlUGFyYW1zQ2hhbmdlZCIsInNvbWUiLCJjb21wdXRlQ2hhbmdlZFJvdXRlcyIsInByZXZSb3V0ZXMiLCJuZXh0Um91dGVzIiwicGFyZW50SXNMZWF2aW5nIiwiaXNMZWF2aW5nIiwiaXNOZXciLCJwYXJhbXNDaGFuZ2VkIiwiY3JlYXRlVHJhbnNpdGlvbkhvb2siLCJhc3luY0FyaXR5IiwiZ2V0RW50ZXJIb29rcyIsIm9uRW50ZXIiLCJnZXRDaGFuZ2VIb29rcyIsInJ1blRyYW5zaXRpb25Ib29rcyIsIml0ZXIiLCJkZXByZWNhdGVkUGF0aG5hbWUiLCJkZXByZWNhdGVkUXVlcnkiLCJvbkxlYXZlIiwibWFwQXN5bmMiLCJ2YWx1ZXMiLCJkb25lQ291bnQiLCJfdHlwZW9mIiwicGF0aElzQWN0aXZlIiwiY3VycmVudFBhdGhuYW1lIiwicm91dGVJc0FjdGl2ZSIsIm1hdGNoZWQiLCJxdWVyeUlzQWN0aXZlIiwiYWN0aXZlUXVlcnkiLCJjdXJyZW50TG9jYXRpb24iLCJfbWFrZVN0YXRlV2l0aExvY2F0aW9uIiwiX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIiLCJnZXRDb21wb25lbnRzRm9yUm91dGUiLCJnZXRDb21wb25lbnQiLCJnZXRDb21wb25lbnRzIiwibmV4dFN0YXRlV2l0aExvY2F0aW9uIiwibWFrZVN0YXRlV2l0aExvY2F0aW9uIiwic3RhdGVXaXRoTG9jYXRpb24iLCJtYXRjaFJvdXRlcyIsImdldENoaWxkUm91dGVzIiwiY3JlYXRlUGFyYW1zIiwicGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiIsImdldEluZGV4Um91dGUiLCJpbmRleFJvdXRlIiwicGF0aGxlc3MiLCJjaGlsZFJvdXRlIiwiYXNzaWduUGFyYW1zIiwibWF0Y2hSb3V0ZURlZXAiLCJfcmV0MiIsIl9tYXRjaCRyb3V0ZXMiLCJvbkNoaWxkUm91dGVzIiwidW5zaGlmdCIsIl9nZXRSb3V0ZVBhcmFtcyIsIl9nZXRSb3V0ZVBhcmFtczIiLCJyZWR1Y2VSaWdodCIsInJvdXRlUGFyYW1zIiwiZWxlbWVudHMiLCJnZXRSb3V0ZVBhcmFtcyIsIl9Qcm9wVHlwZXMiLCJpc0xlZnRDbGlja0V2ZW50IiwiaXNNb2RpZmllZEV2ZW50IiwiaXNFbXB0eU9iamVjdCIsImNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvciIsImFjdGl2ZVN0eWxlIiwiYWN0aXZlQ2xhc3NOYW1lIiwib25seUFjdGl2ZU9uSW5kZXgiLCJoYW5kbGVDbGljayIsIl9MaW5rIiwiX2hvaXN0Tm9uUmVhY3RTdGF0aWNzIiwiX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiIsImdldERpc3BsYXlOYW1lIiwiV3JhcHBlZENvbXBvbmVudCIsIndpdGhSZWYiLCJXaXRoUm91dGVyIiwiZ2V0V3JhcHBlZEluc3RhbmNlIiwid3JhcHBlZEluc3RhbmNlIiwiUkVBQ1RfU1RBVElDUyIsIktOT1dOX1NUQVRJQ1MiLCJjYWxsZXIiLCJhcml0eSIsImlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaG9pc3ROb25SZWFjdFN0YXRpY3MiLCJ0YXJnZXRDb21wb25lbnQiLCJzb3VyY2VDb21wb25lbnQiLCJjdXN0b21TdGF0aWNzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9SZWRpcmVjdCIsInJvdXRlSW5kZXgiLCJwYXJlbnRQYXR0ZXJuIiwiZ2V0Um91dGVQYXR0ZXJuIiwicm91dGVyV2lsbExlYXZlIiwiX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlIiwiX2NyZWF0ZU1lbW9yeUhpc3RvcnkiLCJoaXN0b3J5TG9jYXRpb24iLCJfdXNlQmFzZW5hbWUiLCJfdXNlQmFzZW5hbWUyIiwibWVtb3J5SGlzdG9yeSIsInVzZUJhc2VuYW1lIiwiY2hlY2tlZEJhc2VIcmVmIiwiY2hlY2tCYXNlSHJlZiIsImJhc2VIcmVmIiwiYWRkQmFzZW5hbWUiLCJwcmVwZW5kQmFzZW5hbWUiLCJwbmFtZSIsIm5vcm1hbGl6ZWRCYXNlbmFtZSIsIm5vcm1hbGl6ZWRQYXRobmFtZSIsImNyZWF0ZVN0YXRlU3RvcmFnZSIsIm1lbW8iLCJfb3B0aW9ucyIsInN0b3JhZ2UiLCJjYW5HbyIsIm1pZGRsZXdhcmVzIiwibWlkZGxld2FyZSIsInJlbmRlclJvdXRlckNvbnRleHQiLCJyZW5kZXJSb3V0ZUNvbXBvbmVudCIsIndpdGhDb250ZXh0Iiwid2l0aENvbXBvbmVudCIsIm1ha2VDcmVhdGVFbGVtZW50IiwiYmFzZUNyZWF0ZUVsZW1lbnQiLCJwcmV2aW91cyIsInJlbmRlclByb3BzIiwiX2NyZWF0ZUJyb3dzZXJIaXN0b3J5IiwiX2NyZWF0ZUJyb3dzZXJIaXN0b3J5MiIsIl9jcmVhdGVSb3V0ZXJIaXN0b3J5IiwiX2NyZWF0ZVJvdXRlckhpc3RvcnkyIiwiY3JlYXRlQnJvd3Nlckhpc3RvcnkiLCJmb3JjZVJlZnJlc2giLCJ1c2VSZWZyZXNoIiwiaGlzdG9yeVN0YXRlIiwiX2hpc3RvcnlTdGF0ZSIsInN0YXJ0UG9wU3RhdGVMaXN0ZW5lciIsInBvcFN0YXRlTGlzdGVuZXIiLCJzdG9wUG9wU3RhdGVMaXN0ZW5lciIsIl91c2VSb3V0ZXJIaXN0b3J5IiwiTmF2aWdhdGlvbiIsIkNsb2NrIiwiQ291bnRkb3duRm9ybSIsIkNvbnRyb2xzIiwiY291bnRkb3duU3RhdHVzIiwic3RhcnRUaW1lciIsImNsZWFySW50ZXJ2YWwiLCJ0aW1lciIsInNldEludGVydmFsIiwibmV3Q291bnQiLCJoYW5kbGVTZXRDb3VudGRvd24iLCJzZWNvbmRzIiwiaGFuZGxlU3RhdHVzQ2hhbmdlIiwibmV3U3RhdHVzIiwicmVuZGVyQ29udHJvbEFyZWEiLCJ0b3RhbFNlY29uZHMiLCJmb3JtYXRTZWNvbmRzIiwibWludXRlcyIsInN0clNlY29uZHMiLCJvblNldENvdW50ZG93biIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsIm9uU3RhdHVzQ2hhbmdlIiwicmVuZGVyU3RhcnRTdG9wQnV0dG9uIl0sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdUJBQWU7QUFDZjtBQUNBO0FBQ0E7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QU07QUFDVCxtQkFBS2x4RixLQUFMLENBQVc0eEYsY0FBWCxDQUEwQlYsU0FBMUI7QUFDSCxVQUZEO0FBR0gsTUFUNEI7QUFVN0JuNUYsYUFBUSxrQkFBVTtBQUFBOztBQUFBLGFBQ1QwNEYsZUFEUyxHQUNVLEtBQUt6d0YsS0FEZixDQUNUeXdGLGVBRFM7O0FBRWQsYUFBSW9CLHdCQUF3QixTQUF4QkEscUJBQXdCLEdBQU07QUFDOUIsaUJBQUdwQixvQkFBb0IsU0FBdkIsRUFBaUM7QUFDN0Isd0JBQ007QUFBQTtBQUFBLHVCQUFRLFdBQVUsa0JBQWxCLEVBQXFDLFNBQVMsT0FBS21CLGNBQUwsQ0FBb0IsUUFBcEIsQ0FBOUM7QUFBQTtBQUFBLGtCQUROO0FBR0gsY0FKRCxNQUlNLElBQUduQixvQkFBb0IsUUFBdkIsRUFBZ0M7QUFDbEMsd0JBQ007QUFBQTtBQUFBLHVCQUFRLFdBQVUsZ0JBQWxCLEVBQW1DLFNBQVMsT0FBS21CLGNBQUwsQ0FBb0IsU0FBcEIsQ0FBNUM7QUFBQTtBQUFBLGtCQUROO0FBR0g7QUFDSixVQVZEOztBQVlBLGdCQUNFO0FBQUE7QUFBQSxlQUFLLFdBQVUsVUFBZjtBQUNPQyxvQ0FEUDtBQUVNO0FBQUE7QUFBQSxtQkFBUSxXQUFVLHFCQUFsQixFQUF3QyxTQUFTLEtBQUtELGNBQUwsQ0FBb0IsU0FBcEIsQ0FBakQ7QUFBQTtBQUFBO0FBRk4sVUFERjtBQU1IO0FBOUI0QixFQUFsQixDQUFmOztBQWlDQTM1RixRQUFPQyxPQUFQLEdBQWlCczRGLFFBQWpCLEMiLCJmaWxlIjoiLi9wdWJsaWMvYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pXG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG5cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGlkOiBtb2R1bGVJZCxcbiBcdFx0XHRsb2FkZWQ6IGZhbHNlXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmxvYWRlZCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgOGI1YTI3NzBlOTE3MjQyM2Y5Y2IiLCJyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxCbGVzaW1ldGFyX1YxMFxcXFxEZXNrdG9wXFxcXFJcXFxcUmVhY3QgLSBDaGFwdGVyVWNlbmplXFxcXEM2IC0gVGltZXJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcYWRkU2NyaXB0LmpzXCIpKHJlcXVpcmUoXCIhIUM6XFxcXFVzZXJzXFxcXEJsZXNpbWV0YXJfVjEwXFxcXERlc2t0b3BcXFxcUlxcXFxSZWFjdCAtIENoYXB0ZXJVY2VuamVcXFxcQzYgLSBUaW1lckFwcFxcXFxub2RlX21vZHVsZXNcXFxcc2NyaXB0LWxvYWRlclxcXFxub2RlX21vZHVsZXNcXFxccmF3LWxvYWRlclxcXFxpbmRleC5qcyFDOlxcXFxVc2Vyc1xcXFxCbGVzaW1ldGFyX1YxMFxcXFxEZXNrdG9wXFxcXFJcXFxcUmVhY3QgLSBDaGFwdGVyVWNlbmplXFxcXEM2IC0gVGltZXJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXGJhYmVsLWxvYWRlclxcXFxsaWJcXFxcaW5kZXguanM/e1xcXCJwcmVzZXRzXFxcIjpbXFxcInJlYWN0XFxcIixcXFwiZXMyMDE1XFxcIixcXFwic3RhZ2UtMFxcXCJdLFxcXCJjb21wYWN0XFxcIjpmYWxzZX0hQzpcXFxcVXNlcnNcXFxcQmxlc2ltZXRhcl9WMTBcXFxcRGVza3RvcFxcXFxSXFxcXFJlYWN0IC0gQ2hhcHRlclVjZW5qZVxcXFxDNiAtIFRpbWVyQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxqcXVlcnlcXFxcZGlzdFxcXFxqcXVlcnkubWluLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9qcXVlcnkvZGlzdC9qcXVlcnkubWluLmpzXG4vLyBtb2R1bGUgaWQgPSAxXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oc3JjKSB7XHJcblx0aWYgKHR5cGVvZiBleGVjU2NyaXB0ID09PSBcImZ1bmN0aW9uXCIpXHJcblx0XHRleGVjU2NyaXB0KHNyYyk7XHJcblx0ZWxzZVxyXG5cdFx0ZXZhbC5jYWxsKG51bGwsIHNyYyk7XHJcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcbi8vIG1vZHVsZSBpZCA9IDJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbi8qISBqUXVlcnkgdjIuMi40IHwgKGMpIGpRdWVyeSBGb3VuZGF0aW9uIHwganF1ZXJ5Lm9yZy9saWNlbnNlICovXFxuIWZ1bmN0aW9uIChhLCBiKSB7XFxuICBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIG1vZHVsZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YobW9kdWxlKSkgJiYgXFxcIm9iamVjdFxcXCIgPT0gX3R5cGVvZihtb2R1bGUuZXhwb3J0cykgPyBtb2R1bGUuZXhwb3J0cyA9IGEuZG9jdW1lbnQgPyBiKGEsICEwKSA6IGZ1bmN0aW9uIChhKSB7XFxuICAgIGlmICghYS5kb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKFxcXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XFxcIik7cmV0dXJuIGIoYSk7XFxuICB9IDogYihhKTtcXG59KFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiB3aW5kb3cgPyB3aW5kb3cgOiB1bmRlZmluZWQsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICB2YXIgYyA9IFtdLFxcbiAgICAgIGQgPSBhLmRvY3VtZW50LFxcbiAgICAgIGUgPSBjLnNsaWNlLFxcbiAgICAgIGYgPSBjLmNvbmNhdCxcXG4gICAgICBnID0gYy5wdXNoLFxcbiAgICAgIGggPSBjLmluZGV4T2YsXFxuICAgICAgaSA9IHt9LFxcbiAgICAgIGogPSBpLnRvU3RyaW5nLFxcbiAgICAgIGsgPSBpLmhhc093blByb3BlcnR5LFxcbiAgICAgIGwgPSB7fSxcXG4gICAgICBtID0gXFxcIjIuMi40XFxcIixcXG4gICAgICBuID0gZnVuY3Rpb24gbihhLCBiKSB7XFxuICAgIHJldHVybiBuZXcgbi5mbi5pbml0KGEsIGIpO1xcbiAgfSxcXG4gICAgICBvID0gL15bXFxcXHNcXFxcdUZFRkZcXFxceEEwXSt8W1xcXFxzXFxcXHVGRUZGXFxcXHhBMF0rJC9nLFxcbiAgICAgIHAgPSAvXi1tcy0vLFxcbiAgICAgIHEgPSAvLShbXFxcXGRhLXpdKS9naSxcXG4gICAgICByID0gZnVuY3Rpb24gcihhLCBiKSB7XFxuICAgIHJldHVybiBiLnRvVXBwZXJDYXNlKCk7XFxuICB9O24uZm4gPSBuLnByb3RvdHlwZSA9IHsganF1ZXJ5OiBtLCBjb25zdHJ1Y3Rvcjogbiwgc2VsZWN0b3I6IFxcXCJcXFwiLCBsZW5ndGg6IDAsIHRvQXJyYXk6IGZ1bmN0aW9uIHRvQXJyYXkoKSB7XFxuICAgICAgcmV0dXJuIGUuY2FsbCh0aGlzKTtcXG4gICAgfSwgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgIHJldHVybiBudWxsICE9IGEgPyAwID4gYSA/IHRoaXNbYSArIHRoaXMubGVuZ3RoXSA6IHRoaXNbYV0gOiBlLmNhbGwodGhpcyk7XFxuICAgIH0sIHB1c2hTdGFjazogZnVuY3Rpb24gcHVzaFN0YWNrKGEpIHtcXG4gICAgICB2YXIgYiA9IG4ubWVyZ2UodGhpcy5jb25zdHJ1Y3RvcigpLCBhKTtyZXR1cm4gYi5wcmV2T2JqZWN0ID0gdGhpcywgYi5jb250ZXh0ID0gdGhpcy5jb250ZXh0LCBiO1xcbiAgICB9LCBlYWNoOiBmdW5jdGlvbiBlYWNoKGEpIHtcXG4gICAgICByZXR1cm4gbi5lYWNoKHRoaXMsIGEpO1xcbiAgICB9LCBtYXA6IGZ1bmN0aW9uIG1hcChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4ubWFwKHRoaXMsIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgICByZXR1cm4gYS5jYWxsKGIsIGMsIGIpO1xcbiAgICAgIH0pKTtcXG4gICAgfSwgc2xpY2U6IGZ1bmN0aW9uIHNsaWNlKCkge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xcbiAgICB9LCBmaXJzdDogZnVuY3Rpb24gZmlyc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXEoMCk7XFxuICAgIH0sIGxhc3Q6IGZ1bmN0aW9uIGxhc3QoKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZXEoLTEpO1xcbiAgICB9LCBlcTogZnVuY3Rpb24gZXEoYSkge1xcbiAgICAgIHZhciBiID0gdGhpcy5sZW5ndGgsXFxuICAgICAgICAgIGMgPSArYSArICgwID4gYSA/IGIgOiAwKTtyZXR1cm4gdGhpcy5wdXNoU3RhY2soYyA+PSAwICYmIGIgPiBjID8gW3RoaXNbY11dIDogW10pO1xcbiAgICB9LCBlbmQ6IGZ1bmN0aW9uIGVuZCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcXG4gICAgfSwgcHVzaDogZywgc29ydDogYy5zb3J0LCBzcGxpY2U6IGMuc3BsaWNlIH0sIG4uZXh0ZW5kID0gbi5mbi5leHRlbmQgPSBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhLFxcbiAgICAgICAgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gYXJndW1lbnRzWzBdIHx8IHt9LFxcbiAgICAgICAgaCA9IDEsXFxuICAgICAgICBpID0gYXJndW1lbnRzLmxlbmd0aCxcXG4gICAgICAgIGogPSAhMTtmb3IgKFxcXCJib29sZWFuXFxcIiA9PSB0eXBlb2YgZyAmJiAoaiA9IGcsIGcgPSBhcmd1bWVudHNbaF0gfHwge30sIGgrKyksIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgZyA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZykpIHx8IG4uaXNGdW5jdGlvbihnKSB8fCAoZyA9IHt9KSwgaCA9PT0gaSAmJiAoZyA9IHRoaXMsIGgtLSk7IGkgPiBoOyBoKyspIHtcXG4gICAgICBpZiAobnVsbCAhPSAoYSA9IGFyZ3VtZW50c1toXSkpIGZvciAoYiBpbiBhKSB7XFxuICAgICAgICBjID0gZ1tiXSwgZCA9IGFbYl0sIGcgIT09IGQgJiYgKGogJiYgZCAmJiAobi5pc1BsYWluT2JqZWN0KGQpIHx8IChlID0gbi5pc0FycmF5KGQpKSkgPyAoZSA/IChlID0gITEsIGYgPSBjICYmIG4uaXNBcnJheShjKSA/IGMgOiBbXSkgOiBmID0gYyAmJiBuLmlzUGxhaW5PYmplY3QoYykgPyBjIDoge30sIGdbYl0gPSBuLmV4dGVuZChqLCBmLCBkKSkgOiB2b2lkIDAgIT09IGQgJiYgKGdbYl0gPSBkKSk7XFxuICAgICAgfVxcbiAgICB9cmV0dXJuIGc7XFxuICB9LCBuLmV4dGVuZCh7IGV4cGFuZG86IFxcXCJqUXVlcnlcXFwiICsgKG0gKyBNYXRoLnJhbmRvbSgpKS5yZXBsYWNlKC9cXFxcRC9nLCBcXFwiXFxcIiksIGlzUmVhZHk6ICEwLCBlcnJvcjogZnVuY3Rpb24gZXJyb3IoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihhKTtcXG4gICAgfSwgbm9vcDogZnVuY3Rpb24gbm9vcCgpIHt9LCBpc0Z1bmN0aW9uOiBmdW5jdGlvbiBpc0Z1bmN0aW9uKGEpIHtcXG4gICAgICByZXR1cm4gXFxcImZ1bmN0aW9uXFxcIiA9PT0gbi50eXBlKGEpO1xcbiAgICB9LCBpc0FycmF5OiBBcnJheS5pc0FycmF5LCBpc1dpbmRvdzogZnVuY3Rpb24gaXNXaW5kb3coYSkge1xcbiAgICAgIHJldHVybiBudWxsICE9IGEgJiYgYSA9PT0gYS53aW5kb3c7XFxuICAgIH0sIGlzTnVtZXJpYzogZnVuY3Rpb24gaXNOdW1lcmljKGEpIHtcXG4gICAgICB2YXIgYiA9IGEgJiYgYS50b1N0cmluZygpO3JldHVybiAhbi5pc0FycmF5KGEpICYmIGIgLSBwYXJzZUZsb2F0KGIpICsgMSA+PSAwO1xcbiAgICB9LCBpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiBpc1BsYWluT2JqZWN0KGEpIHtcXG4gICAgICB2YXIgYjtpZiAoXFxcIm9iamVjdFxcXCIgIT09IG4udHlwZShhKSB8fCBhLm5vZGVUeXBlIHx8IG4uaXNXaW5kb3coYSkpIHJldHVybiAhMTtpZiAoYS5jb25zdHJ1Y3RvciAmJiAhay5jYWxsKGEsIFxcXCJjb25zdHJ1Y3RvclxcXCIpICYmICFrLmNhbGwoYS5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgfHwge30sIFxcXCJpc1Byb3RvdHlwZU9mXFxcIikpIHJldHVybiAhMTtmb3IgKGIgaW4gYSkge31yZXR1cm4gdm9pZCAwID09PSBiIHx8IGsuY2FsbChhLCBiKTtcXG4gICAgfSwgaXNFbXB0eU9iamVjdDogZnVuY3Rpb24gaXNFbXB0eU9iamVjdChhKSB7XFxuICAgICAgdmFyIGI7Zm9yIChiIGluIGEpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9cmV0dXJuICEwO1xcbiAgICB9LCB0eXBlOiBmdW5jdGlvbiB0eXBlKGEpIHtcXG4gICAgICByZXR1cm4gbnVsbCA9PSBhID8gYSArIFxcXCJcXFwiIDogXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKSkgfHwgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSA/IGlbai5jYWxsKGEpXSB8fCBcXFwib2JqZWN0XFxcIiA6IHR5cGVvZiBhID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihhKTtcXG4gICAgfSwgZ2xvYmFsRXZhbDogZnVuY3Rpb24gZ2xvYmFsRXZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMgPSBldmFsO2EgPSBuLnRyaW0oYSksIGEgJiYgKDEgPT09IGEuaW5kZXhPZihcXFwidXNlIHN0cmljdFxcXCIpID8gKGIgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcInNjcmlwdFxcXCIpLCBiLnRleHQgPSBhLCBkLmhlYWQuYXBwZW5kQ2hpbGQoYikucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSkgOiBjKGEpKTtcXG4gICAgfSwgY2FtZWxDYXNlOiBmdW5jdGlvbiBjYW1lbENhc2UoYSkge1xcbiAgICAgIHJldHVybiBhLnJlcGxhY2UocCwgXFxcIm1zLVxcXCIpLnJlcGxhY2UocSwgcik7XFxuICAgIH0sIG5vZGVOYW1lOiBmdW5jdGlvbiBub2RlTmFtZShhLCBiKSB7XFxuICAgICAgcmV0dXJuIGEubm9kZU5hbWUgJiYgYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBiLnRvTG93ZXJDYXNlKCk7XFxuICAgIH0sIGVhY2g6IGZ1bmN0aW9uIGVhY2goYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMDtpZiAocyhhKSkge1xcbiAgICAgICAgZm9yIChjID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBmb3IgKGQgaW4gYSkge1xcbiAgICAgICAgaWYgKGIuY2FsbChhW2RdLCBkLCBhW2RdKSA9PT0gITEpIGJyZWFrO1xcbiAgICAgIH1yZXR1cm4gYTtcXG4gICAgfSwgdHJpbTogZnVuY3Rpb24gdHJpbShhKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSA/IFxcXCJcXFwiIDogKGEgKyBcXFwiXFxcIikucmVwbGFjZShvLCBcXFwiXFxcIik7XFxuICAgIH0sIG1ha2VBcnJheTogZnVuY3Rpb24gbWFrZUFycmF5KGEsIGIpIHtcXG4gICAgICB2YXIgYyA9IGIgfHwgW107cmV0dXJuIG51bGwgIT0gYSAmJiAocyhPYmplY3QoYSkpID8gbi5tZXJnZShjLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IFthXSA6IGEpIDogZy5jYWxsKGMsIGEpKSwgYztcXG4gICAgfSwgaW5BcnJheTogZnVuY3Rpb24gaW5BcnJheShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYiA/IC0xIDogaC5jYWxsKGIsIGEsIGMpO1xcbiAgICB9LCBtZXJnZTogZnVuY3Rpb24gbWVyZ2UoYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSArYi5sZW5ndGgsIGQgPSAwLCBlID0gYS5sZW5ndGg7IGMgPiBkOyBkKyspIHtcXG4gICAgICAgIGFbZSsrXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBhLmxlbmd0aCA9IGUsIGE7XFxuICAgIH0sIGdyZXA6IGZ1bmN0aW9uIGdyZXAoYSwgYiwgYykge1xcbiAgICAgIGZvciAodmFyIGQsIGUgPSBbXSwgZiA9IDAsIGcgPSBhLmxlbmd0aCwgaCA9ICFjOyBnID4gZjsgZisrKSB7XFxuICAgICAgICBkID0gIWIoYVtmXSwgZiksIGQgIT09IGggJiYgZS5wdXNoKGFbZl0pO1xcbiAgICAgIH1yZXR1cm4gZTtcXG4gICAgfSwgbWFwOiBmdW5jdGlvbiBtYXAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkLFxcbiAgICAgICAgICBlLFxcbiAgICAgICAgICBnID0gMCxcXG4gICAgICAgICAgaCA9IFtdO2lmIChzKGEpKSBmb3IgKGQgPSBhLmxlbmd0aDsgZCA+IGc7IGcrKykge1xcbiAgICAgICAgZSA9IGIoYVtnXSwgZywgYyksIG51bGwgIT0gZSAmJiBoLnB1c2goZSk7XFxuICAgICAgfSBlbHNlIGZvciAoZyBpbiBhKSB7XFxuICAgICAgICBlID0gYihhW2ddLCBnLCBjKSwgbnVsbCAhPSBlICYmIGgucHVzaChlKTtcXG4gICAgICB9cmV0dXJuIGYuYXBwbHkoW10sIGgpO1xcbiAgICB9LCBndWlkOiAxLCBwcm94eTogZnVuY3Rpb24gcHJveHkoYSwgYikge1xcbiAgICAgIHZhciBjLCBkLCBmO3JldHVybiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYiAmJiAoYyA9IGFbYl0sIGIgPSBhLCBhID0gYyksIG4uaXNGdW5jdGlvbihhKSA/IChkID0gZS5jYWxsKGFyZ3VtZW50cywgMiksIGYgPSBmdW5jdGlvbiBmKCkge1xcbiAgICAgICAgcmV0dXJuIGEuYXBwbHkoYiB8fCB0aGlzLCBkLmNvbmNhdChlLmNhbGwoYXJndW1lbnRzKSkpO1xcbiAgICAgIH0sIGYuZ3VpZCA9IGEuZ3VpZCA9IGEuZ3VpZCB8fCBuLmd1aWQrKywgZikgOiB2b2lkIDA7XFxuICAgIH0sIG5vdzogRGF0ZS5ub3csIHN1cHBvcnQ6IGwgfSksIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiAobi5mbltTeW1ib2wuaXRlcmF0b3JdID0gY1tTeW1ib2wuaXRlcmF0b3JdKSwgbi5lYWNoKFxcXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgaVtcXFwiW29iamVjdCBcXFwiICsgYiArIFxcXCJdXFxcIl0gPSBiLnRvTG93ZXJDYXNlKCk7XFxuICB9KTtmdW5jdGlvbiBzKGEpIHtcXG4gICAgdmFyIGIgPSAhIWEgJiYgXFxcImxlbmd0aFxcXCIgaW4gYSAmJiBhLmxlbmd0aCxcXG4gICAgICAgIGMgPSBuLnR5cGUoYSk7cmV0dXJuIFxcXCJmdW5jdGlvblxcXCIgPT09IGMgfHwgbi5pc1dpbmRvdyhhKSA/ICExIDogXFxcImFycmF5XFxcIiA9PT0gYyB8fCAwID09PSBiIHx8IFxcXCJudW1iZXJcXFwiID09IHR5cGVvZiBiICYmIGIgPiAwICYmIGIgLSAxIGluIGE7XFxuICB9dmFyIHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIGwsXFxuICAgICAgICBtLFxcbiAgICAgICAgbixcXG4gICAgICAgIG8sXFxuICAgICAgICBwLFxcbiAgICAgICAgcSxcXG4gICAgICAgIHIsXFxuICAgICAgICBzLFxcbiAgICAgICAgdCxcXG4gICAgICAgIHUgPSBcXFwic2l6emxlXFxcIiArIDEgKiBuZXcgRGF0ZSgpLFxcbiAgICAgICAgdiA9IGEuZG9jdW1lbnQsXFxuICAgICAgICB3ID0gMCxcXG4gICAgICAgIHggPSAwLFxcbiAgICAgICAgeSA9IGdhKCksXFxuICAgICAgICB6ID0gZ2EoKSxcXG4gICAgICAgIEEgPSBnYSgpLFxcbiAgICAgICAgQiA9IGZ1bmN0aW9uIEIoYSwgYikge1xcbiAgICAgIHJldHVybiBhID09PSBiICYmIChsID0gITApLCAwO1xcbiAgICB9LFxcbiAgICAgICAgQyA9IDEgPDwgMzEsXFxuICAgICAgICBEID0ge30uaGFzT3duUHJvcGVydHksXFxuICAgICAgICBFID0gW10sXFxuICAgICAgICBGID0gRS5wb3AsXFxuICAgICAgICBHID0gRS5wdXNoLFxcbiAgICAgICAgSCA9IEUucHVzaCxcXG4gICAgICAgIEkgPSBFLnNsaWNlLFxcbiAgICAgICAgSiA9IGZ1bmN0aW9uIEooYSwgYikge1xcbiAgICAgIGZvciAodmFyIGMgPSAwLCBkID0gYS5sZW5ndGg7IGQgPiBjOyBjKyspIHtcXG4gICAgICAgIGlmIChhW2NdID09PSBiKSByZXR1cm4gYztcXG4gICAgICB9cmV0dXJuIC0xO1xcbiAgICB9LFxcbiAgICAgICAgSyA9IFxcXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFxcXCIsXFxuICAgICAgICBMID0gXFxcIltcXFxcXFxcXHgyMFxcXFxcXFxcdFxcXFxcXFxcclxcXFxcXFxcblxcXFxcXFxcZl1cXFwiLFxcbiAgICAgICAgTSA9IFxcXCIoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXFxcXFxcXFx3LV18W15cXFxcXFxcXHgwMC1cXFxcXFxcXHhhMF0pK1xcXCIsXFxuICAgICAgICBOID0gXFxcIlxcXFxcXFxcW1xcXCIgKyBMICsgXFxcIiooXFxcIiArIE0gKyBcXFwiKSg/OlxcXCIgKyBMICsgXFxcIiooWypeJHwhfl0/PSlcXFwiICsgTCArIFxcXCIqKD86JygoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFwnXSkqKSd8XFxcXFxcXCIoKD86XFxcXFxcXFxcXFxcXFxcXC58W15cXFxcXFxcXFxcXFxcXFxcXFxcXFxcXCJdKSopXFxcXFxcXCJ8KFxcXCIgKyBNICsgXFxcIikpfClcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIixcXG4gICAgICAgIE8gPSBcXFwiOihcXFwiICsgTSArIFxcXCIpKD86XFxcXFxcXFwoKCgnKCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCddKSopJ3xcXFxcXFxcIigoPzpcXFxcXFxcXFxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcIl0pKilcXFxcXFxcIil8KCg/OlxcXFxcXFxcXFxcXFxcXFwufFteXFxcXFxcXFxcXFxcXFxcXCgpW1xcXFxcXFxcXV18XFxcIiArIE4gKyBcXFwiKSopfC4qKVxcXFxcXFxcKXwpXFxcIixcXG4gICAgICAgIFAgPSBuZXcgUmVnRXhwKEwgKyBcXFwiK1xcXCIsIFxcXCJnXFxcIiksXFxuICAgICAgICBRID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIit8KCg/Ol58W15cXFxcXFxcXFxcXFxcXFxcXSkoPzpcXFxcXFxcXFxcXFxcXFxcLikqKVxcXCIgKyBMICsgXFxcIiskXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFIgPSBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKixcXFwiICsgTCArIFxcXCIqXFxcIiksXFxuICAgICAgICBTID0gbmV3IFJlZ0V4cChcXFwiXlxcXCIgKyBMICsgXFxcIiooWz4rfl18XFxcIiArIEwgKyBcXFwiKVxcXCIgKyBMICsgXFxcIipcXFwiKSxcXG4gICAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCI9XFxcIiArIEwgKyBcXFwiKihbXlxcXFxcXFxcXSdcXFxcXFxcIl0qPylcXFwiICsgTCArIFxcXCIqXFxcXFxcXFxdXFxcIiwgXFxcImdcXFwiKSxcXG4gICAgICAgIFUgPSBuZXcgUmVnRXhwKE8pLFxcbiAgICAgICAgViA9IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTSArIFxcXCIkXFxcIiksXFxuICAgICAgICBXID0geyBJRDogbmV3IFJlZ0V4cChcXFwiXiMoXFxcIiArIE0gKyBcXFwiKVxcXCIpLCBDTEFTUzogbmV3IFJlZ0V4cChcXFwiXlxcXFxcXFxcLihcXFwiICsgTSArIFxcXCIpXFxcIiksIFRBRzogbmV3IFJlZ0V4cChcXFwiXihcXFwiICsgTSArIFxcXCJ8WypdKVxcXCIpLCBBVFRSOiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIE4pLCBQU0VVRE86IG5ldyBSZWdFeHAoXFxcIl5cXFwiICsgTyksIENISUxEOiBuZXcgUmVnRXhwKFxcXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcXFxcXChcXFwiICsgTCArIFxcXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxcXFxcZCopbnwpXFxcIiArIEwgKyBcXFwiKig/OihbKy1dfClcXFwiICsgTCArIFxcXCIqKFxcXFxcXFxcZCspfCkpXFxcIiArIEwgKyBcXFwiKlxcXFxcXFxcKXwpXFxcIiwgXFxcImlcXFwiKSwgYm9vbDogbmV3IFJlZ0V4cChcXFwiXig/OlxcXCIgKyBLICsgXFxcIikkXFxcIiwgXFxcImlcXFwiKSwgbmVlZHNDb250ZXh0OiBuZXcgUmVnRXhwKFxcXCJeXFxcIiArIEwgKyBcXFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXFxcXFwoXFxcIiArIEwgKyBcXFwiKigoPzotXFxcXFxcXFxkKT9cXFxcXFxcXGQqKVxcXCIgKyBMICsgXFxcIipcXFxcXFxcXCl8KSg/PVteLV18JClcXFwiLCBcXFwiaVxcXCIpIH0sXFxuICAgICAgICBYID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcXG4gICAgICAgIFkgPSAvXmhcXFxcZCQvaSxcXG4gICAgICAgIFogPSAvXltee10rXFxcXHtcXFxccypcXFxcW25hdGl2ZSBcXFxcdy8sXFxuICAgICAgICAkID0gL14oPzojKFtcXFxcdy1dKyl8KFxcXFx3Kyl8XFxcXC4oW1xcXFx3LV0rKSkkLyxcXG4gICAgICAgIF8gPSAvWyt+XS8sXFxuICAgICAgICBhYSA9IC8nfFxcXFxcXFxcL2csXFxuICAgICAgICBiYSA9IG5ldyBSZWdFeHAoXFxcIlxcXFxcXFxcXFxcXFxcXFwoW1xcXFxcXFxcZGEtZl17MSw2fVxcXCIgKyBMICsgXFxcIj98KFxcXCIgKyBMICsgXFxcIil8LilcXFwiLCBcXFwiaWdcXFwiKSxcXG4gICAgICAgIGNhID0gZnVuY3Rpb24gY2EoYSwgYiwgYykge1xcbiAgICAgIHZhciBkID0gXFxcIjB4XFxcIiArIGIgLSA2NTUzNjtyZXR1cm4gZCAhPT0gZCB8fCBjID8gYiA6IDAgPiBkID8gU3RyaW5nLmZyb21DaGFyQ29kZShkICsgNjU1MzYpIDogU3RyaW5nLmZyb21DaGFyQ29kZShkID4+IDEwIHwgNTUyOTYsIDEwMjMgJiBkIHwgNTYzMjApO1xcbiAgICB9LFxcbiAgICAgICAgZGEgPSBmdW5jdGlvbiBkYSgpIHtcXG4gICAgICBtKCk7XFxuICAgIH07dHJ5IHtcXG4gICAgICBILmFwcGx5KEUgPSBJLmNhbGwodi5jaGlsZE5vZGVzKSwgdi5jaGlsZE5vZGVzKSwgRVt2LmNoaWxkTm9kZXMubGVuZ3RoXS5ub2RlVHlwZTtcXG4gICAgfSBjYXRjaCAoZWEpIHtcXG4gICAgICBIID0geyBhcHBseTogRS5sZW5ndGggPyBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICBHLmFwcGx5KGEsIEkuY2FsbChiKSk7XFxuICAgICAgICB9IDogZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxlbmd0aCxcXG4gICAgICAgICAgICAgIGQgPSAwO3doaWxlIChhW2MrK10gPSBiW2QrK10pIHt9YS5sZW5ndGggPSBjIC0gMTtcXG4gICAgICAgIH0gfTtcXG4gICAgfWZ1bmN0aW9uIGZhKGEsIGIsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcixcXG4gICAgICAgICAgcyxcXG4gICAgICAgICAgdyA9IGIgJiYgYi5vd25lckRvY3VtZW50LFxcbiAgICAgICAgICB4ID0gYiA/IGIubm9kZVR5cGUgOiA5O2lmIChkID0gZCB8fCBbXSwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgfHwgIWEgfHwgMSAhPT0geCAmJiA5ICE9PSB4ICYmIDExICE9PSB4KSByZXR1cm4gZDtpZiAoIWUgJiYgKChiID8gYi5vd25lckRvY3VtZW50IHx8IGIgOiB2KSAhPT0gbiAmJiBtKGIpLCBiID0gYiB8fCBuLCBwKSkge1xcbiAgICAgICAgaWYgKDExICE9PSB4ICYmIChvID0gJC5leGVjKGEpKSkgaWYgKGYgPSBvWzFdKSB7XFxuICAgICAgICAgIGlmICg5ID09PSB4KSB7XFxuICAgICAgICAgICAgaWYgKCEoaiA9IGIuZ2V0RWxlbWVudEJ5SWQoZikpKSByZXR1cm4gZDtpZiAoai5pZCA9PT0gZikgcmV0dXJuIGQucHVzaChqKSwgZDtcXG4gICAgICAgICAgfSBlbHNlIGlmICh3ICYmIChqID0gdy5nZXRFbGVtZW50QnlJZChmKSkgJiYgdChiLCBqKSAmJiBqLmlkID09PSBmKSByZXR1cm4gZC5wdXNoKGopLCBkO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgaWYgKG9bMl0pIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSkpLCBkO2lmICgoZiA9IG9bM10pICYmIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBiLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpIHJldHVybiBILmFwcGx5KGQsIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShmKSksIGQ7XFxuICAgICAgICB9aWYgKGMucXNhICYmICFBW2EgKyBcXFwiIFxcXCJdICYmICghcSB8fCAhcS50ZXN0KGEpKSkge1xcbiAgICAgICAgICBpZiAoMSAhPT0geCkgdyA9IGIsIHMgPSBhO2Vsc2UgaWYgKFxcXCJvYmplY3RcXFwiICE9PSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgICAgICAgICAoayA9IGIuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpKSA/IGsgPSBrLnJlcGxhY2UoYWEsIFxcXCJcXFxcXFxcXCQmXFxcIikgOiBiLnNldEF0dHJpYnV0ZShcXFwiaWRcXFwiLCBrID0gdSksIHIgPSBnKGEpLCBoID0gci5sZW5ndGgsIGwgPSBWLnRlc3QoaykgPyBcXFwiI1xcXCIgKyBrIDogXFxcIltpZD0nXFxcIiArIGsgKyBcXFwiJ11cXFwiO3doaWxlIChoLS0pIHtcXG4gICAgICAgICAgICAgIHJbaF0gPSBsICsgXFxcIiBcXFwiICsgcWEocltoXSk7XFxuICAgICAgICAgICAgfXMgPSByLmpvaW4oXFxcIixcXFwiKSwgdyA9IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGI7XFxuICAgICAgICAgIH1pZiAocykgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gSC5hcHBseShkLCB3LnF1ZXJ5U2VsZWN0b3JBbGwocykpLCBkO1xcbiAgICAgICAgICB9IGNhdGNoICh5KSB7fSBmaW5hbGx5IHtcXG4gICAgICAgICAgICBrID09PSB1ICYmIGIucmVtb3ZlQXR0cmlidXRlKFxcXCJpZFxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBpKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSwgYiwgZCwgZSk7XFxuICAgIH1mdW5jdGlvbiBnYSgpIHtcXG4gICAgICB2YXIgYSA9IFtdO2Z1bmN0aW9uIGIoYywgZSkge1xcbiAgICAgICAgcmV0dXJuIGEucHVzaChjICsgXFxcIiBcXFwiKSA+IGQuY2FjaGVMZW5ndGggJiYgZGVsZXRlIGJbYS5zaGlmdCgpXSwgYltjICsgXFxcIiBcXFwiXSA9IGU7XFxuICAgICAgfXJldHVybiBiO1xcbiAgICB9ZnVuY3Rpb24gaGEoYSkge1xcbiAgICAgIHJldHVybiBhW3VdID0gITAsIGE7XFxuICAgIH1mdW5jdGlvbiBpYShhKSB7XFxuICAgICAgdmFyIGIgPSBuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO3RyeSB7XFxuICAgICAgICByZXR1cm4gISFhKGIpO1xcbiAgICAgIH0gY2F0Y2ggKGMpIHtcXG4gICAgICAgIHJldHVybiAhMTtcXG4gICAgICB9IGZpbmFsbHkge1xcbiAgICAgICAgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChiKSwgYiA9IG51bGw7XFxuICAgICAgfVxcbiAgICB9ZnVuY3Rpb24gamEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYS5zcGxpdChcXFwifFxcXCIpLFxcbiAgICAgICAgICBlID0gYy5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgZC5hdHRySGFuZGxlW2NbZV1dID0gYjtcXG4gICAgICB9XFxuICAgIH1mdW5jdGlvbiBrYShhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiICYmIGEsXFxuICAgICAgICAgIGQgPSBjICYmIDEgPT09IGEubm9kZVR5cGUgJiYgMSA9PT0gYi5ub2RlVHlwZSAmJiAofmIuc291cmNlSW5kZXggfHwgQykgLSAofmEuc291cmNlSW5kZXggfHwgQyk7aWYgKGQpIHJldHVybiBkO2lmIChjKSB3aGlsZSAoYyA9IGMubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgIGlmIChjID09PSBiKSByZXR1cm4gLTE7XFxuICAgICAgfXJldHVybiBhID8gMSA6IC0xO1xcbiAgICB9ZnVuY3Rpb24gbGEoYSkge1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGMgJiYgYi50eXBlID09PSBhO1xcbiAgICAgIH07XFxuICAgIH1mdW5jdGlvbiBtYShhKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICB2YXIgYyA9IGIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtyZXR1cm4gKFxcXCJpbnB1dFxcXCIgPT09IGMgfHwgXFxcImJ1dHRvblxcXCIgPT09IGMpICYmIGIudHlwZSA9PT0gYTtcXG4gICAgICB9O1xcbiAgICB9ZnVuY3Rpb24gbmEoYSkge1xcbiAgICAgIHJldHVybiBoYShmdW5jdGlvbiAoYikge1xcbiAgICAgICAgcmV0dXJuIGIgPSArYiwgaGEoZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICAgICAgdmFyIGUsXFxuICAgICAgICAgICAgICBmID0gYShbXSwgYy5sZW5ndGgsIGIpLFxcbiAgICAgICAgICAgICAgZyA9IGYubGVuZ3RoO3doaWxlIChnLS0pIHtcXG4gICAgICAgICAgICBjW2UgPSBmW2ddXSAmJiAoY1tlXSA9ICEoZFtlXSA9IGNbZV0pKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgIH1mdW5jdGlvbiBvYShhKSB7XFxuICAgICAgcmV0dXJuIGEgJiYgXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUgJiYgYTtcXG4gICAgfWMgPSBmYS5zdXBwb3J0ID0ge30sIGYgPSBmYS5pc1hNTCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIgPSBhICYmIChhLm93bmVyRG9jdW1lbnQgfHwgYSkuZG9jdW1lbnRFbGVtZW50O3JldHVybiBiID8gXFxcIkhUTUxcXFwiICE9PSBiLm5vZGVOYW1lIDogITE7XFxuICAgIH0sIG0gPSBmYS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGcgPSBhID8gYS5vd25lckRvY3VtZW50IHx8IGEgOiB2O3JldHVybiBnICE9PSBuICYmIDkgPT09IGcubm9kZVR5cGUgJiYgZy5kb2N1bWVudEVsZW1lbnQgPyAobiA9IGcsIG8gPSBuLmRvY3VtZW50RWxlbWVudCwgcCA9ICFmKG4pLCAoZSA9IG4uZGVmYXVsdFZpZXcpICYmIGUudG9wICE9PSBlICYmIChlLmFkZEV2ZW50TGlzdGVuZXIgPyBlLmFkZEV2ZW50TGlzdGVuZXIoXFxcInVubG9hZFxcXCIsIGRhLCAhMSkgOiBlLmF0dGFjaEV2ZW50ICYmIGUuYXR0YWNoRXZlbnQoXFxcIm9udW5sb2FkXFxcIiwgZGEpKSwgYy5hdHRyaWJ1dGVzID0gaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhLmNsYXNzTmFtZSA9IFxcXCJpXFxcIiwgIWEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc05hbWVcXFwiKTtcXG4gICAgICB9KSwgYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gYS5hcHBlbmRDaGlsZChuLmNyZWF0ZUNvbW1lbnQoXFxcIlxcXCIpKSwgIWEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcIipcXFwiKS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSA9IFoudGVzdChuLmdldEVsZW1lbnRzQnlDbGFzc05hbWUpLCBjLmdldEJ5SWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgcmV0dXJuIG8uYXBwZW5kQ2hpbGQoYSkuaWQgPSB1LCAhbi5nZXRFbGVtZW50c0J5TmFtZSB8fCAhbi5nZXRFbGVtZW50c0J5TmFtZSh1KS5sZW5ndGg7XFxuICAgICAgfSksIGMuZ2V0QnlJZCA/IChkLmZpbmQuSUQgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBiLmdldEVsZW1lbnRCeUlkICYmIHApIHtcXG4gICAgICAgICAgdmFyIGMgPSBiLmdldEVsZW1lbnRCeUlkKGEpO3JldHVybiBjID8gW2NdIDogW107XFxuICAgICAgICB9XFxuICAgICAgfSwgZC5maWx0ZXIuSUQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgdmFyIGIgPSBhLnJlcGxhY2UoYmEsIGNhKTtyZXR1cm4gZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlKFxcXCJpZFxcXCIpID09PSBiO1xcbiAgICAgICAgfTtcXG4gICAgICB9KSA6IChkZWxldGUgZC5maW5kLklELCBkLmZpbHRlci5JRCA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpO3JldHVybiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICB2YXIgYyA9IFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBhLmdldEF0dHJpYnV0ZU5vZGUgJiYgYS5nZXRBdHRyaWJ1dGVOb2RlKFxcXCJpZFxcXCIpO3JldHVybiBjICYmIGMudmFsdWUgPT09IGI7XFxuICAgICAgICB9O1xcbiAgICAgIH0pLCBkLmZpbmQuVEFHID0gYy5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUgPyBiLmdldEVsZW1lbnRzQnlUYWdOYW1lKGEpIDogYy5xc2EgPyBiLnF1ZXJ5U2VsZWN0b3JBbGwoYSkgOiB2b2lkIDA7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICB2YXIgYyxcXG4gICAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgICAgZiA9IGIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYSk7aWYgKFxcXCIqXFxcIiA9PT0gYSkge1xcbiAgICAgICAgICB3aGlsZSAoYyA9IGZbZSsrXSkge1xcbiAgICAgICAgICAgIDEgPT09IGMubm9kZVR5cGUgJiYgZC5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGQ7XFxuICAgICAgICB9cmV0dXJuIGY7XFxuICAgICAgfSwgZC5maW5kLkNMQVNTID0gYy5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICByZXR1cm4gXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGIuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJiBwID8gYi5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGEpIDogdm9pZCAwO1xcbiAgICAgIH0sIHIgPSBbXSwgcSA9IFtdLCAoYy5xc2EgPSBaLnRlc3Qobi5xdWVyeVNlbGVjdG9yQWxsKSkgJiYgKGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBvLmFwcGVuZENoaWxkKGEpLmlubmVySFRNTCA9IFxcXCI8YSBpZD0nXFxcIiArIHUgKyBcXFwiJz48L2E+PHNlbGVjdCBpZD0nXFxcIiArIHUgKyBcXFwiLVxcXFxyXFxcXFxcXFwnIG1zYWxsb3djYXB0dXJlPScnPjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XFxcIiwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbbXNhbGxvd2NhcHR1cmVePScnXVxcXCIpLmxlbmd0aCAmJiBxLnB1c2goXFxcIlsqXiRdPVxcXCIgKyBMICsgXFxcIiooPzonJ3xcXFxcXFxcIlxcXFxcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltzZWxlY3RlZF1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJcXFxcXFxcXFtcXFwiICsgTCArIFxcXCIqKD86dmFsdWV8XFxcIiArIEsgKyBcXFwiKVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIltpZH49XFxcIiArIHUgKyBcXFwiLV1cXFwiKS5sZW5ndGggfHwgcS5wdXNoKFxcXCJ+PVxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIjpjaGVja2VkXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiOmNoZWNrZWRcXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCJhI1xcXCIgKyB1ICsgXFxcIisqXFxcIikubGVuZ3RoIHx8IHEucHVzaChcXFwiLiMuK1srfl1cXFwiKTtcXG4gICAgICB9KSwgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gbi5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Iuc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcImhpZGRlblxcXCIpLCBhLmFwcGVuZENoaWxkKGIpLnNldEF0dHJpYnV0ZShcXFwibmFtZVxcXCIsIFxcXCJEXFxcIiksIGEucXVlcnlTZWxlY3RvckFsbChcXFwiW25hbWU9ZF1cXFwiKS5sZW5ndGggJiYgcS5wdXNoKFxcXCJuYW1lXFxcIiArIEwgKyBcXFwiKlsqXiR8IX5dPz1cXFwiKSwgYS5xdWVyeVNlbGVjdG9yQWxsKFxcXCI6ZW5hYmxlZFxcXCIpLmxlbmd0aCB8fCBxLnB1c2goXFxcIjplbmFibGVkXFxcIiwgXFxcIjpkaXNhYmxlZFxcXCIpLCBhLnF1ZXJ5U2VsZWN0b3JBbGwoXFxcIiosOnhcXFwiKSwgcS5wdXNoKFxcXCIsLio6XFxcIik7XFxuICAgICAgfSkpLCAoYy5tYXRjaGVzU2VsZWN0b3IgPSBaLnRlc3QocyA9IG8ubWF0Y2hlcyB8fCBvLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fCBvLm1vek1hdGNoZXNTZWxlY3RvciB8fCBvLm9NYXRjaGVzU2VsZWN0b3IgfHwgby5tc01hdGNoZXNTZWxlY3RvcikpICYmIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBjLmRpc2Nvbm5lY3RlZE1hdGNoID0gcy5jYWxsKGEsIFxcXCJkaXZcXFwiKSwgcy5jYWxsKGEsIFxcXCJbcyE9JyddOnhcXFwiKSwgci5wdXNoKFxcXCIhPVxcXCIsIE8pO1xcbiAgICAgIH0pLCBxID0gcS5sZW5ndGggJiYgbmV3IFJlZ0V4cChxLmpvaW4oXFxcInxcXFwiKSksIHIgPSByLmxlbmd0aCAmJiBuZXcgUmVnRXhwKHIuam9pbihcXFwifFxcXCIpKSwgYiA9IFoudGVzdChvLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKSwgdCA9IGIgfHwgWi50ZXN0KG8uY29udGFpbnMpID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gOSA9PT0gYS5ub2RlVHlwZSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcXG4gICAgICAgICAgICBkID0gYiAmJiBiLnBhcmVudE5vZGU7cmV0dXJuIGEgPT09IGQgfHwgISghZCB8fCAxICE9PSBkLm5vZGVUeXBlIHx8ICEoYy5jb250YWlucyA/IGMuY29udGFpbnMoZCkgOiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICYmIDE2ICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihkKSkpO1xcbiAgICAgIH0gOiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgaWYgKGIpIHdoaWxlIChiID0gYi5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGlmIChiID09PSBhKSByZXR1cm4gITA7XFxuICAgICAgICB9cmV0dXJuICExO1xcbiAgICAgIH0sIEIgPSBiID8gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIGlmIChhID09PSBiKSByZXR1cm4gbCA9ICEwLCAwO3ZhciBkID0gIWEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gLSAhYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbjtyZXR1cm4gZCA/IGQgOiAoZCA9IChhLm93bmVyRG9jdW1lbnQgfHwgYSkgPT09IChiLm93bmVyRG9jdW1lbnQgfHwgYikgPyBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGIpIDogMSwgMSAmIGQgfHwgIWMuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oYSkgPT09IGQgPyBhID09PSBuIHx8IGEub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGEpID8gLTEgOiBiID09PSBuIHx8IGIub3duZXJEb2N1bWVudCA9PT0gdiAmJiB0KHYsIGIpID8gMSA6IGsgPyBKKGssIGEpIC0gSihrLCBiKSA6IDAgOiA0ICYgZCA/IC0xIDogMSk7XFxuICAgICAgfSA6IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICBpZiAoYSA9PT0gYikgcmV0dXJuIGwgPSAhMCwgMDt2YXIgYyxcXG4gICAgICAgICAgICBkID0gMCxcXG4gICAgICAgICAgICBlID0gYS5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgIGYgPSBiLnBhcmVudE5vZGUsXFxuICAgICAgICAgICAgZyA9IFthXSxcXG4gICAgICAgICAgICBoID0gW2JdO2lmICghZSB8fCAhZikgcmV0dXJuIGEgPT09IG4gPyAtMSA6IGIgPT09IG4gPyAxIDogZSA/IC0xIDogZiA/IDEgOiBrID8gSihrLCBhKSAtIEooaywgYikgOiAwO2lmIChlID09PSBmKSByZXR1cm4ga2EoYSwgYik7YyA9IGE7d2hpbGUgKGMgPSBjLnBhcmVudE5vZGUpIHtcXG4gICAgICAgICAgZy51bnNoaWZ0KGMpO1xcbiAgICAgICAgfWMgPSBiO3doaWxlIChjID0gYy5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgIGgudW5zaGlmdChjKTtcXG4gICAgICAgIH13aGlsZSAoZ1tkXSA9PT0gaFtkXSkge1xcbiAgICAgICAgICBkKys7XFxuICAgICAgICB9cmV0dXJuIGQgPyBrYShnW2RdLCBoW2RdKSA6IGdbZF0gPT09IHYgPyAtMSA6IGhbZF0gPT09IHYgPyAxIDogMDtcXG4gICAgICB9LCBuKSA6IG47XFxuICAgIH0sIGZhLm1hdGNoZXMgPSBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIHJldHVybiBmYShhLCBudWxsLCBudWxsLCBiKTtcXG4gICAgfSwgZmEubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICBpZiAoKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCBiID0gYi5yZXBsYWNlKFQsIFxcXCI9JyQxJ11cXFwiKSwgYy5tYXRjaGVzU2VsZWN0b3IgJiYgcCAmJiAhQVtiICsgXFxcIiBcXFwiXSAmJiAoIXIgfHwgIXIudGVzdChiKSkgJiYgKCFxIHx8ICFxLnRlc3QoYikpKSB0cnkge1xcbiAgICAgICAgdmFyIGQgPSBzLmNhbGwoYSwgYik7aWYgKGQgfHwgYy5kaXNjb25uZWN0ZWRNYXRjaCB8fCBhLmRvY3VtZW50ICYmIDExICE9PSBhLmRvY3VtZW50Lm5vZGVUeXBlKSByZXR1cm4gZDtcXG4gICAgICB9IGNhdGNoIChlKSB7fXJldHVybiBmYShiLCBuLCBudWxsLCBbYV0pLmxlbmd0aCA+IDA7XFxuICAgIH0sIGZhLmNvbnRhaW5zID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICByZXR1cm4gKGEub3duZXJEb2N1bWVudCB8fCBhKSAhPT0gbiAmJiBtKGEpLCB0KGEsIGIpO1xcbiAgICB9LCBmYS5hdHRyID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAoYS5vd25lckRvY3VtZW50IHx8IGEpICE9PSBuICYmIG0oYSk7dmFyIGUgPSBkLmF0dHJIYW5kbGVbYi50b0xvd2VyQ2FzZSgpXSxcXG4gICAgICAgICAgZiA9IGUgJiYgRC5jYWxsKGQuYXR0ckhhbmRsZSwgYi50b0xvd2VyQ2FzZSgpKSA/IGUoYSwgYiwgIXApIDogdm9pZCAwO3JldHVybiB2b2lkIDAgIT09IGYgPyBmIDogYy5hdHRyaWJ1dGVzIHx8ICFwID8gYS5nZXRBdHRyaWJ1dGUoYikgOiAoZiA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZi5zcGVjaWZpZWQgPyBmLnZhbHVlIDogbnVsbDtcXG4gICAgfSwgZmEuZXJyb3IgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXFxcIiArIGEpO1xcbiAgICB9LCBmYS51bmlxdWVTb3J0ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gMCxcXG4gICAgICAgICAgZiA9IDA7aWYgKGwgPSAhYy5kZXRlY3REdXBsaWNhdGVzLCBrID0gIWMuc29ydFN0YWJsZSAmJiBhLnNsaWNlKDApLCBhLnNvcnQoQiksIGwpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYVtmKytdKSB7XFxuICAgICAgICAgIGIgPT09IGFbZl0gJiYgKGUgPSBkLnB1c2goZikpO1xcbiAgICAgICAgfXdoaWxlIChlLS0pIHtcXG4gICAgICAgICAgYS5zcGxpY2UoZFtlXSwgMSk7XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiBrID0gbnVsbCwgYTtcXG4gICAgfSwgZSA9IGZhLmdldFRleHQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gXFxcIlxcXCIsXFxuICAgICAgICAgIGQgPSAwLFxcbiAgICAgICAgICBmID0gYS5ub2RlVHlwZTtpZiAoZikge1xcbiAgICAgICAgaWYgKDEgPT09IGYgfHwgOSA9PT0gZiB8fCAxMSA9PT0gZikge1xcbiAgICAgICAgICBpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEudGV4dENvbnRlbnQpIHJldHVybiBhLnRleHRDb250ZW50O2ZvciAoYSA9IGEuZmlyc3RDaGlsZDsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAgICAgICBjICs9IGUoYSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSBpZiAoMyA9PT0gZiB8fCA0ID09PSBmKSByZXR1cm4gYS5ub2RlVmFsdWU7XFxuICAgICAgfSBlbHNlIHdoaWxlIChiID0gYVtkKytdKSB7XFxuICAgICAgICBjICs9IGUoYik7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9LCBkID0gZmEuc2VsZWN0b3JzID0geyBjYWNoZUxlbmd0aDogNTAsIGNyZWF0ZVBzZXVkbzogaGEsIG1hdGNoOiBXLCBhdHRySGFuZGxlOiB7fSwgZmluZDoge30sIHJlbGF0aXZlOiB7IFxcXCI+XFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCIgXFxcIjogeyBkaXI6IFxcXCJwYXJlbnROb2RlXFxcIiB9LCBcXFwiK1xcXCI6IHsgZGlyOiBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgZmlyc3Q6ICEwIH0sIFxcXCJ+XFxcIjogeyBkaXI6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiIH0gfSwgcHJlRmlsdGVyOiB7IEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSkge1xcbiAgICAgICAgICByZXR1cm4gYVsxXSA9IGFbMV0ucmVwbGFjZShiYSwgY2EpLCBhWzNdID0gKGFbM10gfHwgYVs0XSB8fCBhWzVdIHx8IFxcXCJcXFwiKS5yZXBsYWNlKGJhLCBjYSksIFxcXCJ+PVxcXCIgPT09IGFbMl0gJiYgKGFbM10gPSBcXFwiIFxcXCIgKyBhWzNdICsgXFxcIiBcXFwiKSwgYS5zbGljZSgwLCA0KTtcXG4gICAgICAgIH0sIENISUxEOiBmdW5jdGlvbiBDSElMRChhKSB7XFxuICAgICAgICAgIHJldHVybiBhWzFdID0gYVsxXS50b0xvd2VyQ2FzZSgpLCBcXFwibnRoXFxcIiA9PT0gYVsxXS5zbGljZSgwLCAzKSA/IChhWzNdIHx8IGZhLmVycm9yKGFbMF0pLCBhWzRdID0gKyhhWzRdID8gYVs1XSArIChhWzZdIHx8IDEpIDogMiAqIChcXFwiZXZlblxcXCIgPT09IGFbM10gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSwgYVs1XSA9ICsoYVs3XSArIGFbOF0gfHwgXFxcIm9kZFxcXCIgPT09IGFbM10pKSA6IGFbM10gJiYgZmEuZXJyb3IoYVswXSksIGE7XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhKSB7XFxuICAgICAgICAgIHZhciBiLFxcbiAgICAgICAgICAgICAgYyA9ICFhWzZdICYmIGFbMl07cmV0dXJuIFcuQ0hJTEQudGVzdChhWzBdKSA/IG51bGwgOiAoYVszXSA/IGFbMl0gPSBhWzRdIHx8IGFbNV0gfHwgXFxcIlxcXCIgOiBjICYmIFUudGVzdChjKSAmJiAoYiA9IGcoYywgITApKSAmJiAoYiA9IGMuaW5kZXhPZihcXFwiKVxcXCIsIGMubGVuZ3RoIC0gYikgLSBjLmxlbmd0aCkgJiYgKGFbMF0gPSBhWzBdLnNsaWNlKDAsIGIpLCBhWzJdID0gYy5zbGljZSgwLCBiKSksIGEuc2xpY2UoMCwgMykpO1xcbiAgICAgICAgfSB9LCBmaWx0ZXI6IHsgVEFHOiBmdW5jdGlvbiBUQUcoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IGEucmVwbGFjZShiYSwgY2EpLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCIqXFxcIiA9PT0gYSA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICByZXR1cm4gITA7XFxuICAgICAgICAgIH0gOiBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiBhLm5vZGVOYW1lICYmIGEubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gYjtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0sIENMQVNTOiBmdW5jdGlvbiBDTEFTUyhhKSB7XFxuICAgICAgICAgIHZhciBiID0geVthICsgXFxcIiBcXFwiXTtyZXR1cm4gYiB8fCAoYiA9IG5ldyBSZWdFeHAoXFxcIihefFxcXCIgKyBMICsgXFxcIilcXFwiICsgYSArIFxcXCIoXFxcIiArIEwgKyBcXFwifCQpXFxcIikpICYmIHkoYSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gYi50ZXN0KFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhLmNsYXNzTmFtZSAmJiBhLmNsYXNzTmFtZSB8fCBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRBdHRyaWJ1dGUgJiYgYS5nZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIikgfHwgXFxcIlxcXCIpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0sIEFUVFI6IGZ1bmN0aW9uIEFUVFIoYSwgYiwgYykge1xcbiAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGQpIHtcXG4gICAgICAgICAgICB2YXIgZSA9IGZhLmF0dHIoZCwgYSk7cmV0dXJuIG51bGwgPT0gZSA/IFxcXCIhPVxcXCIgPT09IGIgOiBiID8gKGUgKz0gXFxcIlxcXCIsIFxcXCI9XFxcIiA9PT0gYiA/IGUgPT09IGMgOiBcXFwiIT1cXFwiID09PSBiID8gZSAhPT0gYyA6IFxcXCJePVxcXCIgPT09IGIgPyBjICYmIDAgPT09IGUuaW5kZXhPZihjKSA6IFxcXCIqPVxcXCIgPT09IGIgPyBjICYmIGUuaW5kZXhPZihjKSA+IC0xIDogXFxcIiQ9XFxcIiA9PT0gYiA/IGMgJiYgZS5zbGljZSgtYy5sZW5ndGgpID09PSBjIDogXFxcIn49XFxcIiA9PT0gYiA/IChcXFwiIFxcXCIgKyBlLnJlcGxhY2UoUCwgXFxcIiBcXFwiKSArIFxcXCIgXFxcIikuaW5kZXhPZihjKSA+IC0xIDogXFxcInw9XFxcIiA9PT0gYiA/IGUgPT09IGMgfHwgZS5zbGljZSgwLCBjLmxlbmd0aCArIDEpID09PSBjICsgXFxcIi1cXFwiIDogITEpIDogITA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBDSElMRDogZnVuY3Rpb24gQ0hJTEQoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgICAgICB2YXIgZiA9IFxcXCJudGhcXFwiICE9PSBhLnNsaWNlKDAsIDMpLFxcbiAgICAgICAgICAgICAgZyA9IFxcXCJsYXN0XFxcIiAhPT0gYS5zbGljZSgtNCksXFxuICAgICAgICAgICAgICBoID0gXFxcIm9mLXR5cGVcXFwiID09PSBiO3JldHVybiAxID09PSBkICYmIDAgPT09IGUgPyBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICAgIHJldHVybiAhIWEucGFyZW50Tm9kZTtcXG4gICAgICAgICAgfSA6IGZ1bmN0aW9uIChiLCBjLCBpKSB7XFxuICAgICAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgICAgIGwsXFxuICAgICAgICAgICAgICAgIG0sXFxuICAgICAgICAgICAgICAgIG4sXFxuICAgICAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgICAgIHAgPSBmICE9PSBnID8gXFxcIm5leHRTaWJsaW5nXFxcIiA6IFxcXCJwcmV2aW91c1NpYmxpbmdcXFwiLFxcbiAgICAgICAgICAgICAgICBxID0gYi5wYXJlbnROb2RlLFxcbiAgICAgICAgICAgICAgICByID0gaCAmJiBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXFxuICAgICAgICAgICAgICAgIHMgPSAhaSAmJiAhaCxcXG4gICAgICAgICAgICAgICAgdCA9ICExO2lmIChxKSB7XFxuICAgICAgICAgICAgICBpZiAoZikge1xcbiAgICAgICAgICAgICAgICB3aGlsZSAocCkge1xcbiAgICAgICAgICAgICAgICAgIG0gPSBiO3doaWxlIChtID0gbVtwXSkge1xcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggPyBtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IHIgOiAxID09PSBtLm5vZGVUeXBlKSByZXR1cm4gITE7XFxuICAgICAgICAgICAgICAgICAgfW8gPSBwID0gXFxcIm9ubHlcXFwiID09PSBhICYmICFvICYmIFxcXCJuZXh0U2libGluZ1xcXCI7XFxuICAgICAgICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICAgICAgICB9aWYgKG8gPSBbZyA/IHEuZmlyc3RDaGlsZCA6IHEubGFzdENoaWxkXSwgZyAmJiBzKSB7XFxuICAgICAgICAgICAgICAgIG0gPSBxLCBsID0gbVt1XSB8fCAobVt1XSA9IHt9KSwgayA9IGxbbS51bmlxdWVJRF0gfHwgKGxbbS51bmlxdWVJRF0gPSB7fSksIGogPSBrW2FdIHx8IFtdLCBuID0galswXSA9PT0gdyAmJiBqWzFdLCB0ID0gbiAmJiBqWzJdLCBtID0gbiAmJiBxLmNoaWxkTm9kZXNbbl07d2hpbGUgKG0gPSArK24gJiYgbSAmJiBtW3BdIHx8ICh0ID0gbiA9IDApIHx8IG8ucG9wKCkpIHtcXG4gICAgICAgICAgICAgICAgICBpZiAoMSA9PT0gbS5ub2RlVHlwZSAmJiArK3QgJiYgbSA9PT0gYikge1xcbiAgICAgICAgICAgICAgICAgICAga1thXSA9IFt3LCBuLCB0XTticmVhaztcXG4gICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAocyAmJiAobSA9IGIsIGwgPSBtW3VdIHx8IChtW3VdID0ge30pLCBrID0gbFttLnVuaXF1ZUlEXSB8fCAobFttLnVuaXF1ZUlEXSA9IHt9KSwgaiA9IGtbYV0gfHwgW10sIG4gPSBqWzBdID09PSB3ICYmIGpbMV0sIHQgPSBuKSwgdCA9PT0gITEpIHdoaWxlIChtID0gKytuICYmIG0gJiYgbVtwXSB8fCAodCA9IG4gPSAwKSB8fCBvLnBvcCgpKSB7XFxuICAgICAgICAgICAgICAgIGlmICgoaCA/IG0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gciA6IDEgPT09IG0ubm9kZVR5cGUpICYmICsrdCAmJiAocyAmJiAobCA9IG1bdV0gfHwgKG1bdV0gPSB7fSksIGsgPSBsW20udW5pcXVlSURdIHx8IChsW20udW5pcXVlSURdID0ge30pLCBrW2FdID0gW3csIHRdKSwgbSA9PT0gYikpIGJyZWFrO1xcbiAgICAgICAgICAgICAgfXJldHVybiB0IC09IGUsIHQgPT09IGQgfHwgdCAlIGQgPT09IDAgJiYgdCAvIGQgPj0gMDtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBQU0VVRE86IGZ1bmN0aW9uIFBTRVVETyhhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZSA9IGQucHNldWRvc1thXSB8fCBkLnNldEZpbHRlcnNbYS50b0xvd2VyQ2FzZSgpXSB8fCBmYS5lcnJvcihcXFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcXFwiICsgYSk7cmV0dXJuIGVbdV0gPyBlKGIpIDogZS5sZW5ndGggPiAxID8gKGMgPSBbYSwgYSwgXFxcIlxcXCIsIGJdLCBkLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoYS50b0xvd2VyQ2FzZSgpKSA/IGhhKGZ1bmN0aW9uIChhLCBjKSB7XFxuICAgICAgICAgICAgdmFyIGQsXFxuICAgICAgICAgICAgICAgIGYgPSBlKGEsIGIpLFxcbiAgICAgICAgICAgICAgICBnID0gZi5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgICAgZCA9IEooYSwgZltnXSksIGFbZF0gPSAhKGNbZF0gPSBmW2ddKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgIH0pIDogZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gZShhLCAwLCBjKTtcXG4gICAgICAgICAgfSkgOiBlO1xcbiAgICAgICAgfSB9LCBwc2V1ZG9zOiB7IG5vdDogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBbXSxcXG4gICAgICAgICAgICAgIGMgPSBbXSxcXG4gICAgICAgICAgICAgIGQgPSBoKGEucmVwbGFjZShRLCBcXFwiJDFcXFwiKSk7cmV0dXJuIGRbdV0gPyBoYShmdW5jdGlvbiAoYSwgYiwgYywgZSkge1xcbiAgICAgICAgICAgIHZhciBmLFxcbiAgICAgICAgICAgICAgICBnID0gZChhLCBudWxsLCBlLCBbXSksXFxuICAgICAgICAgICAgICAgIGggPSBhLmxlbmd0aDt3aGlsZSAoaC0tKSB7XFxuICAgICAgICAgICAgICAoZiA9IGdbaF0pICYmIChhW2hdID0gIShiW2hdID0gZikpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfSkgOiBmdW5jdGlvbiAoYSwgZSwgZikge1xcbiAgICAgICAgICAgIHJldHVybiBiWzBdID0gYSwgZChiLCBudWxsLCBmLCBjKSwgYlswXSA9IG51bGwsICFjLnBvcCgpO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIGhhczogaGEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGZhKGEsIGIpLmxlbmd0aCA+IDA7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9KSwgY29udGFpbnM6IGhhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID0gYS5yZXBsYWNlKGJhLCBjYSksIGZ1bmN0aW9uIChiKSB7XFxuICAgICAgICAgICAgcmV0dXJuIChiLnRleHRDb250ZW50IHx8IGIuaW5uZXJUZXh0IHx8IGUoYikpLmluZGV4T2YoYSkgPiAtMTtcXG4gICAgICAgICAgfTtcXG4gICAgICAgIH0pLCBsYW5nOiBoYShmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgICByZXR1cm4gVi50ZXN0KGEgfHwgXFxcIlxcXCIpIHx8IGZhLmVycm9yKFxcXCJ1bnN1cHBvcnRlZCBsYW5nOiBcXFwiICsgYSksIGEgPSBhLnJlcGxhY2UoYmEsIGNhKS50b0xvd2VyQ2FzZSgpLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgICAgIHZhciBjO2RvIHtcXG4gICAgICAgICAgICAgIGlmIChjID0gcCA/IGIubGFuZyA6IGIuZ2V0QXR0cmlidXRlKFxcXCJ4bWw6bGFuZ1xcXCIpIHx8IGIuZ2V0QXR0cmlidXRlKFxcXCJsYW5nXFxcIikpIHJldHVybiBjID0gYy50b0xvd2VyQ2FzZSgpLCBjID09PSBhIHx8IDAgPT09IGMuaW5kZXhPZihhICsgXFxcIi1cXFwiKTtcXG4gICAgICAgICAgICB9IHdoaWxlICgoYiA9IGIucGFyZW50Tm9kZSkgJiYgMSA9PT0gYi5ub2RlVHlwZSk7cmV0dXJuICExO1xcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSksIHRhcmdldDogZnVuY3Rpb24gdGFyZ2V0KGIpIHtcXG4gICAgICAgICAgdmFyIGMgPSBhLmxvY2F0aW9uICYmIGEubG9jYXRpb24uaGFzaDtyZXR1cm4gYyAmJiBjLnNsaWNlKDEpID09PSBiLmlkO1xcbiAgICAgICAgfSwgcm9vdDogZnVuY3Rpb24gcm9vdChhKSB7XFxuICAgICAgICAgIHJldHVybiBhID09PSBvO1xcbiAgICAgICAgfSwgZm9jdXM6IGZ1bmN0aW9uIGZvY3VzKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEgPT09IG4uYWN0aXZlRWxlbWVudCAmJiAoIW4uaGFzRm9jdXMgfHwgbi5oYXNGb2N1cygpKSAmJiAhIShhLnR5cGUgfHwgYS5ocmVmIHx8IH5hLnRhYkluZGV4KTtcXG4gICAgICAgIH0sIGVuYWJsZWQ6IGZ1bmN0aW9uIGVuYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITE7XFxuICAgICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoYSkge1xcbiAgICAgICAgICByZXR1cm4gYS5kaXNhYmxlZCA9PT0gITA7XFxuICAgICAgICB9LCBjaGVja2VkOiBmdW5jdGlvbiBjaGVja2VkKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgISFhLmNoZWNrZWQgfHwgXFxcIm9wdGlvblxcXCIgPT09IGIgJiYgISFhLnNlbGVjdGVkO1xcbiAgICAgICAgfSwgc2VsZWN0ZWQ6IGZ1bmN0aW9uIHNlbGVjdGVkKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIGEucGFyZW50Tm9kZSAmJiBhLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleCwgYS5zZWxlY3RlZCA9PT0gITA7XFxuICAgICAgICB9LCBlbXB0eTogZnVuY3Rpb24gZW1wdHkoYSkge1xcbiAgICAgICAgICBmb3IgKGEgPSBhLmZpcnN0Q2hpbGQ7IGE7IGEgPSBhLm5leHRTaWJsaW5nKSB7XFxuICAgICAgICAgICAgaWYgKGEubm9kZVR5cGUgPCA2KSByZXR1cm4gITE7XFxuICAgICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgICB9LCBwYXJlbnQ6IGZ1bmN0aW9uIHBhcmVudChhKSB7XFxuICAgICAgICAgIHJldHVybiAhZC5wc2V1ZG9zLmVtcHR5KGEpO1xcbiAgICAgICAgfSwgaGVhZGVyOiBmdW5jdGlvbiBoZWFkZXIoYSkge1xcbiAgICAgICAgICByZXR1cm4gWS50ZXN0KGEubm9kZU5hbWUpO1xcbiAgICAgICAgfSwgaW5wdXQ6IGZ1bmN0aW9uIGlucHV0KGEpIHtcXG4gICAgICAgICAgcmV0dXJuIFgudGVzdChhLm5vZGVOYW1lKTtcXG4gICAgICAgIH0sIGJ1dHRvbjogZnVuY3Rpb24gYnV0dG9uKGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7cmV0dXJuIFxcXCJpbnB1dFxcXCIgPT09IGIgJiYgXFxcImJ1dHRvblxcXCIgPT09IGEudHlwZSB8fCBcXFwiYnV0dG9uXFxcIiA9PT0gYjtcXG4gICAgICAgIH0sIHRleHQ6IGZ1bmN0aW9uIHRleHQoYSkge1xcbiAgICAgICAgICB2YXIgYjtyZXR1cm4gXFxcImlucHV0XFxcIiA9PT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICYmIFxcXCJ0ZXh0XFxcIiA9PT0gYS50eXBlICYmIChudWxsID09IChiID0gYS5nZXRBdHRyaWJ1dGUoXFxcInR5cGVcXFwiKSkgfHwgXFxcInRleHRcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkpO1xcbiAgICAgICAgfSwgZmlyc3Q6IG5hKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFswXTtcXG4gICAgICAgIH0pLCBsYXN0OiBuYShmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgICByZXR1cm4gW2IgLSAxXTtcXG4gICAgICAgIH0pLCBlcTogbmEoZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgICAgcmV0dXJuIFswID4gYyA/IGMgKyBiIDogY107XFxuICAgICAgICB9KSwgZXZlbjogbmEoZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGIgPiBjOyBjICs9IDIpIHtcXG4gICAgICAgICAgICBhLnB1c2goYyk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pLCBvZGQ6IG5hKGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIGZvciAodmFyIGMgPSAxOyBiID4gYzsgYyArPSAyKSB7XFxuICAgICAgICAgICAgYS5wdXNoKGMpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgbHQ6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgLS1kID49IDA7KSB7XFxuICAgICAgICAgICAgYS5wdXNoKGQpO1xcbiAgICAgICAgICB9cmV0dXJuIGE7XFxuICAgICAgICB9KSwgZ3Q6IG5hKGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgICAgIGZvciAodmFyIGQgPSAwID4gYyA/IGMgKyBiIDogYzsgKytkIDwgYjspIHtcXG4gICAgICAgICAgICBhLnB1c2goZCk7XFxuICAgICAgICAgIH1yZXR1cm4gYTtcXG4gICAgICAgIH0pIH0gfSwgZC5wc2V1ZG9zLm50aCA9IGQucHNldWRvcy5lcTtmb3IgKGIgaW4geyByYWRpbzogITAsIGNoZWNrYm94OiAhMCwgZmlsZTogITAsIHBhc3N3b3JkOiAhMCwgaW1hZ2U6ICEwIH0pIHtcXG4gICAgICBkLnBzZXVkb3NbYl0gPSBsYShiKTtcXG4gICAgfWZvciAoYiBpbiB7IHN1Ym1pdDogITAsIHJlc2V0OiAhMCB9KSB7XFxuICAgICAgZC5wc2V1ZG9zW2JdID0gbWEoYik7XFxuICAgIH1mdW5jdGlvbiBwYSgpIHt9cGEucHJvdG90eXBlID0gZC5maWx0ZXJzID0gZC5wc2V1ZG9zLCBkLnNldEZpbHRlcnMgPSBuZXcgcGEoKSwgZyA9IGZhLnRva2VuaXplID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IHpbYSArIFxcXCIgXFxcIl07aWYgKGspIHJldHVybiBiID8gMCA6IGsuc2xpY2UoMCk7aCA9IGEsIGkgPSBbXSwgaiA9IGQucHJlRmlsdGVyO3doaWxlIChoKSB7XFxuICAgICAgICBjICYmICEoZSA9IFIuZXhlYyhoKSkgfHwgKGUgJiYgKGggPSBoLnNsaWNlKGVbMF0ubGVuZ3RoKSB8fCBoKSwgaS5wdXNoKGYgPSBbXSkpLCBjID0gITEsIChlID0gUy5leGVjKGgpKSAmJiAoYyA9IGUuc2hpZnQoKSwgZi5wdXNoKHsgdmFsdWU6IGMsIHR5cGU6IGVbMF0ucmVwbGFjZShRLCBcXFwiIFxcXCIpIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO2ZvciAoZyBpbiBkLmZpbHRlcikge1xcbiAgICAgICAgICAhKGUgPSBXW2ddLmV4ZWMoaCkpIHx8IGpbZ10gJiYgIShlID0galtnXShlKSkgfHwgKGMgPSBlLnNoaWZ0KCksIGYucHVzaCh7IHZhbHVlOiBjLCB0eXBlOiBnLCBtYXRjaGVzOiBlIH0pLCBoID0gaC5zbGljZShjLmxlbmd0aCkpO1xcbiAgICAgICAgfWlmICghYykgYnJlYWs7XFxuICAgICAgfXJldHVybiBiID8gaC5sZW5ndGggOiBoID8gZmEuZXJyb3IoYSkgOiB6KGEsIGkpLnNsaWNlKDApO1xcbiAgICB9O2Z1bmN0aW9uIHFhKGEpIHtcXG4gICAgICBmb3IgKHZhciBiID0gMCwgYyA9IGEubGVuZ3RoLCBkID0gXFxcIlxcXCI7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgIGQgKz0gYVtiXS52YWx1ZTtcXG4gICAgICB9cmV0dXJuIGQ7XFxuICAgIH1mdW5jdGlvbiByYShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBiLmRpcixcXG4gICAgICAgICAgZSA9IGMgJiYgXFxcInBhcmVudE5vZGVcXFwiID09PSBkLFxcbiAgICAgICAgICBmID0geCsrO3JldHVybiBiLmZpcnN0ID8gZnVuY3Rpb24gKGIsIGMsIGYpIHtcXG4gICAgICAgIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICBpZiAoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSByZXR1cm4gYShiLCBjLCBmKTtcXG4gICAgICAgIH1cXG4gICAgICB9IDogZnVuY3Rpb24gKGIsIGMsIGcpIHtcXG4gICAgICAgIHZhciBoLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgaixcXG4gICAgICAgICAgICBrID0gW3csIGZdO2lmIChnKSB7XFxuICAgICAgICAgIHdoaWxlIChiID0gYltkXSkge1xcbiAgICAgICAgICAgIGlmICgoMSA9PT0gYi5ub2RlVHlwZSB8fCBlKSAmJiBhKGIsIGMsIGcpKSByZXR1cm4gITA7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB3aGlsZSAoYiA9IGJbZF0pIHtcXG4gICAgICAgICAgaWYgKDEgPT09IGIubm9kZVR5cGUgfHwgZSkge1xcbiAgICAgICAgICAgIGlmIChqID0gYlt1XSB8fCAoYlt1XSA9IHt9KSwgaSA9IGpbYi51bmlxdWVJRF0gfHwgKGpbYi51bmlxdWVJRF0gPSB7fSksIChoID0gaVtkXSkgJiYgaFswXSA9PT0gdyAmJiBoWzFdID09PSBmKSByZXR1cm4ga1syXSA9IGhbMl07aWYgKGlbZF0gPSBrLCBrWzJdID0gYShiLCBjLCBnKSkgcmV0dXJuICEwO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfTtcXG4gICAgfWZ1bmN0aW9uIHNhKGEpIHtcXG4gICAgICByZXR1cm4gYS5sZW5ndGggPiAxID8gZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgICAgIHZhciBlID0gYS5sZW5ndGg7d2hpbGUgKGUtLSkge1xcbiAgICAgICAgICBpZiAoIWFbZV0oYiwgYywgZCkpIHJldHVybiAhMTtcXG4gICAgICAgIH1yZXR1cm4gITA7XFxuICAgICAgfSA6IGFbMF07XFxuICAgIH1mdW5jdGlvbiB0YShhLCBiLCBjKSB7XFxuICAgICAgZm9yICh2YXIgZCA9IDAsIGUgPSBiLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgZmEoYSwgYltkXSwgYyk7XFxuICAgICAgfXJldHVybiBjO1xcbiAgICB9ZnVuY3Rpb24gdWEoYSwgYiwgYywgZCwgZSkge1xcbiAgICAgIGZvciAodmFyIGYsIGcgPSBbXSwgaCA9IDAsIGkgPSBhLmxlbmd0aCwgaiA9IG51bGwgIT0gYjsgaSA+IGg7IGgrKykge1xcbiAgICAgICAgKGYgPSBhW2hdKSAmJiAoYyAmJiAhYyhmLCBkLCBlKSB8fCAoZy5wdXNoKGYpLCBqICYmIGIucHVzaChoKSkpO1xcbiAgICAgIH1yZXR1cm4gZztcXG4gICAgfWZ1bmN0aW9uIHZhKGEsIGIsIGMsIGQsIGUsIGYpIHtcXG4gICAgICByZXR1cm4gZCAmJiAhZFt1XSAmJiAoZCA9IHZhKGQpKSwgZSAmJiAhZVt1XSAmJiAoZSA9IHZhKGUsIGYpKSwgaGEoZnVuY3Rpb24gKGYsIGcsIGgsIGkpIHtcXG4gICAgICAgIHZhciBqLFxcbiAgICAgICAgICAgIGssXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICBtID0gW10sXFxuICAgICAgICAgICAgbiA9IFtdLFxcbiAgICAgICAgICAgIG8gPSBnLmxlbmd0aCxcXG4gICAgICAgICAgICBwID0gZiB8fCB0YShiIHx8IFxcXCIqXFxcIiwgaC5ub2RlVHlwZSA/IFtoXSA6IGgsIFtdKSxcXG4gICAgICAgICAgICBxID0gIWEgfHwgIWYgJiYgYiA/IHAgOiB1YShwLCBtLCBhLCBoLCBpKSxcXG4gICAgICAgICAgICByID0gYyA/IGUgfHwgKGYgPyBhIDogbyB8fCBkKSA/IFtdIDogZyA6IHE7aWYgKGMgJiYgYyhxLCByLCBoLCBpKSwgZCkge1xcbiAgICAgICAgICBqID0gdWEociwgbiksIGQoaiwgW10sIGgsIGkpLCBrID0gai5sZW5ndGg7d2hpbGUgKGstLSkge1xcbiAgICAgICAgICAgIChsID0galtrXSkgJiYgKHJbbltrXV0gPSAhKHFbbltrXV0gPSBsKSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZikge1xcbiAgICAgICAgICBpZiAoZSB8fCBhKSB7XFxuICAgICAgICAgICAgaWYgKGUpIHtcXG4gICAgICAgICAgICAgIGogPSBbXSwgayA9IHIubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAgICAgKGwgPSByW2tdKSAmJiBqLnB1c2gocVtrXSA9IGwpO1xcbiAgICAgICAgICAgICAgfWUobnVsbCwgciA9IFtdLCBqLCBpKTtcXG4gICAgICAgICAgICB9ayA9IHIubGVuZ3RoO3doaWxlIChrLS0pIHtcXG4gICAgICAgICAgICAgIChsID0gcltrXSkgJiYgKGogPSBlID8gSihmLCBsKSA6IG1ba10pID4gLTEgJiYgKGZbal0gPSAhKGdbal0gPSBsKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2UgciA9IHVhKHIgPT09IGcgPyByLnNwbGljZShvLCByLmxlbmd0aCkgOiByKSwgZSA/IGUobnVsbCwgZywgciwgaSkgOiBILmFwcGx5KGcsIHIpO1xcbiAgICAgIH0pO1xcbiAgICB9ZnVuY3Rpb24gd2EoYSkge1xcbiAgICAgIGZvciAodmFyIGIsIGMsIGUsIGYgPSBhLmxlbmd0aCwgZyA9IGQucmVsYXRpdmVbYVswXS50eXBlXSwgaCA9IGcgfHwgZC5yZWxhdGl2ZVtcXFwiIFxcXCJdLCBpID0gZyA/IDEgOiAwLCBrID0gcmEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiBhID09PSBiO1xcbiAgICAgIH0sIGgsICEwKSwgbCA9IHJhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICByZXR1cm4gSihiLCBhKSA+IC0xO1xcbiAgICAgIH0sIGgsICEwKSwgbSA9IFtmdW5jdGlvbiAoYSwgYywgZCkge1xcbiAgICAgICAgdmFyIGUgPSAhZyAmJiAoZCB8fCBjICE9PSBqKSB8fCAoKGIgPSBjKS5ub2RlVHlwZSA/IGsoYSwgYywgZCkgOiBsKGEsIGMsIGQpKTtyZXR1cm4gYiA9IG51bGwsIGU7XFxuICAgICAgfV07IGYgPiBpOyBpKyspIHtcXG4gICAgICAgIGlmIChjID0gZC5yZWxhdGl2ZVthW2ldLnR5cGVdKSBtID0gW3JhKHNhKG0pLCBjKV07ZWxzZSB7XFxuICAgICAgICAgIGlmIChjID0gZC5maWx0ZXJbYVtpXS50eXBlXS5hcHBseShudWxsLCBhW2ldLm1hdGNoZXMpLCBjW3VdKSB7XFxuICAgICAgICAgICAgZm9yIChlID0gKytpOyBmID4gZTsgZSsrKSB7XFxuICAgICAgICAgICAgICBpZiAoZC5yZWxhdGl2ZVthW2VdLnR5cGVdKSBicmVhaztcXG4gICAgICAgICAgICB9cmV0dXJuIHZhKGkgPiAxICYmIHNhKG0pLCBpID4gMSAmJiBxYShhLnNsaWNlKDAsIGkgLSAxKS5jb25jYXQoeyB2YWx1ZTogXFxcIiBcXFwiID09PSBhW2kgLSAyXS50eXBlID8gXFxcIipcXFwiIDogXFxcIlxcXCIgfSkpLnJlcGxhY2UoUSwgXFxcIiQxXFxcIiksIGMsIGUgPiBpICYmIHdhKGEuc2xpY2UoaSwgZSkpLCBmID4gZSAmJiB3YShhID0gYS5zbGljZShlKSksIGYgPiBlICYmIHFhKGEpKTtcXG4gICAgICAgICAgfW0ucHVzaChjKTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIHNhKG0pO1xcbiAgICB9ZnVuY3Rpb24geGEoYSwgYikge1xcbiAgICAgIHZhciBjID0gYi5sZW5ndGggPiAwLFxcbiAgICAgICAgICBlID0gYS5sZW5ndGggPiAwLFxcbiAgICAgICAgICBmID0gZnVuY3Rpb24gZihfZiwgZywgaCwgaSwgaykge1xcbiAgICAgICAgdmFyIGwsXFxuICAgICAgICAgICAgbyxcXG4gICAgICAgICAgICBxLFxcbiAgICAgICAgICAgIHIgPSAwLFxcbiAgICAgICAgICAgIHMgPSBcXFwiMFxcXCIsXFxuICAgICAgICAgICAgdCA9IF9mICYmIFtdLFxcbiAgICAgICAgICAgIHUgPSBbXSxcXG4gICAgICAgICAgICB2ID0gaixcXG4gICAgICAgICAgICB4ID0gX2YgfHwgZSAmJiBkLmZpbmQuVEFHKFxcXCIqXFxcIiwgayksXFxuICAgICAgICAgICAgeSA9IHcgKz0gbnVsbCA9PSB2ID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgLjEsXFxuICAgICAgICAgICAgeiA9IHgubGVuZ3RoO2ZvciAoayAmJiAoaiA9IGcgPT09IG4gfHwgZyB8fCBrKTsgcyAhPT0geiAmJiBudWxsICE9IChsID0geFtzXSk7IHMrKykge1xcbiAgICAgICAgICBpZiAoZSAmJiBsKSB7XFxuICAgICAgICAgICAgbyA9IDAsIGcgfHwgbC5vd25lckRvY3VtZW50ID09PSBuIHx8IChtKGwpLCBoID0gIXApO3doaWxlIChxID0gYVtvKytdKSB7XFxuICAgICAgICAgICAgICBpZiAocShsLCBnIHx8IG4sIGgpKSB7XFxuICAgICAgICAgICAgICAgIGkucHVzaChsKTticmVhaztcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9ayAmJiAodyA9IHkpO1xcbiAgICAgICAgICB9YyAmJiAoKGwgPSAhcSAmJiBsKSAmJiByLS0sIF9mICYmIHQucHVzaChsKSk7XFxuICAgICAgICB9aWYgKHIgKz0gcywgYyAmJiBzICE9PSByKSB7XFxuICAgICAgICAgIG8gPSAwO3doaWxlIChxID0gYltvKytdKSB7XFxuICAgICAgICAgICAgcSh0LCB1LCBnLCBoKTtcXG4gICAgICAgICAgfWlmIChfZikge1xcbiAgICAgICAgICAgIGlmIChyID4gMCkgd2hpbGUgKHMtLSkge1xcbiAgICAgICAgICAgICAgdFtzXSB8fCB1W3NdIHx8ICh1W3NdID0gRi5jYWxsKGkpKTtcXG4gICAgICAgICAgICB9dSA9IHVhKHUpO1xcbiAgICAgICAgICB9SC5hcHBseShpLCB1KSwgayAmJiAhX2YgJiYgdS5sZW5ndGggPiAwICYmIHIgKyBiLmxlbmd0aCA+IDEgJiYgZmEudW5pcXVlU29ydChpKTtcXG4gICAgICAgIH1yZXR1cm4gayAmJiAodyA9IHksIGogPSB2KSwgdDtcXG4gICAgICB9O3JldHVybiBjID8gaGEoZikgOiBmO1xcbiAgICB9cmV0dXJuIGggPSBmYS5jb21waWxlID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCA9IFtdLFxcbiAgICAgICAgICBlID0gW10sXFxuICAgICAgICAgIGYgPSBBW2EgKyBcXFwiIFxcXCJdO2lmICghZikge1xcbiAgICAgICAgYiB8fCAoYiA9IGcoYSkpLCBjID0gYi5sZW5ndGg7d2hpbGUgKGMtLSkge1xcbiAgICAgICAgICBmID0gd2EoYltjXSksIGZbdV0gPyBkLnB1c2goZikgOiBlLnB1c2goZik7XFxuICAgICAgICB9ZiA9IEEoYSwgeGEoZSwgZCkpLCBmLnNlbGVjdG9yID0gYTtcXG4gICAgICB9cmV0dXJuIGY7XFxuICAgIH0sIGkgPSBmYS5zZWxlY3QgPSBmdW5jdGlvbiAoYSwgYiwgZSwgZikge1xcbiAgICAgIHZhciBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBuID0gXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgYSAmJiBhLFxcbiAgICAgICAgICBvID0gIWYgJiYgZyhhID0gbi5zZWxlY3RvciB8fCBhKTtpZiAoZSA9IGUgfHwgW10sIDEgPT09IG8ubGVuZ3RoKSB7XFxuICAgICAgICBpZiAoaiA9IG9bMF0gPSBvWzBdLnNsaWNlKDApLCBqLmxlbmd0aCA+IDIgJiYgXFxcIklEXFxcIiA9PT0gKGsgPSBqWzBdKS50eXBlICYmIGMuZ2V0QnlJZCAmJiA5ID09PSBiLm5vZGVUeXBlICYmIHAgJiYgZC5yZWxhdGl2ZVtqWzFdLnR5cGVdKSB7XFxuICAgICAgICAgIGlmIChiID0gKGQuZmluZC5JRChrLm1hdGNoZXNbMF0ucmVwbGFjZShiYSwgY2EpLCBiKSB8fCBbXSlbMF0sICFiKSByZXR1cm4gZTtuICYmIChiID0gYi5wYXJlbnROb2RlKSwgYSA9IGEuc2xpY2Uoai5zaGlmdCgpLnZhbHVlLmxlbmd0aCk7XFxuICAgICAgICB9aSA9IFcubmVlZHNDb250ZXh0LnRlc3QoYSkgPyAwIDogai5sZW5ndGg7d2hpbGUgKGktLSkge1xcbiAgICAgICAgICBpZiAoayA9IGpbaV0sIGQucmVsYXRpdmVbbCA9IGsudHlwZV0pIGJyZWFrO2lmICgobSA9IGQuZmluZFtsXSkgJiYgKGYgPSBtKGsubWF0Y2hlc1swXS5yZXBsYWNlKGJhLCBjYSksIF8udGVzdChqWzBdLnR5cGUpICYmIG9hKGIucGFyZW50Tm9kZSkgfHwgYikpKSB7XFxuICAgICAgICAgICAgaWYgKGouc3BsaWNlKGksIDEpLCBhID0gZi5sZW5ndGggJiYgcWEoaiksICFhKSByZXR1cm4gSC5hcHBseShlLCBmKSwgZTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gKG4gfHwgaChhLCBvKSkoZiwgYiwgIXAsIGUsICFiIHx8IF8udGVzdChhKSAmJiBvYShiLnBhcmVudE5vZGUpIHx8IGIpLCBlO1xcbiAgICB9LCBjLnNvcnRTdGFibGUgPSB1LnNwbGl0KFxcXCJcXFwiKS5zb3J0KEIpLmpvaW4oXFxcIlxcXCIpID09PSB1LCBjLmRldGVjdER1cGxpY2F0ZXMgPSAhIWwsIG0oKSwgYy5zb3J0RGV0YWNoZWQgPSBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiAxICYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihuLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpKTtcXG4gICAgfSksIGlhKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIGEuaW5uZXJIVE1MID0gXFxcIjxhIGhyZWY9JyMnPjwvYT5cXFwiLCBcXFwiI1xcXCIgPT09IGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcImhyZWZcXFwiKTtcXG4gICAgfSkgfHwgamEoXFxcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcXFwiLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBjID8gdm9pZCAwIDogYS5nZXRBdHRyaWJ1dGUoYiwgXFxcInR5cGVcXFwiID09PSBiLnRvTG93ZXJDYXNlKCkgPyAxIDogMik7XFxuICAgIH0pLCBjLmF0dHJpYnV0ZXMgJiYgaWEoZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gYS5pbm5lckhUTUwgPSBcXFwiPGlucHV0Lz5cXFwiLCBhLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKFxcXCJ2YWx1ZVxcXCIsIFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGEuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXFxcInZhbHVlXFxcIik7XFxuICAgIH0pIHx8IGphKFxcXCJ2YWx1ZVxcXCIsIGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIGMgfHwgXFxcImlucHV0XFxcIiAhPT0gYS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID8gdm9pZCAwIDogYS5kZWZhdWx0VmFsdWU7XFxuICAgIH0pLCBpYShmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09IGEuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpO1xcbiAgICB9KSB8fCBqYShLLCBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICAgIHZhciBkO3JldHVybiBjID8gdm9pZCAwIDogYVtiXSA9PT0gITAgPyBiLnRvTG93ZXJDYXNlKCkgOiAoZCA9IGEuZ2V0QXR0cmlidXRlTm9kZShiKSkgJiYgZC5zcGVjaWZpZWQgPyBkLnZhbHVlIDogbnVsbDtcXG4gICAgfSksIGZhO1xcbiAgfShhKTtuLmZpbmQgPSB0LCBuLmV4cHIgPSB0LnNlbGVjdG9ycywgbi5leHByW1xcXCI6XFxcIl0gPSBuLmV4cHIucHNldWRvcywgbi51bmlxdWVTb3J0ID0gbi51bmlxdWUgPSB0LnVuaXF1ZVNvcnQsIG4udGV4dCA9IHQuZ2V0VGV4dCwgbi5pc1hNTERvYyA9IHQuaXNYTUwsIG4uY29udGFpbnMgPSB0LmNvbnRhaW5zO3ZhciB1ID0gZnVuY3Rpb24gdShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gW10sXFxuICAgICAgICBlID0gdm9pZCAwICE9PSBjO3doaWxlICgoYSA9IGFbYl0pICYmIDkgIT09IGEubm9kZVR5cGUpIHtcXG4gICAgICBpZiAoMSA9PT0gYS5ub2RlVHlwZSkge1xcbiAgICAgICAgaWYgKGUgJiYgbihhKS5pcyhjKSkgYnJlYWs7ZC5wdXNoKGEpO1xcbiAgICAgIH1cXG4gICAgfXJldHVybiBkO1xcbiAgfSxcXG4gICAgICB2ID0gZnVuY3Rpb24gdihhLCBiKSB7XFxuICAgIGZvciAodmFyIGMgPSBbXTsgYTsgYSA9IGEubmV4dFNpYmxpbmcpIHtcXG4gICAgICAxID09PSBhLm5vZGVUeXBlICYmIGEgIT09IGIgJiYgYy5wdXNoKGEpO1xcbiAgICB9cmV0dXJuIGM7XFxuICB9LFxcbiAgICAgIHcgPSBuLmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LFxcbiAgICAgIHggPSAvXjwoW1xcXFx3LV0rKVxcXFxzKlxcXFwvPz4oPzo8XFxcXC9cXFxcMT58KSQvLFxcbiAgICAgIHkgPSAvXi5bXjojXFxcXFtcXFxcLixdKiQvO2Z1bmN0aW9uIHooYSwgYiwgYykge1xcbiAgICBpZiAobi5pc0Z1bmN0aW9uKGIpKSByZXR1cm4gbi5ncmVwKGEsIGZ1bmN0aW9uIChhLCBkKSB7XFxuICAgICAgcmV0dXJuICEhYi5jYWxsKGEsIGQsIGEpICE9PSBjO1xcbiAgICB9KTtpZiAoYi5ub2RlVHlwZSkgcmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBhID09PSBiICE9PSBjO1xcbiAgICB9KTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGIpIHtcXG4gICAgICBpZiAoeS50ZXN0KGIpKSByZXR1cm4gbi5maWx0ZXIoYiwgYSwgYyk7YiA9IG4uZmlsdGVyKGIsIGEpO1xcbiAgICB9cmV0dXJuIG4uZ3JlcChhLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBoLmNhbGwoYiwgYSkgPiAtMSAhPT0gYztcXG4gICAgfSk7XFxuICB9bi5maWx0ZXIgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZCA9IGJbMF07cmV0dXJuIGMgJiYgKGEgPSBcXFwiOm5vdChcXFwiICsgYSArIFxcXCIpXFxcIiksIDEgPT09IGIubGVuZ3RoICYmIDEgPT09IGQubm9kZVR5cGUgPyBuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGQsIGEpID8gW2RdIDogW10gOiBuLmZpbmQubWF0Y2hlcyhhLCBuLmdyZXAoYiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYS5ub2RlVHlwZTtcXG4gICAgfSkpO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmaW5kOiBmdW5jdGlvbiBmaW5kKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyA9IHRoaXMubGVuZ3RoLFxcbiAgICAgICAgICBkID0gW10sXFxuICAgICAgICAgIGUgPSB0aGlzO2lmIChcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgYSkgcmV0dXJuIHRoaXMucHVzaFN0YWNrKG4oYSkuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGZvciAoYiA9IDA7IGMgPiBiOyBiKyspIHtcXG4gICAgICAgICAgaWYgKG4uY29udGFpbnMoZVtiXSwgdGhpcykpIHJldHVybiAhMDtcXG4gICAgICAgIH1cXG4gICAgICB9KSk7Zm9yIChiID0gMDsgYyA+IGI7IGIrKykge1xcbiAgICAgICAgbi5maW5kKGEsIGVbYl0sIGQpO1xcbiAgICAgIH1yZXR1cm4gZCA9IHRoaXMucHVzaFN0YWNrKGMgPiAxID8gbi51bmlxdWUoZCkgOiBkKSwgZC5zZWxlY3RvciA9IHRoaXMuc2VsZWN0b3IgPyB0aGlzLnNlbGVjdG9yICsgXFxcIiBcXFwiICsgYSA6IGEsIGQ7XFxuICAgIH0sIGZpbHRlcjogZnVuY3Rpb24gZmlsdGVyKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wdXNoU3RhY2soeih0aGlzLCBhIHx8IFtdLCAhMSkpO1xcbiAgICB9LCBub3Q6IGZ1bmN0aW9uIG5vdChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucHVzaFN0YWNrKHoodGhpcywgYSB8fCBbXSwgITApKTtcXG4gICAgfSwgaXM6IGZ1bmN0aW9uIGlzKGEpIHtcXG4gICAgICByZXR1cm4gISF6KHRoaXMsIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmIHcudGVzdChhKSA/IG4oYSkgOiBhIHx8IFtdLCAhMSkubGVuZ3RoO1xcbiAgICB9IH0pO3ZhciBBLFxcbiAgICAgIEIgPSAvXig/OlxcXFxzKig8W1xcXFx3XFxcXFddKz4pW14+XSp8IyhbXFxcXHctXSopKSQvLFxcbiAgICAgIEMgPSBuLmZuLmluaXQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICB2YXIgZSwgZjtpZiAoIWEpIHJldHVybiB0aGlzO2lmIChjID0gYyB8fCBBLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSkge1xcbiAgICAgIGlmIChlID0gXFxcIjxcXFwiID09PSBhWzBdICYmIFxcXCI+XFxcIiA9PT0gYVthLmxlbmd0aCAtIDFdICYmIGEubGVuZ3RoID49IDMgPyBbbnVsbCwgYSwgbnVsbF0gOiBCLmV4ZWMoYSksICFlIHx8ICFlWzFdICYmIGIpIHJldHVybiAhYiB8fCBiLmpxdWVyeSA/IChiIHx8IGMpLmZpbmQoYSkgOiB0aGlzLmNvbnN0cnVjdG9yKGIpLmZpbmQoYSk7aWYgKGVbMV0pIHtcXG4gICAgICAgIGlmIChiID0gYiBpbnN0YW5jZW9mIG4gPyBiWzBdIDogYiwgbi5tZXJnZSh0aGlzLCBuLnBhcnNlSFRNTChlWzFdLCBiICYmIGIubm9kZVR5cGUgPyBiLm93bmVyRG9jdW1lbnQgfHwgYiA6IGQsICEwKSksIHgudGVzdChlWzFdKSAmJiBuLmlzUGxhaW5PYmplY3QoYikpIGZvciAoZSBpbiBiKSB7XFxuICAgICAgICAgIG4uaXNGdW5jdGlvbih0aGlzW2VdKSA/IHRoaXNbZV0oYltlXSkgOiB0aGlzLmF0dHIoZSwgYltlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiBmID0gZC5nZXRFbGVtZW50QnlJZChlWzJdKSwgZiAmJiBmLnBhcmVudE5vZGUgJiYgKHRoaXMubGVuZ3RoID0gMSwgdGhpc1swXSA9IGYpLCB0aGlzLmNvbnRleHQgPSBkLCB0aGlzLnNlbGVjdG9yID0gYSwgdGhpcztcXG4gICAgfXJldHVybiBhLm5vZGVUeXBlID8gKHRoaXMuY29udGV4dCA9IHRoaXNbMF0gPSBhLCB0aGlzLmxlbmd0aCA9IDEsIHRoaXMpIDogbi5pc0Z1bmN0aW9uKGEpID8gdm9pZCAwICE9PSBjLnJlYWR5ID8gYy5yZWFkeShhKSA6IGEobikgOiAodm9pZCAwICE9PSBhLnNlbGVjdG9yICYmICh0aGlzLnNlbGVjdG9yID0gYS5zZWxlY3RvciwgdGhpcy5jb250ZXh0ID0gYS5jb250ZXh0KSwgbi5tYWtlQXJyYXkoYSwgdGhpcykpO1xcbiAgfTtDLnByb3RvdHlwZSA9IG4uZm4sIEEgPSBuKGQpO3ZhciBEID0gL14oPzpwYXJlbnRzfHByZXYoPzpVbnRpbHxBbGwpKS8sXFxuICAgICAgRSA9IHsgY2hpbGRyZW46ICEwLCBjb250ZW50czogITAsIG5leHQ6ICEwLCBwcmV2OiAhMCB9O24uZm4uZXh0ZW5kKHsgaGFzOiBmdW5jdGlvbiBoYXMoYSkge1xcbiAgICAgIHZhciBiID0gbihhLCB0aGlzKSxcXG4gICAgICAgICAgYyA9IGIubGVuZ3RoO3JldHVybiB0aGlzLmZpbHRlcihmdW5jdGlvbiAoKSB7XFxuICAgICAgICBmb3IgKHZhciBhID0gMDsgYyA+IGE7IGErKykge1xcbiAgICAgICAgICBpZiAobi5jb250YWlucyh0aGlzLCBiW2FdKSkgcmV0dXJuICEwO1xcbiAgICAgICAgfVxcbiAgICAgIH0pO1xcbiAgICB9LCBjbG9zZXN0OiBmdW5jdGlvbiBjbG9zZXN0KGEsIGIpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gMCwgZSA9IHRoaXMubGVuZ3RoLCBmID0gW10sIGcgPSB3LnRlc3QoYSkgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgPyBuKGEsIGIgfHwgdGhpcy5jb250ZXh0KSA6IDA7IGUgPiBkOyBkKyspIHtcXG4gICAgICAgIGZvciAoYyA9IHRoaXNbZF07IGMgJiYgYyAhPT0gYjsgYyA9IGMucGFyZW50Tm9kZSkge1xcbiAgICAgICAgICBpZiAoYy5ub2RlVHlwZSA8IDExICYmIChnID8gZy5pbmRleChjKSA+IC0xIDogMSA9PT0gYy5ub2RlVHlwZSAmJiBuLmZpbmQubWF0Y2hlc1NlbGVjdG9yKGMsIGEpKSkge1xcbiAgICAgICAgICAgIGYucHVzaChjKTticmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZi5sZW5ndGggPiAxID8gbi51bmlxdWVTb3J0KGYpIDogZik7XFxuICAgIH0sIGluZGV4OiBmdW5jdGlvbiBpbmRleChhKSB7XFxuICAgICAgcmV0dXJuIGEgPyBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSA/IGguY2FsbChuKGEpLCB0aGlzWzBdKSA6IGguY2FsbCh0aGlzLCBhLmpxdWVyeSA/IGFbMF0gOiBhKSA6IHRoaXNbMF0gJiYgdGhpc1swXS5wYXJlbnROb2RlID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcXG4gICAgfSwgYWRkOiBmdW5jdGlvbiBhZGQoYSwgYikge1xcbiAgICAgIHJldHVybiB0aGlzLnB1c2hTdGFjayhuLnVuaXF1ZVNvcnQobi5tZXJnZSh0aGlzLmdldCgpLCBuKGEsIGIpKSkpO1xcbiAgICB9LCBhZGRCYWNrOiBmdW5jdGlvbiBhZGRCYWNrKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5hZGQobnVsbCA9PSBhID8gdGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlcihhKSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gRihhLCBiKSB7XFxuICAgIHdoaWxlICgoYSA9IGFbYl0pICYmIDEgIT09IGEubm9kZVR5cGUpIHt9cmV0dXJuIGE7XFxuICB9bi5lYWNoKHsgcGFyZW50OiBmdW5jdGlvbiBwYXJlbnQoYSkge1xcbiAgICAgIHZhciBiID0gYS5wYXJlbnROb2RlO3JldHVybiBiICYmIDExICE9PSBiLm5vZGVUeXBlID8gYiA6IG51bGw7XFxuICAgIH0sIHBhcmVudHM6IGZ1bmN0aW9uIHBhcmVudHMoYSkge1xcbiAgICAgIHJldHVybiB1KGEsIFxcXCJwYXJlbnROb2RlXFxcIik7XFxuICAgIH0sIHBhcmVudHNVbnRpbDogZnVuY3Rpb24gcGFyZW50c1VudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicGFyZW50Tm9kZVxcXCIsIGMpO1xcbiAgICB9LCBuZXh0OiBmdW5jdGlvbiBuZXh0KGEpIHtcXG4gICAgICByZXR1cm4gRihhLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSwgcHJldjogZnVuY3Rpb24gcHJldihhKSB7XFxuICAgICAgcmV0dXJuIEYoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LCBuZXh0QWxsOiBmdW5jdGlvbiBuZXh0QWxsKGEpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwibmV4dFNpYmxpbmdcXFwiKTtcXG4gICAgfSwgcHJldkFsbDogZnVuY3Rpb24gcHJldkFsbChhKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcInByZXZpb3VzU2libGluZ1xcXCIpO1xcbiAgICB9LCBuZXh0VW50aWw6IGZ1bmN0aW9uIG5leHRVbnRpbChhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIHUoYSwgXFxcIm5leHRTaWJsaW5nXFxcIiwgYyk7XFxuICAgIH0sIHByZXZVbnRpbDogZnVuY3Rpb24gcHJldlVudGlsKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gdShhLCBcXFwicHJldmlvdXNTaWJsaW5nXFxcIiwgYyk7XFxuICAgIH0sIHNpYmxpbmdzOiBmdW5jdGlvbiBzaWJsaW5ncyhhKSB7XFxuICAgICAgcmV0dXJuIHYoKGEucGFyZW50Tm9kZSB8fCB7fSkuZmlyc3RDaGlsZCwgYSk7XFxuICAgIH0sIGNoaWxkcmVuOiBmdW5jdGlvbiBjaGlsZHJlbihhKSB7XFxuICAgICAgcmV0dXJuIHYoYS5maXJzdENoaWxkKTtcXG4gICAgfSwgY29udGVudHM6IGZ1bmN0aW9uIGNvbnRlbnRzKGEpIHtcXG4gICAgICByZXR1cm4gYS5jb250ZW50RG9jdW1lbnQgfHwgbi5tZXJnZShbXSwgYS5jaGlsZE5vZGVzKTtcXG4gICAgfSB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICB2YXIgZSA9IG4ubWFwKHRoaXMsIGIsIGMpO3JldHVybiBcXFwiVW50aWxcXFwiICE9PSBhLnNsaWNlKC01KSAmJiAoZCA9IGMpLCBkICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBkICYmIChlID0gbi5maWx0ZXIoZCwgZSkpLCB0aGlzLmxlbmd0aCA+IDEgJiYgKEVbYV0gfHwgbi51bmlxdWVTb3J0KGUpLCBELnRlc3QoYSkgJiYgZS5yZXZlcnNlKCkpLCB0aGlzLnB1c2hTdGFjayhlKTtcXG4gICAgfTtcXG4gIH0pO3ZhciBHID0gL1xcXFxTKy9nO2Z1bmN0aW9uIEgoYSkge1xcbiAgICB2YXIgYiA9IHt9O3JldHVybiBuLmVhY2goYS5tYXRjaChHKSB8fCBbXSwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICBiW2NdID0gITA7XFxuICAgIH0pLCBiO1xcbiAgfW4uQ2FsbGJhY2tzID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgYSA9IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhID8gSChhKSA6IG4uZXh0ZW5kKHt9LCBhKTt2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYgPSBbXSxcXG4gICAgICAgIGcgPSBbXSxcXG4gICAgICAgIGggPSAtMSxcXG4gICAgICAgIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgIGZvciAoZSA9IGEub25jZSwgZCA9IGIgPSAhMDsgZy5sZW5ndGg7IGggPSAtMSkge1xcbiAgICAgICAgYyA9IGcuc2hpZnQoKTt3aGlsZSAoKytoIDwgZi5sZW5ndGgpIHtcXG4gICAgICAgICAgZltoXS5hcHBseShjWzBdLCBjWzFdKSA9PT0gITEgJiYgYS5zdG9wT25GYWxzZSAmJiAoaCA9IGYubGVuZ3RoLCBjID0gITEpO1xcbiAgICAgICAgfVxcbiAgICAgIH1hLm1lbW9yeSB8fCAoYyA9ICExKSwgYiA9ICExLCBlICYmIChmID0gYyA/IFtdIDogXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICAgICAgaiA9IHsgYWRkOiBmdW5jdGlvbiBhZGQoKSB7XFxuICAgICAgICByZXR1cm4gZiAmJiAoYyAmJiAhYiAmJiAoaCA9IGYubGVuZ3RoIC0gMSwgZy5wdXNoKGMpKSwgZnVuY3Rpb24gZChiKSB7XFxuICAgICAgICAgIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgYykge1xcbiAgICAgICAgICAgIG4uaXNGdW5jdGlvbihjKSA/IGEudW5pcXVlICYmIGouaGFzKGMpIHx8IGYucHVzaChjKSA6IGMgJiYgYy5sZW5ndGggJiYgXFxcInN0cmluZ1xcXCIgIT09IG4udHlwZShjKSAmJiBkKGMpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH0oYXJndW1lbnRzKSwgYyAmJiAhYiAmJiBpKCkpLCB0aGlzO1xcbiAgICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xcbiAgICAgICAgcmV0dXJuIG4uZWFjaChhcmd1bWVudHMsIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjO3doaWxlICgoYyA9IG4uaW5BcnJheShiLCBmLCBjKSkgPiAtMSkge1xcbiAgICAgICAgICAgIGYuc3BsaWNlKGMsIDEpLCBoID49IGMgJiYgaC0tO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KSwgdGhpcztcXG4gICAgICB9LCBoYXM6IGZ1bmN0aW9uIGhhcyhhKSB7XFxuICAgICAgICByZXR1cm4gYSA/IG4uaW5BcnJheShhLCBmKSA+IC0xIDogZi5sZW5ndGggPiAwO1xcbiAgICAgIH0sIGVtcHR5OiBmdW5jdGlvbiBlbXB0eSgpIHtcXG4gICAgICAgIHJldHVybiBmICYmIChmID0gW10pLCB0aGlzO1xcbiAgICAgIH0sIGRpc2FibGU6IGZ1bmN0aW9uIGRpc2FibGUoKSB7XFxuICAgICAgICByZXR1cm4gZSA9IGcgPSBbXSwgZiA9IGMgPSBcXFwiXFxcIiwgdGhpcztcXG4gICAgICB9LCBkaXNhYmxlZDogZnVuY3Rpb24gZGlzYWJsZWQoKSB7XFxuICAgICAgICByZXR1cm4gIWY7XFxuICAgICAgfSwgbG9jazogZnVuY3Rpb24gbG9jaygpIHtcXG4gICAgICAgIHJldHVybiBlID0gZyA9IFtdLCBjIHx8IChmID0gYyA9IFxcXCJcXFwiKSwgdGhpcztcXG4gICAgICB9LCBsb2NrZWQ6IGZ1bmN0aW9uIGxvY2tlZCgpIHtcXG4gICAgICAgIHJldHVybiAhIWU7XFxuICAgICAgfSwgZmlyZVdpdGg6IGZ1bmN0aW9uIGZpcmVXaXRoKGEsIGMpIHtcXG4gICAgICAgIHJldHVybiBlIHx8IChjID0gYyB8fCBbXSwgYyA9IFthLCBjLnNsaWNlID8gYy5zbGljZSgpIDogY10sIGcucHVzaChjKSwgYiB8fCBpKCkpLCB0aGlzO1xcbiAgICAgIH0sIGZpcmU6IGZ1bmN0aW9uIGZpcmUoKSB7XFxuICAgICAgICByZXR1cm4gai5maXJlV2l0aCh0aGlzLCBhcmd1bWVudHMpLCB0aGlzO1xcbiAgICAgIH0sIGZpcmVkOiBmdW5jdGlvbiBmaXJlZCgpIHtcXG4gICAgICAgIHJldHVybiAhIWQ7XFxuICAgICAgfSB9O3JldHVybiBqO1xcbiAgfSwgbi5leHRlbmQoeyBEZWZlcnJlZDogZnVuY3Rpb24gRGVmZXJyZWQoYSkge1xcbiAgICAgIHZhciBiID0gW1tcXFwicmVzb2x2ZVxcXCIsIFxcXCJkb25lXFxcIiwgbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZXNvbHZlZFxcXCJdLCBbXFxcInJlamVjdFxcXCIsIFxcXCJmYWlsXFxcIiwgbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIiksIFxcXCJyZWplY3RlZFxcXCJdLCBbXFxcIm5vdGlmeVxcXCIsIFxcXCJwcm9ncmVzc1xcXCIsIG4uQ2FsbGJhY2tzKFxcXCJtZW1vcnlcXFwiKV1dLFxcbiAgICAgICAgICBjID0gXFxcInBlbmRpbmdcXFwiLFxcbiAgICAgICAgICBkID0geyBzdGF0ZTogZnVuY3Rpb24gc3RhdGUoKSB7XFxuICAgICAgICAgIHJldHVybiBjO1xcbiAgICAgICAgfSwgYWx3YXlzOiBmdW5jdGlvbiBhbHdheXMoKSB7XFxuICAgICAgICAgIHJldHVybiBlLmRvbmUoYXJndW1lbnRzKS5mYWlsKGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgICB9LCB0aGVuOiBmdW5jdGlvbiB0aGVuKCkge1xcbiAgICAgICAgICB2YXIgYSA9IGFyZ3VtZW50cztyZXR1cm4gbi5EZWZlcnJlZChmdW5jdGlvbiAoYykge1xcbiAgICAgICAgICAgIG4uZWFjaChiLCBmdW5jdGlvbiAoYiwgZikge1xcbiAgICAgICAgICAgICAgdmFyIGcgPSBuLmlzRnVuY3Rpb24oYVtiXSkgJiYgYVtiXTtlW2ZbMV1dKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgdmFyIGEgPSBnICYmIGcuYXBwbHkodGhpcywgYXJndW1lbnRzKTthICYmIG4uaXNGdW5jdGlvbihhLnByb21pc2UpID8gYS5wcm9taXNlKCkucHJvZ3Jlc3MoYy5ub3RpZnkpLmRvbmUoYy5yZXNvbHZlKS5mYWlsKGMucmVqZWN0KSA6IGNbZlswXSArIFxcXCJXaXRoXFxcIl0odGhpcyA9PT0gZCA/IGMucHJvbWlzZSgpIDogdGhpcywgZyA/IFthXSA6IGFyZ3VtZW50cyk7XFxuICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICB9KSwgYSA9IG51bGw7XFxuICAgICAgICAgIH0pLnByb21pc2UoKTtcXG4gICAgICAgIH0sIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UoYSkge1xcbiAgICAgICAgICByZXR1cm4gbnVsbCAhPSBhID8gbi5leHRlbmQoYSwgZCkgOiBkO1xcbiAgICAgICAgfSB9LFxcbiAgICAgICAgICBlID0ge307cmV0dXJuIGQucGlwZSA9IGQudGhlbiwgbi5lYWNoKGIsIGZ1bmN0aW9uIChhLCBmKSB7XFxuICAgICAgICB2YXIgZyA9IGZbMl0sXFxuICAgICAgICAgICAgaCA9IGZbM107ZFtmWzFdXSA9IGcuYWRkLCBoICYmIGcuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgYyA9IGg7XFxuICAgICAgICB9LCBiWzEgXiBhXVsyXS5kaXNhYmxlLCBiWzJdWzJdLmxvY2spLCBlW2ZbMF1dID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gZVtmWzBdICsgXFxcIldpdGhcXFwiXSh0aGlzID09PSBlID8gZCA6IHRoaXMsIGFyZ3VtZW50cyksIHRoaXM7XFxuICAgICAgICB9LCBlW2ZbMF0gKyBcXFwiV2l0aFxcXCJdID0gZy5maXJlV2l0aDtcXG4gICAgICB9KSwgZC5wcm9taXNlKGUpLCBhICYmIGEuY2FsbChlLCBlKSwgZTtcXG4gICAgfSwgd2hlbjogZnVuY3Rpb24gd2hlbihhKSB7XFxuICAgICAgdmFyIGIgPSAwLFxcbiAgICAgICAgICBjID0gZS5jYWxsKGFyZ3VtZW50cyksXFxuICAgICAgICAgIGQgPSBjLmxlbmd0aCxcXG4gICAgICAgICAgZiA9IDEgIT09IGQgfHwgYSAmJiBuLmlzRnVuY3Rpb24oYS5wcm9taXNlKSA/IGQgOiAwLFxcbiAgICAgICAgICBnID0gMSA9PT0gZiA/IGEgOiBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIGggPSBmdW5jdGlvbiBoKGEsIGIsIGMpIHtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoZCkge1xcbiAgICAgICAgICBiW2FdID0gdGhpcywgY1thXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gZS5jYWxsKGFyZ3VtZW50cykgOiBkLCBjID09PSBpID8gZy5ub3RpZnlXaXRoKGIsIGMpIDogLS1mIHx8IGcucmVzb2x2ZVdpdGgoYiwgYyk7XFxuICAgICAgICB9O1xcbiAgICAgIH0sXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGs7aWYgKGQgPiAxKSBmb3IgKGkgPSBuZXcgQXJyYXkoZCksIGogPSBuZXcgQXJyYXkoZCksIGsgPSBuZXcgQXJyYXkoZCk7IGQgPiBiOyBiKyspIHtcXG4gICAgICAgIGNbYl0gJiYgbi5pc0Z1bmN0aW9uKGNbYl0ucHJvbWlzZSkgPyBjW2JdLnByb21pc2UoKS5wcm9ncmVzcyhoKGIsIGosIGkpKS5kb25lKGgoYiwgaywgYykpLmZhaWwoZy5yZWplY3QpIDogLS1mO1xcbiAgICAgIH1yZXR1cm4gZiB8fCBnLnJlc29sdmVXaXRoKGssIGMpLCBnLnByb21pc2UoKTtcXG4gICAgfSB9KTt2YXIgSTtuLmZuLnJlYWR5ID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIG4ucmVhZHkucHJvbWlzZSgpLmRvbmUoYSksIHRoaXM7XFxuICB9LCBuLmV4dGVuZCh7IGlzUmVhZHk6ICExLCByZWFkeVdhaXQ6IDEsIGhvbGRSZWFkeTogZnVuY3Rpb24gaG9sZFJlYWR5KGEpIHtcXG4gICAgICBhID8gbi5yZWFkeVdhaXQrKyA6IG4ucmVhZHkoITApO1xcbiAgICB9LCByZWFkeTogZnVuY3Rpb24gcmVhZHkoYSkge1xcbiAgICAgIChhID09PSAhMCA/IC0tbi5yZWFkeVdhaXQgOiBuLmlzUmVhZHkpIHx8IChuLmlzUmVhZHkgPSAhMCwgYSAhPT0gITAgJiYgLS1uLnJlYWR5V2FpdCA+IDAgfHwgKEkucmVzb2x2ZVdpdGgoZCwgW25dKSwgbi5mbi50cmlnZ2VySGFuZGxlciAmJiAobihkKS50cmlnZ2VySGFuZGxlcihcXFwicmVhZHlcXFwiKSwgbihkKS5vZmYoXFxcInJlYWR5XFxcIikpKSk7XFxuICAgIH0gfSk7ZnVuY3Rpb24gSigpIHtcXG4gICAgZC5yZW1vdmVFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgSiksIGEucmVtb3ZlRXZlbnRMaXN0ZW5lcihcXFwibG9hZFxcXCIsIEopLCBuLnJlYWR5KCk7XFxuICB9bi5yZWFkeS5wcm9taXNlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgcmV0dXJuIEkgfHwgKEkgPSBuLkRlZmVycmVkKCksIFxcXCJjb21wbGV0ZVxcXCIgPT09IGQucmVhZHlTdGF0ZSB8fCBcXFwibG9hZGluZ1xcXCIgIT09IGQucmVhZHlTdGF0ZSAmJiAhZC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgPyBhLnNldFRpbWVvdXQobi5yZWFkeSkgOiAoZC5hZGRFdmVudExpc3RlbmVyKFxcXCJET01Db250ZW50TG9hZGVkXFxcIiwgSiksIGEuYWRkRXZlbnRMaXN0ZW5lcihcXFwibG9hZFxcXCIsIEopKSksIEkucHJvbWlzZShiKTtcXG4gIH0sIG4ucmVhZHkucHJvbWlzZSgpO3ZhciBLID0gZnVuY3Rpb24gSyhhLCBiLCBjLCBkLCBlLCBmLCBnKSB7XFxuICAgIHZhciBoID0gMCxcXG4gICAgICAgIGkgPSBhLmxlbmd0aCxcXG4gICAgICAgIGogPSBudWxsID09IGM7aWYgKFxcXCJvYmplY3RcXFwiID09PSBuLnR5cGUoYykpIHtcXG4gICAgICBlID0gITA7Zm9yIChoIGluIGMpIHtcXG4gICAgICAgIEsoYSwgYiwgaCwgY1toXSwgITAsIGYsIGcpO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICh2b2lkIDAgIT09IGQgJiYgKGUgPSAhMCwgbi5pc0Z1bmN0aW9uKGQpIHx8IChnID0gITApLCBqICYmIChnID8gKGIuY2FsbChhLCBkKSwgYiA9IG51bGwpIDogKGogPSBiLCBiID0gZnVuY3Rpb24gYihhLCBfYiwgYykge1xcbiAgICAgIHJldHVybiBqLmNhbGwobihhKSwgYyk7XFxuICAgIH0pKSwgYikpIGZvciAoOyBpID4gaDsgaCsrKSB7XFxuICAgICAgYihhW2hdLCBjLCBnID8gZCA6IGQuY2FsbChhW2hdLCBoLCBiKGFbaF0sIGMpKSk7XFxuICAgIH1yZXR1cm4gZSA/IGEgOiBqID8gYi5jYWxsKGEpIDogaSA/IGIoYVswXSwgYykgOiBmO1xcbiAgfSxcXG4gICAgICBMID0gZnVuY3Rpb24gTChhKSB7XFxuICAgIHJldHVybiAxID09PSBhLm5vZGVUeXBlIHx8IDkgPT09IGEubm9kZVR5cGUgfHwgISthLm5vZGVUeXBlO1xcbiAgfTtmdW5jdGlvbiBNKCkge1xcbiAgICB0aGlzLmV4cGFuZG8gPSBuLmV4cGFuZG8gKyBNLnVpZCsrO1xcbiAgfU0udWlkID0gMSwgTS5wcm90b3R5cGUgPSB7IHJlZ2lzdGVyOiBmdW5jdGlvbiByZWdpc3RlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSBiIHx8IHt9O3JldHVybiBhLm5vZGVUeXBlID8gYVt0aGlzLmV4cGFuZG9dID0gYyA6IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhLCB0aGlzLmV4cGFuZG8sIHsgdmFsdWU6IGMsIHdyaXRhYmxlOiAhMCwgY29uZmlndXJhYmxlOiAhMCB9KSwgYVt0aGlzLmV4cGFuZG9dO1xcbiAgICB9LCBjYWNoZTogZnVuY3Rpb24gY2FjaGUoYSkge1xcbiAgICAgIGlmICghTChhKSkgcmV0dXJuIHt9O3ZhciBiID0gYVt0aGlzLmV4cGFuZG9dO3JldHVybiBiIHx8IChiID0ge30sIEwoYSkgJiYgKGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSBiIDogT2JqZWN0LmRlZmluZVByb3BlcnR5KGEsIHRoaXMuZXhwYW5kbywgeyB2YWx1ZTogYiwgY29uZmlndXJhYmxlOiAhMCB9KSkpLCBiO1xcbiAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUgPSB0aGlzLmNhY2hlKGEpO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYikgZVtiXSA9IGM7ZWxzZSBmb3IgKGQgaW4gYikge1xcbiAgICAgICAgZVtkXSA9IGJbZF07XFxuICAgICAgfXJldHVybiBlO1xcbiAgICB9LCBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHZvaWQgMCA9PT0gYiA/IHRoaXMuY2FjaGUoYSkgOiBhW3RoaXMuZXhwYW5kb10gJiYgYVt0aGlzLmV4cGFuZG9dW2JdO1xcbiAgICB9LCBhY2Nlc3M6IGZ1bmN0aW9uIGFjY2VzcyhhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQ7cmV0dXJuIHZvaWQgMCA9PT0gYiB8fCBiICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiICYmIHZvaWQgMCA9PT0gYyA/IChkID0gdGhpcy5nZXQoYSwgYiksIHZvaWQgMCAhPT0gZCA/IGQgOiB0aGlzLmdldChhLCBuLmNhbWVsQ2FzZShiKSkpIDogKHRoaXMuc2V0KGEsIGIsIGMpLCB2b2lkIDAgIT09IGMgPyBjIDogYik7XFxuICAgIH0sIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZiA9IGFbdGhpcy5leHBhbmRvXTtpZiAodm9pZCAwICE9PSBmKSB7XFxuICAgICAgICBpZiAodm9pZCAwID09PSBiKSB0aGlzLnJlZ2lzdGVyKGEpO2Vsc2Uge1xcbiAgICAgICAgICBuLmlzQXJyYXkoYikgPyBkID0gYi5jb25jYXQoYi5tYXAobi5jYW1lbENhc2UpKSA6IChlID0gbi5jYW1lbENhc2UoYiksIGIgaW4gZiA/IGQgPSBbYiwgZV0gOiAoZCA9IGUsIGQgPSBkIGluIGYgPyBbZF0gOiBkLm1hdGNoKEcpIHx8IFtdKSksIGMgPSBkLmxlbmd0aDt3aGlsZSAoYy0tKSB7XFxuICAgICAgICAgICAgZGVsZXRlIGZbZFtjXV07XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0odm9pZCAwID09PSBiIHx8IG4uaXNFbXB0eU9iamVjdChmKSkgJiYgKGEubm9kZVR5cGUgPyBhW3RoaXMuZXhwYW5kb10gPSB2b2lkIDAgOiBkZWxldGUgYVt0aGlzLmV4cGFuZG9dKTtcXG4gICAgICB9XFxuICAgIH0sIGhhc0RhdGE6IGZ1bmN0aW9uIGhhc0RhdGEoYSkge1xcbiAgICAgIHZhciBiID0gYVt0aGlzLmV4cGFuZG9dO3JldHVybiB2b2lkIDAgIT09IGIgJiYgIW4uaXNFbXB0eU9iamVjdChiKTtcXG4gICAgfSB9O3ZhciBOID0gbmV3IE0oKSxcXG4gICAgICBPID0gbmV3IE0oKSxcXG4gICAgICBQID0gL14oPzpcXFxce1tcXFxcd1xcXFxXXSpcXFxcfXxcXFxcW1tcXFxcd1xcXFxXXSpcXFxcXSkkLyxcXG4gICAgICBRID0gL1tBLVpdL2c7ZnVuY3Rpb24gUihhLCBiLCBjKSB7XFxuICAgIHZhciBkO2lmICh2b2lkIDAgPT09IGMgJiYgMSA9PT0gYS5ub2RlVHlwZSkgaWYgKGQgPSBcXFwiZGF0YS1cXFwiICsgYi5yZXBsYWNlKFEsIFxcXCItJCZcXFwiKS50b0xvd2VyQ2FzZSgpLCBjID0gYS5nZXRBdHRyaWJ1dGUoZCksIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBjKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGMgPSBcXFwidHJ1ZVxcXCIgPT09IGMgPyAhMCA6IFxcXCJmYWxzZVxcXCIgPT09IGMgPyAhMSA6IFxcXCJudWxsXFxcIiA9PT0gYyA/IG51bGwgOiArYyArIFxcXCJcXFwiID09PSBjID8gK2MgOiBQLnRlc3QoYykgPyBuLnBhcnNlSlNPTihjKSA6IGM7XFxuICAgICAgfSBjYXRjaCAoZSkge31PLnNldChhLCBiLCBjKTtcXG4gICAgfSBlbHNlIGMgPSB2b2lkIDA7cmV0dXJuIGM7XFxuICB9bi5leHRlbmQoeyBoYXNEYXRhOiBmdW5jdGlvbiBoYXNEYXRhKGEpIHtcXG4gICAgICByZXR1cm4gTy5oYXNEYXRhKGEpIHx8IE4uaGFzRGF0YShhKTtcXG4gICAgfSwgZGF0YTogZnVuY3Rpb24gZGF0YShhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIE8uYWNjZXNzKGEsIGIsIGMpO1xcbiAgICB9LCByZW1vdmVEYXRhOiBmdW5jdGlvbiByZW1vdmVEYXRhKGEsIGIpIHtcXG4gICAgICBPLnJlbW92ZShhLCBiKTtcXG4gICAgfSwgX2RhdGE6IGZ1bmN0aW9uIF9kYXRhKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gTi5hY2Nlc3MoYSwgYiwgYyk7XFxuICAgIH0sIF9yZW1vdmVEYXRhOiBmdW5jdGlvbiBfcmVtb3ZlRGF0YShhLCBiKSB7XFxuICAgICAgTi5yZW1vdmUoYSwgYik7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgZGF0YTogZnVuY3Rpb24gZGF0YShhLCBiKSB7XFxuICAgICAgdmFyIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSB0aGlzWzBdLFxcbiAgICAgICAgICBnID0gZiAmJiBmLmF0dHJpYnV0ZXM7aWYgKHZvaWQgMCA9PT0gYSkge1xcbiAgICAgICAgaWYgKHRoaXMubGVuZ3RoICYmIChlID0gTy5nZXQoZiksIDEgPT09IGYubm9kZVR5cGUgJiYgIU4uZ2V0KGYsIFxcXCJoYXNEYXRhQXR0cnNcXFwiKSkpIHtcXG4gICAgICAgICAgYyA9IGcubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICAgICAgICBnW2NdICYmIChkID0gZ1tjXS5uYW1lLCAwID09PSBkLmluZGV4T2YoXFxcImRhdGEtXFxcIikgJiYgKGQgPSBuLmNhbWVsQ2FzZShkLnNsaWNlKDUpKSwgUihmLCBkLCBlW2RdKSkpO1xcbiAgICAgICAgICB9Ti5zZXQoZiwgXFxcImhhc0RhdGFBdHRyc1xcXCIsICEwKTtcXG4gICAgICAgIH1yZXR1cm4gZTtcXG4gICAgICB9cmV0dXJuIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYSkpID8gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIE8uc2V0KHRoaXMsIGEpO1xcbiAgICAgIH0pIDogSyh0aGlzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMsIGQ7aWYgKGYgJiYgdm9pZCAwID09PSBiKSB7XFxuICAgICAgICAgIGlmIChjID0gTy5nZXQoZiwgYSkgfHwgTy5nZXQoZiwgYS5yZXBsYWNlKFEsIFxcXCItJCZcXFwiKS50b0xvd2VyQ2FzZSgpKSwgdm9pZCAwICE9PSBjKSByZXR1cm4gYztpZiAoZCA9IG4uY2FtZWxDYXNlKGEpLCBjID0gTy5nZXQoZiwgZCksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7aWYgKGMgPSBSKGYsIGQsIHZvaWQgMCksIHZvaWQgMCAhPT0gYykgcmV0dXJuIGM7XFxuICAgICAgICB9IGVsc2UgZCA9IG4uY2FtZWxDYXNlKGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgYyA9IE8uZ2V0KHRoaXMsIGQpO08uc2V0KHRoaXMsIGQsIGIpLCBhLmluZGV4T2YoXFxcIi1cXFwiKSA+IC0xICYmIHZvaWQgMCAhPT0gYyAmJiBPLnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0sIG51bGwsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxLCBudWxsLCAhMCk7XFxuICAgIH0sIHJlbW92ZURhdGE6IGZ1bmN0aW9uIHJlbW92ZURhdGEoYSkge1xcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgTy5yZW1vdmUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgcXVldWU6IGZ1bmN0aW9uIHF1ZXVlKGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZDtyZXR1cm4gYSA/IChiID0gKGIgfHwgXFxcImZ4XFxcIikgKyBcXFwicXVldWVcXFwiLCBkID0gTi5nZXQoYSwgYiksIGMgJiYgKCFkIHx8IG4uaXNBcnJheShjKSA/IGQgPSBOLmFjY2VzcyhhLCBiLCBuLm1ha2VBcnJheShjKSkgOiBkLnB1c2goYykpLCBkIHx8IFtdKSA6IHZvaWQgMDtcXG4gICAgfSwgZGVxdWV1ZTogZnVuY3Rpb24gZGVxdWV1ZShhLCBiKSB7XFxuICAgICAgYiA9IGIgfHwgXFxcImZ4XFxcIjt2YXIgYyA9IG4ucXVldWUoYSwgYiksXFxuICAgICAgICAgIGQgPSBjLmxlbmd0aCxcXG4gICAgICAgICAgZSA9IGMuc2hpZnQoKSxcXG4gICAgICAgICAgZiA9IG4uX3F1ZXVlSG9va3MoYSwgYiksXFxuICAgICAgICAgIGcgPSBmdW5jdGlvbiBnKCkge1xcbiAgICAgICAgbi5kZXF1ZXVlKGEsIGIpO1xcbiAgICAgIH07XFxcImlucHJvZ3Jlc3NcXFwiID09PSBlICYmIChlID0gYy5zaGlmdCgpLCBkLS0pLCBlICYmIChcXFwiZnhcXFwiID09PSBiICYmIGMudW5zaGlmdChcXFwiaW5wcm9ncmVzc1xcXCIpLCBkZWxldGUgZi5zdG9wLCBlLmNhbGwoYSwgZywgZikpLCAhZCAmJiBmICYmIGYuZW1wdHkuZmlyZSgpO1xcbiAgICB9LCBfcXVldWVIb29rczogZnVuY3Rpb24gX3F1ZXVlSG9va3MoYSwgYikge1xcbiAgICAgIHZhciBjID0gYiArIFxcXCJxdWV1ZUhvb2tzXFxcIjtyZXR1cm4gTi5nZXQoYSwgYykgfHwgTi5hY2Nlc3MoYSwgYywgeyBlbXB0eTogbi5DYWxsYmFja3MoXFxcIm9uY2UgbWVtb3J5XFxcIikuYWRkKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgTi5yZW1vdmUoYSwgW2IgKyBcXFwicXVldWVcXFwiLCBjXSk7XFxuICAgICAgICB9KSB9KTtcXG4gICAgfSB9KSwgbi5mbi5leHRlbmQoeyBxdWV1ZTogZnVuY3Rpb24gcXVldWUoYSwgYikge1xcbiAgICAgIHZhciBjID0gMjtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGIgPSBhLCBhID0gXFxcImZ4XFxcIiwgYy0tKSwgYXJndW1lbnRzLmxlbmd0aCA8IGMgPyBuLnF1ZXVlKHRoaXNbMF0sIGEpIDogdm9pZCAwID09PSBiID8gdGhpcyA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYyA9IG4ucXVldWUodGhpcywgYSwgYik7bi5fcXVldWVIb29rcyh0aGlzLCBhKSwgXFxcImZ4XFxcIiA9PT0gYSAmJiBcXFwiaW5wcm9ncmVzc1xcXCIgIT09IGNbMF0gJiYgbi5kZXF1ZXVlKHRoaXMsIGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBkZXF1ZXVlOiBmdW5jdGlvbiBkZXF1ZXVlKGEpIHtcXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4uZGVxdWV1ZSh0aGlzLCBhKTtcXG4gICAgICB9KTtcXG4gICAgfSwgY2xlYXJRdWV1ZTogZnVuY3Rpb24gY2xlYXJRdWV1ZShhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMucXVldWUoYSB8fCBcXFwiZnhcXFwiLCBbXSk7XFxuICAgIH0sIHByb21pc2U6IGZ1bmN0aW9uIHByb21pc2UoYSwgYikge1xcbiAgICAgIHZhciBjLFxcbiAgICAgICAgICBkID0gMSxcXG4gICAgICAgICAgZSA9IG4uRGVmZXJyZWQoKSxcXG4gICAgICAgICAgZiA9IHRoaXMsXFxuICAgICAgICAgIGcgPSB0aGlzLmxlbmd0aCxcXG4gICAgICAgICAgaCA9IGZ1bmN0aW9uIGgoKSB7XFxuICAgICAgICAtLWQgfHwgZS5yZXNvbHZlV2l0aChmLCBbZl0pO1xcbiAgICAgIH07XFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGIgPSBhLCBhID0gdm9pZCAwKSwgYSA9IGEgfHwgXFxcImZ4XFxcIjt3aGlsZSAoZy0tKSB7XFxuICAgICAgICBjID0gTi5nZXQoZltnXSwgYSArIFxcXCJxdWV1ZUhvb2tzXFxcIiksIGMgJiYgYy5lbXB0eSAmJiAoZCsrLCBjLmVtcHR5LmFkZChoKSk7XFxuICAgICAgfXJldHVybiBoKCksIGUucHJvbWlzZShiKTtcXG4gICAgfSB9KTt2YXIgUyA9IC9bKy1dPyg/OlxcXFxkKlxcXFwufClcXFxcZCsoPzpbZUVdWystXT9cXFxcZCt8KS8uc291cmNlLFxcbiAgICAgIFQgPSBuZXcgUmVnRXhwKFxcXCJeKD86KFsrLV0pPXwpKFxcXCIgKyBTICsgXFxcIikoW2EteiVdKikkXFxcIiwgXFxcImlcXFwiKSxcXG4gICAgICBVID0gW1xcXCJUb3BcXFwiLCBcXFwiUmlnaHRcXFwiLCBcXFwiQm90dG9tXFxcIiwgXFxcIkxlZnRcXFwiXSxcXG4gICAgICBWID0gZnVuY3Rpb24gVihhLCBiKSB7XFxuICAgIHJldHVybiBhID0gYiB8fCBhLCBcXFwibm9uZVxcXCIgPT09IG4uY3NzKGEsIFxcXCJkaXNwbGF5XFxcIikgfHwgIW4uY29udGFpbnMoYS5vd25lckRvY3VtZW50LCBhKTtcXG4gIH07ZnVuY3Rpb24gVyhhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZiA9IDEsXFxuICAgICAgICBnID0gMjAsXFxuICAgICAgICBoID0gZCA/IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZC5jdXIoKTtcXG4gICAgfSA6IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gbi5jc3MoYSwgYiwgXFxcIlxcXCIpO1xcbiAgICB9LFxcbiAgICAgICAgaSA9IGgoKSxcXG4gICAgICAgIGogPSBjICYmIGNbM10gfHwgKG4uY3NzTnVtYmVyW2JdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSxcXG4gICAgICAgIGsgPSAobi5jc3NOdW1iZXJbYl0gfHwgXFxcInB4XFxcIiAhPT0gaiAmJiAraSkgJiYgVC5leGVjKG4uY3NzKGEsIGIpKTtpZiAoayAmJiBrWzNdICE9PSBqKSB7XFxuICAgICAgaiA9IGogfHwga1szXSwgYyA9IGMgfHwgW10sIGsgPSAraSB8fCAxO2RvIHtcXG4gICAgICAgIGYgPSBmIHx8IFxcXCIuNVxcXCIsIGsgLz0gZiwgbi5zdHlsZShhLCBiLCBrICsgaik7XFxuICAgICAgfSB3aGlsZSAoZiAhPT0gKGYgPSBoKCkgLyBpKSAmJiAxICE9PSBmICYmIC0tZyk7XFxuICAgIH1yZXR1cm4gYyAmJiAoayA9ICtrIHx8ICtpIHx8IDAsIGUgPSBjWzFdID8gayArIChjWzFdICsgMSkgKiBjWzJdIDogK2NbMl0sIGQgJiYgKGQudW5pdCA9IGosIGQuc3RhcnQgPSBrLCBkLmVuZCA9IGUpKSwgZTtcXG4gIH12YXIgWCA9IC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pLFxcbiAgICAgIFkgPSAvPChbXFxcXHc6LV0rKS8sXFxuICAgICAgWiA9IC9eJHxcXFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSxcXG4gICAgICAkID0geyBvcHRpb246IFsxLCBcXFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlxcXCIsIFxcXCI8L3NlbGVjdD5cXFwiXSwgdGhlYWQ6IFsxLCBcXFwiPHRhYmxlPlxcXCIsIFxcXCI8L3RhYmxlPlxcXCJdLCBjb2w6IFsyLCBcXFwiPHRhYmxlPjxjb2xncm91cD5cXFwiLCBcXFwiPC9jb2xncm91cD48L3RhYmxlPlxcXCJdLCB0cjogWzIsIFxcXCI8dGFibGU+PHRib2R5PlxcXCIsIFxcXCI8L3Rib2R5PjwvdGFibGU+XFxcIl0sIHRkOiBbMywgXFxcIjx0YWJsZT48dGJvZHk+PHRyPlxcXCIsIFxcXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cXFwiXSwgX2RlZmF1bHQ6IFswLCBcXFwiXFxcIiwgXFxcIlxcXCJdIH07JC5vcHRncm91cCA9ICQub3B0aW9uLCAkLnRib2R5ID0gJC50Zm9vdCA9ICQuY29sZ3JvdXAgPSAkLmNhcHRpb24gPSAkLnRoZWFkLCAkLnRoID0gJC50ZDtmdW5jdGlvbiBfKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgYS5nZXRFbGVtZW50c0J5VGFnTmFtZSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoYiB8fCBcXFwiKlxcXCIpIDogXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIGEucXVlcnlTZWxlY3RvckFsbCA/IGEucXVlcnlTZWxlY3RvckFsbChiIHx8IFxcXCIqXFxcIikgOiBbXTtyZXR1cm4gdm9pZCAwID09PSBiIHx8IGIgJiYgbi5ub2RlTmFtZShhLCBiKSA/IG4ubWVyZ2UoW2FdLCBjKSA6IGM7XFxuICB9ZnVuY3Rpb24gYWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjID0gMCwgZCA9IGEubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgTi5zZXQoYVtjXSwgXFxcImdsb2JhbEV2YWxcXFwiLCAhYiB8fCBOLmdldChiW2NdLCBcXFwiZ2xvYmFsRXZhbFxcXCIpKTtcXG4gICAgfVxcbiAgfXZhciBiYSA9IC88fCYjP1xcXFx3KzsvO2Z1bmN0aW9uIGNhKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgZm9yICh2YXIgZiwgZywgaCwgaSwgaiwgaywgbCA9IGIuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLCBtID0gW10sIG8gPSAwLCBwID0gYS5sZW5ndGg7IHAgPiBvOyBvKyspIHtcXG4gICAgICBpZiAoZiA9IGFbb10sIGYgfHwgMCA9PT0gZikgaWYgKFxcXCJvYmplY3RcXFwiID09PSBuLnR5cGUoZikpIG4ubWVyZ2UobSwgZi5ub2RlVHlwZSA/IFtmXSA6IGYpO2Vsc2UgaWYgKGJhLnRlc3QoZikpIHtcXG4gICAgICAgIGcgPSBnIHx8IGwuYXBwZW5kQ2hpbGQoYi5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSksIGggPSAoWS5leGVjKGYpIHx8IFtcXFwiXFxcIiwgXFxcIlxcXCJdKVsxXS50b0xvd2VyQ2FzZSgpLCBpID0gJFtoXSB8fCAkLl9kZWZhdWx0LCBnLmlubmVySFRNTCA9IGlbMV0gKyBuLmh0bWxQcmVmaWx0ZXIoZikgKyBpWzJdLCBrID0gaVswXTt3aGlsZSAoay0tKSB7XFxuICAgICAgICAgIGcgPSBnLmxhc3RDaGlsZDtcXG4gICAgICAgIH1uLm1lcmdlKG0sIGcuY2hpbGROb2RlcyksIGcgPSBsLmZpcnN0Q2hpbGQsIGcudGV4dENvbnRlbnQgPSBcXFwiXFxcIjtcXG4gICAgICB9IGVsc2UgbS5wdXNoKGIuY3JlYXRlVGV4dE5vZGUoZikpO1xcbiAgICB9bC50ZXh0Q29udGVudCA9IFxcXCJcXFwiLCBvID0gMDt3aGlsZSAoZiA9IG1bbysrXSkge1xcbiAgICAgIGlmIChkICYmIG4uaW5BcnJheShmLCBkKSA+IC0xKSBlICYmIGUucHVzaChmKTtlbHNlIGlmIChqID0gbi5jb250YWlucyhmLm93bmVyRG9jdW1lbnQsIGYpLCBnID0gXyhsLmFwcGVuZENoaWxkKGYpLCBcXFwic2NyaXB0XFxcIiksIGogJiYgYWEoZyksIGMpIHtcXG4gICAgICAgIGsgPSAwO3doaWxlIChmID0gZ1trKytdKSB7XFxuICAgICAgICAgIFoudGVzdChmLnR5cGUgfHwgXFxcIlxcXCIpICYmIGMucHVzaChmKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4gbDtcXG4gIH0hZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSA9IGQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxcbiAgICAgICAgYiA9IGEuYXBwZW5kQ2hpbGQoZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKSksXFxuICAgICAgICBjID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpO2Muc2V0QXR0cmlidXRlKFxcXCJ0eXBlXFxcIiwgXFxcInJhZGlvXFxcIiksIGMuc2V0QXR0cmlidXRlKFxcXCJjaGVja2VkXFxcIiwgXFxcImNoZWNrZWRcXFwiKSwgYy5zZXRBdHRyaWJ1dGUoXFxcIm5hbWVcXFwiLCBcXFwidFxcXCIpLCBiLmFwcGVuZENoaWxkKGMpLCBsLmNoZWNrQ2xvbmUgPSBiLmNsb25lTm9kZSghMCkuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuY2hlY2tlZCwgYi5pbm5lckhUTUwgPSBcXFwiPHRleHRhcmVhPng8L3RleHRhcmVhPlxcXCIsIGwubm9DbG9uZUNoZWNrZWQgPSAhIWIuY2xvbmVOb2RlKCEwKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xcbiAgfSgpO3ZhciBkYSA9IC9ea2V5LyxcXG4gICAgICBlYSA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcXG4gICAgICBmYSA9IC9eKFteLl0qKSg/OlxcXFwuKC4rKXwpLztmdW5jdGlvbiBnYSgpIHtcXG4gICAgcmV0dXJuICEwO1xcbiAgfWZ1bmN0aW9uIGhhKCkge1xcbiAgICByZXR1cm4gITE7XFxuICB9ZnVuY3Rpb24gaWEoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgcmV0dXJuIGQuYWN0aXZlRWxlbWVudDtcXG4gICAgfSBjYXRjaCAoYSkge31cXG4gIH1mdW5jdGlvbiBqYShhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgIHZhciBnLCBoO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGIgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGIpKSkge1xcbiAgICAgIFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBjICYmIChkID0gZCB8fCBjLCBjID0gdm9pZCAwKTtmb3IgKGggaW4gYikge1xcbiAgICAgICAgamEoYSwgaCwgYywgZCwgYltoXSwgZik7XFxuICAgICAgfXJldHVybiBhO1xcbiAgICB9aWYgKG51bGwgPT0gZCAmJiBudWxsID09IGUgPyAoZSA9IGMsIGQgPSBjID0gdm9pZCAwKSA6IG51bGwgPT0gZSAmJiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGMgPyAoZSA9IGQsIGQgPSB2b2lkIDApIDogKGUgPSBkLCBkID0gYywgYyA9IHZvaWQgMCkpLCBlID09PSAhMSkgZSA9IGhhO2Vsc2UgaWYgKCFlKSByZXR1cm4gYTtyZXR1cm4gMSA9PT0gZiAmJiAoZyA9IGUsIGUgPSBmdW5jdGlvbiBlKGEpIHtcXG4gICAgICByZXR1cm4gbigpLm9mZihhKSwgZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9LCBlLmd1aWQgPSBnLmd1aWQgfHwgKGcuZ3VpZCA9IG4uZ3VpZCsrKSksIGEuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgbi5ldmVudC5hZGQodGhpcywgYiwgZSwgZCwgYyk7XFxuICAgIH0pO1xcbiAgfW4uZXZlbnQgPSB7IGdsb2JhbDoge30sIGFkZDogZnVuY3Rpb24gYWRkKGEsIGIsIGMsIGQsIGUpIHtcXG4gICAgICB2YXIgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayxcXG4gICAgICAgICAgbCxcXG4gICAgICAgICAgbSxcXG4gICAgICAgICAgbyxcXG4gICAgICAgICAgcCxcXG4gICAgICAgICAgcSxcXG4gICAgICAgICAgciA9IE4uZ2V0KGEpO2lmIChyKSB7XFxuICAgICAgICBjLmhhbmRsZXIgJiYgKGYgPSBjLCBjID0gZi5oYW5kbGVyLCBlID0gZi5zZWxlY3RvciksIGMuZ3VpZCB8fCAoYy5ndWlkID0gbi5ndWlkKyspLCAoaSA9IHIuZXZlbnRzKSB8fCAoaSA9IHIuZXZlbnRzID0ge30pLCAoZyA9IHIuaGFuZGxlKSB8fCAoZyA9IHIuaGFuZGxlID0gZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiICE9IHR5cGVvZiBuICYmIG4uZXZlbnQudHJpZ2dlcmVkICE9PSBiLnR5cGUgPyBuLmV2ZW50LmRpc3BhdGNoLmFwcGx5KGEsIGFyZ3VtZW50cykgOiB2b2lkIDA7XFxuICAgICAgICB9KSwgYiA9IChiIHx8IFxcXCJcXFwiKS5tYXRjaChHKSB8fCBbXFxcIlxcXCJdLCBqID0gYi5sZW5ndGg7d2hpbGUgKGotLSkge1xcbiAgICAgICAgICBoID0gZmEuZXhlYyhiW2pdKSB8fCBbXSwgbyA9IHEgPSBoWzFdLCBwID0gKGhbMl0gfHwgXFxcIlxcXCIpLnNwbGl0KFxcXCIuXFxcIikuc29ydCgpLCBvICYmIChsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBvID0gKGUgPyBsLmRlbGVnYXRlVHlwZSA6IGwuYmluZFR5cGUpIHx8IG8sIGwgPSBuLmV2ZW50LnNwZWNpYWxbb10gfHwge30sIGsgPSBuLmV4dGVuZCh7IHR5cGU6IG8sIG9yaWdUeXBlOiBxLCBkYXRhOiBkLCBoYW5kbGVyOiBjLCBndWlkOiBjLmd1aWQsIHNlbGVjdG9yOiBlLCBuZWVkc0NvbnRleHQ6IGUgJiYgbi5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KGUpLCBuYW1lc3BhY2U6IHAuam9pbihcXFwiLlxcXCIpIH0sIGYpLCAobSA9IGlbb10pIHx8IChtID0gaVtvXSA9IFtdLCBtLmRlbGVnYXRlQ291bnQgPSAwLCBsLnNldHVwICYmIGwuc2V0dXAuY2FsbChhLCBkLCBwLCBnKSAhPT0gITEgfHwgYS5hZGRFdmVudExpc3RlbmVyICYmIGEuYWRkRXZlbnRMaXN0ZW5lcihvLCBnKSksIGwuYWRkICYmIChsLmFkZC5jYWxsKGEsIGspLCBrLmhhbmRsZXIuZ3VpZCB8fCAoay5oYW5kbGVyLmd1aWQgPSBjLmd1aWQpKSwgZSA/IG0uc3BsaWNlKG0uZGVsZWdhdGVDb3VudCsrLCAwLCBrKSA6IG0ucHVzaChrKSwgbi5ldmVudC5nbG9iYWxbb10gPSAhMCk7XFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9LCByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShhLCBiLCBjLCBkLCBlKSB7XFxuICAgICAgdmFyIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGgsXFxuICAgICAgICAgIGksXFxuICAgICAgICAgIGosXFxuICAgICAgICAgIGssXFxuICAgICAgICAgIGwsXFxuICAgICAgICAgIG0sXFxuICAgICAgICAgIG8sXFxuICAgICAgICAgIHAsXFxuICAgICAgICAgIHEsXFxuICAgICAgICAgIHIgPSBOLmhhc0RhdGEoYSkgJiYgTi5nZXQoYSk7aWYgKHIgJiYgKGkgPSByLmV2ZW50cykpIHtcXG4gICAgICAgIGIgPSAoYiB8fCBcXFwiXFxcIikubWF0Y2goRykgfHwgW1xcXCJcXFwiXSwgaiA9IGIubGVuZ3RoO3doaWxlIChqLS0pIHtcXG4gICAgICAgICAgaWYgKGggPSBmYS5leGVjKGJbal0pIHx8IFtdLCBvID0gcSA9IGhbMV0sIHAgPSAoaFsyXSB8fCBcXFwiXFxcIikuc3BsaXQoXFxcIi5cXFwiKS5zb3J0KCksIG8pIHtcXG4gICAgICAgICAgICBsID0gbi5ldmVudC5zcGVjaWFsW29dIHx8IHt9LCBvID0gKGQgPyBsLmRlbGVnYXRlVHlwZSA6IGwuYmluZFR5cGUpIHx8IG8sIG0gPSBpW29dIHx8IFtdLCBoID0gaFsyXSAmJiBuZXcgUmVnRXhwKFxcXCIoXnxcXFxcXFxcXC4pXFxcIiArIHAuam9pbihcXFwiXFxcXFxcXFwuKD86LipcXFxcXFxcXC58KVxcXCIpICsgXFxcIihcXFxcXFxcXC58JClcXFwiKSwgZyA9IGYgPSBtLmxlbmd0aDt3aGlsZSAoZi0tKSB7XFxuICAgICAgICAgICAgICBrID0gbVtmXSwgIWUgJiYgcSAhPT0gay5vcmlnVHlwZSB8fCBjICYmIGMuZ3VpZCAhPT0gay5ndWlkIHx8IGggJiYgIWgudGVzdChrLm5hbWVzcGFjZSkgfHwgZCAmJiBkICE9PSBrLnNlbGVjdG9yICYmIChcXFwiKipcXFwiICE9PSBkIHx8ICFrLnNlbGVjdG9yKSB8fCAobS5zcGxpY2UoZiwgMSksIGsuc2VsZWN0b3IgJiYgbS5kZWxlZ2F0ZUNvdW50LS0sIGwucmVtb3ZlICYmIGwucmVtb3ZlLmNhbGwoYSwgaykpO1xcbiAgICAgICAgICAgIH1nICYmICFtLmxlbmd0aCAmJiAobC50ZWFyZG93biAmJiBsLnRlYXJkb3duLmNhbGwoYSwgcCwgci5oYW5kbGUpICE9PSAhMSB8fCBuLnJlbW92ZUV2ZW50KGEsIG8sIHIuaGFuZGxlKSwgZGVsZXRlIGlbb10pO1xcbiAgICAgICAgICB9IGVsc2UgZm9yIChvIGluIGkpIHtcXG4gICAgICAgICAgICBuLmV2ZW50LnJlbW92ZShhLCBvICsgYltqXSwgYywgZCwgITApO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9bi5pc0VtcHR5T2JqZWN0KGkpICYmIE4ucmVtb3ZlKGEsIFxcXCJoYW5kbGUgZXZlbnRzXFxcIik7XFxuICAgICAgfVxcbiAgICB9LCBkaXNwYXRjaDogZnVuY3Rpb24gZGlzcGF0Y2goYSkge1xcbiAgICAgIGEgPSBuLmV2ZW50LmZpeChhKTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCA9IFtdLFxcbiAgICAgICAgICBpID0gZS5jYWxsKGFyZ3VtZW50cyksXFxuICAgICAgICAgIGogPSAoTi5nZXQodGhpcywgXFxcImV2ZW50c1xcXCIpIHx8IHt9KVthLnR5cGVdIHx8IFtdLFxcbiAgICAgICAgICBrID0gbi5ldmVudC5zcGVjaWFsW2EudHlwZV0gfHwge307aWYgKGlbMF0gPSBhLCBhLmRlbGVnYXRlVGFyZ2V0ID0gdGhpcywgIWsucHJlRGlzcGF0Y2ggfHwgay5wcmVEaXNwYXRjaC5jYWxsKHRoaXMsIGEpICE9PSAhMSkge1xcbiAgICAgICAgaCA9IG4uZXZlbnQuaGFuZGxlcnMuY2FsbCh0aGlzLCBhLCBqKSwgYiA9IDA7d2hpbGUgKChmID0gaFtiKytdKSAmJiAhYS5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGEuY3VycmVudFRhcmdldCA9IGYuZWxlbSwgYyA9IDA7d2hpbGUgKChnID0gZi5oYW5kbGVyc1tjKytdKSAmJiAhYS5pc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgICAgYS5ybmFtZXNwYWNlICYmICFhLnJuYW1lc3BhY2UudGVzdChnLm5hbWVzcGFjZSkgfHwgKGEuaGFuZGxlT2JqID0gZywgYS5kYXRhID0gZy5kYXRhLCBkID0gKChuLmV2ZW50LnNwZWNpYWxbZy5vcmlnVHlwZV0gfHwge30pLmhhbmRsZSB8fCBnLmhhbmRsZXIpLmFwcGx5KGYuZWxlbSwgaSksIHZvaWQgMCAhPT0gZCAmJiAoYS5yZXN1bHQgPSBkKSA9PT0gITEgJiYgKGEucHJldmVudERlZmF1bHQoKSwgYS5zdG9wUHJvcGFnYXRpb24oKSkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9cmV0dXJuIGsucG9zdERpc3BhdGNoICYmIGsucG9zdERpc3BhdGNoLmNhbGwodGhpcywgYSksIGEucmVzdWx0O1xcbiAgICAgIH1cXG4gICAgfSwgaGFuZGxlcnM6IGZ1bmN0aW9uIGhhbmRsZXJzKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyA9IFtdLFxcbiAgICAgICAgICBoID0gYi5kZWxlZ2F0ZUNvdW50LFxcbiAgICAgICAgICBpID0gYS50YXJnZXQ7aWYgKGggJiYgaS5ub2RlVHlwZSAmJiAoXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlIHx8IGlzTmFOKGEuYnV0dG9uKSB8fCBhLmJ1dHRvbiA8IDEpKSBmb3IgKDsgaSAhPT0gdGhpczsgaSA9IGkucGFyZW50Tm9kZSB8fCB0aGlzKSB7XFxuICAgICAgICBpZiAoMSA9PT0gaS5ub2RlVHlwZSAmJiAoaS5kaXNhYmxlZCAhPT0gITAgfHwgXFxcImNsaWNrXFxcIiAhPT0gYS50eXBlKSkge1xcbiAgICAgICAgICBmb3IgKGQgPSBbXSwgYyA9IDA7IGggPiBjOyBjKyspIHtcXG4gICAgICAgICAgICBmID0gYltjXSwgZSA9IGYuc2VsZWN0b3IgKyBcXFwiIFxcXCIsIHZvaWQgMCA9PT0gZFtlXSAmJiAoZFtlXSA9IGYubmVlZHNDb250ZXh0ID8gbihlLCB0aGlzKS5pbmRleChpKSA+IC0xIDogbi5maW5kKGUsIHRoaXMsIG51bGwsIFtpXSkubGVuZ3RoKSwgZFtlXSAmJiBkLnB1c2goZik7XFxuICAgICAgICAgIH1kLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiBpLCBoYW5kbGVyczogZCB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9cmV0dXJuIGggPCBiLmxlbmd0aCAmJiBnLnB1c2goeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogYi5zbGljZShoKSB9KSwgZztcXG4gICAgfSwgcHJvcHM6IFxcXCJhbHRLZXkgYnViYmxlcyBjYW5jZWxhYmxlIGN0cmxLZXkgY3VycmVudFRhcmdldCBkZXRhaWwgZXZlbnRQaGFzZSBtZXRhS2V5IHJlbGF0ZWRUYXJnZXQgc2hpZnRLZXkgdGFyZ2V0IHRpbWVTdGFtcCB2aWV3IHdoaWNoXFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmaXhIb29rczoge30sIGtleUhvb2tzOiB7IHByb3BzOiBcXFwiY2hhciBjaGFyQ29kZSBrZXkga2V5Q29kZVxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgcmV0dXJuIG51bGwgPT0gYS53aGljaCAmJiAoYS53aGljaCA9IG51bGwgIT0gYi5jaGFyQ29kZSA/IGIuY2hhckNvZGUgOiBiLmtleUNvZGUpLCBhO1xcbiAgICAgIH0gfSwgbW91c2VIb29rczogeyBwcm9wczogXFxcImJ1dHRvbiBidXR0b25zIGNsaWVudFggY2xpZW50WSBvZmZzZXRYIG9mZnNldFkgcGFnZVggcGFnZVkgc2NyZWVuWCBzY3JlZW5ZIHRvRWxlbWVudFxcXCIuc3BsaXQoXFxcIiBcXFwiKSwgZmlsdGVyOiBmdW5jdGlvbiBmaWx0ZXIoYSwgYikge1xcbiAgICAgICAgdmFyIGMsXFxuICAgICAgICAgICAgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcgPSBiLmJ1dHRvbjtyZXR1cm4gbnVsbCA9PSBhLnBhZ2VYICYmIG51bGwgIT0gYi5jbGllbnRYICYmIChjID0gYS50YXJnZXQub3duZXJEb2N1bWVudCB8fCBkLCBlID0gYy5kb2N1bWVudEVsZW1lbnQsIGYgPSBjLmJvZHksIGEucGFnZVggPSBiLmNsaWVudFggKyAoZSAmJiBlLnNjcm9sbExlZnQgfHwgZiAmJiBmLnNjcm9sbExlZnQgfHwgMCkgLSAoZSAmJiBlLmNsaWVudExlZnQgfHwgZiAmJiBmLmNsaWVudExlZnQgfHwgMCksIGEucGFnZVkgPSBiLmNsaWVudFkgKyAoZSAmJiBlLnNjcm9sbFRvcCB8fCBmICYmIGYuc2Nyb2xsVG9wIHx8IDApIC0gKGUgJiYgZS5jbGllbnRUb3AgfHwgZiAmJiBmLmNsaWVudFRvcCB8fCAwKSksIGEud2hpY2ggfHwgdm9pZCAwID09PSBnIHx8IChhLndoaWNoID0gMSAmIGcgPyAxIDogMiAmIGcgPyAzIDogNCAmIGcgPyAyIDogMCksIGE7XFxuICAgICAgfSB9LCBmaXg6IGZ1bmN0aW9uIGZpeChhKSB7XFxuICAgICAgaWYgKGFbbi5leHBhbmRvXSkgcmV0dXJuIGE7dmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLnR5cGUsXFxuICAgICAgICAgIGcgPSBhLFxcbiAgICAgICAgICBoID0gdGhpcy5maXhIb29rc1tmXTtoIHx8ICh0aGlzLmZpeEhvb2tzW2ZdID0gaCA9IGVhLnRlc3QoZikgPyB0aGlzLm1vdXNlSG9va3MgOiBkYS50ZXN0KGYpID8gdGhpcy5rZXlIb29rcyA6IHt9KSwgZSA9IGgucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdChoLnByb3BzKSA6IHRoaXMucHJvcHMsIGEgPSBuZXcgbi5FdmVudChnKSwgYiA9IGUubGVuZ3RoO3doaWxlIChiLS0pIHtcXG4gICAgICAgIGMgPSBlW2JdLCBhW2NdID0gZ1tjXTtcXG4gICAgICB9cmV0dXJuIGEudGFyZ2V0IHx8IChhLnRhcmdldCA9IGQpLCAzID09PSBhLnRhcmdldC5ub2RlVHlwZSAmJiAoYS50YXJnZXQgPSBhLnRhcmdldC5wYXJlbnROb2RlKSwgaC5maWx0ZXIgPyBoLmZpbHRlcihhLCBnKSA6IGE7XFxuICAgIH0sIHNwZWNpYWw6IHsgbG9hZDogeyBub0J1YmJsZTogITAgfSwgZm9jdXM6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgIT09IGlhKCkgJiYgdGhpcy5mb2N1cyA/ICh0aGlzLmZvY3VzKCksICExKSA6IHZvaWQgMDtcXG4gICAgICAgIH0sIGRlbGVnYXRlVHlwZTogXFxcImZvY3VzaW5cXFwiIH0sIGJsdXI6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIHRoaXMgPT09IGlhKCkgJiYgdGhpcy5ibHVyID8gKHRoaXMuYmx1cigpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBkZWxlZ2F0ZVR5cGU6IFxcXCJmb2N1c291dFxcXCIgfSwgY2xpY2s6IHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcigpIHtcXG4gICAgICAgICAgcmV0dXJuIFxcXCJjaGVja2JveFxcXCIgPT09IHRoaXMudHlwZSAmJiB0aGlzLmNsaWNrICYmIG4ubm9kZU5hbWUodGhpcywgXFxcImlucHV0XFxcIikgPyAodGhpcy5jbGljaygpLCAhMSkgOiB2b2lkIDA7XFxuICAgICAgICB9LCBfZGVmYXVsdDogZnVuY3Rpb24gX2RlZmF1bHQoYSkge1xcbiAgICAgICAgICByZXR1cm4gbi5ub2RlTmFtZShhLnRhcmdldCwgXFxcImFcXFwiKTtcXG4gICAgICAgIH0gfSwgYmVmb3JldW5sb2FkOiB7IHBvc3REaXNwYXRjaDogZnVuY3Rpb24gcG9zdERpc3BhdGNoKGEpIHtcXG4gICAgICAgICAgdm9pZCAwICE9PSBhLnJlc3VsdCAmJiBhLm9yaWdpbmFsRXZlbnQgJiYgKGEub3JpZ2luYWxFdmVudC5yZXR1cm5WYWx1ZSA9IGEucmVzdWx0KTtcXG4gICAgICAgIH0gfSB9IH0sIG4ucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBhLnJlbW92ZUV2ZW50TGlzdGVuZXIgJiYgYS5yZW1vdmVFdmVudExpc3RlbmVyKGIsIGMpO1xcbiAgfSwgbi5FdmVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIHJldHVybiB0aGlzIGluc3RhbmNlb2Ygbi5FdmVudCA/IChhICYmIGEudHlwZSA/ICh0aGlzLm9yaWdpbmFsRXZlbnQgPSBhLCB0aGlzLnR5cGUgPSBhLnR5cGUsIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gYS5kZWZhdWx0UHJldmVudGVkIHx8IHZvaWQgMCA9PT0gYS5kZWZhdWx0UHJldmVudGVkICYmIGEucmV0dXJuVmFsdWUgPT09ICExID8gZ2EgOiBoYSkgOiB0aGlzLnR5cGUgPSBhLCBiICYmIG4uZXh0ZW5kKHRoaXMsIGIpLCB0aGlzLnRpbWVTdGFtcCA9IGEgJiYgYS50aW1lU3RhbXAgfHwgbi5ub3coKSwgdm9pZCAodGhpc1tuLmV4cGFuZG9dID0gITApKSA6IG5ldyBuLkV2ZW50KGEsIGIpO1xcbiAgfSwgbi5FdmVudC5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBuLkV2ZW50LCBpc0RlZmF1bHRQcmV2ZW50ZWQ6IGhhLCBpc1Byb3BhZ2F0aW9uU3RvcHBlZDogaGEsIGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiBoYSwgaXNTaW11bGF0ZWQ6ICExLCBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gcHJldmVudERlZmF1bHQoKSB7XFxuICAgICAgdmFyIGEgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnByZXZlbnREZWZhdWx0KCk7XFxuICAgIH0sIHN0b3BQcm9wYWdhdGlvbjogZnVuY3Rpb24gc3RvcFByb3BhZ2F0aW9uKCkge1xcbiAgICAgIHZhciBhID0gdGhpcy5vcmlnaW5hbEV2ZW50O3RoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBnYSwgYSAmJiAhdGhpcy5pc1NpbXVsYXRlZCAmJiBhLnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICB9LCBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb246IGZ1bmN0aW9uIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpIHtcXG4gICAgICB2YXIgYSA9IHRoaXMub3JpZ2luYWxFdmVudDt0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gZ2EsIGEgJiYgIXRoaXMuaXNTaW11bGF0ZWQgJiYgYS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcXG4gICAgfSB9LCBuLmVhY2goeyBtb3VzZWVudGVyOiBcXFwibW91c2VvdmVyXFxcIiwgbW91c2VsZWF2ZTogXFxcIm1vdXNlb3V0XFxcIiwgcG9pbnRlcmVudGVyOiBcXFwicG9pbnRlcm92ZXJcXFwiLCBwb2ludGVybGVhdmU6IFxcXCJwb2ludGVyb3V0XFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmV2ZW50LnNwZWNpYWxbYV0gPSB7IGRlbGVnYXRlVHlwZTogYiwgYmluZFR5cGU6IGIsIGhhbmRsZTogZnVuY3Rpb24gaGFuZGxlKGEpIHtcXG4gICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgIGQgPSB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBhLnJlbGF0ZWRUYXJnZXQsXFxuICAgICAgICAgICAgZiA9IGEuaGFuZGxlT2JqO3JldHVybiBlICYmIChlID09PSBkIHx8IG4uY29udGFpbnMoZCwgZSkpIHx8IChhLnR5cGUgPSBmLm9yaWdUeXBlLCBjID0gZi5oYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksIGEudHlwZSA9IGIpLCBjO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IG9uOiBmdW5jdGlvbiBvbihhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQpO1xcbiAgICB9LCBvbmU6IGZ1bmN0aW9uIG9uZShhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIGphKHRoaXMsIGEsIGIsIGMsIGQsIDEpO1xcbiAgICB9LCBvZmY6IGZ1bmN0aW9uIG9mZihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsIGU7aWYgKGEgJiYgYS5wcmV2ZW50RGVmYXVsdCAmJiBhLmhhbmRsZU9iaikgcmV0dXJuIGQgPSBhLmhhbmRsZU9iaiwgbihhLmRlbGVnYXRlVGFyZ2V0KS5vZmYoZC5uYW1lc3BhY2UgPyBkLm9yaWdUeXBlICsgXFxcIi5cXFwiICsgZC5uYW1lc3BhY2UgOiBkLm9yaWdUeXBlLCBkLnNlbGVjdG9yLCBkLmhhbmRsZXIpLCB0aGlzO2lmIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSkge1xcbiAgICAgICAgZm9yIChlIGluIGEpIHtcXG4gICAgICAgICAgdGhpcy5vZmYoZSwgYiwgYVtlXSk7XFxuICAgICAgICB9cmV0dXJuIHRoaXM7XFxuICAgICAgfXJldHVybiBiICE9PSAhMSAmJiBcXFwiZnVuY3Rpb25cXFwiICE9IHR5cGVvZiBiIHx8IChjID0gYiwgYiA9IHZvaWQgMCksIGMgPT09ICExICYmIChjID0gaGEpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbi5ldmVudC5yZW1vdmUodGhpcywgYSwgYywgYik7XFxuICAgICAgfSk7XFxuICAgIH0gfSk7dmFyIGthID0gLzwoPyFhcmVhfGJyfGNvbHxlbWJlZHxocnxpbWd8aW5wdXR8bGlua3xtZXRhfHBhcmFtKSgoW1xcXFx3Oi1dKylbXj5dKilcXFxcLz4vZ2ksXFxuICAgICAgbGEgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcXG4gICAgICBtYSA9IC9jaGVja2VkXFxcXHMqKD86W149XXw9XFxcXHMqLmNoZWNrZWQuKS9pLFxcbiAgICAgIG5hID0gL150cnVlXFxcXC8oLiopLyxcXG4gICAgICBvYSA9IC9eXFxcXHMqPCEoPzpcXFxcW0NEQVRBXFxcXFt8LS0pfCg/OlxcXFxdXFxcXF18LS0pPlxcXFxzKiQvZztmdW5jdGlvbiBwYShhLCBiKSB7XFxuICAgIHJldHVybiBuLm5vZGVOYW1lKGEsIFxcXCJ0YWJsZVxcXCIpICYmIG4ubm9kZU5hbWUoMTEgIT09IGIubm9kZVR5cGUgPyBiIDogYi5maXJzdENoaWxkLCBcXFwidHJcXFwiKSA/IGEuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXFxcInRib2R5XFxcIilbMF0gfHwgYS5hcHBlbmRDaGlsZChhLm93bmVyRG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwidGJvZHlcXFwiKSkgOiBhO1xcbiAgfWZ1bmN0aW9uIHFhKGEpIHtcXG4gICAgcmV0dXJuIGEudHlwZSA9IChudWxsICE9PSBhLmdldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIpKSArIFxcXCIvXFxcIiArIGEudHlwZSwgYTtcXG4gIH1mdW5jdGlvbiByYShhKSB7XFxuICAgIHZhciBiID0gbmEuZXhlYyhhLnR5cGUpO3JldHVybiBiID8gYS50eXBlID0gYlsxXSA6IGEucmVtb3ZlQXR0cmlidXRlKFxcXCJ0eXBlXFxcIiksIGE7XFxuICB9ZnVuY3Rpb24gc2EoYSwgYikge1xcbiAgICB2YXIgYywgZCwgZSwgZiwgZywgaCwgaSwgajtpZiAoMSA9PT0gYi5ub2RlVHlwZSkge1xcbiAgICAgIGlmIChOLmhhc0RhdGEoYSkgJiYgKGYgPSBOLmFjY2VzcyhhKSwgZyA9IE4uc2V0KGIsIGYpLCBqID0gZi5ldmVudHMpKSB7XFxuICAgICAgICBkZWxldGUgZy5oYW5kbGUsIGcuZXZlbnRzID0ge307Zm9yIChlIGluIGopIHtcXG4gICAgICAgICAgZm9yIChjID0gMCwgZCA9IGpbZV0ubGVuZ3RoOyBkID4gYzsgYysrKSB7XFxuICAgICAgICAgICAgbi5ldmVudC5hZGQoYiwgZSwgaltlXVtjXSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICB9Ty5oYXNEYXRhKGEpICYmIChoID0gTy5hY2Nlc3MoYSksIGkgPSBuLmV4dGVuZCh7fSwgaCksIE8uc2V0KGIsIGkpKTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIHRhKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XFxcImlucHV0XFxcIiA9PT0gYyAmJiBYLnRlc3QoYS50eXBlKSA/IGIuY2hlY2tlZCA9IGEuY2hlY2tlZCA6IFxcXCJpbnB1dFxcXCIgIT09IGMgJiYgXFxcInRleHRhcmVhXFxcIiAhPT0gYyB8fCAoYi5kZWZhdWx0VmFsdWUgPSBhLmRlZmF1bHRWYWx1ZSk7XFxuICB9ZnVuY3Rpb24gdWEoYSwgYiwgYywgZCkge1xcbiAgICBiID0gZi5hcHBseShbXSwgYik7dmFyIGUsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCxcXG4gICAgICAgIGksXFxuICAgICAgICBqLFxcbiAgICAgICAgayxcXG4gICAgICAgIG0gPSAwLFxcbiAgICAgICAgbyA9IGEubGVuZ3RoLFxcbiAgICAgICAgcCA9IG8gLSAxLFxcbiAgICAgICAgcSA9IGJbMF0sXFxuICAgICAgICByID0gbi5pc0Z1bmN0aW9uKHEpO2lmIChyIHx8IG8gPiAxICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBxICYmICFsLmNoZWNrQ2xvbmUgJiYgbWEudGVzdChxKSkgcmV0dXJuIGEuZWFjaChmdW5jdGlvbiAoZSkge1xcbiAgICAgIHZhciBmID0gYS5lcShlKTtyICYmIChiWzBdID0gcS5jYWxsKHRoaXMsIGUsIGYuaHRtbCgpKSksIHVhKGYsIGIsIGMsIGQpO1xcbiAgICB9KTtpZiAobyAmJiAoZSA9IGNhKGIsIGFbMF0ub3duZXJEb2N1bWVudCwgITEsIGEsIGQpLCBnID0gZS5maXJzdENoaWxkLCAxID09PSBlLmNoaWxkTm9kZXMubGVuZ3RoICYmIChlID0gZyksIGcgfHwgZCkpIHtcXG4gICAgICBmb3IgKGggPSBuLm1hcChfKGUsIFxcXCJzY3JpcHRcXFwiKSwgcWEpLCBpID0gaC5sZW5ndGg7IG8gPiBtOyBtKyspIHtcXG4gICAgICAgIGogPSBlLCBtICE9PSBwICYmIChqID0gbi5jbG9uZShqLCAhMCwgITApLCBpICYmIG4ubWVyZ2UoaCwgXyhqLCBcXFwic2NyaXB0XFxcIikpKSwgYy5jYWxsKGFbbV0sIGosIG0pO1xcbiAgICAgIH1pZiAoaSkgZm9yIChrID0gaFtoLmxlbmd0aCAtIDFdLm93bmVyRG9jdW1lbnQsIG4ubWFwKGgsIHJhKSwgbSA9IDA7IGkgPiBtOyBtKyspIHtcXG4gICAgICAgIGogPSBoW21dLCBaLnRlc3Qoai50eXBlIHx8IFxcXCJcXFwiKSAmJiAhTi5hY2Nlc3MoaiwgXFxcImdsb2JhbEV2YWxcXFwiKSAmJiBuLmNvbnRhaW5zKGssIGopICYmIChqLnNyYyA/IG4uX2V2YWxVcmwgJiYgbi5fZXZhbFVybChqLnNyYykgOiBuLmdsb2JhbEV2YWwoai50ZXh0Q29udGVudC5yZXBsYWNlKG9hLCBcXFwiXFxcIikpKTtcXG4gICAgICB9XFxuICAgIH1yZXR1cm4gYTtcXG4gIH1mdW5jdGlvbiB2YShhLCBiLCBjKSB7XFxuICAgIGZvciAodmFyIGQsIGUgPSBiID8gbi5maWx0ZXIoYiwgYSkgOiBhLCBmID0gMDsgbnVsbCAhPSAoZCA9IGVbZl0pOyBmKyspIHtcXG4gICAgICBjIHx8IDEgIT09IGQubm9kZVR5cGUgfHwgbi5jbGVhbkRhdGEoXyhkKSksIGQucGFyZW50Tm9kZSAmJiAoYyAmJiBuLmNvbnRhaW5zKGQub3duZXJEb2N1bWVudCwgZCkgJiYgYWEoXyhkLCBcXFwic2NyaXB0XFxcIikpLCBkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZCkpO1xcbiAgICB9cmV0dXJuIGE7XFxuICB9bi5leHRlbmQoeyBodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiBodG1sUHJlZmlsdGVyKGEpIHtcXG4gICAgICByZXR1cm4gYS5yZXBsYWNlKGthLCBcXFwiPCQxPjwvJDI+XFxcIik7XFxuICAgIH0sIGNsb25lOiBmdW5jdGlvbiBjbG9uZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBhLmNsb25lTm9kZSghMCksXFxuICAgICAgICAgIGkgPSBuLmNvbnRhaW5zKGEub3duZXJEb2N1bWVudCwgYSk7aWYgKCEobC5ub0Nsb25lQ2hlY2tlZCB8fCAxICE9PSBhLm5vZGVUeXBlICYmIDExICE9PSBhLm5vZGVUeXBlIHx8IG4uaXNYTUxEb2MoYSkpKSBmb3IgKGcgPSBfKGgpLCBmID0gXyhhKSwgZCA9IDAsIGUgPSBmLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgdGEoZltkXSwgZ1tkXSk7XFxuICAgICAgfWlmIChiKSBpZiAoYykgZm9yIChmID0gZiB8fCBfKGEpLCBnID0gZyB8fCBfKGgpLCBkID0gMCwgZSA9IGYubGVuZ3RoOyBlID4gZDsgZCsrKSB7XFxuICAgICAgICBzYShmW2RdLCBnW2RdKTtcXG4gICAgICB9IGVsc2Ugc2EoYSwgaCk7cmV0dXJuIGcgPSBfKGgsIFxcXCJzY3JpcHRcXFwiKSwgZy5sZW5ndGggPiAwICYmIGFhKGcsICFpICYmIF8oYSwgXFxcInNjcmlwdFxcXCIpKSwgaDtcXG4gICAgfSwgY2xlYW5EYXRhOiBmdW5jdGlvbiBjbGVhbkRhdGEoYSkge1xcbiAgICAgIGZvciAodmFyIGIsIGMsIGQsIGUgPSBuLmV2ZW50LnNwZWNpYWwsIGYgPSAwOyB2b2lkIDAgIT09IChjID0gYVtmXSk7IGYrKykge1xcbiAgICAgICAgaWYgKEwoYykpIHtcXG4gICAgICAgICAgaWYgKGIgPSBjW04uZXhwYW5kb10pIHtcXG4gICAgICAgICAgICBpZiAoYi5ldmVudHMpIGZvciAoZCBpbiBiLmV2ZW50cykge1xcbiAgICAgICAgICAgICAgZVtkXSA/IG4uZXZlbnQucmVtb3ZlKGMsIGQpIDogbi5yZW1vdmVFdmVudChjLCBkLCBiLmhhbmRsZSk7XFxuICAgICAgICAgICAgfWNbTi5leHBhbmRvXSA9IHZvaWQgMDtcXG4gICAgICAgICAgfWNbTy5leHBhbmRvXSAmJiAoY1tPLmV4cGFuZG9dID0gdm9pZCAwKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgZG9tTWFuaXA6IHVhLCBkZXRhY2g6IGZ1bmN0aW9uIGRldGFjaChhKSB7XFxuICAgICAgcmV0dXJuIHZhKHRoaXMsIGEsICEwKTtcXG4gICAgfSwgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoYSkge1xcbiAgICAgIHJldHVybiB2YSh0aGlzLCBhKTtcXG4gICAgfSwgdGV4dDogZnVuY3Rpb24gdGV4dChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHJldHVybiB2b2lkIDAgPT09IGEgPyBuLnRleHQodGhpcykgOiB0aGlzLmVtcHR5KCkuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIDEgIT09IHRoaXMubm9kZVR5cGUgJiYgMTEgIT09IHRoaXMubm9kZVR5cGUgJiYgOSAhPT0gdGhpcy5ub2RlVHlwZSB8fCAodGhpcy50ZXh0Q29udGVudCA9IGEpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSwgbnVsbCwgYSwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH0sIGFwcGVuZDogZnVuY3Rpb24gYXBwZW5kKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICBpZiAoMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCAxMSA9PT0gdGhpcy5ub2RlVHlwZSB8fCA5ID09PSB0aGlzLm5vZGVUeXBlKSB7XFxuICAgICAgICAgIHZhciBiID0gcGEodGhpcywgYSk7Yi5hcHBlbmRDaGlsZChhKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtcXG4gICAgfSwgcHJlcGVuZDogZnVuY3Rpb24gcHJlcGVuZCgpIHtcXG4gICAgICByZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYSkge1xcbiAgICAgICAgaWYgKDEgPT09IHRoaXMubm9kZVR5cGUgfHwgMTEgPT09IHRoaXMubm9kZVR5cGUgfHwgOSA9PT0gdGhpcy5ub2RlVHlwZSkge1xcbiAgICAgICAgICB2YXIgYiA9IHBhKHRoaXMsIGEpO2IuaW5zZXJ0QmVmb3JlKGEsIGIuZmlyc3RDaGlsZCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH0sIGJlZm9yZTogZnVuY3Rpb24gYmVmb3JlKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzKTtcXG4gICAgICB9KTtcXG4gICAgfSwgYWZ0ZXI6IGZ1bmN0aW9uIGFmdGVyKCkge1xcbiAgICAgIHJldHVybiB1YSh0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICB0aGlzLnBhcmVudE5vZGUgJiYgdGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShhLCB0aGlzLm5leHRTaWJsaW5nKTtcXG4gICAgICB9KTtcXG4gICAgfSwgZW1wdHk6IGZ1bmN0aW9uIGVtcHR5KCkge1xcbiAgICAgIGZvciAodmFyIGEsIGIgPSAwOyBudWxsICE9IChhID0gdGhpc1tiXSk7IGIrKykge1xcbiAgICAgICAgMSA9PT0gYS5ub2RlVHlwZSAmJiAobi5jbGVhbkRhdGEoXyhhLCAhMSkpLCBhLnRleHRDb250ZW50ID0gXFxcIlxcXCIpO1xcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgY2xvbmU6IGZ1bmN0aW9uIGNsb25lKGEsIGIpIHtcXG4gICAgICByZXR1cm4gYSA9IG51bGwgPT0gYSA/ICExIDogYSwgYiA9IG51bGwgPT0gYiA/IGEgOiBiLCB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICByZXR1cm4gbi5jbG9uZSh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTtcXG4gICAgfSwgaHRtbDogZnVuY3Rpb24gaHRtbChhKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgIHZhciBiID0gdGhpc1swXSB8fCB7fSxcXG4gICAgICAgICAgICBjID0gMCxcXG4gICAgICAgICAgICBkID0gdGhpcy5sZW5ndGg7aWYgKHZvaWQgMCA9PT0gYSAmJiAxID09PSBiLm5vZGVUeXBlKSByZXR1cm4gYi5pbm5lckhUTUw7aWYgKFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBhICYmICFsYS50ZXN0KGEpICYmICEkWyhZLmV4ZWMoYSkgfHwgW1xcXCJcXFwiLCBcXFwiXFxcIl0pWzFdLnRvTG93ZXJDYXNlKCldKSB7XFxuICAgICAgICAgIGEgPSBuLmh0bWxQcmVmaWx0ZXIoYSk7dHJ5IHtcXG4gICAgICAgICAgICBmb3IgKDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICAgICAgYiA9IHRoaXNbY10gfHwge30sIDEgPT09IGIubm9kZVR5cGUgJiYgKG4uY2xlYW5EYXRhKF8oYiwgITEpKSwgYi5pbm5lckhUTUwgPSBhKTtcXG4gICAgICAgICAgICB9YiA9IDA7XFxuICAgICAgICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgICAgICB9YiAmJiB0aGlzLmVtcHR5KCkuYXBwZW5kKGEpO1xcbiAgICAgIH0sIG51bGwsIGEsIGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICB9LCByZXBsYWNlV2l0aDogZnVuY3Rpb24gcmVwbGFjZVdpdGgoKSB7XFxuICAgICAgdmFyIGEgPSBbXTtyZXR1cm4gdWEodGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgICAgdmFyIGMgPSB0aGlzLnBhcmVudE5vZGU7bi5pbkFycmF5KHRoaXMsIGEpIDwgMCAmJiAobi5jbGVhbkRhdGEoXyh0aGlzKSksIGMgJiYgYy5yZXBsYWNlQ2hpbGQoYiwgdGhpcykpO1xcbiAgICAgIH0sIGEpO1xcbiAgICB9IH0pLCBuLmVhY2goeyBhcHBlbmRUbzogXFxcImFwcGVuZFxcXCIsIHByZXBlbmRUbzogXFxcInByZXBlbmRcXFwiLCBpbnNlcnRCZWZvcmU6IFxcXCJiZWZvcmVcXFwiLCBpbnNlcnRBZnRlcjogXFxcImFmdGVyXFxcIiwgcmVwbGFjZUFsbDogXFxcInJlcGxhY2VXaXRoXFxcIiB9LCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2FdID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgICBmb3IgKHZhciBjLCBkID0gW10sIGUgPSBuKGEpLCBmID0gZS5sZW5ndGggLSAxLCBoID0gMDsgZiA+PSBoOyBoKyspIHtcXG4gICAgICAgIGMgPSBoID09PSBmID8gdGhpcyA6IHRoaXMuY2xvbmUoITApLCBuKGVbaF0pW2JdKGMpLCBnLmFwcGx5KGQsIGMuZ2V0KCkpO1xcbiAgICAgIH1yZXR1cm4gdGhpcy5wdXNoU3RhY2soZCk7XFxuICAgIH07XFxuICB9KTt2YXIgd2EsXFxuICAgICAgeGEgPSB7IEhUTUw6IFxcXCJibG9ja1xcXCIsIEJPRFk6IFxcXCJibG9ja1xcXCIgfTtmdW5jdGlvbiB5YShhLCBiKSB7XFxuICAgIHZhciBjID0gbihiLmNyZWF0ZUVsZW1lbnQoYSkpLmFwcGVuZFRvKGIuYm9keSksXFxuICAgICAgICBkID0gbi5jc3MoY1swXSwgXFxcImRpc3BsYXlcXFwiKTtyZXR1cm4gYy5kZXRhY2goKSwgZDtcXG4gIH1mdW5jdGlvbiB6YShhKSB7XFxuICAgIHZhciBiID0gZCxcXG4gICAgICAgIGMgPSB4YVthXTtyZXR1cm4gYyB8fCAoYyA9IHlhKGEsIGIpLCBcXFwibm9uZVxcXCIgIT09IGMgJiYgYyB8fCAod2EgPSAod2EgfHwgbihcXFwiPGlmcmFtZSBmcmFtZWJvcmRlcj0nMCcgd2lkdGg9JzAnIGhlaWdodD0nMCcvPlxcXCIpKS5hcHBlbmRUbyhiLmRvY3VtZW50RWxlbWVudCksIGIgPSB3YVswXS5jb250ZW50RG9jdW1lbnQsIGIud3JpdGUoKSwgYi5jbG9zZSgpLCBjID0geWEoYSwgYiksIHdhLmRldGFjaCgpKSwgeGFbYV0gPSBjKSwgYztcXG4gIH12YXIgQWEgPSAvXm1hcmdpbi8sXFxuICAgICAgQmEgPSBuZXcgUmVnRXhwKFxcXCJeKFxcXCIgKyBTICsgXFxcIikoPyFweClbYS16JV0rJFxcXCIsIFxcXCJpXFxcIiksXFxuICAgICAgQ2EgPSBmdW5jdGlvbiBDYShiKSB7XFxuICAgIHZhciBjID0gYi5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O3JldHVybiBjICYmIGMub3BlbmVyIHx8IChjID0gYSksIGMuZ2V0Q29tcHV0ZWRTdHlsZShiKTtcXG4gIH0sXFxuICAgICAgRGEgPSBmdW5jdGlvbiBEYShhLCBiLCBjLCBkKSB7XFxuICAgIHZhciBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSB7fTtmb3IgKGYgaW4gYikge1xcbiAgICAgIGdbZl0gPSBhLnN0eWxlW2ZdLCBhLnN0eWxlW2ZdID0gYltmXTtcXG4gICAgfWUgPSBjLmFwcGx5KGEsIGQgfHwgW10pO2ZvciAoZiBpbiBiKSB7XFxuICAgICAgYS5zdHlsZVtmXSA9IGdbZl07XFxuICAgIH1yZXR1cm4gZTtcXG4gIH0sXFxuICAgICAgRWEgPSBkLmRvY3VtZW50RWxlbWVudDshZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYixcXG4gICAgICAgIGMsXFxuICAgICAgICBlLFxcbiAgICAgICAgZixcXG4gICAgICAgIGcgPSBkLmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpLFxcbiAgICAgICAgaCA9IGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aWYgKGguc3R5bGUpIHtcXG4gICAgICAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGkgPSBmdW5jdGlvbiBpKCkge1xcbiAgICAgICAgICBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7LW1vei1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6YmxvY2s7bWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDt0b3A6MSU7d2lkdGg6NTAlXFxcIiwgaC5pbm5lckhUTUwgPSBcXFwiXFxcIiwgRWEuYXBwZW5kQ2hpbGQoZyk7dmFyIGQgPSBhLmdldENvbXB1dGVkU3R5bGUoaCk7YiA9IFxcXCIxJVxcXCIgIT09IGQudG9wLCBmID0gXFxcIjJweFxcXCIgPT09IGQubWFyZ2luTGVmdCwgYyA9IFxcXCI0cHhcXFwiID09PSBkLndpZHRoLCBoLnN0eWxlLm1hcmdpblJpZ2h0ID0gXFxcIjUwJVxcXCIsIGUgPSBcXFwiNHB4XFxcIiA9PT0gZC5tYXJnaW5SaWdodCwgRWEucmVtb3ZlQ2hpbGQoZyk7XFxuICAgICAgICB9O1xcblxcbiAgICAgICAgaC5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJjb250ZW50LWJveFxcXCIsIGguY2xvbmVOb2RlKCEwKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFxcXCJcXFwiLCBsLmNsZWFyQ2xvbmVTdHlsZSA9IFxcXCJjb250ZW50LWJveFxcXCIgPT09IGguc3R5bGUuYmFja2dyb3VuZENsaXAsIGcuc3R5bGUuY3NzVGV4dCA9IFxcXCJib3JkZXI6MDt3aWR0aDo4cHg7aGVpZ2h0OjA7dG9wOjA7bGVmdDotOTk5OXB4O3BhZGRpbmc6MDttYXJnaW4tdG9wOjFweDtwb3NpdGlvbjphYnNvbHV0ZVxcXCIsIGcuYXBwZW5kQ2hpbGQoaCk7bi5leHRlbmQobCwgeyBwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbiBwaXhlbFBvc2l0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiBpKCksIGI7XFxuICAgICAgICAgIH0sIGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbiBib3hTaXppbmdSZWxpYWJsZSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgYztcXG4gICAgICAgICAgfSwgcGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24gcGl4ZWxNYXJnaW5SaWdodCgpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBjICYmIGkoKSwgZTtcXG4gICAgICAgICAgfSwgcmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbiByZWxpYWJsZU1hcmdpbkxlZnQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIG51bGwgPT0gYyAmJiBpKCksIGY7XFxuICAgICAgICAgIH0sIHJlbGlhYmxlTWFyZ2luUmlnaHQ6IGZ1bmN0aW9uIHJlbGlhYmxlTWFyZ2luUmlnaHQoKSB7XFxuICAgICAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgICAgIGMgPSBoLmFwcGVuZENoaWxkKGQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIikpO3JldHVybiBjLnN0eWxlLmNzc1RleHQgPSBoLnN0eWxlLmNzc1RleHQgPSBcXFwiLXdlYmtpdC1ib3gtc2l6aW5nOmNvbnRlbnQtYm94O2JveC1zaXppbmc6Y29udGVudC1ib3g7ZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcXFwiLCBjLnN0eWxlLm1hcmdpblJpZ2h0ID0gYy5zdHlsZS53aWR0aCA9IFxcXCIwXFxcIiwgaC5zdHlsZS53aWR0aCA9IFxcXCIxcHhcXFwiLCBFYS5hcHBlbmRDaGlsZChnKSwgYiA9ICFwYXJzZUZsb2F0KGEuZ2V0Q29tcHV0ZWRTdHlsZShjKS5tYXJnaW5SaWdodCksIEVhLnJlbW92ZUNoaWxkKGcpLCBoLnJlbW92ZUNoaWxkKGMpLCBiO1xcbiAgICAgICAgICB9IH0pO1xcbiAgICAgIH0pKCk7XFxuICAgIH1cXG4gIH0oKTtmdW5jdGlvbiBGYShhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuc3R5bGU7cmV0dXJuIGMgPSBjIHx8IENhKGEpLCBnID0gYyA/IGMuZ2V0UHJvcGVydHlWYWx1ZShiKSB8fCBjW2JdIDogdm9pZCAwLCBcXFwiXFxcIiAhPT0gZyAmJiB2b2lkIDAgIT09IGcgfHwgbi5jb250YWlucyhhLm93bmVyRG9jdW1lbnQsIGEpIHx8IChnID0gbi5zdHlsZShhLCBiKSksIGMgJiYgIWwucGl4ZWxNYXJnaW5SaWdodCgpICYmIEJhLnRlc3QoZykgJiYgQWEudGVzdChiKSAmJiAoZCA9IGgud2lkdGgsIGUgPSBoLm1pbldpZHRoLCBmID0gaC5tYXhXaWR0aCwgaC5taW5XaWR0aCA9IGgubWF4V2lkdGggPSBoLndpZHRoID0gZywgZyA9IGMud2lkdGgsIGgud2lkdGggPSBkLCBoLm1pbldpZHRoID0gZSwgaC5tYXhXaWR0aCA9IGYpLCB2b2lkIDAgIT09IGcgPyBnICsgXFxcIlxcXCIgOiBnO1xcbiAgfWZ1bmN0aW9uIEdhKGEsIGIpIHtcXG4gICAgcmV0dXJuIHsgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XFxuICAgICAgICByZXR1cm4gYSgpID8gdm9pZCBkZWxldGUgdGhpcy5nZXQgOiAodGhpcy5nZXQgPSBiKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICAgIH0gfTtcXG4gIH12YXIgSGEgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXFxuICAgICAgSWEgPSB7IHBvc2l0aW9uOiBcXFwiYWJzb2x1dGVcXFwiLCB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9LFxcbiAgICAgIEphID0geyBsZXR0ZXJTcGFjaW5nOiBcXFwiMFxcXCIsIGZvbnRXZWlnaHQ6IFxcXCI0MDBcXFwiIH0sXFxuICAgICAgS2EgPSBbXFxcIldlYmtpdFxcXCIsIFxcXCJPXFxcIiwgXFxcIk1velxcXCIsIFxcXCJtc1xcXCJdLFxcbiAgICAgIExhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJkaXZcXFwiKS5zdHlsZTtmdW5jdGlvbiBNYShhKSB7XFxuICAgIGlmIChhIGluIExhKSByZXR1cm4gYTt2YXIgYiA9IGFbMF0udG9VcHBlckNhc2UoKSArIGEuc2xpY2UoMSksXFxuICAgICAgICBjID0gS2EubGVuZ3RoO3doaWxlIChjLS0pIHtcXG4gICAgICBpZiAoYSA9IEthW2NdICsgYiwgYSBpbiBMYSkgcmV0dXJuIGE7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBOYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gVC5leGVjKGIpO3JldHVybiBkID8gTWF0aC5tYXgoMCwgZFsyXSAtIChjIHx8IDApKSArIChkWzNdIHx8IFxcXCJweFxcXCIpIDogYjtcXG4gIH1mdW5jdGlvbiBPYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIGZvciAodmFyIGYgPSBjID09PSAoZCA/IFxcXCJib3JkZXJcXFwiIDogXFxcImNvbnRlbnRcXFwiKSA/IDQgOiBcXFwid2lkdGhcXFwiID09PSBiID8gMSA6IDAsIGcgPSAwOyA0ID4gZjsgZiArPSAyKSB7XFxuICAgICAgXFxcIm1hcmdpblxcXCIgPT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgYyArIFVbZl0sICEwLCBlKSksIGQgPyAoXFxcImNvbnRlbnRcXFwiID09PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJwYWRkaW5nXFxcIiArIFVbZl0sICEwLCBlKSksIFxcXCJtYXJnaW5cXFwiICE9PSBjICYmIChnIC09IG4uY3NzKGEsIFxcXCJib3JkZXJcXFwiICsgVVtmXSArIFxcXCJXaWR0aFxcXCIsICEwLCBlKSkpIDogKGcgKz0gbi5jc3MoYSwgXFxcInBhZGRpbmdcXFwiICsgVVtmXSwgITAsIGUpLCBcXFwicGFkZGluZ1xcXCIgIT09IGMgJiYgKGcgKz0gbi5jc3MoYSwgXFxcImJvcmRlclxcXCIgKyBVW2ZdICsgXFxcIldpZHRoXFxcIiwgITAsIGUpKSk7XFxuICAgIH1yZXR1cm4gZztcXG4gIH1mdW5jdGlvbiBQYShhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gITAsXFxuICAgICAgICBlID0gXFxcIndpZHRoXFxcIiA9PT0gYiA/IGEub2Zmc2V0V2lkdGggOiBhLm9mZnNldEhlaWdodCxcXG4gICAgICAgIGYgPSBDYShhKSxcXG4gICAgICAgIGcgPSBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZik7aWYgKDAgPj0gZSB8fCBudWxsID09IGUpIHtcXG4gICAgICBpZiAoZSA9IEZhKGEsIGIsIGYpLCAoMCA+IGUgfHwgbnVsbCA9PSBlKSAmJiAoZSA9IGEuc3R5bGVbYl0pLCBCYS50ZXN0KGUpKSByZXR1cm4gZTtkID0gZyAmJiAobC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGUgPT09IGEuc3R5bGVbYl0pLCBlID0gcGFyc2VGbG9hdChlKSB8fCAwO1xcbiAgICB9cmV0dXJuIGUgKyBPYShhLCBiLCBjIHx8IChnID8gXFxcImJvcmRlclxcXCIgOiBcXFwiY29udGVudFxcXCIpLCBkLCBmKSArIFxcXCJweFxcXCI7XFxuICB9ZnVuY3Rpb24gUWEoYSwgYikge1xcbiAgICBmb3IgKHZhciBjLCBkLCBlLCBmID0gW10sIGcgPSAwLCBoID0gYS5sZW5ndGg7IGggPiBnOyBnKyspIHtcXG4gICAgICBkID0gYVtnXSwgZC5zdHlsZSAmJiAoZltnXSA9IE4uZ2V0KGQsIFxcXCJvbGRkaXNwbGF5XFxcIiksIGMgPSBkLnN0eWxlLmRpc3BsYXksIGIgPyAoZltnXSB8fCBcXFwibm9uZVxcXCIgIT09IGMgfHwgKGQuc3R5bGUuZGlzcGxheSA9IFxcXCJcXFwiKSwgXFxcIlxcXCIgPT09IGQuc3R5bGUuZGlzcGxheSAmJiBWKGQpICYmIChmW2ddID0gTi5hY2Nlc3MoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCB6YShkLm5vZGVOYW1lKSkpKSA6IChlID0gVihkKSwgXFxcIm5vbmVcXFwiID09PSBjICYmIGUgfHwgTi5zZXQoZCwgXFxcIm9sZGRpc3BsYXlcXFwiLCBlID8gYyA6IG4uY3NzKGQsIFxcXCJkaXNwbGF5XFxcIikpKSk7XFxuICAgIH1mb3IgKGcgPSAwOyBoID4gZzsgZysrKSB7XFxuICAgICAgZCA9IGFbZ10sIGQuc3R5bGUgJiYgKGIgJiYgXFxcIm5vbmVcXFwiICE9PSBkLnN0eWxlLmRpc3BsYXkgJiYgXFxcIlxcXCIgIT09IGQuc3R5bGUuZGlzcGxheSB8fCAoZC5zdHlsZS5kaXNwbGF5ID0gYiA/IGZbZ10gfHwgXFxcIlxcXCIgOiBcXFwibm9uZVxcXCIpKTtcXG4gICAgfXJldHVybiBhO1xcbiAgfW4uZXh0ZW5kKHsgY3NzSG9va3M6IHsgb3BhY2l0eTogeyBnZXQ6IGZ1bmN0aW9uIGdldChhLCBiKSB7XFxuICAgICAgICAgIGlmIChiKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBGYShhLCBcXFwib3BhY2l0eVxcXCIpO3JldHVybiBcXFwiXFxcIiA9PT0gYyA/IFxcXCIxXFxcIiA6IGM7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCBjc3NOdW1iZXI6IHsgYW5pbWF0aW9uSXRlcmF0aW9uQ291bnQ6ICEwLCBjb2x1bW5Db3VudDogITAsIGZpbGxPcGFjaXR5OiAhMCwgZmxleEdyb3c6ICEwLCBmbGV4U2hyaW5rOiAhMCwgZm9udFdlaWdodDogITAsIGxpbmVIZWlnaHQ6ICEwLCBvcGFjaXR5OiAhMCwgb3JkZXI6ICEwLCBvcnBoYW5zOiAhMCwgd2lkb3dzOiAhMCwgekluZGV4OiAhMCwgem9vbTogITAgfSwgY3NzUHJvcHM6IHsgXFxcImZsb2F0XFxcIjogXFxcImNzc0Zsb2F0XFxcIiB9LCBzdHlsZTogZnVuY3Rpb24gc3R5bGUoYSwgYiwgYywgZCkge1xcbiAgICAgIGlmIChhICYmIDMgIT09IGEubm9kZVR5cGUgJiYgOCAhPT0gYS5ub2RlVHlwZSAmJiBhLnN0eWxlKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmLFxcbiAgICAgICAgICAgIGcsXFxuICAgICAgICAgICAgaCA9IG4uY2FtZWxDYXNlKGIpLFxcbiAgICAgICAgICAgIGkgPSBhLnN0eWxlO3JldHVybiBiID0gbi5jc3NQcm9wc1toXSB8fCAobi5jc3NQcm9wc1toXSA9IE1hKGgpIHx8IGgpLCBnID0gbi5jc3NIb29rc1tiXSB8fCBuLmNzc0hvb2tzW2hdLCB2b2lkIDAgPT09IGMgPyBnICYmIFxcXCJnZXRcXFwiIGluIGcgJiYgdm9pZCAwICE9PSAoZSA9IGcuZ2V0KGEsICExLCBkKSkgPyBlIDogaVtiXSA6IChmID0gdHlwZW9mIGMgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGMpLCBcXFwic3RyaW5nXFxcIiA9PT0gZiAmJiAoZSA9IFQuZXhlYyhjKSkgJiYgZVsxXSAmJiAoYyA9IFcoYSwgYiwgZSksIGYgPSBcXFwibnVtYmVyXFxcIiksIG51bGwgIT0gYyAmJiBjID09PSBjICYmIChcXFwibnVtYmVyXFxcIiA9PT0gZiAmJiAoYyArPSBlICYmIGVbM10gfHwgKG4uY3NzTnVtYmVyW2hdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKSksIGwuY2xlYXJDbG9uZVN0eWxlIHx8IFxcXCJcXFwiICE9PSBjIHx8IDAgIT09IGIuaW5kZXhPZihcXFwiYmFja2dyb3VuZFxcXCIpIHx8IChpW2JdID0gXFxcImluaGVyaXRcXFwiKSwgZyAmJiBcXFwic2V0XFxcIiBpbiBnICYmIHZvaWQgMCA9PT0gKGMgPSBnLnNldChhLCBjLCBkKSkgfHwgKGlbYl0gPSBjKSksIHZvaWQgMCk7XFxuICAgICAgfVxcbiAgICB9LCBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUsXFxuICAgICAgICAgIGYsXFxuICAgICAgICAgIGcsXFxuICAgICAgICAgIGggPSBuLmNhbWVsQ2FzZShiKTtyZXR1cm4gYiA9IG4uY3NzUHJvcHNbaF0gfHwgKG4uY3NzUHJvcHNbaF0gPSBNYShoKSB8fCBoKSwgZyA9IG4uY3NzSG9va3NbYl0gfHwgbi5jc3NIb29rc1toXSwgZyAmJiBcXFwiZ2V0XFxcIiBpbiBnICYmIChlID0gZy5nZXQoYSwgITAsIGMpKSwgdm9pZCAwID09PSBlICYmIChlID0gRmEoYSwgYiwgZCkpLCBcXFwibm9ybWFsXFxcIiA9PT0gZSAmJiBiIGluIEphICYmIChlID0gSmFbYl0pLCBcXFwiXFxcIiA9PT0gYyB8fCBjID8gKGYgPSBwYXJzZUZsb2F0KGUpLCBjID09PSAhMCB8fCBpc0Zpbml0ZShmKSA/IGYgfHwgMCA6IGUpIDogZTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwiaGVpZ2h0XFxcIiwgXFxcIndpZHRoXFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uY3NzSG9va3NbYl0gPSB7IGdldDogZnVuY3Rpb24gZ2V0KGEsIGMsIGQpIHtcXG4gICAgICAgIHJldHVybiBjID8gSGEudGVzdChuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpKSAmJiAwID09PSBhLm9mZnNldFdpZHRoID8gRGEoYSwgSWEsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcmV0dXJuIFBhKGEsIGIsIGQpO1xcbiAgICAgICAgfSkgOiBQYShhLCBiLCBkKSA6IHZvaWQgMDtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBjLCBkKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBmID0gZCAmJiBDYShhKSxcXG4gICAgICAgICAgICBnID0gZCAmJiBPYShhLCBiLCBkLCBcXFwiYm9yZGVyLWJveFxcXCIgPT09IG4uY3NzKGEsIFxcXCJib3hTaXppbmdcXFwiLCAhMSwgZiksIGYpO3JldHVybiBnICYmIChlID0gVC5leGVjKGMpKSAmJiBcXFwicHhcXFwiICE9PSAoZVszXSB8fCBcXFwicHhcXFwiKSAmJiAoYS5zdHlsZVtiXSA9IGMsIGMgPSBuLmNzcyhhLCBiKSksIE5hKGEsIGMsIGcpO1xcbiAgICAgIH0gfTtcXG4gIH0pLCBuLmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBHYShsLnJlbGlhYmxlTWFyZ2luTGVmdCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyAocGFyc2VGbG9hdChGYShhLCBcXFwibWFyZ2luTGVmdFxcXCIpKSB8fCBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBEYShhLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBhLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XFxuICAgIH0pKSArIFxcXCJweFxcXCIgOiB2b2lkIDA7XFxuICB9KSwgbi5jc3NIb29rcy5tYXJnaW5SaWdodCA9IEdhKGwucmVsaWFibGVNYXJnaW5SaWdodCwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgcmV0dXJuIGIgPyBEYShhLCB7IGRpc3BsYXk6IFxcXCJpbmxpbmUtYmxvY2tcXFwiIH0sIEZhLCBbYSwgXFxcIm1hcmdpblJpZ2h0XFxcIl0pIDogdm9pZCAwO1xcbiAgfSksIG4uZWFjaCh7IG1hcmdpbjogXFxcIlxcXCIsIHBhZGRpbmc6IFxcXCJcXFwiLCBib3JkZXI6IFxcXCJXaWR0aFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1thICsgYl0gPSB7IGV4cGFuZDogZnVuY3Rpb24gZXhwYW5kKGMpIHtcXG4gICAgICAgIGZvciAodmFyIGQgPSAwLCBlID0ge30sIGYgPSBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMuc3BsaXQoXFxcIiBcXFwiKSA6IFtjXTsgNCA+IGQ7IGQrKykge1xcbiAgICAgICAgICBlW2EgKyBVW2RdICsgYl0gPSBmW2RdIHx8IGZbZCAtIDJdIHx8IGZbMF07XFxuICAgICAgICB9cmV0dXJuIGU7XFxuICAgICAgfSB9LCBBYS50ZXN0KGEpIHx8IChuLmNzc0hvb2tzW2EgKyBiXS5zZXQgPSBOYSk7XFxuICB9KSwgbi5mbi5leHRlbmQoeyBjc3M6IGZ1bmN0aW9uIGNzcyhhLCBiKSB7XFxuICAgICAgcmV0dXJuIEsodGhpcywgZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgICAgIHZhciBkLFxcbiAgICAgICAgICAgIGUsXFxuICAgICAgICAgICAgZiA9IHt9LFxcbiAgICAgICAgICAgIGcgPSAwO2lmIChuLmlzQXJyYXkoYikpIHtcXG4gICAgICAgICAgZm9yIChkID0gQ2EoYSksIGUgPSBiLmxlbmd0aDsgZSA+IGc7IGcrKykge1xcbiAgICAgICAgICAgIGZbYltnXV0gPSBuLmNzcyhhLCBiW2ddLCAhMSwgZCk7XFxuICAgICAgICAgIH1yZXR1cm4gZjtcXG4gICAgICAgIH1yZXR1cm4gdm9pZCAwICE9PSBjID8gbi5zdHlsZShhLCBiLCBjKSA6IG4uY3NzKGEsIGIpO1xcbiAgICAgIH0sIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcXG4gICAgICByZXR1cm4gUWEodGhpcywgITApO1xcbiAgICB9LCBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xcbiAgICAgIHJldHVybiBRYSh0aGlzKTtcXG4gICAgfSwgdG9nZ2xlOiBmdW5jdGlvbiB0b2dnbGUoYSkge1xcbiAgICAgIHJldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBhID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBWKHRoaXMpID8gbih0aGlzKS5zaG93KCkgOiBuKHRoaXMpLmhpZGUoKTtcXG4gICAgICB9KTtcXG4gICAgfSB9KTtmdW5jdGlvbiBSYShhLCBiLCBjLCBkLCBlKSB7XFxuICAgIHJldHVybiBuZXcgUmEucHJvdG90eXBlLmluaXQoYSwgYiwgYywgZCwgZSk7XFxuICB9bi5Ud2VlbiA9IFJhLCBSYS5wcm90b3R5cGUgPSB7IGNvbnN0cnVjdG9yOiBSYSwgaW5pdDogZnVuY3Rpb24gaW5pdChhLCBiLCBjLCBkLCBlLCBmKSB7XFxuICAgICAgdGhpcy5lbGVtID0gYSwgdGhpcy5wcm9wID0gYywgdGhpcy5lYXNpbmcgPSBlIHx8IG4uZWFzaW5nLl9kZWZhdWx0LCB0aGlzLm9wdGlvbnMgPSBiLCB0aGlzLnN0YXJ0ID0gdGhpcy5ub3cgPSB0aGlzLmN1cigpLCB0aGlzLmVuZCA9IGQsIHRoaXMudW5pdCA9IGYgfHwgKG4uY3NzTnVtYmVyW2NdID8gXFxcIlxcXCIgOiBcXFwicHhcXFwiKTtcXG4gICAgfSwgY3VyOiBmdW5jdGlvbiBjdXIoKSB7XFxuICAgICAgdmFyIGEgPSBSYS5wcm9wSG9va3NbdGhpcy5wcm9wXTtyZXR1cm4gYSAmJiBhLmdldCA/IGEuZ2V0KHRoaXMpIDogUmEucHJvcEhvb2tzLl9kZWZhdWx0LmdldCh0aGlzKTtcXG4gICAgfSwgcnVuOiBmdW5jdGlvbiBydW4oYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjID0gUmEucHJvcEhvb2tzW3RoaXMucHJvcF07cmV0dXJuIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA/IHRoaXMucG9zID0gYiA9IG4uZWFzaW5nW3RoaXMuZWFzaW5nXShhLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBhLCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb24pIDogdGhpcy5wb3MgPSBiID0gYSwgdGhpcy5ub3cgPSAodGhpcy5lbmQgLSB0aGlzLnN0YXJ0KSAqIGIgKyB0aGlzLnN0YXJ0LCB0aGlzLm9wdGlvbnMuc3RlcCAmJiB0aGlzLm9wdGlvbnMuc3RlcC5jYWxsKHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMpLCBjICYmIGMuc2V0ID8gYy5zZXQodGhpcykgOiBSYS5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KHRoaXMpLCB0aGlzO1xcbiAgICB9IH0sIFJhLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFJhLnByb3RvdHlwZSwgUmEucHJvcEhvb2tzID0geyBfZGVmYXVsdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICB2YXIgYjtyZXR1cm4gMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgIT0gYS5lbGVtW2EucHJvcF0gJiYgbnVsbCA9PSBhLmVsZW0uc3R5bGVbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdIDogKGIgPSBuLmNzcyhhLmVsZW0sIGEucHJvcCwgXFxcIlxcXCIpLCBiICYmIFxcXCJhdXRvXFxcIiAhPT0gYiA/IGIgOiAwKTtcXG4gICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgICBuLmZ4LnN0ZXBbYS5wcm9wXSA/IG4uZnguc3RlcFthLnByb3BdKGEpIDogMSAhPT0gYS5lbGVtLm5vZGVUeXBlIHx8IG51bGwgPT0gYS5lbGVtLnN0eWxlW24uY3NzUHJvcHNbYS5wcm9wXV0gJiYgIW4uY3NzSG9va3NbYS5wcm9wXSA/IGEuZWxlbVthLnByb3BdID0gYS5ub3cgOiBuLnN0eWxlKGEuZWxlbSwgYS5wcm9wLCBhLm5vdyArIGEudW5pdCk7XFxuICAgICAgfSB9IH0sIFJhLnByb3BIb29rcy5zY3JvbGxUb3AgPSBSYS5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSkge1xcbiAgICAgIGEuZWxlbS5ub2RlVHlwZSAmJiBhLmVsZW0ucGFyZW50Tm9kZSAmJiAoYS5lbGVtW2EucHJvcF0gPSBhLm5vdyk7XFxuICAgIH0gfSwgbi5lYXNpbmcgPSB7IGxpbmVhcjogZnVuY3Rpb24gbGluZWFyKGEpIHtcXG4gICAgICByZXR1cm4gYTtcXG4gICAgfSwgc3dpbmc6IGZ1bmN0aW9uIHN3aW5nKGEpIHtcXG4gICAgICByZXR1cm4gLjUgLSBNYXRoLmNvcyhhICogTWF0aC5QSSkgLyAyO1xcbiAgICB9LCBfZGVmYXVsdDogXFxcInN3aW5nXFxcIiB9LCBuLmZ4ID0gUmEucHJvdG90eXBlLmluaXQsIG4uZnguc3RlcCA9IHt9O3ZhciBTYSxcXG4gICAgICBUYSxcXG4gICAgICBVYSA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcXG4gICAgICBWYSA9IC9xdWV1ZUhvb2tzJC87ZnVuY3Rpb24gV2EoKSB7XFxuICAgIHJldHVybiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgIFNhID0gdm9pZCAwO1xcbiAgICB9KSwgU2EgPSBuLm5vdygpO1xcbiAgfWZ1bmN0aW9uIFhhKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gMCxcXG4gICAgICAgIGUgPSB7IGhlaWdodDogYSB9O2ZvciAoYiA9IGIgPyAxIDogMDsgNCA+IGQ7IGQgKz0gMiAtIGIpIHtcXG4gICAgICBjID0gVVtkXSwgZVtcXFwibWFyZ2luXFxcIiArIGNdID0gZVtcXFwicGFkZGluZ1xcXCIgKyBjXSA9IGE7XFxuICAgIH1yZXR1cm4gYiAmJiAoZS5vcGFjaXR5ID0gZS53aWR0aCA9IGEpLCBlO1xcbiAgfWZ1bmN0aW9uIFlhKGEsIGIsIGMpIHtcXG4gICAgZm9yICh2YXIgZCwgZSA9IChfYS50d2VlbmVyc1tiXSB8fCBbXSkuY29uY2F0KF9hLnR3ZWVuZXJzW1xcXCIqXFxcIl0pLCBmID0gMCwgZyA9IGUubGVuZ3RoOyBnID4gZjsgZisrKSB7XFxuICAgICAgaWYgKGQgPSBlW2ZdLmNhbGwoYywgYiwgYSkpIHJldHVybiBkO1xcbiAgICB9XFxuICB9ZnVuY3Rpb24gWmEoYSwgYiwgYykge1xcbiAgICB2YXIgZCxcXG4gICAgICAgIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaixcXG4gICAgICAgIGssXFxuICAgICAgICBsID0gdGhpcyxcXG4gICAgICAgIG0gPSB7fSxcXG4gICAgICAgIG8gPSBhLnN0eWxlLFxcbiAgICAgICAgcCA9IGEubm9kZVR5cGUgJiYgVihhKSxcXG4gICAgICAgIHEgPSBOLmdldChhLCBcXFwiZnhzaG93XFxcIik7Yy5xdWV1ZSB8fCAoaCA9IG4uX3F1ZXVlSG9va3MoYSwgXFxcImZ4XFxcIiksIG51bGwgPT0gaC51bnF1ZXVlZCAmJiAoaC51bnF1ZXVlZCA9IDAsIGkgPSBoLmVtcHR5LmZpcmUsIGguZW1wdHkuZmlyZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBoLnVucXVldWVkIHx8IGkoKTtcXG4gICAgfSksIGgudW5xdWV1ZWQrKywgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIGwuYWx3YXlzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGgudW5xdWV1ZWQtLSwgbi5xdWV1ZShhLCBcXFwiZnhcXFwiKS5sZW5ndGggfHwgaC5lbXB0eS5maXJlKCk7XFxuICAgICAgfSk7XFxuICAgIH0pKSwgMSA9PT0gYS5ub2RlVHlwZSAmJiAoXFxcImhlaWdodFxcXCIgaW4gYiB8fCBcXFwid2lkdGhcXFwiIGluIGIpICYmIChjLm92ZXJmbG93ID0gW28ub3ZlcmZsb3csIG8ub3ZlcmZsb3dYLCBvLm92ZXJmbG93WV0sIGogPSBuLmNzcyhhLCBcXFwiZGlzcGxheVxcXCIpLCBrID0gXFxcIm5vbmVcXFwiID09PSBqID8gTi5nZXQoYSwgXFxcIm9sZGRpc3BsYXlcXFwiKSB8fCB6YShhLm5vZGVOYW1lKSA6IGosIFxcXCJpbmxpbmVcXFwiID09PSBrICYmIFxcXCJub25lXFxcIiA9PT0gbi5jc3MoYSwgXFxcImZsb2F0XFxcIikgJiYgKG8uZGlzcGxheSA9IFxcXCJpbmxpbmUtYmxvY2tcXFwiKSksIGMub3ZlcmZsb3cgJiYgKG8ub3ZlcmZsb3cgPSBcXFwiaGlkZGVuXFxcIiwgbC5hbHdheXMoZnVuY3Rpb24gKCkge1xcbiAgICAgIG8ub3ZlcmZsb3cgPSBjLm92ZXJmbG93WzBdLCBvLm92ZXJmbG93WCA9IGMub3ZlcmZsb3dbMV0sIG8ub3ZlcmZsb3dZID0gYy5vdmVyZmxvd1syXTtcXG4gICAgfSkpO2ZvciAoZCBpbiBiKSB7XFxuICAgICAgaWYgKGUgPSBiW2RdLCBVYS5leGVjKGUpKSB7XFxuICAgICAgICBpZiAoZGVsZXRlIGJbZF0sIGYgPSBmIHx8IFxcXCJ0b2dnbGVcXFwiID09PSBlLCBlID09PSAocCA/IFxcXCJoaWRlXFxcIiA6IFxcXCJzaG93XFxcIikpIHtcXG4gICAgICAgICAgaWYgKFxcXCJzaG93XFxcIiAhPT0gZSB8fCAhcSB8fCB2b2lkIDAgPT09IHFbZF0pIGNvbnRpbnVlO3AgPSAhMDtcXG4gICAgICAgIH1tW2RdID0gcSAmJiBxW2RdIHx8IG4uc3R5bGUoYSwgZCk7XFxuICAgICAgfSBlbHNlIGogPSB2b2lkIDA7XFxuICAgIH1pZiAobi5pc0VtcHR5T2JqZWN0KG0pKSBcXFwiaW5saW5lXFxcIiA9PT0gKFxcXCJub25lXFxcIiA9PT0gaiA/IHphKGEubm9kZU5hbWUpIDogaikgJiYgKG8uZGlzcGxheSA9IGopO2Vsc2Uge1xcbiAgICAgIHEgPyBcXFwiaGlkZGVuXFxcIiBpbiBxICYmIChwID0gcS5oaWRkZW4pIDogcSA9IE4uYWNjZXNzKGEsIFxcXCJmeHNob3dcXFwiLCB7fSksIGYgJiYgKHEuaGlkZGVuID0gIXApLCBwID8gbihhKS5zaG93KCkgOiBsLmRvbmUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgbihhKS5oaWRlKCk7XFxuICAgICAgfSksIGwuZG9uZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYjtOLnJlbW92ZShhLCBcXFwiZnhzaG93XFxcIik7Zm9yIChiIGluIG0pIHtcXG4gICAgICAgICAgbi5zdHlsZShhLCBiLCBtW2JdKTtcXG4gICAgICAgIH1cXG4gICAgICB9KTtmb3IgKGQgaW4gbSkge1xcbiAgICAgICAgZyA9IFlhKHAgPyBxW2RdIDogMCwgZCwgbCksIGQgaW4gcSB8fCAocVtkXSA9IGcuc3RhcnQsIHAgJiYgKGcuZW5kID0gZy5zdGFydCwgZy5zdGFydCA9IFxcXCJ3aWR0aFxcXCIgPT09IGQgfHwgXFxcImhlaWdodFxcXCIgPT09IGQgPyAxIDogMCkpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfWZ1bmN0aW9uICRhKGEsIGIpIHtcXG4gICAgdmFyIGMsIGQsIGUsIGYsIGc7Zm9yIChjIGluIGEpIHtcXG4gICAgICBpZiAoZCA9IG4uY2FtZWxDYXNlKGMpLCBlID0gYltkXSwgZiA9IGFbY10sIG4uaXNBcnJheShmKSAmJiAoZSA9IGZbMV0sIGYgPSBhW2NdID0gZlswXSksIGMgIT09IGQgJiYgKGFbZF0gPSBmLCBkZWxldGUgYVtjXSksIGcgPSBuLmNzc0hvb2tzW2RdLCBnICYmIFxcXCJleHBhbmRcXFwiIGluIGcpIHtcXG4gICAgICAgIGYgPSBnLmV4cGFuZChmKSwgZGVsZXRlIGFbZF07Zm9yIChjIGluIGYpIHtcXG4gICAgICAgICAgYyBpbiBhIHx8IChhW2NdID0gZltjXSwgYltjXSA9IGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSBiW2RdID0gZTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIF9hKGEsIGIsIGMpIHtcXG4gICAgdmFyIGQsXFxuICAgICAgICBlLFxcbiAgICAgICAgZiA9IDAsXFxuICAgICAgICBnID0gX2EucHJlZmlsdGVycy5sZW5ndGgsXFxuICAgICAgICBoID0gbi5EZWZlcnJlZCgpLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgZGVsZXRlIGkuZWxlbTtcXG4gICAgfSksXFxuICAgICAgICBpID0gZnVuY3Rpb24gaSgpIHtcXG4gICAgICBpZiAoZSkgcmV0dXJuICExO2ZvciAodmFyIGIgPSBTYSB8fCBXYSgpLCBjID0gTWF0aC5tYXgoMCwgai5zdGFydFRpbWUgKyBqLmR1cmF0aW9uIC0gYiksIGQgPSBjIC8gai5kdXJhdGlvbiB8fCAwLCBmID0gMSAtIGQsIGcgPSAwLCBpID0gai50d2VlbnMubGVuZ3RoOyBpID4gZzsgZysrKSB7XFxuICAgICAgICBqLnR3ZWVuc1tnXS5ydW4oZik7XFxuICAgICAgfXJldHVybiBoLm5vdGlmeVdpdGgoYSwgW2osIGYsIGNdKSwgMSA+IGYgJiYgaSA/IGMgOiAoaC5yZXNvbHZlV2l0aChhLCBbal0pLCAhMSk7XFxuICAgIH0sXFxuICAgICAgICBqID0gaC5wcm9taXNlKHsgZWxlbTogYSwgcHJvcHM6IG4uZXh0ZW5kKHt9LCBiKSwgb3B0czogbi5leHRlbmQoITAsIHsgc3BlY2lhbEVhc2luZzoge30sIGVhc2luZzogbi5lYXNpbmcuX2RlZmF1bHQgfSwgYyksIG9yaWdpbmFsUHJvcGVydGllczogYiwgb3JpZ2luYWxPcHRpb25zOiBjLCBzdGFydFRpbWU6IFNhIHx8IFdhKCksIGR1cmF0aW9uOiBjLmR1cmF0aW9uLCB0d2VlbnM6IFtdLCBjcmVhdGVUd2VlbjogZnVuY3Rpb24gY3JlYXRlVHdlZW4oYiwgYykge1xcbiAgICAgICAgdmFyIGQgPSBuLlR3ZWVuKGEsIGoub3B0cywgYiwgYywgai5vcHRzLnNwZWNpYWxFYXNpbmdbYl0gfHwgai5vcHRzLmVhc2luZyk7cmV0dXJuIGoudHdlZW5zLnB1c2goZCksIGQ7XFxuICAgICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChiKSB7XFxuICAgICAgICB2YXIgYyA9IDAsXFxuICAgICAgICAgICAgZCA9IGIgPyBqLnR3ZWVucy5sZW5ndGggOiAwO2lmIChlKSByZXR1cm4gdGhpcztmb3IgKGUgPSAhMDsgZCA+IGM7IGMrKykge1xcbiAgICAgICAgICBqLnR3ZWVuc1tjXS5ydW4oMSk7XFxuICAgICAgICB9cmV0dXJuIGIgPyAoaC5ub3RpZnlXaXRoKGEsIFtqLCAxLCAwXSksIGgucmVzb2x2ZVdpdGgoYSwgW2osIGJdKSkgOiBoLnJlamVjdFdpdGgoYSwgW2osIGJdKSwgdGhpcztcXG4gICAgICB9IH0pLFxcbiAgICAgICAgayA9IGoucHJvcHM7Zm9yICgkYShrLCBqLm9wdHMuc3BlY2lhbEVhc2luZyk7IGcgPiBmOyBmKyspIHtcXG4gICAgICBpZiAoZCA9IF9hLnByZWZpbHRlcnNbZl0uY2FsbChqLCBhLCBrLCBqLm9wdHMpKSByZXR1cm4gbi5pc0Z1bmN0aW9uKGQuc3RvcCkgJiYgKG4uX3F1ZXVlSG9va3Moai5lbGVtLCBqLm9wdHMucXVldWUpLnN0b3AgPSBuLnByb3h5KGQuc3RvcCwgZCkpLCBkO1xcbiAgICB9cmV0dXJuIG4ubWFwKGssIFlhLCBqKSwgbi5pc0Z1bmN0aW9uKGoub3B0cy5zdGFydCkgJiYgai5vcHRzLnN0YXJ0LmNhbGwoYSwgaiksIG4uZngudGltZXIobi5leHRlbmQoaSwgeyBlbGVtOiBhLCBhbmltOiBqLCBxdWV1ZTogai5vcHRzLnF1ZXVlIH0pKSwgai5wcm9ncmVzcyhqLm9wdHMucHJvZ3Jlc3MpLmRvbmUoai5vcHRzLmRvbmUsIGoub3B0cy5jb21wbGV0ZSkuZmFpbChqLm9wdHMuZmFpbCkuYWx3YXlzKGoub3B0cy5hbHdheXMpO1xcbiAgfW4uQW5pbWF0aW9uID0gbi5leHRlbmQoX2EsIHsgdHdlZW5lcnM6IHsgXFxcIipcXFwiOiBbZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgICAgIHZhciBjID0gdGhpcy5jcmVhdGVUd2VlbihhLCBiKTtyZXR1cm4gVyhjLmVsZW0sIGEsIFQuZXhlYyhiKSwgYyksIGM7XFxuICAgICAgfV0gfSwgdHdlZW5lcjogZnVuY3Rpb24gdHdlZW5lcihhLCBiKSB7XFxuICAgICAgbi5pc0Z1bmN0aW9uKGEpID8gKGIgPSBhLCBhID0gW1xcXCIqXFxcIl0pIDogYSA9IGEubWF0Y2goRyk7Zm9yICh2YXIgYywgZCA9IDAsIGUgPSBhLmxlbmd0aDsgZSA+IGQ7IGQrKykge1xcbiAgICAgICAgYyA9IGFbZF0sIF9hLnR3ZWVuZXJzW2NdID0gX2EudHdlZW5lcnNbY10gfHwgW10sIF9hLnR3ZWVuZXJzW2NdLnVuc2hpZnQoYik7XFxuICAgICAgfVxcbiAgICB9LCBwcmVmaWx0ZXJzOiBbWmFdLCBwcmVmaWx0ZXI6IGZ1bmN0aW9uIHByZWZpbHRlcihhLCBiKSB7XFxuICAgICAgYiA/IF9hLnByZWZpbHRlcnMudW5zaGlmdChhKSA6IF9hLnByZWZpbHRlcnMucHVzaChhKTtcXG4gICAgfSB9KSwgbi5zcGVlZCA9IGZ1bmN0aW9uIChhLCBiLCBjKSB7XFxuICAgIHZhciBkID0gYSAmJiBcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpKSA/IG4uZXh0ZW5kKHt9LCBhKSA6IHsgY29tcGxldGU6IGMgfHwgIWMgJiYgYiB8fCBuLmlzRnVuY3Rpb24oYSkgJiYgYSwgZHVyYXRpb246IGEsIGVhc2luZzogYyAmJiBiIHx8IGIgJiYgIW4uaXNGdW5jdGlvbihiKSAmJiBiIH07cmV0dXJuIGQuZHVyYXRpb24gPSBuLmZ4Lm9mZiA/IDAgOiBcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgZC5kdXJhdGlvbiA/IGQuZHVyYXRpb24gOiBkLmR1cmF0aW9uIGluIG4uZnguc3BlZWRzID8gbi5meC5zcGVlZHNbZC5kdXJhdGlvbl0gOiBuLmZ4LnNwZWVkcy5fZGVmYXVsdCwgbnVsbCAhPSBkLnF1ZXVlICYmIGQucXVldWUgIT09ICEwIHx8IChkLnF1ZXVlID0gXFxcImZ4XFxcIiksIGQub2xkID0gZC5jb21wbGV0ZSwgZC5jb21wbGV0ZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBuLmlzRnVuY3Rpb24oZC5vbGQpICYmIGQub2xkLmNhbGwodGhpcyksIGQucXVldWUgJiYgbi5kZXF1ZXVlKHRoaXMsIGQucXVldWUpO1xcbiAgICB9LCBkO1xcbiAgfSwgbi5mbi5leHRlbmQoeyBmYWRlVG86IGZ1bmN0aW9uIGZhZGVUbyhhLCBiLCBjLCBkKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKFYpLmNzcyhcXFwib3BhY2l0eVxcXCIsIDApLnNob3coKS5lbmQoKS5hbmltYXRlKHsgb3BhY2l0eTogYiB9LCBhLCBjLCBkKTtcXG4gICAgfSwgYW5pbWF0ZTogZnVuY3Rpb24gYW5pbWF0ZShhLCBiLCBjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBuLmlzRW1wdHlPYmplY3QoYSksXFxuICAgICAgICAgIGYgPSBuLnNwZWVkKGIsIGMsIGQpLFxcbiAgICAgICAgICBnID0gZnVuY3Rpb24gZygpIHtcXG4gICAgICAgIHZhciBiID0gX2EodGhpcywgbi5leHRlbmQoe30sIGEpLCBmKTsoZSB8fCBOLmdldCh0aGlzLCBcXFwiZmluaXNoXFxcIikpICYmIGIuc3RvcCghMCk7XFxuICAgICAgfTtyZXR1cm4gZy5maW5pc2ggPSBnLCBlIHx8IGYucXVldWUgPT09ICExID8gdGhpcy5lYWNoKGcpIDogdGhpcy5xdWV1ZShmLnF1ZXVlLCBnKTtcXG4gICAgfSwgc3RvcDogZnVuY3Rpb24gc3RvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBmdW5jdGlvbiBkKGEpIHtcXG4gICAgICAgIHZhciBiID0gYS5zdG9wO2RlbGV0ZSBhLnN0b3AsIGIoYyk7XFxuICAgICAgfTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgKGMgPSBiLCBiID0gYSwgYSA9IHZvaWQgMCksIGIgJiYgYSAhPT0gITEgJiYgdGhpcy5xdWV1ZShhIHx8IFxcXCJmeFxcXCIsIFtdKSwgdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBiID0gITAsXFxuICAgICAgICAgICAgZSA9IG51bGwgIT0gYSAmJiBhICsgXFxcInF1ZXVlSG9va3NcXFwiLFxcbiAgICAgICAgICAgIGYgPSBuLnRpbWVycyxcXG4gICAgICAgICAgICBnID0gTi5nZXQodGhpcyk7aWYgKGUpIGdbZV0gJiYgZ1tlXS5zdG9wICYmIGQoZ1tlXSk7ZWxzZSBmb3IgKGUgaW4gZykge1xcbiAgICAgICAgICBnW2VdICYmIGdbZV0uc3RvcCAmJiBWYS50ZXN0KGUpICYmIGQoZ1tlXSk7XFxuICAgICAgICB9Zm9yIChlID0gZi5sZW5ndGg7IGUtLTspIHtcXG4gICAgICAgICAgZltlXS5lbGVtICE9PSB0aGlzIHx8IG51bGwgIT0gYSAmJiBmW2VdLnF1ZXVlICE9PSBhIHx8IChmW2VdLmFuaW0uc3RvcChjKSwgYiA9ICExLCBmLnNwbGljZShlLCAxKSk7XFxuICAgICAgICB9IWIgJiYgYyB8fCBuLmRlcXVldWUodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0sIGZpbmlzaDogZnVuY3Rpb24gZmluaXNoKGEpIHtcXG4gICAgICByZXR1cm4gYSAhPT0gITEgJiYgKGEgPSBhIHx8IFxcXCJmeFxcXCIpLCB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIsXFxuICAgICAgICAgICAgYyA9IE4uZ2V0KHRoaXMpLFxcbiAgICAgICAgICAgIGQgPSBjW2EgKyBcXFwicXVldWVcXFwiXSxcXG4gICAgICAgICAgICBlID0gY1thICsgXFxcInF1ZXVlSG9va3NcXFwiXSxcXG4gICAgICAgICAgICBmID0gbi50aW1lcnMsXFxuICAgICAgICAgICAgZyA9IGQgPyBkLmxlbmd0aCA6IDA7Zm9yIChjLmZpbmlzaCA9ICEwLCBuLnF1ZXVlKHRoaXMsIGEsIFtdKSwgZSAmJiBlLnN0b3AgJiYgZS5zdG9wLmNhbGwodGhpcywgITApLCBiID0gZi5sZW5ndGg7IGItLTspIHtcXG4gICAgICAgICAgZltiXS5lbGVtID09PSB0aGlzICYmIGZbYl0ucXVldWUgPT09IGEgJiYgKGZbYl0uYW5pbS5zdG9wKCEwKSwgZi5zcGxpY2UoYiwgMSkpO1xcbiAgICAgICAgfWZvciAoYiA9IDA7IGcgPiBiOyBiKyspIHtcXG4gICAgICAgICAgZFtiXSAmJiBkW2JdLmZpbmlzaCAmJiBkW2JdLmZpbmlzaC5jYWxsKHRoaXMpO1xcbiAgICAgICAgfWRlbGV0ZSBjLmZpbmlzaDtcXG4gICAgICB9KTtcXG4gICAgfSB9KSwgbi5lYWNoKFtcXFwidG9nZ2xlXFxcIiwgXFxcInNob3dcXFwiLCBcXFwiaGlkZVxcXCJdLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICB2YXIgYyA9IG4uZm5bYl07bi5mbltiXSA9IGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgcmV0dXJuIG51bGwgPT0gYSB8fCBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGEgPyBjLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiB0aGlzLmFuaW1hdGUoWGEoYiwgITApLCBhLCBkLCBlKTtcXG4gICAgfTtcXG4gIH0pLCBuLmVhY2goeyBzbGlkZURvd246IFhhKFxcXCJzaG93XFxcIiksIHNsaWRlVXA6IFhhKFxcXCJoaWRlXFxcIiksIHNsaWRlVG9nZ2xlOiBYYShcXFwidG9nZ2xlXFxcIiksIGZhZGVJbjogeyBvcGFjaXR5OiBcXFwic2hvd1xcXCIgfSwgZmFkZU91dDogeyBvcGFjaXR5OiBcXFwiaGlkZVxcXCIgfSwgZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcXFwidG9nZ2xlXFxcIiB9IH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZm5bYV0gPSBmdW5jdGlvbiAoYSwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLmFuaW1hdGUoYiwgYSwgYywgZCk7XFxuICAgIH07XFxuICB9KSwgbi50aW1lcnMgPSBbXSwgbi5meC50aWNrID0gZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgYSxcXG4gICAgICAgIGIgPSAwLFxcbiAgICAgICAgYyA9IG4udGltZXJzO2ZvciAoU2EgPSBuLm5vdygpOyBiIDwgYy5sZW5ndGg7IGIrKykge1xcbiAgICAgIGEgPSBjW2JdLCBhKCkgfHwgY1tiXSAhPT0gYSB8fCBjLnNwbGljZShiLS0sIDEpO1xcbiAgICB9Yy5sZW5ndGggfHwgbi5meC5zdG9wKCksIFNhID0gdm9pZCAwO1xcbiAgfSwgbi5meC50aW1lciA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIG4udGltZXJzLnB1c2goYSksIGEoKSA/IG4uZnguc3RhcnQoKSA6IG4udGltZXJzLnBvcCgpO1xcbiAgfSwgbi5meC5pbnRlcnZhbCA9IDEzLCBuLmZ4LnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICBUYSB8fCAoVGEgPSBhLnNldEludGVydmFsKG4uZngudGljaywgbi5meC5pbnRlcnZhbCkpO1xcbiAgfSwgbi5meC5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICBhLmNsZWFySW50ZXJ2YWwoVGEpLCBUYSA9IG51bGw7XFxuICB9LCBuLmZ4LnNwZWVkcyA9IHsgc2xvdzogNjAwLCBmYXN0OiAyMDAsIF9kZWZhdWx0OiA0MDAgfSwgbi5mbi5kZWxheSA9IGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgIHJldHVybiBiID0gbi5meCA/IG4uZnguc3BlZWRzW2JdIHx8IGIgOiBiLCBjID0gYyB8fCBcXFwiZnhcXFwiLCB0aGlzLnF1ZXVlKGMsIGZ1bmN0aW9uIChjLCBkKSB7XFxuICAgICAgdmFyIGUgPSBhLnNldFRpbWVvdXQoYywgYik7ZC5zdG9wID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYS5jbGVhclRpbWVvdXQoZSk7XFxuICAgICAgfTtcXG4gICAgfSk7XFxuICB9LCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLFxcbiAgICAgICAgYiA9IGQuY3JlYXRlRWxlbWVudChcXFwic2VsZWN0XFxcIiksXFxuICAgICAgICBjID0gYi5hcHBlbmRDaGlsZChkLmNyZWF0ZUVsZW1lbnQoXFxcIm9wdGlvblxcXCIpKTthLnR5cGUgPSBcXFwiY2hlY2tib3hcXFwiLCBsLmNoZWNrT24gPSBcXFwiXFxcIiAhPT0gYS52YWx1ZSwgbC5vcHRTZWxlY3RlZCA9IGMuc2VsZWN0ZWQsIGIuZGlzYWJsZWQgPSAhMCwgbC5vcHREaXNhYmxlZCA9ICFjLmRpc2FibGVkLCBhID0gZC5jcmVhdGVFbGVtZW50KFxcXCJpbnB1dFxcXCIpLCBhLnZhbHVlID0gXFxcInRcXFwiLCBhLnR5cGUgPSBcXFwicmFkaW9cXFwiLCBsLnJhZGlvVmFsdWUgPSBcXFwidFxcXCIgPT09IGEudmFsdWU7XFxuICB9KCk7dmFyIGFiLFxcbiAgICAgIGJiID0gbi5leHByLmF0dHJIYW5kbGU7bi5mbi5leHRlbmQoeyBhdHRyOiBmdW5jdGlvbiBhdHRyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBuLmF0dHIsIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgcmVtb3ZlQXR0cjogZnVuY3Rpb24gcmVtb3ZlQXR0cihhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLnJlbW92ZUF0dHIodGhpcywgYSk7XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgYXR0cjogZnVuY3Rpb24gYXR0cihhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmICgzICE9PSBmICYmIDggIT09IGYgJiYgMiAhPT0gZikgcmV0dXJuIFxcXCJ1bmRlZmluZWRcXFwiID09IHR5cGVvZiBhLmdldEF0dHJpYnV0ZSA/IG4ucHJvcChhLCBiLCBjKSA6ICgxID09PSBmICYmIG4uaXNYTUxEb2MoYSkgfHwgKGIgPSBiLnRvTG93ZXJDYXNlKCksIGUgPSBuLmF0dHJIb29rc1tiXSB8fCAobi5leHByLm1hdGNoLmJvb2wudGVzdChiKSA/IGFiIDogdm9pZCAwKSksIHZvaWQgMCAhPT0gYyA/IG51bGwgPT09IGMgPyB2b2lkIG4ucmVtb3ZlQXR0cihhLCBiKSA6IGUgJiYgXFxcInNldFxcXCIgaW4gZSAmJiB2b2lkIDAgIT09IChkID0gZS5zZXQoYSwgYywgYikpID8gZCA6IChhLnNldEF0dHJpYnV0ZShiLCBjICsgXFxcIlxcXCIpLCBjKSA6IGUgJiYgXFxcImdldFxcXCIgaW4gZSAmJiBudWxsICE9PSAoZCA9IGUuZ2V0KGEsIGIpKSA/IGQgOiAoZCA9IG4uZmluZC5hdHRyKGEsIGIpLCBudWxsID09IGQgPyB2b2lkIDAgOiBkKSk7XFxuICAgIH0sIGF0dHJIb29rczogeyB0eXBlOiB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgICAgaWYgKCFsLnJhZGlvVmFsdWUgJiYgXFxcInJhZGlvXFxcIiA9PT0gYiAmJiBuLm5vZGVOYW1lKGEsIFxcXCJpbnB1dFxcXCIpKSB7XFxuICAgICAgICAgICAgdmFyIGMgPSBhLnZhbHVlO3JldHVybiBhLnNldEF0dHJpYnV0ZShcXFwidHlwZVxcXCIsIGIpLCBjICYmIChhLnZhbHVlID0gYyksIGI7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gfSB9LCByZW1vdmVBdHRyOiBmdW5jdGlvbiByZW1vdmVBdHRyKGEsIGIpIHtcXG4gICAgICB2YXIgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiICYmIGIubWF0Y2goRyk7aWYgKGYgJiYgMSA9PT0gYS5ub2RlVHlwZSkgd2hpbGUgKGMgPSBmW2UrK10pIHtcXG4gICAgICAgIGQgPSBuLnByb3BGaXhbY10gfHwgYywgbi5leHByLm1hdGNoLmJvb2wudGVzdChjKSAmJiAoYVtkXSA9ICExKSwgYS5yZW1vdmVBdHRyaWJ1dGUoYyk7XFxuICAgICAgfVxcbiAgICB9IH0pLCBhYiA9IHsgc2V0OiBmdW5jdGlvbiBzZXQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiBiID09PSAhMSA/IG4ucmVtb3ZlQXR0cihhLCBjKSA6IGEuc2V0QXR0cmlidXRlKGMsIGMpLCBjO1xcbiAgICB9IH0sIG4uZWFjaChuLmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goL1xcXFx3Ky9nKSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBiYltiXSB8fCBuLmZpbmQuYXR0cjtiYltiXSA9IGZ1bmN0aW9uIChhLCBiLCBkKSB7XFxuICAgICAgdmFyIGUsIGY7cmV0dXJuIGQgfHwgKGYgPSBiYltiXSwgYmJbYl0gPSBlLCBlID0gbnVsbCAhPSBjKGEsIGIsIGQpID8gYi50b0xvd2VyQ2FzZSgpIDogbnVsbCwgYmJbYl0gPSBmKSwgZTtcXG4gICAgfTtcXG4gIH0pO3ZhciBjYiA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXFxuICAgICAgZGIgPSAvXig/OmF8YXJlYSkkL2k7bi5mbi5leHRlbmQoeyBwcm9wOiBmdW5jdGlvbiBwcm9wKGEsIGIpIHtcXG4gICAgICByZXR1cm4gSyh0aGlzLCBuLnByb3AsIGEsIGIsIGFyZ3VtZW50cy5sZW5ndGggPiAxKTtcXG4gICAgfSwgcmVtb3ZlUHJvcDogZnVuY3Rpb24gcmVtb3ZlUHJvcChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBkZWxldGUgdGhpc1tuLnByb3BGaXhbYV0gfHwgYV07XFxuICAgICAgfSk7XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgcHJvcDogZnVuY3Rpb24gcHJvcChhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQsXFxuICAgICAgICAgIGUsXFxuICAgICAgICAgIGYgPSBhLm5vZGVUeXBlO2lmICgzICE9PSBmICYmIDggIT09IGYgJiYgMiAhPT0gZikgcmV0dXJuIDEgPT09IGYgJiYgbi5pc1hNTERvYyhhKSB8fCAoYiA9IG4ucHJvcEZpeFtiXSB8fCBiLCBlID0gbi5wcm9wSG9va3NbYl0pLCB2b2lkIDAgIT09IGMgPyBlICYmIFxcXCJzZXRcXFwiIGluIGUgJiYgdm9pZCAwICE9PSAoZCA9IGUuc2V0KGEsIGMsIGIpKSA/IGQgOiBhW2JdID0gYyA6IGUgJiYgXFxcImdldFxcXCIgaW4gZSAmJiBudWxsICE9PSAoZCA9IGUuZ2V0KGEsIGIpKSA/IGQgOiBhW2JdO1xcbiAgICB9LCBwcm9wSG9va3M6IHsgdGFiSW5kZXg6IHsgZ2V0OiBmdW5jdGlvbiBnZXQoYSkge1xcbiAgICAgICAgICB2YXIgYiA9IG4uZmluZC5hdHRyKGEsIFxcXCJ0YWJpbmRleFxcXCIpO3JldHVybiBiID8gcGFyc2VJbnQoYiwgMTApIDogY2IudGVzdChhLm5vZGVOYW1lKSB8fCBkYi50ZXN0KGEubm9kZU5hbWUpICYmIGEuaHJlZiA/IDAgOiAtMTtcXG4gICAgICAgIH0gfSB9LCBwcm9wRml4OiB7IFxcXCJmb3JcXFwiOiBcXFwiaHRtbEZvclxcXCIsIFxcXCJjbGFzc1xcXCI6IFxcXCJjbGFzc05hbWVcXFwiIH0gfSksIGwub3B0U2VsZWN0ZWQgfHwgKG4ucHJvcEhvb2tzLnNlbGVjdGVkID0geyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7cmV0dXJuIGIgJiYgYi5wYXJlbnROb2RlICYmIGIucGFyZW50Tm9kZS5zZWxlY3RlZEluZGV4LCBudWxsO1xcbiAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhKSB7XFxuICAgICAgdmFyIGIgPSBhLnBhcmVudE5vZGU7YiAmJiAoYi5zZWxlY3RlZEluZGV4LCBiLnBhcmVudE5vZGUgJiYgYi5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXgpO1xcbiAgICB9IH0pLCBuLmVhY2goW1xcXCJ0YWJJbmRleFxcXCIsIFxcXCJyZWFkT25seVxcXCIsIFxcXCJtYXhMZW5ndGhcXFwiLCBcXFwiY2VsbFNwYWNpbmdcXFwiLCBcXFwiY2VsbFBhZGRpbmdcXFwiLCBcXFwicm93U3BhblxcXCIsIFxcXCJjb2xTcGFuXFxcIiwgXFxcInVzZU1hcFxcXCIsIFxcXCJmcmFtZUJvcmRlclxcXCIsIFxcXCJjb250ZW50RWRpdGFibGVcXFwiXSwgZnVuY3Rpb24gKCkge1xcbiAgICBuLnByb3BGaXhbdGhpcy50b0xvd2VyQ2FzZSgpXSA9IHRoaXM7XFxuICB9KTt2YXIgZWIgPSAvW1xcXFx0XFxcXHJcXFxcblxcXFxmXS9nO2Z1bmN0aW9uIGZiKGEpIHtcXG4gICAgcmV0dXJuIGEuZ2V0QXR0cmlidXRlICYmIGEuZ2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIpIHx8IFxcXCJcXFwiO1xcbiAgfW4uZm4uZXh0ZW5kKHsgYWRkQ2xhc3M6IGZ1bmN0aW9uIGFkZENsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSA9IDA7aWYgKG4uaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS5hZGRDbGFzcyhhLmNhbGwodGhpcywgYiwgZmIodGhpcykpKTtcXG4gICAgICB9KTtpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIGEgJiYgYSkge1xcbiAgICAgICAgYiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGMgPSB0aGlzW2krK10pIHtcXG4gICAgICAgICAgaWYgKGUgPSBmYihjKSwgZCA9IDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGUgKyBcXFwiIFxcXCIpLnJlcGxhY2UoZWIsIFxcXCIgXFxcIikpIHtcXG4gICAgICAgICAgICBnID0gMDt3aGlsZSAoZiA9IGJbZysrXSkge1xcbiAgICAgICAgICAgICAgZC5pbmRleE9mKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIpIDwgMCAmJiAoZCArPSBmICsgXFxcIiBcXFwiKTtcXG4gICAgICAgICAgICB9aCA9IG4udHJpbShkKSwgZSAhPT0gaCAmJiBjLnNldEF0dHJpYnV0ZShcXFwiY2xhc3NcXFwiLCBoKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gdGhpcztcXG4gICAgfSwgcmVtb3ZlQ2xhc3M6IGZ1bmN0aW9uIHJlbW92ZUNsYXNzKGEpIHtcXG4gICAgICB2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSA9IDA7aWYgKG4uaXNGdW5jdGlvbihhKSkgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS5yZW1vdmVDbGFzcyhhLmNhbGwodGhpcywgYiwgZmIodGhpcykpKTtcXG4gICAgICB9KTtpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHJldHVybiB0aGlzLmF0dHIoXFxcImNsYXNzXFxcIiwgXFxcIlxcXCIpO2lmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYSAmJiBhKSB7XFxuICAgICAgICBiID0gYS5tYXRjaChHKSB8fCBbXTt3aGlsZSAoYyA9IHRoaXNbaSsrXSkge1xcbiAgICAgICAgICBpZiAoZSA9IGZiKGMpLCBkID0gMSA9PT0gYy5ub2RlVHlwZSAmJiAoXFxcIiBcXFwiICsgZSArIFxcXCIgXFxcIikucmVwbGFjZShlYiwgXFxcIiBcXFwiKSkge1xcbiAgICAgICAgICAgIGcgPSAwO3doaWxlIChmID0gYltnKytdKSB7XFxuICAgICAgICAgICAgICB3aGlsZSAoZC5pbmRleE9mKFxcXCIgXFxcIiArIGYgKyBcXFwiIFxcXCIpID4gLTEpIHtcXG4gICAgICAgICAgICAgICAgZCA9IGQucmVwbGFjZShcXFwiIFxcXCIgKyBmICsgXFxcIiBcXFwiLCBcXFwiIFxcXCIpO1xcbiAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1oID0gbi50cmltKGQpLCBlICE9PSBoICYmIGMuc2V0QXR0cmlidXRlKFxcXCJjbGFzc1xcXCIsIGgpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfXJldHVybiB0aGlzO1xcbiAgICB9LCB0b2dnbGVDbGFzczogZnVuY3Rpb24gdG9nZ2xlQ2xhc3MoYSwgYikge1xcbiAgICAgIHZhciBjID0gdHlwZW9mIGEgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGEpO3JldHVybiBcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGIgJiYgXFxcInN0cmluZ1xcXCIgPT09IGMgPyBiID8gdGhpcy5hZGRDbGFzcyhhKSA6IHRoaXMucmVtb3ZlQ2xhc3MoYSkgOiBuLmlzRnVuY3Rpb24oYSkgPyB0aGlzLmVhY2goZnVuY3Rpb24gKGMpIHtcXG4gICAgICAgIG4odGhpcykudG9nZ2xlQ2xhc3MoYS5jYWxsKHRoaXMsIGMsIGZiKHRoaXMpLCBiKSwgYik7XFxuICAgICAgfSkgOiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGIsIGQsIGUsIGY7aWYgKFxcXCJzdHJpbmdcXFwiID09PSBjKSB7XFxuICAgICAgICAgIGQgPSAwLCBlID0gbih0aGlzKSwgZiA9IGEubWF0Y2goRykgfHwgW107d2hpbGUgKGIgPSBmW2QrK10pIHtcXG4gICAgICAgICAgICBlLmhhc0NsYXNzKGIpID8gZS5yZW1vdmVDbGFzcyhiKSA6IGUuYWRkQ2xhc3MoYik7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0gZWxzZSB2b2lkIDAgIT09IGEgJiYgXFxcImJvb2xlYW5cXFwiICE9PSBjIHx8IChiID0gZmIodGhpcyksIGIgJiYgTi5zZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiLCBiKSwgdGhpcy5zZXRBdHRyaWJ1dGUgJiYgdGhpcy5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgYiB8fCBhID09PSAhMSA/IFxcXCJcXFwiIDogTi5nZXQodGhpcywgXFxcIl9fY2xhc3NOYW1lX19cXFwiKSB8fCBcXFwiXFxcIikpO1xcbiAgICAgIH0pO1xcbiAgICB9LCBoYXNDbGFzczogZnVuY3Rpb24gaGFzQ2xhc3MoYSkge1xcbiAgICAgIHZhciBiLFxcbiAgICAgICAgICBjLFxcbiAgICAgICAgICBkID0gMDtiID0gXFxcIiBcXFwiICsgYSArIFxcXCIgXFxcIjt3aGlsZSAoYyA9IHRoaXNbZCsrXSkge1xcbiAgICAgICAgaWYgKDEgPT09IGMubm9kZVR5cGUgJiYgKFxcXCIgXFxcIiArIGZiKGMpICsgXFxcIiBcXFwiKS5yZXBsYWNlKGViLCBcXFwiIFxcXCIpLmluZGV4T2YoYikgPiAtMSkgcmV0dXJuICEwO1xcbiAgICAgIH1yZXR1cm4gITE7XFxuICAgIH0gfSk7dmFyIGdiID0gL1xcXFxyL2csXFxuICAgICAgaGIgPSAvW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl0rL2c7bi5mbi5leHRlbmQoeyB2YWw6IGZ1bmN0aW9uIHZhbChhKSB7XFxuICAgICAgdmFyIGIsXFxuICAgICAgICAgIGMsXFxuICAgICAgICAgIGQsXFxuICAgICAgICAgIGUgPSB0aGlzWzBdO3tcXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoKSByZXR1cm4gZCA9IG4uaXNGdW5jdGlvbihhKSwgdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICAgIHZhciBlOzEgPT09IHRoaXMubm9kZVR5cGUgJiYgKGUgPSBkID8gYS5jYWxsKHRoaXMsIGMsIG4odGhpcykudmFsKCkpIDogYSwgbnVsbCA9PSBlID8gZSA9IFxcXCJcXFwiIDogXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGUgPyBlICs9IFxcXCJcXFwiIDogbi5pc0FycmF5KGUpICYmIChlID0gbi5tYXAoZSwgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgICByZXR1cm4gbnVsbCA9PSBhID8gXFxcIlxcXCIgOiBhICsgXFxcIlxcXCI7XFxuICAgICAgICAgIH0pKSwgYiA9IG4udmFsSG9va3NbdGhpcy50eXBlXSB8fCBuLnZhbEhvb2tzW3RoaXMubm9kZU5hbWUudG9Mb3dlckNhc2UoKV0sIGIgJiYgXFxcInNldFxcXCIgaW4gYiAmJiB2b2lkIDAgIT09IGIuc2V0KHRoaXMsIGUsIFxcXCJ2YWx1ZVxcXCIpIHx8ICh0aGlzLnZhbHVlID0gZSkpO1xcbiAgICAgICAgfSk7aWYgKGUpIHJldHVybiBiID0gbi52YWxIb29rc1tlLnR5cGVdIHx8IG4udmFsSG9va3NbZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpXSwgYiAmJiBcXFwiZ2V0XFxcIiBpbiBiICYmIHZvaWQgMCAhPT0gKGMgPSBiLmdldChlLCBcXFwidmFsdWVcXFwiKSkgPyBjIDogKGMgPSBlLnZhbHVlLCBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgYyA/IGMucmVwbGFjZShnYiwgXFxcIlxcXCIpIDogbnVsbCA9PSBjID8gXFxcIlxcXCIgOiBjKTtcXG4gICAgICB9XFxuICAgIH0gfSksIG4uZXh0ZW5kKHsgdmFsSG9va3M6IHsgb3B0aW9uOiB7IGdldDogZnVuY3Rpb24gZ2V0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBuLmZpbmQuYXR0cihhLCBcXFwidmFsdWVcXFwiKTtyZXR1cm4gbnVsbCAhPSBiID8gYiA6IG4udHJpbShuLnRleHQoYSkpLnJlcGxhY2UoaGIsIFxcXCIgXFxcIik7XFxuICAgICAgICB9IH0sIHNlbGVjdDogeyBnZXQ6IGZ1bmN0aW9uIGdldChhKSB7XFxuICAgICAgICAgIGZvciAodmFyIGIsIGMsIGQgPSBhLm9wdGlvbnMsIGUgPSBhLnNlbGVjdGVkSW5kZXgsIGYgPSBcXFwic2VsZWN0LW9uZVxcXCIgPT09IGEudHlwZSB8fCAwID4gZSwgZyA9IGYgPyBudWxsIDogW10sIGggPSBmID8gZSArIDEgOiBkLmxlbmd0aCwgaSA9IDAgPiBlID8gaCA6IGYgPyBlIDogMDsgaCA+IGk7IGkrKykge1xcbiAgICAgICAgICAgIGlmIChjID0gZFtpXSwgKGMuc2VsZWN0ZWQgfHwgaSA9PT0gZSkgJiYgKGwub3B0RGlzYWJsZWQgPyAhYy5kaXNhYmxlZCA6IG51bGwgPT09IGMuZ2V0QXR0cmlidXRlKFxcXCJkaXNhYmxlZFxcXCIpKSAmJiAoIWMucGFyZW50Tm9kZS5kaXNhYmxlZCB8fCAhbi5ub2RlTmFtZShjLnBhcmVudE5vZGUsIFxcXCJvcHRncm91cFxcXCIpKSkge1xcbiAgICAgICAgICAgICAgaWYgKGIgPSBuKGMpLnZhbCgpLCBmKSByZXR1cm4gYjtnLnB1c2goYik7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9cmV0dXJuIGc7XFxuICAgICAgICB9LCBzZXQ6IGZ1bmN0aW9uIHNldChhLCBiKSB7XFxuICAgICAgICAgIHZhciBjLFxcbiAgICAgICAgICAgICAgZCxcXG4gICAgICAgICAgICAgIGUgPSBhLm9wdGlvbnMsXFxuICAgICAgICAgICAgICBmID0gbi5tYWtlQXJyYXkoYiksXFxuICAgICAgICAgICAgICBnID0gZS5sZW5ndGg7d2hpbGUgKGctLSkge1xcbiAgICAgICAgICAgIGQgPSBlW2ddLCAoZC5zZWxlY3RlZCA9IG4uaW5BcnJheShuLnZhbEhvb2tzLm9wdGlvbi5nZXQoZCksIGYpID4gLTEpICYmIChjID0gITApO1xcbiAgICAgICAgICB9cmV0dXJuIGMgfHwgKGEuc2VsZWN0ZWRJbmRleCA9IC0xKSwgZjtcXG4gICAgICAgIH0gfSB9IH0pLCBuLmVhY2goW1xcXCJyYWRpb1xcXCIsIFxcXCJjaGVja2JveFxcXCJdLCBmdW5jdGlvbiAoKSB7XFxuICAgIG4udmFsSG9va3NbdGhpc10gPSB7IHNldDogZnVuY3Rpb24gc2V0KGEsIGIpIHtcXG4gICAgICAgIHJldHVybiBuLmlzQXJyYXkoYikgPyBhLmNoZWNrZWQgPSBuLmluQXJyYXkobihhKS52YWwoKSwgYikgPiAtMSA6IHZvaWQgMDtcXG4gICAgICB9IH0sIGwuY2hlY2tPbiB8fCAobi52YWxIb29rc1t0aGlzXS5nZXQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICAgIHJldHVybiBudWxsID09PSBhLmdldEF0dHJpYnV0ZShcXFwidmFsdWVcXFwiKSA/IFxcXCJvblxcXCIgOiBhLnZhbHVlO1xcbiAgICB9KTtcXG4gIH0pO3ZhciBpYiA9IC9eKD86Zm9jdXNpbmZvY3VzfGZvY3Vzb3V0Ymx1cikkLztuLmV4dGVuZChuLmV2ZW50LCB7IHRyaWdnZXI6IGZ1bmN0aW9uIHRyaWdnZXIoYiwgYywgZSwgZikge1xcbiAgICAgIHZhciBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtLFxcbiAgICAgICAgICBvLFxcbiAgICAgICAgICBwID0gW2UgfHwgZF0sXFxuICAgICAgICAgIHEgPSBrLmNhbGwoYiwgXFxcInR5cGVcXFwiKSA/IGIudHlwZSA6IGIsXFxuICAgICAgICAgIHIgPSBrLmNhbGwoYiwgXFxcIm5hbWVzcGFjZVxcXCIpID8gYi5uYW1lc3BhY2Uuc3BsaXQoXFxcIi5cXFwiKSA6IFtdO2lmIChoID0gaSA9IGUgPSBlIHx8IGQsIDMgIT09IGUubm9kZVR5cGUgJiYgOCAhPT0gZS5ub2RlVHlwZSAmJiAhaWIudGVzdChxICsgbi5ldmVudC50cmlnZ2VyZWQpICYmIChxLmluZGV4T2YoXFxcIi5cXFwiKSA+IC0xICYmIChyID0gcS5zcGxpdChcXFwiLlxcXCIpLCBxID0gci5zaGlmdCgpLCByLnNvcnQoKSksIGwgPSBxLmluZGV4T2YoXFxcIjpcXFwiKSA8IDAgJiYgXFxcIm9uXFxcIiArIHEsIGIgPSBiW24uZXhwYW5kb10gPyBiIDogbmV3IG4uRXZlbnQocSwgXFxcIm9iamVjdFxcXCIgPT0gKHR5cGVvZiBiID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihiKSkgJiYgYiksIGIuaXNUcmlnZ2VyID0gZiA/IDIgOiAzLCBiLm5hbWVzcGFjZSA9IHIuam9pbihcXFwiLlxcXCIpLCBiLnJuYW1lc3BhY2UgPSBiLm5hbWVzcGFjZSA/IG5ldyBSZWdFeHAoXFxcIihefFxcXFxcXFxcLilcXFwiICsgci5qb2luKFxcXCJcXFxcXFxcXC4oPzouKlxcXFxcXFxcLnwpXFxcIikgKyBcXFwiKFxcXFxcXFxcLnwkKVxcXCIpIDogbnVsbCwgYi5yZXN1bHQgPSB2b2lkIDAsIGIudGFyZ2V0IHx8IChiLnRhcmdldCA9IGUpLCBjID0gbnVsbCA9PSBjID8gW2JdIDogbi5tYWtlQXJyYXkoYywgW2JdKSwgbyA9IG4uZXZlbnQuc3BlY2lhbFtxXSB8fCB7fSwgZiB8fCAhby50cmlnZ2VyIHx8IG8udHJpZ2dlci5hcHBseShlLCBjKSAhPT0gITEpKSB7XFxuICAgICAgICBpZiAoIWYgJiYgIW8ubm9CdWJibGUgJiYgIW4uaXNXaW5kb3coZSkpIHtcXG4gICAgICAgICAgZm9yIChqID0gby5kZWxlZ2F0ZVR5cGUgfHwgcSwgaWIudGVzdChqICsgcSkgfHwgKGggPSBoLnBhcmVudE5vZGUpOyBoOyBoID0gaC5wYXJlbnROb2RlKSB7XFxuICAgICAgICAgICAgcC5wdXNoKGgpLCBpID0gaDtcXG4gICAgICAgICAgfWkgPT09IChlLm93bmVyRG9jdW1lbnQgfHwgZCkgJiYgcC5wdXNoKGkuZGVmYXVsdFZpZXcgfHwgaS5wYXJlbnRXaW5kb3cgfHwgYSk7XFxuICAgICAgICB9ZyA9IDA7d2hpbGUgKChoID0gcFtnKytdKSAmJiAhYi5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XFxuICAgICAgICAgIGIudHlwZSA9IGcgPiAxID8gaiA6IG8uYmluZFR5cGUgfHwgcSwgbSA9IChOLmdldChoLCBcXFwiZXZlbnRzXFxcIikgfHwge30pW2IudHlwZV0gJiYgTi5nZXQoaCwgXFxcImhhbmRsZVxcXCIpLCBtICYmIG0uYXBwbHkoaCwgYyksIG0gPSBsICYmIGhbbF0sIG0gJiYgbS5hcHBseSAmJiBMKGgpICYmIChiLnJlc3VsdCA9IG0uYXBwbHkoaCwgYyksIGIucmVzdWx0ID09PSAhMSAmJiBiLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgICAgfXJldHVybiBiLnR5cGUgPSBxLCBmIHx8IGIuaXNEZWZhdWx0UHJldmVudGVkKCkgfHwgby5fZGVmYXVsdCAmJiBvLl9kZWZhdWx0LmFwcGx5KHAucG9wKCksIGMpICE9PSAhMSB8fCAhTChlKSB8fCBsICYmIG4uaXNGdW5jdGlvbihlW3FdKSAmJiAhbi5pc1dpbmRvdyhlKSAmJiAoaSA9IGVbbF0sIGkgJiYgKGVbbF0gPSBudWxsKSwgbi5ldmVudC50cmlnZ2VyZWQgPSBxLCBlW3FdKCksIG4uZXZlbnQudHJpZ2dlcmVkID0gdm9pZCAwLCBpICYmIChlW2xdID0gaSkpLCBiLnJlc3VsdDtcXG4gICAgICB9XFxuICAgIH0sIHNpbXVsYXRlOiBmdW5jdGlvbiBzaW11bGF0ZShhLCBiLCBjKSB7XFxuICAgICAgdmFyIGQgPSBuLmV4dGVuZChuZXcgbi5FdmVudCgpLCBjLCB7IHR5cGU6IGEsIGlzU2ltdWxhdGVkOiAhMCB9KTtuLmV2ZW50LnRyaWdnZXIoZCwgbnVsbCwgYik7XFxuICAgIH0gfSksIG4uZm4uZXh0ZW5kKHsgdHJpZ2dlcjogZnVuY3Rpb24gdHJpZ2dlcihhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuLmV2ZW50LnRyaWdnZXIoYSwgYiwgdGhpcyk7XFxuICAgICAgfSk7XFxuICAgIH0sIHRyaWdnZXJIYW5kbGVyOiBmdW5jdGlvbiB0cmlnZ2VySGFuZGxlcihhLCBiKSB7XFxuICAgICAgdmFyIGMgPSB0aGlzWzBdO3JldHVybiBjID8gbi5ldmVudC50cmlnZ2VyKGEsIGIsIGMsICEwKSA6IHZvaWQgMDtcXG4gICAgfSB9KSwgbi5lYWNoKFxcXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBjaGFuZ2Ugc2VsZWN0IHN1Ym1pdCBrZXlkb3duIGtleXByZXNzIGtleXVwIGVycm9yIGNvbnRleHRtZW51XFxcIi5zcGxpdChcXFwiIFxcXCIpLCBmdW5jdGlvbiAoYSwgYikge1xcbiAgICBuLmZuW2JdID0gZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgPyB0aGlzLm9uKGIsIG51bGwsIGEsIGMpIDogdGhpcy50cmlnZ2VyKGIpO1xcbiAgICB9O1xcbiAgfSksIG4uZm4uZXh0ZW5kKHsgaG92ZXI6IGZ1bmN0aW9uIGhvdmVyKGEsIGIpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tb3VzZWVudGVyKGEpLm1vdXNlbGVhdmUoYiB8fCBhKTtcXG4gICAgfSB9KSwgbC5mb2N1c2luID0gXFxcIm9uZm9jdXNpblxcXCIgaW4gYSwgbC5mb2N1c2luIHx8IG4uZWFjaCh7IGZvY3VzOiBcXFwiZm9jdXNpblxcXCIsIGJsdXI6IFxcXCJmb2N1c291dFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBmdW5jdGlvbiBjKGEpIHtcXG4gICAgICBuLmV2ZW50LnNpbXVsYXRlKGIsIGEudGFyZ2V0LCBuLmV2ZW50LmZpeChhKSk7XFxuICAgIH07bi5ldmVudC5zcGVjaWFsW2JdID0geyBzZXR1cDogZnVuY3Rpb24gc2V0dXAoKSB7XFxuICAgICAgICB2YXIgZCA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxcbiAgICAgICAgICAgIGUgPSBOLmFjY2VzcyhkLCBiKTtlIHx8IGQuYWRkRXZlbnRMaXN0ZW5lcihhLCBjLCAhMCksIE4uYWNjZXNzKGQsIGIsIChlIHx8IDApICsgMSk7XFxuICAgICAgfSwgdGVhcmRvd246IGZ1bmN0aW9uIHRlYXJkb3duKCkge1xcbiAgICAgICAgdmFyIGQgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcXG4gICAgICAgICAgICBlID0gTi5hY2Nlc3MoZCwgYikgLSAxO2UgPyBOLmFjY2VzcyhkLCBiLCBlKSA6IChkLnJlbW92ZUV2ZW50TGlzdGVuZXIoYSwgYywgITApLCBOLnJlbW92ZShkLCBiKSk7XFxuICAgICAgfSB9O1xcbiAgfSk7dmFyIGpiID0gYS5sb2NhdGlvbixcXG4gICAgICBrYiA9IG4ubm93KCksXFxuICAgICAgbGIgPSAvXFxcXD8vO24ucGFyc2VKU09OID0gZnVuY3Rpb24gKGEpIHtcXG4gICAgcmV0dXJuIEpTT04ucGFyc2UoYSArIFxcXCJcXFwiKTtcXG4gIH0sIG4ucGFyc2VYTUwgPSBmdW5jdGlvbiAoYikge1xcbiAgICB2YXIgYztpZiAoIWIgfHwgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIpIHJldHVybiBudWxsO3RyeSB7XFxuICAgICAgYyA9IG5ldyBhLkRPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhiLCBcXFwidGV4dC94bWxcXFwiKTtcXG4gICAgfSBjYXRjaCAoZCkge1xcbiAgICAgIGMgPSB2b2lkIDA7XFxuICAgIH1yZXR1cm4gYyAmJiAhYy5nZXRFbGVtZW50c0J5VGFnTmFtZShcXFwicGFyc2VyZXJyb3JcXFwiKS5sZW5ndGggfHwgbi5lcnJvcihcXFwiSW52YWxpZCBYTUw6IFxcXCIgKyBiKSwgYztcXG4gIH07dmFyIG1iID0gLyMuKiQvLFxcbiAgICAgIG5iID0gLyhbPyZdKV89W14mXSovLFxcbiAgICAgIG9iID0gL14oLio/KTpbIFxcXFx0XSooW15cXFxcclxcXFxuXSopJC9nbSxcXG4gICAgICBwYiA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxcbiAgICAgIHFiID0gL14oPzpHRVR8SEVBRCkkLyxcXG4gICAgICByYiA9IC9eXFxcXC9cXFxcLy8sXFxuICAgICAgc2IgPSB7fSxcXG4gICAgICB0YiA9IHt9LFxcbiAgICAgIHViID0gXFxcIiovXFxcIi5jb25jYXQoXFxcIipcXFwiKSxcXG4gICAgICB2YiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3ZiLmhyZWYgPSBqYi5ocmVmO2Z1bmN0aW9uIHdiKGEpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChiLCBjKSB7XFxuICAgICAgXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gXFxcIipcXFwiKTt2YXIgZCxcXG4gICAgICAgICAgZSA9IDAsXFxuICAgICAgICAgIGYgPSBiLnRvTG93ZXJDYXNlKCkubWF0Y2goRykgfHwgW107aWYgKG4uaXNGdW5jdGlvbihjKSkgd2hpbGUgKGQgPSBmW2UrK10pIHtcXG4gICAgICAgIFxcXCIrXFxcIiA9PT0gZFswXSA/IChkID0gZC5zbGljZSgxKSB8fCBcXFwiKlxcXCIsIChhW2RdID0gYVtkXSB8fCBbXSkudW5zaGlmdChjKSkgOiAoYVtkXSA9IGFbZF0gfHwgW10pLnB1c2goYyk7XFxuICAgICAgfVxcbiAgICB9O1xcbiAgfWZ1bmN0aW9uIHhiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUgPSB7fSxcXG4gICAgICAgIGYgPSBhID09PSB0YjtmdW5jdGlvbiBnKGgpIHtcXG4gICAgICB2YXIgaTtyZXR1cm4gZVtoXSA9ICEwLCBuLmVhY2goYVtoXSB8fCBbXSwgZnVuY3Rpb24gKGEsIGgpIHtcXG4gICAgICAgIHZhciBqID0gaChiLCBjLCBkKTtyZXR1cm4gXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGogfHwgZiB8fCBlW2pdID8gZiA/ICEoaSA9IGopIDogdm9pZCAwIDogKGIuZGF0YVR5cGVzLnVuc2hpZnQoaiksIGcoaiksICExKTtcXG4gICAgICB9KSwgaTtcXG4gICAgfXJldHVybiBnKGIuZGF0YVR5cGVzWzBdKSB8fCAhZVtcXFwiKlxcXCJdICYmIGcoXFxcIipcXFwiKTtcXG4gIH1mdW5jdGlvbiB5YihhLCBiKSB7XFxuICAgIHZhciBjLFxcbiAgICAgICAgZCxcXG4gICAgICAgIGUgPSBuLmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtmb3IgKGMgaW4gYikge1xcbiAgICAgIHZvaWQgMCAhPT0gYltjXSAmJiAoKGVbY10gPyBhIDogZCB8fCAoZCA9IHt9KSlbY10gPSBiW2NdKTtcXG4gICAgfXJldHVybiBkICYmIG4uZXh0ZW5kKCEwLCBhLCBkKSwgYTtcXG4gIH1mdW5jdGlvbiB6YihhLCBiLCBjKSB7XFxuICAgIHZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnLFxcbiAgICAgICAgaCA9IGEuY29udGVudHMsXFxuICAgICAgICBpID0gYS5kYXRhVHlwZXM7d2hpbGUgKFxcXCIqXFxcIiA9PT0gaVswXSkge1xcbiAgICAgIGkuc2hpZnQoKSwgdm9pZCAwID09PSBkICYmIChkID0gYS5taW1lVHlwZSB8fCBiLmdldFJlc3BvbnNlSGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiKSk7XFxuICAgIH1pZiAoZCkgZm9yIChlIGluIGgpIHtcXG4gICAgICBpZiAoaFtlXSAmJiBoW2VdLnRlc3QoZCkpIHtcXG4gICAgICAgIGkudW5zaGlmdChlKTticmVhaztcXG4gICAgICB9XFxuICAgIH1pZiAoaVswXSBpbiBjKSBmID0gaVswXTtlbHNlIHtcXG4gICAgICBmb3IgKGUgaW4gYykge1xcbiAgICAgICAgaWYgKCFpWzBdIHx8IGEuY29udmVydGVyc1tlICsgXFxcIiBcXFwiICsgaVswXV0pIHtcXG4gICAgICAgICAgZiA9IGU7YnJlYWs7XFxuICAgICAgICB9ZyB8fCAoZyA9IGUpO1xcbiAgICAgIH1mID0gZiB8fCBnO1xcbiAgICB9cmV0dXJuIGYgPyAoZiAhPT0gaVswXSAmJiBpLnVuc2hpZnQoZiksIGNbZl0pIDogdm9pZCAwO1xcbiAgfWZ1bmN0aW9uIEFiKGEsIGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGgsXFxuICAgICAgICBpLFxcbiAgICAgICAgaiA9IHt9LFxcbiAgICAgICAgayA9IGEuZGF0YVR5cGVzLnNsaWNlKCk7aWYgKGtbMV0pIGZvciAoZyBpbiBhLmNvbnZlcnRlcnMpIHtcXG4gICAgICBqW2cudG9Mb3dlckNhc2UoKV0gPSBhLmNvbnZlcnRlcnNbZ107XFxuICAgIH1mID0gay5zaGlmdCgpO3doaWxlIChmKSB7XFxuICAgICAgaWYgKGEucmVzcG9uc2VGaWVsZHNbZl0gJiYgKGNbYS5yZXNwb25zZUZpZWxkc1tmXV0gPSBiKSwgIWkgJiYgZCAmJiBhLmRhdGFGaWx0ZXIgJiYgKGIgPSBhLmRhdGFGaWx0ZXIoYiwgYS5kYXRhVHlwZSkpLCBpID0gZiwgZiA9IGsuc2hpZnQoKSkgaWYgKFxcXCIqXFxcIiA9PT0gZikgZiA9IGk7ZWxzZSBpZiAoXFxcIipcXFwiICE9PSBpICYmIGkgIT09IGYpIHtcXG4gICAgICAgIGlmIChnID0galtpICsgXFxcIiBcXFwiICsgZl0gfHwgaltcXFwiKiBcXFwiICsgZl0sICFnKSBmb3IgKGUgaW4gaikge1xcbiAgICAgICAgICBpZiAoaCA9IGUuc3BsaXQoXFxcIiBcXFwiKSwgaFsxXSA9PT0gZiAmJiAoZyA9IGpbaSArIFxcXCIgXFxcIiArIGhbMF1dIHx8IGpbXFxcIiogXFxcIiArIGhbMF1dKSkge1xcbiAgICAgICAgICAgIGcgPT09ICEwID8gZyA9IGpbZV0gOiBqW2VdICE9PSAhMCAmJiAoZiA9IGhbMF0sIGsudW5zaGlmdChoWzFdKSk7YnJlYWs7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH1pZiAoZyAhPT0gITApIGlmIChnICYmIGFbXFxcInRocm93c1xcXCJdKSBiID0gZyhiKTtlbHNlIHRyeSB7XFxuICAgICAgICAgIGIgPSBnKGIpO1xcbiAgICAgICAgfSBjYXRjaCAobCkge1xcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZTogXFxcInBhcnNlcmVycm9yXFxcIiwgZXJyb3I6IGcgPyBsIDogXFxcIk5vIGNvbnZlcnNpb24gZnJvbSBcXFwiICsgaSArIFxcXCIgdG8gXFxcIiArIGYgfTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1yZXR1cm4geyBzdGF0ZTogXFxcInN1Y2Nlc3NcXFwiLCBkYXRhOiBiIH07XFxuICB9bi5leHRlbmQoeyBhY3RpdmU6IDAsIGxhc3RNb2RpZmllZDoge30sIGV0YWc6IHt9LCBhamF4U2V0dGluZ3M6IHsgdXJsOiBqYi5ocmVmLCB0eXBlOiBcXFwiR0VUXFxcIiwgaXNMb2NhbDogcGIudGVzdChqYi5wcm90b2NvbCksIGdsb2JhbDogITAsIHByb2Nlc3NEYXRhOiAhMCwgYXN5bmM6ICEwLCBjb250ZW50VHlwZTogXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFxcXCIsIGFjY2VwdHM6IHsgXFxcIipcXFwiOiB1YiwgdGV4dDogXFxcInRleHQvcGxhaW5cXFwiLCBodG1sOiBcXFwidGV4dC9odG1sXFxcIiwgeG1sOiBcXFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFxcXCIsIGpzb246IFxcXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcXFwiIH0sIGNvbnRlbnRzOiB7IHhtbDogL1xcXFxieG1sXFxcXGIvLCBodG1sOiAvXFxcXGJodG1sLywganNvbjogL1xcXFxianNvblxcXFxiLyB9LCByZXNwb25zZUZpZWxkczogeyB4bWw6IFxcXCJyZXNwb25zZVhNTFxcXCIsIHRleHQ6IFxcXCJyZXNwb25zZVRleHRcXFwiLCBqc29uOiBcXFwicmVzcG9uc2VKU09OXFxcIiB9LCBjb252ZXJ0ZXJzOiB7IFxcXCIqIHRleHRcXFwiOiBTdHJpbmcsIFxcXCJ0ZXh0IGh0bWxcXFwiOiAhMCwgXFxcInRleHQganNvblxcXCI6IG4ucGFyc2VKU09OLCBcXFwidGV4dCB4bWxcXFwiOiBuLnBhcnNlWE1MIH0sIGZsYXRPcHRpb25zOiB7IHVybDogITAsIGNvbnRleHQ6ICEwIH0gfSwgYWpheFNldHVwOiBmdW5jdGlvbiBhamF4U2V0dXAoYSwgYikge1xcbiAgICAgIHJldHVybiBiID8geWIoeWIoYSwgbi5hamF4U2V0dGluZ3MpLCBiKSA6IHliKG4uYWpheFNldHRpbmdzLCBhKTtcXG4gICAgfSwgYWpheFByZWZpbHRlcjogd2Ioc2IpLCBhamF4VHJhbnNwb3J0OiB3Yih0YiksIGFqYXg6IGZ1bmN0aW9uIGFqYXgoYiwgYykge1xcbiAgICAgIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChjID0gYiwgYiA9IHZvaWQgMCksIGMgPSBjIHx8IHt9O3ZhciBlLFxcbiAgICAgICAgICBmLFxcbiAgICAgICAgICBnLFxcbiAgICAgICAgICBoLFxcbiAgICAgICAgICBpLFxcbiAgICAgICAgICBqLFxcbiAgICAgICAgICBrLFxcbiAgICAgICAgICBsLFxcbiAgICAgICAgICBtID0gbi5hamF4U2V0dXAoe30sIGMpLFxcbiAgICAgICAgICBvID0gbS5jb250ZXh0IHx8IG0sXFxuICAgICAgICAgIHAgPSBtLmNvbnRleHQgJiYgKG8ubm9kZVR5cGUgfHwgby5qcXVlcnkpID8gbihvKSA6IG4uZXZlbnQsXFxuICAgICAgICAgIHEgPSBuLkRlZmVycmVkKCksXFxuICAgICAgICAgIHIgPSBuLkNhbGxiYWNrcyhcXFwib25jZSBtZW1vcnlcXFwiKSxcXG4gICAgICAgICAgcyA9IG0uc3RhdHVzQ29kZSB8fCB7fSxcXG4gICAgICAgICAgdCA9IHt9LFxcbiAgICAgICAgICB1ID0ge30sXFxuICAgICAgICAgIHYgPSAwLFxcbiAgICAgICAgICB3ID0gXFxcImNhbmNlbGVkXFxcIixcXG4gICAgICAgICAgeCA9IHsgcmVhZHlTdGF0ZTogMCwgZ2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uIGdldFJlc3BvbnNlSGVhZGVyKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKDIgPT09IHYpIHtcXG4gICAgICAgICAgICBpZiAoIWgpIHtcXG4gICAgICAgICAgICAgIGggPSB7fTt3aGlsZSAoYiA9IG9iLmV4ZWMoZykpIHtcXG4gICAgICAgICAgICAgICAgaFtiWzFdLnRvTG93ZXJDYXNlKCldID0gYlsyXTtcXG4gICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9YiA9IGhbYS50b0xvd2VyQ2FzZSgpXTtcXG4gICAgICAgICAgfXJldHVybiBudWxsID09IGIgPyBudWxsIDogYjtcXG4gICAgICAgIH0sIGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24gZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkge1xcbiAgICAgICAgICByZXR1cm4gMiA9PT0gdiA/IGcgOiBudWxsO1xcbiAgICAgICAgfSwgc2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcihhLCBiKSB7XFxuICAgICAgICAgIHZhciBjID0gYS50b0xvd2VyQ2FzZSgpO3JldHVybiB2IHx8IChhID0gdVtjXSA9IHVbY10gfHwgYSwgdFthXSA9IGIpLCB0aGlzO1xcbiAgICAgICAgfSwgb3ZlcnJpZGVNaW1lVHlwZTogZnVuY3Rpb24gb3ZlcnJpZGVNaW1lVHlwZShhKSB7XFxuICAgICAgICAgIHJldHVybiB2IHx8IChtLm1pbWVUeXBlID0gYSksIHRoaXM7XFxuICAgICAgICB9LCBzdGF0dXNDb2RlOiBmdW5jdGlvbiBzdGF0dXNDb2RlKGEpIHtcXG4gICAgICAgICAgdmFyIGI7aWYgKGEpIGlmICgyID4gdikgZm9yIChiIGluIGEpIHtcXG4gICAgICAgICAgICBzW2JdID0gW3NbYl0sIGFbYl1dO1xcbiAgICAgICAgICB9IGVsc2UgeC5hbHdheXMoYVt4LnN0YXR1c10pO3JldHVybiB0aGlzO1xcbiAgICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KGEpIHtcXG4gICAgICAgICAgdmFyIGIgPSBhIHx8IHc7cmV0dXJuIGUgJiYgZS5hYm9ydChiKSwgeigwLCBiKSwgdGhpcztcXG4gICAgICAgIH0gfTtpZiAocS5wcm9taXNlKHgpLmNvbXBsZXRlID0gci5hZGQsIHguc3VjY2VzcyA9IHguZG9uZSwgeC5lcnJvciA9IHguZmFpbCwgbS51cmwgPSAoKGIgfHwgbS51cmwgfHwgamIuaHJlZikgKyBcXFwiXFxcIikucmVwbGFjZShtYiwgXFxcIlxcXCIpLnJlcGxhY2UocmIsIGpiLnByb3RvY29sICsgXFxcIi8vXFxcIiksIG0udHlwZSA9IGMubWV0aG9kIHx8IGMudHlwZSB8fCBtLm1ldGhvZCB8fCBtLnR5cGUsIG0uZGF0YVR5cGVzID0gbi50cmltKG0uZGF0YVR5cGUgfHwgXFxcIipcXFwiKS50b0xvd2VyQ2FzZSgpLm1hdGNoKEcpIHx8IFtcXFwiXFxcIl0sIG51bGwgPT0gbS5jcm9zc0RvbWFpbikge1xcbiAgICAgICAgaiA9IGQuY3JlYXRlRWxlbWVudChcXFwiYVxcXCIpO3RyeSB7XFxuICAgICAgICAgIGouaHJlZiA9IG0udXJsLCBqLmhyZWYgPSBqLmhyZWYsIG0uY3Jvc3NEb21haW4gPSB2Yi5wcm90b2NvbCArIFxcXCIvL1xcXCIgKyB2Yi5ob3N0ICE9IGoucHJvdG9jb2wgKyBcXFwiLy9cXFwiICsgai5ob3N0O1xcbiAgICAgICAgfSBjYXRjaCAoeSkge1xcbiAgICAgICAgICBtLmNyb3NzRG9tYWluID0gITA7XFxuICAgICAgICB9XFxuICAgICAgfWlmIChtLmRhdGEgJiYgbS5wcm9jZXNzRGF0YSAmJiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgbS5kYXRhICYmIChtLmRhdGEgPSBuLnBhcmFtKG0uZGF0YSwgbS50cmFkaXRpb25hbCkpLCB4YihzYiwgbSwgYywgeCksIDIgPT09IHYpIHJldHVybiB4O2sgPSBuLmV2ZW50ICYmIG0uZ2xvYmFsLCBrICYmIDAgPT09IG4uYWN0aXZlKysgJiYgbi5ldmVudC50cmlnZ2VyKFxcXCJhamF4U3RhcnRcXFwiKSwgbS50eXBlID0gbS50eXBlLnRvVXBwZXJDYXNlKCksIG0uaGFzQ29udGVudCA9ICFxYi50ZXN0KG0udHlwZSksIGYgPSBtLnVybCwgbS5oYXNDb250ZW50IHx8IChtLmRhdGEgJiYgKGYgPSBtLnVybCArPSAobGIudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBtLmRhdGEsIGRlbGV0ZSBtLmRhdGEpLCBtLmNhY2hlID09PSAhMSAmJiAobS51cmwgPSBuYi50ZXN0KGYpID8gZi5yZXBsYWNlKG5iLCBcXFwiJDFfPVxcXCIgKyBrYisrKSA6IGYgKyAobGIudGVzdChmKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBcXFwiXz1cXFwiICsga2IrKykpLCBtLmlmTW9kaWZpZWQgJiYgKG4ubGFzdE1vZGlmaWVkW2ZdICYmIHguc2V0UmVxdWVzdEhlYWRlcihcXFwiSWYtTW9kaWZpZWQtU2luY2VcXFwiLCBuLmxhc3RNb2RpZmllZFtmXSksIG4uZXRhZ1tmXSAmJiB4LnNldFJlcXVlc3RIZWFkZXIoXFxcIklmLU5vbmUtTWF0Y2hcXFwiLCBuLmV0YWdbZl0pKSwgKG0uZGF0YSAmJiBtLmhhc0NvbnRlbnQgJiYgbS5jb250ZW50VHlwZSAhPT0gITEgfHwgYy5jb250ZW50VHlwZSkgJiYgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJDb250ZW50LVR5cGVcXFwiLCBtLmNvbnRlbnRUeXBlKSwgeC5zZXRSZXF1ZXN0SGVhZGVyKFxcXCJBY2NlcHRcXFwiLCBtLmRhdGFUeXBlc1swXSAmJiBtLmFjY2VwdHNbbS5kYXRhVHlwZXNbMF1dID8gbS5hY2NlcHRzW20uZGF0YVR5cGVzWzBdXSArIChcXFwiKlxcXCIgIT09IG0uZGF0YVR5cGVzWzBdID8gXFxcIiwgXFxcIiArIHViICsgXFxcIjsgcT0wLjAxXFxcIiA6IFxcXCJcXFwiKSA6IG0uYWNjZXB0c1tcXFwiKlxcXCJdKTtmb3IgKGwgaW4gbS5oZWFkZXJzKSB7XFxuICAgICAgICB4LnNldFJlcXVlc3RIZWFkZXIobCwgbS5oZWFkZXJzW2xdKTtcXG4gICAgICB9aWYgKG0uYmVmb3JlU2VuZCAmJiAobS5iZWZvcmVTZW5kLmNhbGwobywgeCwgbSkgPT09ICExIHx8IDIgPT09IHYpKSByZXR1cm4geC5hYm9ydCgpO3cgPSBcXFwiYWJvcnRcXFwiO2ZvciAobCBpbiB7IHN1Y2Nlc3M6IDEsIGVycm9yOiAxLCBjb21wbGV0ZTogMSB9KSB7XFxuICAgICAgICB4W2xdKG1bbF0pO1xcbiAgICAgIH1pZiAoZSA9IHhiKHRiLCBtLCBjLCB4KSkge1xcbiAgICAgICAgaWYgKHgucmVhZHlTdGF0ZSA9IDEsIGsgJiYgcC50cmlnZ2VyKFxcXCJhamF4U2VuZFxcXCIsIFt4LCBtXSksIDIgPT09IHYpIHJldHVybiB4O20uYXN5bmMgJiYgbS50aW1lb3V0ID4gMCAmJiAoaSA9IGEuc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHguYWJvcnQoXFxcInRpbWVvdXRcXFwiKTtcXG4gICAgICAgIH0sIG0udGltZW91dCkpO3RyeSB7XFxuICAgICAgICAgIHYgPSAxLCBlLnNlbmQodCwgeik7XFxuICAgICAgICB9IGNhdGNoICh5KSB7XFxuICAgICAgICAgIGlmICghKDIgPiB2KSkgdGhyb3cgeTt6KC0xLCB5KTtcXG4gICAgICAgIH1cXG4gICAgICB9IGVsc2UgeigtMSwgXFxcIk5vIFRyYW5zcG9ydFxcXCIpO2Z1bmN0aW9uIHooYiwgYywgZCwgaCkge1xcbiAgICAgICAgdmFyIGosXFxuICAgICAgICAgICAgbCxcXG4gICAgICAgICAgICB0LFxcbiAgICAgICAgICAgIHUsXFxuICAgICAgICAgICAgdyxcXG4gICAgICAgICAgICB5ID0gYzsyICE9PSB2ICYmICh2ID0gMiwgaSAmJiBhLmNsZWFyVGltZW91dChpKSwgZSA9IHZvaWQgMCwgZyA9IGggfHwgXFxcIlxcXCIsIHgucmVhZHlTdGF0ZSA9IGIgPiAwID8gNCA6IDAsIGogPSBiID49IDIwMCAmJiAzMDAgPiBiIHx8IDMwNCA9PT0gYiwgZCAmJiAodSA9IHpiKG0sIHgsIGQpKSwgdSA9IEFiKG0sIHUsIHgsIGopLCBqID8gKG0uaWZNb2RpZmllZCAmJiAodyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcIkxhc3QtTW9kaWZpZWRcXFwiKSwgdyAmJiAobi5sYXN0TW9kaWZpZWRbZl0gPSB3KSwgdyA9IHguZ2V0UmVzcG9uc2VIZWFkZXIoXFxcImV0YWdcXFwiKSwgdyAmJiAobi5ldGFnW2ZdID0gdykpLCAyMDQgPT09IGIgfHwgXFxcIkhFQURcXFwiID09PSBtLnR5cGUgPyB5ID0gXFxcIm5vY29udGVudFxcXCIgOiAzMDQgPT09IGIgPyB5ID0gXFxcIm5vdG1vZGlmaWVkXFxcIiA6ICh5ID0gdS5zdGF0ZSwgbCA9IHUuZGF0YSwgdCA9IHUuZXJyb3IsIGogPSAhdCkpIDogKHQgPSB5LCAhYiAmJiB5IHx8ICh5ID0gXFxcImVycm9yXFxcIiwgMCA+IGIgJiYgKGIgPSAwKSkpLCB4LnN0YXR1cyA9IGIsIHguc3RhdHVzVGV4dCA9IChjIHx8IHkpICsgXFxcIlxcXCIsIGogPyBxLnJlc29sdmVXaXRoKG8sIFtsLCB5LCB4XSkgOiBxLnJlamVjdFdpdGgobywgW3gsIHksIHRdKSwgeC5zdGF0dXNDb2RlKHMpLCBzID0gdm9pZCAwLCBrICYmIHAudHJpZ2dlcihqID8gXFxcImFqYXhTdWNjZXNzXFxcIiA6IFxcXCJhamF4RXJyb3JcXFwiLCBbeCwgbSwgaiA/IGwgOiB0XSksIHIuZmlyZVdpdGgobywgW3gsIHldKSwgayAmJiAocC50cmlnZ2VyKFxcXCJhamF4Q29tcGxldGVcXFwiLCBbeCwgbV0pLCAtLW4uYWN0aXZlIHx8IG4uZXZlbnQudHJpZ2dlcihcXFwiYWpheFN0b3BcXFwiKSkpO1xcbiAgICAgIH1yZXR1cm4geDtcXG4gICAgfSwgZ2V0SlNPTjogZnVuY3Rpb24gZ2V0SlNPTihhLCBiLCBjKSB7XFxuICAgICAgcmV0dXJuIG4uZ2V0KGEsIGIsIGMsIFxcXCJqc29uXFxcIik7XFxuICAgIH0sIGdldFNjcmlwdDogZnVuY3Rpb24gZ2V0U2NyaXB0KGEsIGIpIHtcXG4gICAgICByZXR1cm4gbi5nZXQoYSwgdm9pZCAwLCBiLCBcXFwic2NyaXB0XFxcIik7XFxuICAgIH0gfSksIG4uZWFjaChbXFxcImdldFxcXCIsIFxcXCJwb3N0XFxcIl0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG5bYl0gPSBmdW5jdGlvbiAoYSwgYywgZCwgZSkge1xcbiAgICAgIHJldHVybiBuLmlzRnVuY3Rpb24oYykgJiYgKGUgPSBlIHx8IGQsIGQgPSBjLCBjID0gdm9pZCAwKSwgbi5hamF4KG4uZXh0ZW5kKHsgdXJsOiBhLCB0eXBlOiBiLCBkYXRhVHlwZTogZSwgZGF0YTogYywgc3VjY2VzczogZCB9LCBuLmlzUGxhaW5PYmplY3QoYSkgJiYgYSkpO1xcbiAgICB9O1xcbiAgfSksIG4uX2V2YWxVcmwgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5hamF4KHsgdXJsOiBhLCB0eXBlOiBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJzY3JpcHRcXFwiLCBhc3luYzogITEsIGdsb2JhbDogITEsIFxcXCJ0aHJvd3NcXFwiOiAhMCB9KTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgd3JhcEFsbDogZnVuY3Rpb24gd3JhcEFsbChhKSB7XFxuICAgICAgdmFyIGI7cmV0dXJuIG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS53cmFwQWxsKGEuY2FsbCh0aGlzLCBiKSk7XFxuICAgICAgfSkgOiAodGhpc1swXSAmJiAoYiA9IG4oYSwgdGhpc1swXS5vd25lckRvY3VtZW50KS5lcSgwKS5jbG9uZSghMCksIHRoaXNbMF0ucGFyZW50Tm9kZSAmJiBiLmluc2VydEJlZm9yZSh0aGlzWzBdKSwgYi5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzO3doaWxlIChhLmZpcnN0RWxlbWVudENoaWxkKSB7XFxuICAgICAgICAgIGEgPSBhLmZpcnN0RWxlbWVudENoaWxkO1xcbiAgICAgICAgfXJldHVybiBhO1xcbiAgICAgIH0pLmFwcGVuZCh0aGlzKSksIHRoaXMpO1xcbiAgICB9LCB3cmFwSW5uZXI6IGZ1bmN0aW9uIHdyYXBJbm5lcihhKSB7XFxuICAgICAgcmV0dXJuIG4uaXNGdW5jdGlvbihhKSA/IHRoaXMuZWFjaChmdW5jdGlvbiAoYikge1xcbiAgICAgICAgbih0aGlzKS53cmFwSW5uZXIoYS5jYWxsKHRoaXMsIGIpKTtcXG4gICAgICB9KSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYiA9IG4odGhpcyksXFxuICAgICAgICAgICAgYyA9IGIuY29udGVudHMoKTtjLmxlbmd0aCA/IGMud3JhcEFsbChhKSA6IGIuYXBwZW5kKGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB3cmFwOiBmdW5jdGlvbiB3cmFwKGEpIHtcXG4gICAgICB2YXIgYiA9IG4uaXNGdW5jdGlvbihhKTtyZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uIChjKSB7XFxuICAgICAgICBuKHRoaXMpLndyYXBBbGwoYiA/IGEuY2FsbCh0aGlzLCBjKSA6IGEpO1xcbiAgICAgIH0pO1xcbiAgICB9LCB1bndyYXA6IGZ1bmN0aW9uIHVud3JhcCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIG4ubm9kZU5hbWUodGhpcywgXFxcImJvZHlcXFwiKSB8fCBuKHRoaXMpLnJlcGxhY2VXaXRoKHRoaXMuY2hpbGROb2Rlcyk7XFxuICAgICAgfSkuZW5kKCk7XFxuICAgIH0gfSksIG4uZXhwci5maWx0ZXJzLmhpZGRlbiA9IGZ1bmN0aW9uIChhKSB7XFxuICAgIHJldHVybiAhbi5leHByLmZpbHRlcnMudmlzaWJsZShhKTtcXG4gIH0sIG4uZXhwci5maWx0ZXJzLnZpc2libGUgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gYS5vZmZzZXRXaWR0aCA+IDAgfHwgYS5vZmZzZXRIZWlnaHQgPiAwIHx8IGEuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPiAwO1xcbiAgfTt2YXIgQmIgPSAvJTIwL2csXFxuICAgICAgQ2IgPSAvXFxcXFtcXFxcXSQvLFxcbiAgICAgIERiID0gL1xcXFxyP1xcXFxuL2csXFxuICAgICAgRWIgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXFxuICAgICAgRmIgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxrZXlnZW4pL2k7ZnVuY3Rpb24gR2IoYSwgYiwgYywgZCkge1xcbiAgICB2YXIgZTtpZiAobi5pc0FycmF5KGIpKSBuLmVhY2goYiwgZnVuY3Rpb24gKGIsIGUpIHtcXG4gICAgICBjIHx8IENiLnRlc3QoYSkgPyBkKGEsIGUpIDogR2IoYSArIFxcXCJbXFxcIiArIChcXFwib2JqZWN0XFxcIiA9PSAodHlwZW9mIGUgPT09IFxcXCJ1bmRlZmluZWRcXFwiID8gXFxcInVuZGVmaW5lZFxcXCIgOiBfdHlwZW9mKGUpKSAmJiBudWxsICE9IGUgPyBiIDogXFxcIlxcXCIpICsgXFxcIl1cXFwiLCBlLCBjLCBkKTtcXG4gICAgfSk7ZWxzZSBpZiAoYyB8fCBcXFwib2JqZWN0XFxcIiAhPT0gbi50eXBlKGIpKSBkKGEsIGIpO2Vsc2UgZm9yIChlIGluIGIpIHtcXG4gICAgICBHYihhICsgXFxcIltcXFwiICsgZSArIFxcXCJdXFxcIiwgYltlXSwgYywgZCk7XFxuICAgIH1cXG4gIH1uLnBhcmFtID0gZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMsXFxuICAgICAgICBkID0gW10sXFxuICAgICAgICBlID0gZnVuY3Rpb24gZShhLCBiKSB7XFxuICAgICAgYiA9IG4uaXNGdW5jdGlvbihiKSA/IGIoKSA6IG51bGwgPT0gYiA/IFxcXCJcXFwiIDogYiwgZFtkLmxlbmd0aF0gPSBlbmNvZGVVUklDb21wb25lbnQoYSkgKyBcXFwiPVxcXCIgKyBlbmNvZGVVUklDb21wb25lbnQoYik7XFxuICAgIH07aWYgKHZvaWQgMCA9PT0gYiAmJiAoYiA9IG4uYWpheFNldHRpbmdzICYmIG4uYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsKSwgbi5pc0FycmF5KGEpIHx8IGEuanF1ZXJ5ICYmICFuLmlzUGxhaW5PYmplY3QoYSkpIG4uZWFjaChhLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgZSh0aGlzLm5hbWUsIHRoaXMudmFsdWUpO1xcbiAgICB9KTtlbHNlIGZvciAoYyBpbiBhKSB7XFxuICAgICAgR2IoYywgYVtjXSwgYiwgZSk7XFxuICAgIH1yZXR1cm4gZC5qb2luKFxcXCImXFxcIikucmVwbGFjZShCYiwgXFxcIitcXFwiKTtcXG4gIH0sIG4uZm4uZXh0ZW5kKHsgc2VyaWFsaXplOiBmdW5jdGlvbiBzZXJpYWxpemUoKSB7XFxuICAgICAgcmV0dXJuIG4ucGFyYW0odGhpcy5zZXJpYWxpemVBcnJheSgpKTtcXG4gICAgfSwgc2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uIHNlcmlhbGl6ZUFycmF5KCkge1xcbiAgICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICB2YXIgYSA9IG4ucHJvcCh0aGlzLCBcXFwiZWxlbWVudHNcXFwiKTtyZXR1cm4gYSA/IG4ubWFrZUFycmF5KGEpIDogdGhpcztcXG4gICAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLnR5cGU7cmV0dXJuIHRoaXMubmFtZSAmJiAhbih0aGlzKS5pcyhcXFwiOmRpc2FibGVkXFxcIikgJiYgRmIudGVzdCh0aGlzLm5vZGVOYW1lKSAmJiAhRWIudGVzdChhKSAmJiAodGhpcy5jaGVja2VkIHx8ICFYLnRlc3QoYSkpO1xcbiAgICAgIH0pLm1hcChmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgICAgdmFyIGMgPSBuKHRoaXMpLnZhbCgpO3JldHVybiBudWxsID09IGMgPyBudWxsIDogbi5pc0FycmF5KGMpID8gbi5tYXAoYywgZnVuY3Rpb24gKGEpIHtcXG4gICAgICAgICAgcmV0dXJuIHsgbmFtZTogYi5uYW1lLCB2YWx1ZTogYS5yZXBsYWNlKERiLCBcXFwiXFxcXHJcXFxcblxcXCIpIH07XFxuICAgICAgICB9KSA6IHsgbmFtZTogYi5uYW1lLCB2YWx1ZTogYy5yZXBsYWNlKERiLCBcXFwiXFxcXHJcXFxcblxcXCIpIH07XFxuICAgICAgfSkuZ2V0KCk7XFxuICAgIH0gfSksIG4uYWpheFNldHRpbmdzLnhociA9IGZ1bmN0aW9uICgpIHtcXG4gICAgdHJ5IHtcXG4gICAgICByZXR1cm4gbmV3IGEuWE1MSHR0cFJlcXVlc3QoKTtcXG4gICAgfSBjYXRjaCAoYikge31cXG4gIH07dmFyIEhiID0geyAwOiAyMDAsIDEyMjM6IDIwNCB9LFxcbiAgICAgIEliID0gbi5hamF4U2V0dGluZ3MueGhyKCk7bC5jb3JzID0gISFJYiAmJiBcXFwid2l0aENyZWRlbnRpYWxzXFxcIiBpbiBJYiwgbC5hamF4ID0gSWIgPSAhIUliLCBuLmFqYXhUcmFuc3BvcnQoZnVuY3Rpb24gKGIpIHtcXG4gICAgdmFyIF9jLCBkO3JldHVybiBsLmNvcnMgfHwgSWIgJiYgIWIuY3Jvc3NEb21haW4gPyB7IHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZSwgZikge1xcbiAgICAgICAgdmFyIGcsXFxuICAgICAgICAgICAgaCA9IGIueGhyKCk7aWYgKGgub3BlbihiLnR5cGUsIGIudXJsLCBiLmFzeW5jLCBiLnVzZXJuYW1lLCBiLnBhc3N3b3JkKSwgYi54aHJGaWVsZHMpIGZvciAoZyBpbiBiLnhockZpZWxkcykge1xcbiAgICAgICAgICBoW2ddID0gYi54aHJGaWVsZHNbZ107XFxuICAgICAgICB9Yi5taW1lVHlwZSAmJiBoLm92ZXJyaWRlTWltZVR5cGUgJiYgaC5vdmVycmlkZU1pbWVUeXBlKGIubWltZVR5cGUpLCBiLmNyb3NzRG9tYWluIHx8IGVbXFxcIlgtUmVxdWVzdGVkLVdpdGhcXFwiXSB8fCAoZVtcXFwiWC1SZXF1ZXN0ZWQtV2l0aFxcXCJdID0gXFxcIlhNTEh0dHBSZXF1ZXN0XFxcIik7Zm9yIChnIGluIGUpIHtcXG4gICAgICAgICAgaC5zZXRSZXF1ZXN0SGVhZGVyKGcsIGVbZ10pO1xcbiAgICAgICAgfV9jID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgX2MgJiYgKF9jID0gZCA9IGgub25sb2FkID0gaC5vbmVycm9yID0gaC5vbmFib3J0ID0gaC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsLCBcXFwiYWJvcnRcXFwiID09PSBhID8gaC5hYm9ydCgpIDogXFxcImVycm9yXFxcIiA9PT0gYSA/IFxcXCJudW1iZXJcXFwiICE9IHR5cGVvZiBoLnN0YXR1cyA/IGYoMCwgXFxcImVycm9yXFxcIikgOiBmKGguc3RhdHVzLCBoLnN0YXR1c1RleHQpIDogZihIYltoLnN0YXR1c10gfHwgaC5zdGF0dXMsIGguc3RhdHVzVGV4dCwgXFxcInRleHRcXFwiICE9PSAoaC5yZXNwb25zZVR5cGUgfHwgXFxcInRleHRcXFwiKSB8fCBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgaC5yZXNwb25zZVRleHQgPyB7IGJpbmFyeTogaC5yZXNwb25zZSB9IDogeyB0ZXh0OiBoLnJlc3BvbnNlVGV4dCB9LCBoLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSk7XFxuICAgICAgICAgIH07XFxuICAgICAgICB9LCBoLm9ubG9hZCA9IF9jKCksIGQgPSBoLm9uZXJyb3IgPSBfYyhcXFwiZXJyb3JcXFwiKSwgdm9pZCAwICE9PSBoLm9uYWJvcnQgPyBoLm9uYWJvcnQgPSBkIDogaC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIDQgPT09IGgucmVhZHlTdGF0ZSAmJiBhLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIF9jICYmIGQoKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9LCBfYyA9IF9jKFxcXCJhYm9ydFxcXCIpO3RyeSB7XFxuICAgICAgICAgIGguc2VuZChiLmhhc0NvbnRlbnQgJiYgYi5kYXRhIHx8IG51bGwpO1xcbiAgICAgICAgfSBjYXRjaCAoaSkge1xcbiAgICAgICAgICBpZiAoX2MpIHRocm93IGk7XFxuICAgICAgICB9XFxuICAgICAgfSwgYWJvcnQ6IGZ1bmN0aW9uIGFib3J0KCkge1xcbiAgICAgICAgX2MgJiYgX2MoKTtcXG4gICAgICB9IH0gOiB2b2lkIDA7XFxuICB9KSwgbi5hamF4U2V0dXAoeyBhY2NlcHRzOiB7IHNjcmlwdDogXFxcInRleHQvamF2YXNjcmlwdCwgYXBwbGljYXRpb24vamF2YXNjcmlwdCwgYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XFxcIiB9LCBjb250ZW50czogeyBzY3JpcHQ6IC9cXFxcYig/OmphdmF8ZWNtYSlzY3JpcHRcXFxcYi8gfSwgY29udmVydGVyczogeyBcXFwidGV4dCBzY3JpcHRcXFwiOiBmdW5jdGlvbiB0ZXh0U2NyaXB0KGEpIHtcXG4gICAgICAgIHJldHVybiBuLmdsb2JhbEV2YWwoYSksIGE7XFxuICAgICAgfSB9IH0pLCBuLmFqYXhQcmVmaWx0ZXIoXFxcInNjcmlwdFxcXCIsIGZ1bmN0aW9uIChhKSB7XFxuICAgIHZvaWQgMCA9PT0gYS5jYWNoZSAmJiAoYS5jYWNoZSA9ICExKSwgYS5jcm9zc0RvbWFpbiAmJiAoYS50eXBlID0gXFxcIkdFVFxcXCIpO1xcbiAgfSksIG4uYWpheFRyYW5zcG9ydChcXFwic2NyaXB0XFxcIiwgZnVuY3Rpb24gKGEpIHtcXG4gICAgaWYgKGEuY3Jvc3NEb21haW4pIHtcXG4gICAgICB2YXIgYiwgX2MyO3JldHVybiB7IHNlbmQ6IGZ1bmN0aW9uIHNlbmQoZSwgZikge1xcbiAgICAgICAgICBiID0gbihcXFwiPHNjcmlwdD5cXFwiKS5wcm9wKHsgY2hhcnNldDogYS5zY3JpcHRDaGFyc2V0LCBzcmM6IGEudXJsIH0pLm9uKFxcXCJsb2FkIGVycm9yXFxcIiwgX2MyID0gZnVuY3Rpb24gYyhhKSB7XFxuICAgICAgICAgICAgYi5yZW1vdmUoKSwgX2MyID0gbnVsbCwgYSAmJiBmKFxcXCJlcnJvclxcXCIgPT09IGEudHlwZSA/IDQwNCA6IDIwMCwgYS50eXBlKTtcXG4gICAgICAgICAgfSksIGQuaGVhZC5hcHBlbmRDaGlsZChiWzBdKTtcXG4gICAgICAgIH0sIGFib3J0OiBmdW5jdGlvbiBhYm9ydCgpIHtcXG4gICAgICAgICAgX2MyICYmIF9jMigpO1xcbiAgICAgICAgfSB9O1xcbiAgICB9XFxuICB9KTt2YXIgSmIgPSBbXSxcXG4gICAgICBLYiA9IC8oPSlcXFxcPyg/PSZ8JCl8XFxcXD9cXFxcPy87bi5hamF4U2V0dXAoeyBqc29ucDogXFxcImNhbGxiYWNrXFxcIiwganNvbnBDYWxsYmFjazogZnVuY3Rpb24ganNvbnBDYWxsYmFjaygpIHtcXG4gICAgICB2YXIgYSA9IEpiLnBvcCgpIHx8IG4uZXhwYW5kbyArIFxcXCJfXFxcIiArIGtiKys7cmV0dXJuIHRoaXNbYV0gPSAhMCwgYTtcXG4gICAgfSB9KSwgbi5hamF4UHJlZmlsdGVyKFxcXCJqc29uIGpzb25wXFxcIiwgZnVuY3Rpb24gKGIsIGMsIGQpIHtcXG4gICAgdmFyIGUsXFxuICAgICAgICBmLFxcbiAgICAgICAgZyxcXG4gICAgICAgIGggPSBiLmpzb25wICE9PSAhMSAmJiAoS2IudGVzdChiLnVybCkgPyBcXFwidXJsXFxcIiA6IFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBiLmRhdGEgJiYgMCA9PT0gKGIuY29udGVudFR5cGUgfHwgXFxcIlxcXCIpLmluZGV4T2YoXFxcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFxcXCIpICYmIEtiLnRlc3QoYi5kYXRhKSAmJiBcXFwiZGF0YVxcXCIpO3JldHVybiBoIHx8IFxcXCJqc29ucFxcXCIgPT09IGIuZGF0YVR5cGVzWzBdID8gKGUgPSBiLmpzb25wQ2FsbGJhY2sgPSBuLmlzRnVuY3Rpb24oYi5qc29ucENhbGxiYWNrKSA/IGIuanNvbnBDYWxsYmFjaygpIDogYi5qc29ucENhbGxiYWNrLCBoID8gYltoXSA9IGJbaF0ucmVwbGFjZShLYiwgXFxcIiQxXFxcIiArIGUpIDogYi5qc29ucCAhPT0gITEgJiYgKGIudXJsICs9IChsYi50ZXN0KGIudXJsKSA/IFxcXCImXFxcIiA6IFxcXCI/XFxcIikgKyBiLmpzb25wICsgXFxcIj1cXFwiICsgZSksIGIuY29udmVydGVyc1tcXFwic2NyaXB0IGpzb25cXFwiXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICByZXR1cm4gZyB8fCBuLmVycm9yKGUgKyBcXFwiIHdhcyBub3QgY2FsbGVkXFxcIiksIGdbMF07XFxuICAgIH0sIGIuZGF0YVR5cGVzWzBdID0gXFxcImpzb25cXFwiLCBmID0gYVtlXSwgYVtlXSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBnID0gYXJndW1lbnRzO1xcbiAgICB9LCBkLmFsd2F5cyhmdW5jdGlvbiAoKSB7XFxuICAgICAgdm9pZCAwID09PSBmID8gbihhKS5yZW1vdmVQcm9wKGUpIDogYVtlXSA9IGYsIGJbZV0gJiYgKGIuanNvbnBDYWxsYmFjayA9IGMuanNvbnBDYWxsYmFjaywgSmIucHVzaChlKSksIGcgJiYgbi5pc0Z1bmN0aW9uKGYpICYmIGYoZ1swXSksIGcgPSBmID0gdm9pZCAwO1xcbiAgICB9KSwgXFxcInNjcmlwdFxcXCIpIDogdm9pZCAwO1xcbiAgfSksIG4ucGFyc2VIVE1MID0gZnVuY3Rpb24gKGEsIGIsIGMpIHtcXG4gICAgaWYgKCFhIHx8IFxcXCJzdHJpbmdcXFwiICE9IHR5cGVvZiBhKSByZXR1cm4gbnVsbDtcXFwiYm9vbGVhblxcXCIgPT0gdHlwZW9mIGIgJiYgKGMgPSBiLCBiID0gITEpLCBiID0gYiB8fCBkO3ZhciBlID0geC5leGVjKGEpLFxcbiAgICAgICAgZiA9ICFjICYmIFtdO3JldHVybiBlID8gW2IuY3JlYXRlRWxlbWVudChlWzFdKV0gOiAoZSA9IGNhKFthXSwgYiwgZiksIGYgJiYgZi5sZW5ndGggJiYgbihmKS5yZW1vdmUoKSwgbi5tZXJnZShbXSwgZS5jaGlsZE5vZGVzKSk7XFxuICB9O3ZhciBMYiA9IG4uZm4ubG9hZDtuLmZuLmxvYWQgPSBmdW5jdGlvbiAoYSwgYiwgYykge1xcbiAgICBpZiAoXFxcInN0cmluZ1xcXCIgIT0gdHlwZW9mIGEgJiYgTGIpIHJldHVybiBMYi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO3ZhciBkLFxcbiAgICAgICAgZSxcXG4gICAgICAgIGYsXFxuICAgICAgICBnID0gdGhpcyxcXG4gICAgICAgIGggPSBhLmluZGV4T2YoXFxcIiBcXFwiKTtyZXR1cm4gaCA+IC0xICYmIChkID0gbi50cmltKGEuc2xpY2UoaCkpLCBhID0gYS5zbGljZSgwLCBoKSksIG4uaXNGdW5jdGlvbihiKSA/IChjID0gYiwgYiA9IHZvaWQgMCkgOiBiICYmIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgYiA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoYikpICYmIChlID0gXFxcIlBPU1RcXFwiKSwgZy5sZW5ndGggPiAwICYmIG4uYWpheCh7IHVybDogYSwgdHlwZTogZSB8fCBcXFwiR0VUXFxcIiwgZGF0YVR5cGU6IFxcXCJodG1sXFxcIiwgZGF0YTogYiB9KS5kb25lKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgZiA9IGFyZ3VtZW50cywgZy5odG1sKGQgPyBuKFxcXCI8ZGl2PlxcXCIpLmFwcGVuZChuLnBhcnNlSFRNTChhKSkuZmluZChkKSA6IGEpO1xcbiAgICB9KS5hbHdheXMoYyAmJiBmdW5jdGlvbiAoYSwgYikge1xcbiAgICAgIGcuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjLmFwcGx5KHRoaXMsIGYgfHwgW2EucmVzcG9uc2VUZXh0LCBiLCBhXSk7XFxuICAgICAgfSk7XFxuICAgIH0pLCB0aGlzO1xcbiAgfSwgbi5lYWNoKFtcXFwiYWpheFN0YXJ0XFxcIiwgXFxcImFqYXhTdG9wXFxcIiwgXFxcImFqYXhDb21wbGV0ZVxcXCIsIFxcXCJhamF4RXJyb3JcXFwiLCBcXFwiYWpheFN1Y2Nlc3NcXFwiLCBcXFwiYWpheFNlbmRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5mbltiXSA9IGZ1bmN0aW9uIChhKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub24oYiwgYSk7XFxuICAgIH07XFxuICB9KSwgbi5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiAoYSkge1xcbiAgICByZXR1cm4gbi5ncmVwKG4udGltZXJzLCBmdW5jdGlvbiAoYikge1xcbiAgICAgIHJldHVybiBhID09PSBiLmVsZW07XFxuICAgIH0pLmxlbmd0aDtcXG4gIH07ZnVuY3Rpb24gTWIoYSkge1xcbiAgICByZXR1cm4gbi5pc1dpbmRvdyhhKSA/IGEgOiA5ID09PSBhLm5vZGVUeXBlICYmIGEuZGVmYXVsdFZpZXc7XFxuICB9bi5vZmZzZXQgPSB7IHNldE9mZnNldDogZnVuY3Rpb24gc2V0T2Zmc2V0KGEsIGIsIGMpIHtcXG4gICAgICB2YXIgZCxcXG4gICAgICAgICAgZSxcXG4gICAgICAgICAgZixcXG4gICAgICAgICAgZyxcXG4gICAgICAgICAgaCxcXG4gICAgICAgICAgaSxcXG4gICAgICAgICAgaixcXG4gICAgICAgICAgayA9IG4uY3NzKGEsIFxcXCJwb3NpdGlvblxcXCIpLFxcbiAgICAgICAgICBsID0gbihhKSxcXG4gICAgICAgICAgbSA9IHt9O1xcXCJzdGF0aWNcXFwiID09PSBrICYmIChhLnN0eWxlLnBvc2l0aW9uID0gXFxcInJlbGF0aXZlXFxcIiksIGggPSBsLm9mZnNldCgpLCBmID0gbi5jc3MoYSwgXFxcInRvcFxcXCIpLCBpID0gbi5jc3MoYSwgXFxcImxlZnRcXFwiKSwgaiA9IChcXFwiYWJzb2x1dGVcXFwiID09PSBrIHx8IFxcXCJmaXhlZFxcXCIgPT09IGspICYmIChmICsgaSkuaW5kZXhPZihcXFwiYXV0b1xcXCIpID4gLTEsIGogPyAoZCA9IGwucG9zaXRpb24oKSwgZyA9IGQudG9wLCBlID0gZC5sZWZ0KSA6IChnID0gcGFyc2VGbG9hdChmKSB8fCAwLCBlID0gcGFyc2VGbG9hdChpKSB8fCAwKSwgbi5pc0Z1bmN0aW9uKGIpICYmIChiID0gYi5jYWxsKGEsIGMsIG4uZXh0ZW5kKHt9LCBoKSkpLCBudWxsICE9IGIudG9wICYmIChtLnRvcCA9IGIudG9wIC0gaC50b3AgKyBnKSwgbnVsbCAhPSBiLmxlZnQgJiYgKG0ubGVmdCA9IGIubGVmdCAtIGgubGVmdCArIGUpLCBcXFwidXNpbmdcXFwiIGluIGIgPyBiLnVzaW5nLmNhbGwoYSwgbSkgOiBsLmNzcyhtKTtcXG4gICAgfSB9LCBuLmZuLmV4dGVuZCh7IG9mZnNldDogZnVuY3Rpb24gb2Zmc2V0KGEpIHtcXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCkgcmV0dXJuIHZvaWQgMCA9PT0gYSA/IHRoaXMgOiB0aGlzLmVhY2goZnVuY3Rpb24gKGIpIHtcXG4gICAgICAgIG4ub2Zmc2V0LnNldE9mZnNldCh0aGlzLCBhLCBiKTtcXG4gICAgICB9KTt2YXIgYixcXG4gICAgICAgICAgYyxcXG4gICAgICAgICAgZCA9IHRoaXNbMF0sXFxuICAgICAgICAgIGUgPSB7IHRvcDogMCwgbGVmdDogMCB9LFxcbiAgICAgICAgICBmID0gZCAmJiBkLm93bmVyRG9jdW1lbnQ7aWYgKGYpIHJldHVybiBiID0gZi5kb2N1bWVudEVsZW1lbnQsIG4uY29udGFpbnMoYiwgZCkgPyAoZSA9IGQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGMgPSBNYihmKSwgeyB0b3A6IGUudG9wICsgYy5wYWdlWU9mZnNldCAtIGIuY2xpZW50VG9wLCBsZWZ0OiBlLmxlZnQgKyBjLnBhZ2VYT2Zmc2V0IC0gYi5jbGllbnRMZWZ0IH0pIDogZTtcXG4gICAgfSwgcG9zaXRpb246IGZ1bmN0aW9uIHBvc2l0aW9uKCkge1xcbiAgICAgIGlmICh0aGlzWzBdKSB7XFxuICAgICAgICB2YXIgYSxcXG4gICAgICAgICAgICBiLFxcbiAgICAgICAgICAgIGMgPSB0aGlzWzBdLFxcbiAgICAgICAgICAgIGQgPSB7IHRvcDogMCwgbGVmdDogMCB9O3JldHVybiBcXFwiZml4ZWRcXFwiID09PSBuLmNzcyhjLCBcXFwicG9zaXRpb25cXFwiKSA/IGIgPSBjLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIDogKGEgPSB0aGlzLm9mZnNldFBhcmVudCgpLCBiID0gdGhpcy5vZmZzZXQoKSwgbi5ub2RlTmFtZShhWzBdLCBcXFwiaHRtbFxcXCIpIHx8IChkID0gYS5vZmZzZXQoKSksIGQudG9wICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJUb3BXaWR0aFxcXCIsICEwKSwgZC5sZWZ0ICs9IG4uY3NzKGFbMF0sIFxcXCJib3JkZXJMZWZ0V2lkdGhcXFwiLCAhMCkpLCB7IHRvcDogYi50b3AgLSBkLnRvcCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5Ub3BcXFwiLCAhMCksIGxlZnQ6IGIubGVmdCAtIGQubGVmdCAtIG4uY3NzKGMsIFxcXCJtYXJnaW5MZWZ0XFxcIiwgITApIH07XFxuICAgICAgfVxcbiAgICB9LCBvZmZzZXRQYXJlbnQ6IGZ1bmN0aW9uIG9mZnNldFBhcmVudCgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGEgPSB0aGlzLm9mZnNldFBhcmVudDt3aGlsZSAoYSAmJiBcXFwic3RhdGljXFxcIiA9PT0gbi5jc3MoYSwgXFxcInBvc2l0aW9uXFxcIikpIHtcXG4gICAgICAgICAgYSA9IGEub2Zmc2V0UGFyZW50O1xcbiAgICAgICAgfXJldHVybiBhIHx8IEVhO1xcbiAgICAgIH0pO1xcbiAgICB9IH0pLCBuLmVhY2goeyBzY3JvbGxMZWZ0OiBcXFwicGFnZVhPZmZzZXRcXFwiLCBzY3JvbGxUb3A6IFxcXCJwYWdlWU9mZnNldFxcXCIgfSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgdmFyIGMgPSBcXFwicGFnZVlPZmZzZXRcXFwiID09PSBiO24uZm5bYV0gPSBmdW5jdGlvbiAoZCkge1xcbiAgICAgIHJldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChhLCBkLCBlKSB7XFxuICAgICAgICB2YXIgZiA9IE1iKGEpO3JldHVybiB2b2lkIDAgPT09IGUgPyBmID8gZltiXSA6IGFbZF0gOiB2b2lkIChmID8gZi5zY3JvbGxUbyhjID8gZi5wYWdlWE9mZnNldCA6IGUsIGMgPyBlIDogZi5wYWdlWU9mZnNldCkgOiBhW2RdID0gZSk7XFxuICAgICAgfSwgYSwgZCwgYXJndW1lbnRzLmxlbmd0aCk7XFxuICAgIH07XFxuICB9KSwgbi5lYWNoKFtcXFwidG9wXFxcIiwgXFxcImxlZnRcXFwiXSwgZnVuY3Rpb24gKGEsIGIpIHtcXG4gICAgbi5jc3NIb29rc1tiXSA9IEdhKGwucGl4ZWxQb3NpdGlvbiwgZnVuY3Rpb24gKGEsIGMpIHtcXG4gICAgICByZXR1cm4gYyA/IChjID0gRmEoYSwgYiksIEJhLnRlc3QoYykgPyBuKGEpLnBvc2l0aW9uKClbYl0gKyBcXFwicHhcXFwiIDogYykgOiB2b2lkIDA7XFxuICAgIH0pO1xcbiAgfSksIG4uZWFjaCh7IEhlaWdodDogXFxcImhlaWdodFxcXCIsIFdpZHRoOiBcXFwid2lkdGhcXFwiIH0sIGZ1bmN0aW9uIChhLCBiKSB7XFxuICAgIG4uZWFjaCh7IHBhZGRpbmc6IFxcXCJpbm5lclxcXCIgKyBhLCBjb250ZW50OiBiLCBcXFwiXFxcIjogXFxcIm91dGVyXFxcIiArIGEgfSwgZnVuY3Rpb24gKGMsIGQpIHtcXG4gICAgICBuLmZuW2RdID0gZnVuY3Rpb24gKGQsIGUpIHtcXG4gICAgICAgIHZhciBmID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoYyB8fCBcXFwiYm9vbGVhblxcXCIgIT0gdHlwZW9mIGQpLFxcbiAgICAgICAgICAgIGcgPSBjIHx8IChkID09PSAhMCB8fCBlID09PSAhMCA/IFxcXCJtYXJnaW5cXFwiIDogXFxcImJvcmRlclxcXCIpO3JldHVybiBLKHRoaXMsIGZ1bmN0aW9uIChiLCBjLCBkKSB7XFxuICAgICAgICAgIHZhciBlO3JldHVybiBuLmlzV2luZG93KGIpID8gYi5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbXFxcImNsaWVudFxcXCIgKyBhXSA6IDkgPT09IGIubm9kZVR5cGUgPyAoZSA9IGIuZG9jdW1lbnRFbGVtZW50LCBNYXRoLm1heChiLmJvZHlbXFxcInNjcm9sbFxcXCIgKyBhXSwgZVtcXFwic2Nyb2xsXFxcIiArIGFdLCBiLmJvZHlbXFxcIm9mZnNldFxcXCIgKyBhXSwgZVtcXFwib2Zmc2V0XFxcIiArIGFdLCBlW1xcXCJjbGllbnRcXFwiICsgYV0pKSA6IHZvaWQgMCA9PT0gZCA/IG4uY3NzKGIsIGMsIGcpIDogbi5zdHlsZShiLCBjLCBkLCBnKTtcXG4gICAgICAgIH0sIGIsIGYgPyBkIDogdm9pZCAwLCBmLCBudWxsKTtcXG4gICAgICB9O1xcbiAgICB9KTtcXG4gIH0pLCBuLmZuLmV4dGVuZCh7IGJpbmQ6IGZ1bmN0aW9uIGJpbmQoYSwgYiwgYykge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGEsIG51bGwsIGIsIGMpO1xcbiAgICB9LCB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZChhLCBiKSB7XFxuICAgICAgcmV0dXJuIHRoaXMub2ZmKGEsIG51bGwsIGIpO1xcbiAgICB9LCBkZWxlZ2F0ZTogZnVuY3Rpb24gZGVsZWdhdGUoYSwgYiwgYywgZCkge1xcbiAgICAgIHJldHVybiB0aGlzLm9uKGIsIGEsIGMsIGQpO1xcbiAgICB9LCB1bmRlbGVnYXRlOiBmdW5jdGlvbiB1bmRlbGVnYXRlKGEsIGIsIGMpIHtcXG4gICAgICByZXR1cm4gMSA9PT0gYXJndW1lbnRzLmxlbmd0aCA/IHRoaXMub2ZmKGEsIFxcXCIqKlxcXCIpIDogdGhpcy5vZmYoYiwgYSB8fCBcXFwiKipcXFwiLCBjKTtcXG4gICAgfSwgc2l6ZTogZnVuY3Rpb24gc2l6ZSgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5sZW5ndGg7XFxuICAgIH0gfSksIG4uZm4uYW5kU2VsZiA9IG4uZm4uYWRkQmFjaywgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgZGVmaW5lICYmIGRlZmluZS5hbWQgJiYgZGVmaW5lKFxcXCJqcXVlcnlcXFwiLCBbXSwgZnVuY3Rpb24gKCkge1xcbiAgICByZXR1cm4gbjtcXG4gIH0pO3ZhciBOYiA9IGEualF1ZXJ5LFxcbiAgICAgIE9iID0gYS4kO3JldHVybiBuLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoYikge1xcbiAgICByZXR1cm4gYS4kID09PSBuICYmIChhLiQgPSBPYiksIGIgJiYgYS5qUXVlcnkgPT09IG4gJiYgKGEualF1ZXJ5ID0gTmIpLCBuO1xcbiAgfSwgYiB8fCAoYS5qUXVlcnkgPSBhLiQgPSBuKSwgbjtcXG59KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyL34vcmF3LWxvYWRlciEuL34vYmFiZWwtbG9hZGVyL2xpYj97XCJwcmVzZXRzXCI6W1wicmVhY3RcIixcImVzMjAxNVwiLFwic3RhZ2UtMFwiXSxcImNvbXBhY3RcIjpmYWxzZX0hLi9+L2pxdWVyeS9kaXN0L2pxdWVyeS5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwicmVxdWlyZShcIiEhQzpcXFxcVXNlcnNcXFxcQmxlc2ltZXRhcl9WMTBcXFxcRGVza3RvcFxcXFxSXFxcXFJlYWN0IC0gQ2hhcHRlclVjZW5qZVxcXFxDNiAtIFRpbWVyQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxzY3JpcHQtbG9hZGVyXFxcXGFkZFNjcmlwdC5qc1wiKShyZXF1aXJlKFwiISFDOlxcXFxVc2Vyc1xcXFxCbGVzaW1ldGFyX1YxMFxcXFxEZXNrdG9wXFxcXFJcXFxcUmVhY3QgLSBDaGFwdGVyVWNlbmplXFxcXEM2IC0gVGltZXJBcHBcXFxcbm9kZV9tb2R1bGVzXFxcXHNjcmlwdC1sb2FkZXJcXFxcbm9kZV9tb2R1bGVzXFxcXHJhdy1sb2FkZXJcXFxcaW5kZXguanMhQzpcXFxcVXNlcnNcXFxcQmxlc2ltZXRhcl9WMTBcXFxcRGVza3RvcFxcXFxSXFxcXFJlYWN0IC0gQ2hhcHRlclVjZW5qZVxcXFxDNiAtIFRpbWVyQXBwXFxcXG5vZGVfbW9kdWxlc1xcXFxiYWJlbC1sb2FkZXJcXFxcbGliXFxcXGluZGV4LmpzP3tcXFwicHJlc2V0c1xcXCI6W1xcXCJyZWFjdFxcXCIsXFxcImVzMjAxNVxcXCIsXFxcInN0YWdlLTBcXFwiXSxcXFwiY29tcGFjdFxcXCI6ZmFsc2V9IUM6XFxcXFVzZXJzXFxcXEJsZXNpbWV0YXJfVjEwXFxcXERlc2t0b3BcXFxcUlxcXFxSZWFjdCAtIENoYXB0ZXJVY2VuamVcXFxcQzYgLSBUaW1lckFwcFxcXFxub2RlX21vZHVsZXNcXFxcZm91bmRhdGlvbi1zaXRlc1xcXFxkaXN0XFxcXGZvdW5kYXRpb24ubWluLmpzXCIpKVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyIS4vfi9mb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwibW9kdWxlLmV4cG9ydHMgPSBcIlxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCwgZSkge1xcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTtcXG59ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsIGUpIHtcXG4gIGlmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxufWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCwgZSkge1xcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTtcXG59ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsIGUpIHtcXG4gIGlmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxufWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCwgZSkge1xcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTtcXG59ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsIGUpIHtcXG4gIGlmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxufWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCwgZSkge1xcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTtcXG59ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsIGUpIHtcXG4gIGlmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxufWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCwgZSkge1xcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTtcXG59ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsIGUpIHtcXG4gIGlmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxufWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn1mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2sodCwgZSkge1xcbiAgaWYgKCEodCBpbnN0YW5jZW9mIGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFxcXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cXFwiKTtcXG59ZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKHQsIGUpIHtcXG4gIGlmICghKHQgaW5zdGFuY2VvZiBlKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7XFxufWZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayh0LCBlKSB7XFxuICBpZiAoISh0IGluc3RhbmNlb2YgZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblxcXCIpO1xcbn0hZnVuY3Rpb24gKHQpIHtcXG4gIFxcXCJ1c2Ugc3RyaWN0XFxcIjtcXG4gIGZ1bmN0aW9uIGUodCkge1xcbiAgICBpZiAodm9pZCAwID09PSBGdW5jdGlvbi5wcm90b3R5cGUubmFtZSkge1xcbiAgICAgIHZhciBlID0gL2Z1bmN0aW9uXFxcXHMoW14oXXsxLH0pXFxcXCgvLFxcbiAgICAgICAgICBpID0gZS5leGVjKHQudG9TdHJpbmcoKSk7cmV0dXJuIGkgJiYgaS5sZW5ndGggPiAxID8gaVsxXS50cmltKCkgOiBcXFwiXFxcIjtcXG4gICAgfXJldHVybiB2b2lkIDAgPT09IHQucHJvdG90eXBlID8gdC5jb25zdHJ1Y3Rvci5uYW1lIDogdC5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZTtcXG4gIH1mdW5jdGlvbiBpKHQpIHtcXG4gICAgcmV0dXJuICEhL3RydWUvLnRlc3QodCkgfHwgIS9mYWxzZS8udGVzdCh0KSAmJiAoaXNOYU4oMSAqIHQpID8gdCA6IHBhcnNlRmxvYXQodCkpO1xcbiAgfWZ1bmN0aW9uIG4odCkge1xcbiAgICByZXR1cm4gdC5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCBcXFwiJDEtJDJcXFwiKS50b0xvd2VyQ2FzZSgpO1xcbiAgfXZhciBzID0gXFxcIjYuMi40XFxcIixcXG4gICAgICBvID0geyB2ZXJzaW9uOiBzLCBfcGx1Z2luczoge30sIF91dWlkczogW10sIHJ0bDogZnVuY3Rpb24gcnRsKCkge1xcbiAgICAgIHJldHVybiBcXFwicnRsXFxcIiA9PT0gdChcXFwiaHRtbFxcXCIpLmF0dHIoXFxcImRpclxcXCIpO1xcbiAgICB9LCBwbHVnaW46IGZ1bmN0aW9uIHBsdWdpbih0LCBpKSB7XFxuICAgICAgdmFyIHMgPSBpIHx8IGUodCksXFxuICAgICAgICAgIG8gPSBuKHMpO3RoaXMuX3BsdWdpbnNbb10gPSB0aGlzW3NdID0gdDtcXG4gICAgfSwgcmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHJlZ2lzdGVyUGx1Z2luKHQsIGkpIHtcXG4gICAgICB2YXIgcyA9IGkgPyBuKGkpIDogZSh0LmNvbnN0cnVjdG9yKS50b0xvd2VyQ2FzZSgpO3QudXVpZCA9IHRoaXMuR2V0WW9EaWdpdHMoNiwgcyksIHQuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1cXFwiICsgcykgfHwgdC4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLVxcXCIgKyBzLCB0LnV1aWQpLCB0LiRlbGVtZW50LmRhdGEoXFxcInpmUGx1Z2luXFxcIikgfHwgdC4kZWxlbWVudC5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIsIHQpLCB0LiRlbGVtZW50LnRyaWdnZXIoXFxcImluaXQuemYuXFxcIiArIHMpLCB0aGlzLl91dWlkcy5wdXNoKHQudXVpZCk7XFxuICAgIH0sIHVucmVnaXN0ZXJQbHVnaW46IGZ1bmN0aW9uIHVucmVnaXN0ZXJQbHVnaW4odCkge1xcbiAgICAgIHZhciBpID0gbihlKHQuJGVsZW1lbnQuZGF0YShcXFwiemZQbHVnaW5cXFwiKS5jb25zdHJ1Y3RvcikpO3RoaXMuX3V1aWRzLnNwbGljZSh0aGlzLl91dWlkcy5pbmRleE9mKHQudXVpZCksIDEpLCB0LiRlbGVtZW50LnJlbW92ZUF0dHIoXFxcImRhdGEtXFxcIiArIGkpLnJlbW92ZURhdGEoXFxcInpmUGx1Z2luXFxcIikudHJpZ2dlcihcXFwiZGVzdHJveWVkLnpmLlxcXCIgKyBpKTtmb3IgKHZhciBzIGluIHQpIHtcXG4gICAgICAgIHRbc10gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgfSwgcmVJbml0OiBmdW5jdGlvbiByZUluaXQoZSkge1xcbiAgICAgIHZhciBpID0gZSBpbnN0YW5jZW9mIHQ7dHJ5IHtcXG4gICAgICAgIGlmIChpKSBlLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0KHRoaXMpLmRhdGEoXFxcInpmUGx1Z2luXFxcIikuX2luaXQoKTtcXG4gICAgICAgIH0pO2Vsc2Uge1xcbiAgICAgICAgICB2YXIgcyA9IHR5cGVvZiBlID09PSBcXFwidW5kZWZpbmVkXFxcIiA/IFxcXCJ1bmRlZmluZWRcXFwiIDogX3R5cGVvZihlKSxcXG4gICAgICAgICAgICAgIG8gPSB0aGlzLFxcbiAgICAgICAgICAgICAgYSA9IHsgb2JqZWN0OiBmdW5jdGlvbiBvYmplY3QoZSkge1xcbiAgICAgICAgICAgICAgZS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgICAgIGUgPSBuKGUpLCB0KFxcXCJbZGF0YS1cXFwiICsgZSArIFxcXCJdXFxcIikuZm91bmRhdGlvbihcXFwiX2luaXRcXFwiKTtcXG4gICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgIH0sIHN0cmluZzogZnVuY3Rpb24gc3RyaW5nKCkge1xcbiAgICAgICAgICAgICAgZSA9IG4oZSksIHQoXFxcIltkYXRhLVxcXCIgKyBlICsgXFxcIl1cXFwiKS5mb3VuZGF0aW9uKFxcXCJfaW5pdFxcXCIpO1xcbiAgICAgICAgICAgIH0sIHVuZGVmaW5lZDogZnVuY3Rpb24gdW5kZWZpbmVkKCkge1xcbiAgICAgICAgICAgICAgdGhpcy5vYmplY3QoT2JqZWN0LmtleXMoby5fcGx1Z2lucykpO1xcbiAgICAgICAgICAgIH0gfTthW3NdKGUpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gY2F0Y2ggKHIpIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3Iocik7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIHJldHVybiBlO1xcbiAgICAgIH1cXG4gICAgfSwgR2V0WW9EaWdpdHM6IGZ1bmN0aW9uIEdldFlvRGlnaXRzKHQsIGUpIHtcXG4gICAgICByZXR1cm4gdCA9IHQgfHwgNiwgTWF0aC5yb3VuZChNYXRoLnBvdygzNiwgdCArIDEpIC0gTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDM2LCB0KSkudG9TdHJpbmcoMzYpLnNsaWNlKDEpICsgKGUgPyBcXFwiLVxcXCIgKyBlIDogXFxcIlxcXCIpO1xcbiAgICB9LCByZWZsb3c6IGZ1bmN0aW9uIHJlZmxvdyhlLCBuKSB7XFxuICAgICAgXFxcInVuZGVmaW5lZFxcXCIgPT0gdHlwZW9mIG4gPyBuID0gT2JqZWN0LmtleXModGhpcy5fcGx1Z2lucykgOiBcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgbiAmJiAobiA9IFtuXSk7dmFyIHMgPSB0aGlzO3QuZWFjaChuLCBmdW5jdGlvbiAobiwgbykge1xcbiAgICAgICAgdmFyIGEgPSBzLl9wbHVnaW5zW29dLFxcbiAgICAgICAgICAgIHIgPSB0KGUpLmZpbmQoXFxcIltkYXRhLVxcXCIgKyBvICsgXFxcIl1cXFwiKS5hZGRCYWNrKFxcXCJbZGF0YS1cXFwiICsgbyArIFxcXCJdXFxcIik7ci5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGUgPSB0KHRoaXMpLFxcbiAgICAgICAgICAgICAgbiA9IHt9O2lmIChlLmRhdGEoXFxcInpmUGx1Z2luXFxcIikpIHJldHVybiB2b2lkIGNvbnNvbGUud2FybihcXFwiVHJpZWQgdG8gaW5pdGlhbGl6ZSBcXFwiICsgbyArIFxcXCIgb24gYW4gZWxlbWVudCB0aGF0IGFscmVhZHkgaGFzIGEgRm91bmRhdGlvbiBwbHVnaW4uXFxcIik7aWYgKGUuYXR0cihcXFwiZGF0YS1vcHRpb25zXFxcIikpIHtcXG4gICAgICAgICAgICBlLmF0dHIoXFxcImRhdGEtb3B0aW9uc1xcXCIpLnNwbGl0KFxcXCI7XFxcIikuZm9yRWFjaChmdW5jdGlvbiAodCwgZSkge1xcbiAgICAgICAgICAgICAgdmFyIHMgPSB0LnNwbGl0KFxcXCI6XFxcIikubWFwKGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB0LnRyaW0oKTtcXG4gICAgICAgICAgICAgIH0pO3NbMF0gJiYgKG5bc1swXV0gPSBpKHNbMV0pKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfXRyeSB7XFxuICAgICAgICAgICAgZS5kYXRhKFxcXCJ6ZlBsdWdpblxcXCIsIG5ldyBhKHQodGhpcyksIG4pKTtcXG4gICAgICAgICAgfSBjYXRjaCAocykge1xcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3Iocyk7XFxuICAgICAgICAgIH0gZmluYWxseSB7XFxuICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfSwgZ2V0Rm5OYW1lOiBlLCB0cmFuc2l0aW9uZW5kOiBmdW5jdGlvbiB0cmFuc2l0aW9uZW5kKHQpIHtcXG4gICAgICB2YXIgZSxcXG4gICAgICAgICAgaSA9IHsgdHJhbnNpdGlvbjogXFxcInRyYW5zaXRpb25lbmRcXFwiLCBXZWJraXRUcmFuc2l0aW9uOiBcXFwid2Via2l0VHJhbnNpdGlvbkVuZFxcXCIsIE1velRyYW5zaXRpb246IFxcXCJ0cmFuc2l0aW9uZW5kXFxcIiwgT1RyYW5zaXRpb246IFxcXCJvdHJhbnNpdGlvbmVuZFxcXCIgfSxcXG4gICAgICAgICAgbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXFxcImRpdlxcXCIpO2ZvciAodmFyIHMgaW4gaSkge1xcbiAgICAgICAgXFxcInVuZGVmaW5lZFxcXCIgIT0gdHlwZW9mIG4uc3R5bGVbc10gJiYgKGUgPSBpW3NdKTtcXG4gICAgICB9cmV0dXJuIGUgPyBlIDogKGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHQudHJpZ2dlckhhbmRsZXIoXFxcInRyYW5zaXRpb25lbmRcXFwiLCBbdF0pO1xcbiAgICAgIH0sIDEpLCBcXFwidHJhbnNpdGlvbmVuZFxcXCIpO1xcbiAgICB9IH07by51dGlsID0geyB0aHJvdHRsZTogZnVuY3Rpb24gdGhyb3R0bGUodCwgZSkge1xcbiAgICAgIHZhciBpID0gbnVsbDtyZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIG4gPSB0aGlzLFxcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHM7bnVsbCA9PT0gaSAmJiAoaSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0LmFwcGx5KG4sIHMpLCBpID0gbnVsbDtcXG4gICAgICAgIH0sIGUpKTtcXG4gICAgICB9O1xcbiAgICB9IH07dmFyIGEgPSBmdW5jdGlvbiBhKGkpIHtcXG4gICAgdmFyIG4gPSB0eXBlb2YgaSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoaSksXFxuICAgICAgICBzID0gdChcXFwibWV0YS5mb3VuZGF0aW9uLW1xXFxcIiksXFxuICAgICAgICBhID0gdChcXFwiLm5vLWpzXFxcIik7aWYgKHMubGVuZ3RoIHx8IHQoJzxtZXRhIGNsYXNzPVxcXCJmb3VuZGF0aW9uLW1xXFxcIj4nKS5hcHBlbmRUbyhkb2N1bWVudC5oZWFkKSwgYS5sZW5ndGggJiYgYS5yZW1vdmVDbGFzcyhcXFwibm8tanNcXFwiKSwgXFxcInVuZGVmaW5lZFxcXCIgPT09IG4pIG8uTWVkaWFRdWVyeS5faW5pdCgpLCBvLnJlZmxvdyh0aGlzKTtlbHNlIHtcXG4gICAgICBpZiAoXFxcInN0cmluZ1xcXCIgIT09IG4pIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIldlJ3JlIHNvcnJ5LCBcXFwiICsgbiArIFxcXCIgaXMgbm90IGEgdmFsaWQgcGFyYW1ldGVyLiBZb3UgbXVzdCB1c2UgYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBtZXRob2QgeW91IHdpc2ggdG8gaW52b2tlLlxcXCIpO3ZhciByID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcXG4gICAgICAgICAgbCA9IHRoaXMuZGF0YShcXFwiemZQbHVnaW5cXFwiKTtpZiAodm9pZCAwID09PSBsIHx8IHZvaWQgMCA9PT0gbFtpXSkgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFxcXCJXZSdyZSBzb3JyeSwgJ1xcXCIgKyBpICsgXFxcIicgaXMgbm90IGFuIGF2YWlsYWJsZSBtZXRob2QgZm9yIFxcXCIgKyAobCA/IGUobCkgOiBcXFwidGhpcyBlbGVtZW50XFxcIikgKyBcXFwiLlxcXCIpOzEgPT09IHRoaXMubGVuZ3RoID8gbFtpXS5hcHBseShsLCByKSA6IHRoaXMuZWFjaChmdW5jdGlvbiAoZSwgbikge1xcbiAgICAgICAgbFtpXS5hcHBseSh0KG4pLmRhdGEoXFxcInpmUGx1Z2luXFxcIiksIHIpO1xcbiAgICAgIH0pO1xcbiAgICB9cmV0dXJuIHRoaXM7XFxuICB9O3dpbmRvdy5Gb3VuZGF0aW9uID0gbywgdC5mbi5mb3VuZGF0aW9uID0gYSwgZnVuY3Rpb24gKCkge1xcbiAgICBEYXRlLm5vdyAmJiB3aW5kb3cuRGF0ZS5ub3cgfHwgKHdpbmRvdy5EYXRlLm5vdyA9IERhdGUubm93ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcXG4gICAgfSk7Zm9yICh2YXIgdCA9IFtcXFwid2Via2l0XFxcIiwgXFxcIm1velxcXCJdLCBlID0gMDsgZSA8IHQubGVuZ3RoICYmICF3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lOyArK2UpIHtcXG4gICAgICB2YXIgaSA9IHRbZV07d2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IHdpbmRvd1tpICsgXFxcIlJlcXVlc3RBbmltYXRpb25GcmFtZVxcXCJdLCB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPSB3aW5kb3dbaSArIFxcXCJDYW5jZWxBbmltYXRpb25GcmFtZVxcXCJdIHx8IHdpbmRvd1tpICsgXFxcIkNhbmNlbFJlcXVlc3RBbmltYXRpb25GcmFtZVxcXCJdO1xcbiAgICB9aWYgKC9pUChhZHxob25lfG9kKS4qT1MgNi8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgIXdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgIXdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSkge1xcbiAgICAgIHZhciBuID0gMDt3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgIHZhciBlID0gRGF0ZS5ub3coKSxcXG4gICAgICAgICAgICBpID0gTWF0aC5tYXgobiArIDE2LCBlKTtyZXR1cm4gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHQobiA9IGkpO1xcbiAgICAgICAgfSwgaSAtIGUpO1xcbiAgICAgIH0sIHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSA9IGNsZWFyVGltZW91dDtcXG4gICAgfXdpbmRvdy5wZXJmb3JtYW5jZSAmJiB3aW5kb3cucGVyZm9ybWFuY2Uubm93IHx8ICh3aW5kb3cucGVyZm9ybWFuY2UgPSB7IHN0YXJ0OiBEYXRlLm5vdygpLCBub3c6IGZ1bmN0aW9uIG5vdygpIHtcXG4gICAgICAgIHJldHVybiBEYXRlLm5vdygpIC0gdGhpcy5zdGFydDtcXG4gICAgICB9IH0pO1xcbiAgfSgpLCBGdW5jdGlvbi5wcm90b3R5cGUuYmluZCB8fCAoRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgPSBmdW5jdGlvbiAodCkge1xcbiAgICBpZiAoXFxcImZ1bmN0aW9uXFxcIiAhPSB0eXBlb2YgdGhpcykgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiRnVuY3Rpb24ucHJvdG90eXBlLmJpbmQgLSB3aGF0IGlzIHRyeWluZyB0byBiZSBib3VuZCBpcyBub3QgY2FsbGFibGVcXFwiKTt2YXIgZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSksXFxuICAgICAgICBpID0gdGhpcyxcXG4gICAgICAgIG4gPSBmdW5jdGlvbiBuKCkge30sXFxuICAgICAgICBzID0gZnVuY3Rpb24gcygpIHtcXG4gICAgICByZXR1cm4gaS5hcHBseSh0aGlzIGluc3RhbmNlb2YgbiA/IHRoaXMgOiB0LCBlLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XFxuICAgIH07cmV0dXJuIHRoaXMucHJvdG90eXBlICYmIChuLnByb3RvdHlwZSA9IHRoaXMucHJvdG90eXBlKSwgcy5wcm90b3R5cGUgPSBuZXcgbigpLCBzO1xcbiAgfSk7XFxufShqUXVlcnkpLCAhZnVuY3Rpb24gKHQpIHtcXG4gIGZ1bmN0aW9uIGUodCwgZSwgbiwgcykge1xcbiAgICB2YXIgbyxcXG4gICAgICAgIGEsXFxuICAgICAgICByLFxcbiAgICAgICAgbCxcXG4gICAgICAgIHUgPSBpKHQpO2lmIChlKSB7XFxuICAgICAgdmFyIGQgPSBpKGUpO2EgPSB1Lm9mZnNldC50b3AgKyB1LmhlaWdodCA8PSBkLmhlaWdodCArIGQub2Zmc2V0LnRvcCwgbyA9IHUub2Zmc2V0LnRvcCA+PSBkLm9mZnNldC50b3AsIHIgPSB1Lm9mZnNldC5sZWZ0ID49IGQub2Zmc2V0LmxlZnQsIGwgPSB1Lm9mZnNldC5sZWZ0ICsgdS53aWR0aCA8PSBkLndpZHRoICsgZC5vZmZzZXQubGVmdDtcXG4gICAgfSBlbHNlIGEgPSB1Lm9mZnNldC50b3AgKyB1LmhlaWdodCA8PSB1LndpbmRvd0RpbXMuaGVpZ2h0ICsgdS53aW5kb3dEaW1zLm9mZnNldC50b3AsIG8gPSB1Lm9mZnNldC50b3AgPj0gdS53aW5kb3dEaW1zLm9mZnNldC50b3AsIHIgPSB1Lm9mZnNldC5sZWZ0ID49IHUud2luZG93RGltcy5vZmZzZXQubGVmdCwgbCA9IHUub2Zmc2V0LmxlZnQgKyB1LndpZHRoIDw9IHUud2luZG93RGltcy53aWR0aDt2YXIgaCA9IFthLCBvLCByLCBsXTtyZXR1cm4gbiA/IHIgPT09IGwgPT0gITAgOiBzID8gbyA9PT0gYSA9PSAhMCA6IGguaW5kZXhPZighMSkgPT09IC0xO1xcbiAgfWZ1bmN0aW9uIGkodCwgZSkge1xcbiAgICBpZiAodCA9IHQubGVuZ3RoID8gdFswXSA6IHQsIHQgPT09IHdpbmRvdyB8fCB0ID09PSBkb2N1bWVudCkgdGhyb3cgbmV3IEVycm9yKFxcXCJJJ20gc29ycnksIERhdmUuIEknbSBhZnJhaWQgSSBjYW4ndCBkbyB0aGF0LlxcXCIpO3ZhciBpID0gdC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcXG4gICAgICAgIG4gPSB0LnBhcmVudE5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXFxuICAgICAgICBzID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcXG4gICAgICAgIG8gPSB3aW5kb3cucGFnZVlPZmZzZXQsXFxuICAgICAgICBhID0gd2luZG93LnBhZ2VYT2Zmc2V0O3JldHVybiB7IHdpZHRoOiBpLndpZHRoLCBoZWlnaHQ6IGkuaGVpZ2h0LCBvZmZzZXQ6IHsgdG9wOiBpLnRvcCArIG8sIGxlZnQ6IGkubGVmdCArIGEgfSwgcGFyZW50RGltczogeyB3aWR0aDogbi53aWR0aCwgaGVpZ2h0OiBuLmhlaWdodCwgb2Zmc2V0OiB7IHRvcDogbi50b3AgKyBvLCBsZWZ0OiBuLmxlZnQgKyBhIH0gfSwgd2luZG93RGltczogeyB3aWR0aDogcy53aWR0aCwgaGVpZ2h0OiBzLmhlaWdodCwgb2Zmc2V0OiB7IHRvcDogbywgbGVmdDogYSB9IH0gfTtcXG4gIH1mdW5jdGlvbiBuKHQsIGUsIG4sIHMsIG8sIGEpIHtcXG4gICAgdmFyIHIgPSBpKHQpLFxcbiAgICAgICAgbCA9IGUgPyBpKGUpIDogbnVsbDtzd2l0Y2ggKG4pIHtjYXNlIFxcXCJ0b3BcXFwiOlxcbiAgICAgICAgcmV0dXJuIHsgbGVmdDogRm91bmRhdGlvbi5ydGwoKSA/IGwub2Zmc2V0LmxlZnQgLSByLndpZHRoICsgbC53aWR0aCA6IGwub2Zmc2V0LmxlZnQsIHRvcDogbC5vZmZzZXQudG9wIC0gKHIuaGVpZ2h0ICsgcykgfTtjYXNlIFxcXCJsZWZ0XFxcIjpcXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGwub2Zmc2V0LmxlZnQgLSAoci53aWR0aCArIG8pLCB0b3A6IGwub2Zmc2V0LnRvcCB9O2Nhc2UgXFxcInJpZ2h0XFxcIjpcXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGwub2Zmc2V0LmxlZnQgKyBsLndpZHRoICsgbywgdG9wOiBsLm9mZnNldC50b3AgfTtjYXNlIFxcXCJjZW50ZXIgdG9wXFxcIjpcXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGwub2Zmc2V0LmxlZnQgKyBsLndpZHRoIC8gMiAtIHIud2lkdGggLyAyLCB0b3A6IGwub2Zmc2V0LnRvcCAtIChyLmhlaWdodCArIHMpIH07Y2FzZSBcXFwiY2VudGVyIGJvdHRvbVxcXCI6XFxuICAgICAgICByZXR1cm4geyBsZWZ0OiBhID8gbyA6IGwub2Zmc2V0LmxlZnQgKyBsLndpZHRoIC8gMiAtIHIud2lkdGggLyAyLCB0b3A6IGwub2Zmc2V0LnRvcCArIGwuaGVpZ2h0ICsgcyB9O2Nhc2UgXFxcImNlbnRlciBsZWZ0XFxcIjpcXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGwub2Zmc2V0LmxlZnQgLSAoci53aWR0aCArIG8pLCB0b3A6IGwub2Zmc2V0LnRvcCArIGwuaGVpZ2h0IC8gMiAtIHIuaGVpZ2h0IC8gMiB9O2Nhc2UgXFxcImNlbnRlciByaWdodFxcXCI6XFxuICAgICAgICByZXR1cm4geyBsZWZ0OiBsLm9mZnNldC5sZWZ0ICsgbC53aWR0aCArIG8gKyAxLCB0b3A6IGwub2Zmc2V0LnRvcCArIGwuaGVpZ2h0IC8gMiAtIHIuaGVpZ2h0IC8gMiB9O2Nhc2UgXFxcImNlbnRlclxcXCI6XFxuICAgICAgICByZXR1cm4geyBsZWZ0OiByLndpbmRvd0RpbXMub2Zmc2V0LmxlZnQgKyByLndpbmRvd0RpbXMud2lkdGggLyAyIC0gci53aWR0aCAvIDIsIHRvcDogci53aW5kb3dEaW1zLm9mZnNldC50b3AgKyByLndpbmRvd0RpbXMuaGVpZ2h0IC8gMiAtIHIuaGVpZ2h0IC8gMiB9O2Nhc2UgXFxcInJldmVhbFxcXCI6XFxuICAgICAgICByZXR1cm4geyBsZWZ0OiAoci53aW5kb3dEaW1zLndpZHRoIC0gci53aWR0aCkgLyAyLCB0b3A6IHIud2luZG93RGltcy5vZmZzZXQudG9wICsgcyB9O2Nhc2UgXFxcInJldmVhbCBmdWxsXFxcIjpcXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IHIud2luZG93RGltcy5vZmZzZXQubGVmdCwgdG9wOiByLndpbmRvd0RpbXMub2Zmc2V0LnRvcCB9O2Nhc2UgXFxcImxlZnQgYm90dG9tXFxcIjpcXG4gICAgICAgIHJldHVybiB7IGxlZnQ6IGwub2Zmc2V0LmxlZnQsIHRvcDogbC5vZmZzZXQudG9wICsgbC5oZWlnaHQgfTtjYXNlIFxcXCJyaWdodCBib3R0b21cXFwiOlxcbiAgICAgICAgcmV0dXJuIHsgbGVmdDogbC5vZmZzZXQubGVmdCArIGwud2lkdGggKyBvIC0gci53aWR0aCwgdG9wOiBsLm9mZnNldC50b3AgKyBsLmhlaWdodCB9O2RlZmF1bHQ6XFxuICAgICAgICByZXR1cm4geyBsZWZ0OiBGb3VuZGF0aW9uLnJ0bCgpID8gbC5vZmZzZXQubGVmdCAtIHIud2lkdGggKyBsLndpZHRoIDogbC5vZmZzZXQubGVmdCArIG8sIHRvcDogbC5vZmZzZXQudG9wICsgbC5oZWlnaHQgKyBzIH07fVxcbiAgfUZvdW5kYXRpb24uQm94ID0geyBJbU5vdFRvdWNoaW5nWW91OiBlLCBHZXREaW1lbnNpb25zOiBpLCBHZXRPZmZzZXRzOiBuIH07XFxufShqUXVlcnkpLCAhZnVuY3Rpb24gKHQpIHtcXG4gIGZ1bmN0aW9uIGUodCkge1xcbiAgICB2YXIgZSA9IHt9O2ZvciAodmFyIGkgaW4gdCkge1xcbiAgICAgIGVbdFtpXV0gPSB0W2ldO1xcbiAgICB9cmV0dXJuIGU7XFxuICB9dmFyIGkgPSB7IDk6IFxcXCJUQUJcXFwiLCAxMzogXFxcIkVOVEVSXFxcIiwgMjc6IFxcXCJFU0NBUEVcXFwiLCAzMjogXFxcIlNQQUNFXFxcIiwgMzc6IFxcXCJBUlJPV19MRUZUXFxcIiwgMzg6IFxcXCJBUlJPV19VUFxcXCIsIDM5OiBcXFwiQVJST1dfUklHSFRcXFwiLCA0MDogXFxcIkFSUk9XX0RPV05cXFwiIH0sXFxuICAgICAgbiA9IHt9LFxcbiAgICAgIHMgPSB7IGtleXM6IGUoaSksIHBhcnNlS2V5OiBmdW5jdGlvbiBwYXJzZUtleSh0KSB7XFxuICAgICAgdmFyIGUgPSBpW3Qud2hpY2ggfHwgdC5rZXlDb2RlXSB8fCBTdHJpbmcuZnJvbUNoYXJDb2RlKHQud2hpY2gpLnRvVXBwZXJDYXNlKCk7cmV0dXJuIHQuc2hpZnRLZXkgJiYgKGUgPSBcXFwiU0hJRlRfXFxcIiArIGUpLCB0LmN0cmxLZXkgJiYgKGUgPSBcXFwiQ1RSTF9cXFwiICsgZSksIHQuYWx0S2V5ICYmIChlID0gXFxcIkFMVF9cXFwiICsgZSksIGU7XFxuICAgIH0sIGhhbmRsZUtleTogZnVuY3Rpb24gaGFuZGxlS2V5KGUsIGksIHMpIHtcXG4gICAgICB2YXIgbyxcXG4gICAgICAgICAgYSxcXG4gICAgICAgICAgcixcXG4gICAgICAgICAgbCA9IG5baV0sXFxuICAgICAgICAgIHUgPSB0aGlzLnBhcnNlS2V5KGUpO2lmICghbCkgcmV0dXJuIGNvbnNvbGUud2FybihcXFwiQ29tcG9uZW50IG5vdCBkZWZpbmVkIVxcXCIpO2lmIChvID0gXFxcInVuZGVmaW5lZFxcXCIgPT0gdHlwZW9mIGwubHRyID8gbCA6IEZvdW5kYXRpb24ucnRsKCkgPyB0LmV4dGVuZCh7fSwgbC5sdHIsIGwucnRsKSA6IHQuZXh0ZW5kKHt9LCBsLnJ0bCwgbC5sdHIpLCBhID0gb1t1XSwgciA9IHNbYV0sIHIgJiYgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2Ygcikge1xcbiAgICAgICAgdmFyIGQgPSByLmFwcGx5KCk7KHMuaGFuZGxlZCB8fCBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBzLmhhbmRsZWQpICYmIHMuaGFuZGxlZChkKTtcXG4gICAgICB9IGVsc2UgKHMudW5oYW5kbGVkIHx8IFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIHMudW5oYW5kbGVkKSAmJiBzLnVuaGFuZGxlZCgpO1xcbiAgICB9LCBmaW5kRm9jdXNhYmxlOiBmdW5jdGlvbiBmaW5kRm9jdXNhYmxlKGUpIHtcXG4gICAgICByZXR1cm4gZS5maW5kKFxcXCJhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgYnV0dG9uOm5vdChbZGlzYWJsZWRdKSwgaWZyYW1lLCBvYmplY3QsIGVtYmVkLCAqW3RhYmluZGV4XSwgKltjb250ZW50ZWRpdGFibGVdXFxcIikuZmlsdGVyKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHJldHVybiAhKCF0KHRoaXMpLmlzKFxcXCI6dmlzaWJsZVxcXCIpIHx8IHQodGhpcykuYXR0cihcXFwidGFiaW5kZXhcXFwiKSA8IDApO1xcbiAgICAgIH0pO1xcbiAgICB9LCByZWdpc3RlcjogZnVuY3Rpb24gcmVnaXN0ZXIodCwgZSkge1xcbiAgICAgIG5bdF0gPSBlO1xcbiAgICB9IH07Rm91bmRhdGlvbi5LZXlib2FyZCA9IHM7XFxufShqUXVlcnkpLCAhZnVuY3Rpb24gKHQpIHtcXG4gIGZ1bmN0aW9uIGUodCkge1xcbiAgICB2YXIgZSA9IHt9O3JldHVybiBcXFwic3RyaW5nXFxcIiAhPSB0eXBlb2YgdCA/IGUgOiAodCA9IHQudHJpbSgpLnNsaWNlKDEsIC0xKSkgPyBlID0gdC5zcGxpdChcXFwiJlxcXCIpLnJlZHVjZShmdW5jdGlvbiAodCwgZSkge1xcbiAgICAgIHZhciBpID0gZS5yZXBsYWNlKC9cXFxcKy9nLCBcXFwiIFxcXCIpLnNwbGl0KFxcXCI9XFxcIiksXFxuICAgICAgICAgIG4gPSBpWzBdLFxcbiAgICAgICAgICBzID0gaVsxXTtyZXR1cm4gbiA9IGRlY29kZVVSSUNvbXBvbmVudChuKSwgcyA9IHZvaWQgMCA9PT0gcyA/IG51bGwgOiBkZWNvZGVVUklDb21wb25lbnQocyksIHQuaGFzT3duUHJvcGVydHkobikgPyBBcnJheS5pc0FycmF5KHRbbl0pID8gdFtuXS5wdXNoKHMpIDogdFtuXSA9IFt0W25dLCBzXSA6IHRbbl0gPSBzLCB0O1xcbiAgICB9LCB7fSkgOiBlO1xcbiAgfXZhciBpID0geyBxdWVyaWVzOiBbXSwgY3VycmVudDogXFxcIlxcXCIsIF9pbml0OiBmdW5jdGlvbiBfaW5pdCgpIHtcXG4gICAgICB2YXIgaSxcXG4gICAgICAgICAgbiA9IHRoaXMsXFxuICAgICAgICAgIHMgPSB0KFxcXCIuZm91bmRhdGlvbi1tcVxcXCIpLmNzcyhcXFwiZm9udC1mYW1pbHlcXFwiKTtpID0gZShzKTtmb3IgKHZhciBvIGluIGkpIHtcXG4gICAgICAgIGkuaGFzT3duUHJvcGVydHkobykgJiYgbi5xdWVyaWVzLnB1c2goeyBuYW1lOiBvLCB2YWx1ZTogXFxcIm9ubHkgc2NyZWVuIGFuZCAobWluLXdpZHRoOiBcXFwiICsgaVtvXSArIFxcXCIpXFxcIiB9KTtcXG4gICAgICB9dGhpcy5jdXJyZW50ID0gdGhpcy5fZ2V0Q3VycmVudFNpemUoKSwgdGhpcy5fd2F0Y2hlcigpO1xcbiAgICB9LCBhdExlYXN0OiBmdW5jdGlvbiBhdExlYXN0KHQpIHtcXG4gICAgICB2YXIgZSA9IHRoaXMuZ2V0KHQpO3JldHVybiAhIWUgJiYgd2luZG93Lm1hdGNoTWVkaWEoZSkubWF0Y2hlcztcXG4gICAgfSwgZ2V0OiBmdW5jdGlvbiBnZXQodCkge1xcbiAgICAgIGZvciAodmFyIGUgaW4gdGhpcy5xdWVyaWVzKSB7XFxuICAgICAgICBpZiAodGhpcy5xdWVyaWVzLmhhc093blByb3BlcnR5KGUpKSB7XFxuICAgICAgICAgIHZhciBpID0gdGhpcy5xdWVyaWVzW2VdO2lmICh0ID09PSBpLm5hbWUpIHJldHVybiBpLnZhbHVlO1xcbiAgICAgICAgfVxcbiAgICAgIH1yZXR1cm4gbnVsbDtcXG4gICAgfSwgX2dldEN1cnJlbnRTaXplOiBmdW5jdGlvbiBfZ2V0Q3VycmVudFNpemUoKSB7XFxuICAgICAgZm9yICh2YXIgdCwgZSA9IDA7IGUgPCB0aGlzLnF1ZXJpZXMubGVuZ3RoOyBlKyspIHtcXG4gICAgICAgIHZhciBpID0gdGhpcy5xdWVyaWVzW2VdO3dpbmRvdy5tYXRjaE1lZGlhKGkudmFsdWUpLm1hdGNoZXMgJiYgKHQgPSBpKTtcXG4gICAgICB9cmV0dXJuIFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YodCkpID8gdC5uYW1lIDogdDtcXG4gICAgfSwgX3dhdGNoZXI6IGZ1bmN0aW9uIF93YXRjaGVyKCkge1xcbiAgICAgIHZhciBlID0gdGhpczt0KHdpbmRvdykub24oXFxcInJlc2l6ZS56Zi5tZWRpYXF1ZXJ5XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGkgPSBlLl9nZXRDdXJyZW50U2l6ZSgpLFxcbiAgICAgICAgICAgIG4gPSBlLmN1cnJlbnQ7aSAhPT0gbiAmJiAoZS5jdXJyZW50ID0gaSwgdCh3aW5kb3cpLnRyaWdnZXIoXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsIFtpLCBuXSkpO1xcbiAgICAgIH0pO1xcbiAgICB9IH07Rm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gaSwgd2luZG93Lm1hdGNoTWVkaWEgfHwgKHdpbmRvdy5tYXRjaE1lZGlhID0gZnVuY3Rpb24gKCkge1xcbiAgICBcXFwidXNlIHN0cmljdFxcXCI7XFxuICAgIHZhciB0ID0gd2luZG93LnN0eWxlTWVkaWEgfHwgd2luZG93Lm1lZGlhO2lmICghdCkge1xcbiAgICAgIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwic3R5bGVcXFwiKSxcXG4gICAgICAgICAgaSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKFxcXCJzY3JpcHRcXFwiKVswXSxcXG4gICAgICAgICAgbiA9IG51bGw7ZS50eXBlID0gXFxcInRleHQvY3NzXFxcIiwgZS5pZCA9IFxcXCJtYXRjaG1lZGlhanMtdGVzdFxcXCIsIGkgJiYgaS5wYXJlbnROb2RlICYmIGkucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZSwgaSksIG4gPSBcXFwiZ2V0Q29tcHV0ZWRTdHlsZVxcXCIgaW4gd2luZG93ICYmIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGUsIG51bGwpIHx8IGUuY3VycmVudFN0eWxlLCB0ID0geyBtYXRjaE1lZGl1bTogZnVuY3Rpb24gbWF0Y2hNZWRpdW0odCkge1xcbiAgICAgICAgICB2YXIgaSA9IFxcXCJAbWVkaWEgXFxcIiArIHQgKyBcXFwieyAjbWF0Y2htZWRpYWpzLXRlc3QgeyB3aWR0aDogMXB4OyB9IH1cXFwiO3JldHVybiBlLnN0eWxlU2hlZXQgPyBlLnN0eWxlU2hlZXQuY3NzVGV4dCA9IGkgOiBlLnRleHRDb250ZW50ID0gaSwgXFxcIjFweFxcXCIgPT09IG4ud2lkdGg7XFxuICAgICAgICB9IH07XFxuICAgIH1yZXR1cm4gZnVuY3Rpb24gKGUpIHtcXG4gICAgICByZXR1cm4geyBtYXRjaGVzOiB0Lm1hdGNoTWVkaXVtKGUgfHwgXFxcImFsbFxcXCIpLCBtZWRpYTogZSB8fCBcXFwiYWxsXFxcIiB9O1xcbiAgICB9O1xcbiAgfSgpKSwgRm91bmRhdGlvbi5NZWRpYVF1ZXJ5ID0gaTtcXG59KGpRdWVyeSksICFmdW5jdGlvbiAodCkge1xcbiAgZnVuY3Rpb24gZSh0LCBlLCBpKSB7XFxuICAgIGZ1bmN0aW9uIG4ocikge1xcbiAgICAgIGEgfHwgKGEgPSB3aW5kb3cucGVyZm9ybWFuY2Uubm93KCkpLCBvID0gciAtIGEsIGkuYXBwbHkoZSksIG8gPCB0ID8gcyA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUobiwgZSkgOiAod2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lKHMpLCBlLnRyaWdnZXIoXFxcImZpbmlzaGVkLnpmLmFuaW1hdGVcXFwiLCBbZV0pLnRyaWdnZXJIYW5kbGVyKFxcXCJmaW5pc2hlZC56Zi5hbmltYXRlXFxcIiwgW2VdKSk7XFxuICAgIH12YXIgcyxcXG4gICAgICAgIG8sXFxuICAgICAgICBhID0gbnVsbDtzID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShuKTtcXG4gIH1mdW5jdGlvbiBpKGUsIGksIG8sIGEpIHtcXG4gICAgZnVuY3Rpb24gcigpIHtcXG4gICAgICBlIHx8IGkuaGlkZSgpLCBsKCksIGEgJiYgYS5hcHBseShpKTtcXG4gICAgfWZ1bmN0aW9uIGwoKSB7XFxuICAgICAgaVswXS5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAwLCBpLnJlbW92ZUNsYXNzKHUgKyBcXFwiIFxcXCIgKyBkICsgXFxcIiBcXFwiICsgbyk7XFxuICAgIH1pZiAoaSA9IHQoaSkuZXEoMCksIGkubGVuZ3RoKSB7XFxuICAgICAgdmFyIHUgPSBlID8gblswXSA6IG5bMV0sXFxuICAgICAgICAgIGQgPSBlID8gc1swXSA6IHNbMV07bCgpLCBpLmFkZENsYXNzKG8pLmNzcyhcXFwidHJhbnNpdGlvblxcXCIsIFxcXCJub25lXFxcIiksIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICBpLmFkZENsYXNzKHUpLCBlICYmIGkuc2hvdygpO1xcbiAgICAgIH0pLCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaVswXS5vZmZzZXRXaWR0aCwgaS5jc3MoXFxcInRyYW5zaXRpb25cXFwiLCBcXFwiXFxcIikuYWRkQ2xhc3MoZCk7XFxuICAgICAgfSksIGkub25lKEZvdW5kYXRpb24udHJhbnNpdGlvbmVuZChpKSwgcik7XFxuICAgIH1cXG4gIH12YXIgbiA9IFtcXFwibXVpLWVudGVyXFxcIiwgXFxcIm11aS1sZWF2ZVxcXCJdLFxcbiAgICAgIHMgPSBbXFxcIm11aS1lbnRlci1hY3RpdmVcXFwiLCBcXFwibXVpLWxlYXZlLWFjdGl2ZVxcXCJdLFxcbiAgICAgIG8gPSB7IGFuaW1hdGVJbjogZnVuY3Rpb24gYW5pbWF0ZUluKHQsIGUsIG4pIHtcXG4gICAgICBpKCEwLCB0LCBlLCBuKTtcXG4gICAgfSwgYW5pbWF0ZU91dDogZnVuY3Rpb24gYW5pbWF0ZU91dCh0LCBlLCBuKSB7XFxuICAgICAgaSghMSwgdCwgZSwgbik7XFxuICAgIH0gfTtGb3VuZGF0aW9uLk1vdmUgPSBlLCBGb3VuZGF0aW9uLk1vdGlvbiA9IG87XFxufShqUXVlcnkpLCAhZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0geyBGZWF0aGVyOiBmdW5jdGlvbiBGZWF0aGVyKGUpIHtcXG4gICAgICB2YXIgaSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHZvaWQgMCAhPT0gYXJndW1lbnRzWzFdID8gYXJndW1lbnRzWzFdIDogXFxcInpmXFxcIjtlLmF0dHIoXFxcInJvbGVcXFwiLCBcXFwibWVudWJhclxcXCIpO3ZhciBuID0gZS5maW5kKFxcXCJsaVxcXCIpLmF0dHIoeyByb2xlOiBcXFwibWVudWl0ZW1cXFwiIH0pLFxcbiAgICAgICAgICBzID0gXFxcImlzLVxcXCIgKyBpICsgXFxcIi1zdWJtZW51XFxcIixcXG4gICAgICAgICAgbyA9IHMgKyBcXFwiLWl0ZW1cXFwiLFxcbiAgICAgICAgICBhID0gXFxcImlzLVxcXCIgKyBpICsgXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7ZS5maW5kKFxcXCJhOmZpcnN0XFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLCAwKSwgbi5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIHZhciBlID0gdCh0aGlzKSxcXG4gICAgICAgICAgICBpID0gZS5jaGlsZHJlbihcXFwidWxcXFwiKTtpLmxlbmd0aCAmJiAoZS5hZGRDbGFzcyhhKS5hdHRyKHsgXFxcImFyaWEtaGFzcG9wdXBcXFwiOiAhMCwgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiAhMSwgXFxcImFyaWEtbGFiZWxcXFwiOiBlLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikudGV4dCgpIH0pLCBpLmFkZENsYXNzKFxcXCJzdWJtZW51IFxcXCIgKyBzKS5hdHRyKHsgXFxcImRhdGEtc3VibWVudVxcXCI6IFxcXCJcXFwiLCBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhMCwgcm9sZTogXFxcIm1lbnVcXFwiIH0pKSwgZS5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoICYmIGUuYWRkQ2xhc3MoXFxcImlzLXN1Ym1lbnUtaXRlbSBcXFwiICsgbyk7XFxuICAgICAgfSk7XFxuICAgIH0sIEJ1cm46IGZ1bmN0aW9uIEJ1cm4odCwgZSkge1xcbiAgICAgIHZhciBpID0gKHQuZmluZChcXFwibGlcXFwiKS5yZW1vdmVBdHRyKFxcXCJ0YWJpbmRleFxcXCIpLCBcXFwiaXMtXFxcIiArIGUgKyBcXFwiLXN1Ym1lbnVcXFwiKSxcXG4gICAgICAgICAgbiA9IGkgKyBcXFwiLWl0ZW1cXFwiLFxcbiAgICAgICAgICBzID0gXFxcImlzLVxcXCIgKyBlICsgXFxcIi1zdWJtZW51LXBhcmVudFxcXCI7dC5maW5kKFxcXCI+bGksIC5tZW51LCAubWVudSA+IGxpXFxcIikucmVtb3ZlQ2xhc3MoaSArIFxcXCIgXFxcIiArIG4gKyBcXFwiIFxcXCIgKyBzICsgXFxcIiBpcy1zdWJtZW51LWl0ZW0gc3VibWVudSBpcy1hY3RpdmVcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXN1Ym1lbnVcXFwiKS5jc3MoXFxcImRpc3BsYXlcXFwiLCBcXFwiXFxcIik7XFxuICAgIH0gfTtGb3VuZGF0aW9uLk5lc3QgPSBlO1xcbn0oalF1ZXJ5KSwgIWZ1bmN0aW9uICh0KSB7XFxuICBmdW5jdGlvbiBlKHQsIGUsIGkpIHtcXG4gICAgdmFyIG4sXFxuICAgICAgICBzLFxcbiAgICAgICAgbyA9IHRoaXMsXFxuICAgICAgICBhID0gZS5kdXJhdGlvbixcXG4gICAgICAgIHIgPSBPYmplY3Qua2V5cyh0LmRhdGEoKSlbMF0gfHwgXFxcInRpbWVyXFxcIixcXG4gICAgICAgIGwgPSAtMTt0aGlzLmlzUGF1c2VkID0gITEsIHRoaXMucmVzdGFydCA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICBsID0gLTEsIGNsZWFyVGltZW91dChzKSwgdGhpcy5zdGFydCgpO1xcbiAgICB9LCB0aGlzLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgICAgIHRoaXMuaXNQYXVzZWQgPSAhMSwgY2xlYXJUaW1lb3V0KHMpLCBsID0gbCA8PSAwID8gYSA6IGwsIHQuZGF0YShcXFwicGF1c2VkXFxcIiwgITEpLCBuID0gRGF0ZS5ub3coKSwgcyA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZS5pbmZpbml0ZSAmJiBvLnJlc3RhcnQoKSwgaSAmJiBcXFwiZnVuY3Rpb25cXFwiID09IHR5cGVvZiBpICYmIGkoKTtcXG4gICAgICB9LCBsKSwgdC50cmlnZ2VyKFxcXCJ0aW1lcnN0YXJ0LnpmLlxcXCIgKyByKTtcXG4gICAgfSwgdGhpcy5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgICB0aGlzLmlzUGF1c2VkID0gITAsIGNsZWFyVGltZW91dChzKSwgdC5kYXRhKFxcXCJwYXVzZWRcXFwiLCAhMCk7dmFyIGUgPSBEYXRlLm5vdygpO2wgLT0gZSAtIG4sIHQudHJpZ2dlcihcXFwidGltZXJwYXVzZWQuemYuXFxcIiArIHIpO1xcbiAgICB9O1xcbiAgfWZ1bmN0aW9uIGkoZSwgaSkge1xcbiAgICBmdW5jdGlvbiBuKCkge1xcbiAgICAgIHMtLSwgMCA9PT0gcyAmJiBpKCk7XFxuICAgIH12YXIgcyA9IGUubGVuZ3RoOzAgPT09IHMgJiYgaSgpLCBlLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgIHRoaXMuY29tcGxldGUgPyBuKCkgOiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgdGhpcy5uYXR1cmFsV2lkdGggJiYgdGhpcy5uYXR1cmFsV2lkdGggPiAwID8gbigpIDogdCh0aGlzKS5vbmUoXFxcImxvYWRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBuKCk7XFxuICAgICAgfSk7XFxuICAgIH0pO1xcbiAgfUZvdW5kYXRpb24uVGltZXIgPSBlLCBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkID0gaTtcXG59KGpRdWVyeSksIGZ1bmN0aW9uICh0KSB7XFxuICBmdW5jdGlvbiBlKCkge1xcbiAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcInRvdWNobW92ZVxcXCIsIGkpLCB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXFxcInRvdWNoZW5kXFxcIiwgZSksIHUgPSAhMTtcXG4gIH1mdW5jdGlvbiBpKGkpIHtcXG4gICAgaWYgKHQuc3BvdFN3aXBlLnByZXZlbnREZWZhdWx0ICYmIGkucHJldmVudERlZmF1bHQoKSwgdSkge1xcbiAgICAgIHZhciBuLFxcbiAgICAgICAgICBzID0gaS50b3VjaGVzWzBdLnBhZ2VYLFxcbiAgICAgICAgICBhID0gKGkudG91Y2hlc1swXS5wYWdlWSwgbyAtIHMpO2wgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSAtIHIsIE1hdGguYWJzKGEpID49IHQuc3BvdFN3aXBlLm1vdmVUaHJlc2hvbGQgJiYgbCA8PSB0LnNwb3RTd2lwZS50aW1lVGhyZXNob2xkICYmIChuID0gYSA+IDAgPyBcXFwibGVmdFxcXCIgOiBcXFwicmlnaHRcXFwiKSwgbiAmJiAoaS5wcmV2ZW50RGVmYXVsdCgpLCBlLmNhbGwodGhpcyksIHQodGhpcykudHJpZ2dlcihcXFwic3dpcGVcXFwiLCBuKS50cmlnZ2VyKFxcXCJzd2lwZVxcXCIgKyBuKSk7XFxuICAgIH1cXG4gIH1mdW5jdGlvbiBuKHQpIHtcXG4gICAgMSA9PSB0LnRvdWNoZXMubGVuZ3RoICYmIChvID0gdC50b3VjaGVzWzBdLnBhZ2VYLCBhID0gdC50b3VjaGVzWzBdLnBhZ2VZLCB1ID0gITAsIHIgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKSwgdGhpcy5hZGRFdmVudExpc3RlbmVyKFxcXCJ0b3VjaG1vdmVcXFwiLCBpLCAhMSksIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihcXFwidG91Y2hlbmRcXFwiLCBlLCAhMSkpO1xcbiAgfWZ1bmN0aW9uIHMoKSB7XFxuICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciAmJiB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXFxcInRvdWNoc3RhcnRcXFwiLCBuLCAhMSk7XFxuICB9dC5zcG90U3dpcGUgPSB7IHZlcnNpb246IFxcXCIxLjAuMFxcXCIsIGVuYWJsZWQ6IFxcXCJvbnRvdWNoc3RhcnRcXFwiIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgcHJldmVudERlZmF1bHQ6ICExLCBtb3ZlVGhyZXNob2xkOiA3NSwgdGltZVRocmVzaG9sZDogMjAwIH07dmFyIG8sXFxuICAgICAgYSxcXG4gICAgICByLFxcbiAgICAgIGwsXFxuICAgICAgdSA9ICExO3QuZXZlbnQuc3BlY2lhbC5zd2lwZSA9IHsgc2V0dXA6IHMgfSwgdC5lYWNoKFtcXFwibGVmdFxcXCIsIFxcXCJ1cFxcXCIsIFxcXCJkb3duXFxcIiwgXFxcInJpZ2h0XFxcIl0sIGZ1bmN0aW9uICgpIHtcXG4gICAgdC5ldmVudC5zcGVjaWFsW1xcXCJzd2lwZVxcXCIgKyB0aGlzXSA9IHsgc2V0dXA6IGZ1bmN0aW9uIHNldHVwKCkge1xcbiAgICAgICAgdCh0aGlzKS5vbihcXFwic3dpcGVcXFwiLCB0Lm5vb3ApO1xcbiAgICAgIH0gfTtcXG4gIH0pO1xcbn0oalF1ZXJ5KSwgIWZ1bmN0aW9uICh0KSB7XFxuICB0LmZuLmFkZFRvdWNoID0gZnVuY3Rpb24gKCkge1xcbiAgICB0aGlzLmVhY2goZnVuY3Rpb24gKGksIG4pIHtcXG4gICAgICB0KG4pLmJpbmQoXFxcInRvdWNoc3RhcnQgdG91Y2htb3ZlIHRvdWNoZW5kIHRvdWNoY2FuY2VsXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgZShldmVudCk7XFxuICAgICAgfSk7XFxuICAgIH0pO3ZhciBlID0gZnVuY3Rpb24gZSh0KSB7XFxuICAgICAgdmFyIGUsXFxuICAgICAgICAgIGkgPSB0LmNoYW5nZWRUb3VjaGVzLFxcbiAgICAgICAgICBuID0gaVswXSxcXG4gICAgICAgICAgcyA9IHsgdG91Y2hzdGFydDogXFxcIm1vdXNlZG93blxcXCIsIHRvdWNobW92ZTogXFxcIm1vdXNlbW92ZVxcXCIsIHRvdWNoZW5kOiBcXFwibW91c2V1cFxcXCIgfSxcXG4gICAgICAgICAgbyA9IHNbdC50eXBlXTtcXFwiTW91c2VFdmVudFxcXCIgaW4gd2luZG93ICYmIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIHdpbmRvdy5Nb3VzZUV2ZW50ID8gZSA9IG5ldyB3aW5kb3cuTW91c2VFdmVudChvLCB7IGJ1YmJsZXM6ICEwLCBjYW5jZWxhYmxlOiAhMCwgc2NyZWVuWDogbi5zY3JlZW5YLCBzY3JlZW5ZOiBuLnNjcmVlblksIGNsaWVudFg6IG4uY2xpZW50WCwgY2xpZW50WTogbi5jbGllbnRZIH0pIDogKGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudChcXFwiTW91c2VFdmVudFxcXCIpLCBlLmluaXRNb3VzZUV2ZW50KG8sICEwLCAhMCwgd2luZG93LCAxLCBuLnNjcmVlblgsIG4uc2NyZWVuWSwgbi5jbGllbnRYLCBuLmNsaWVudFksICExLCAhMSwgITEsICExLCAwLCBudWxsKSksIG4udGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XFxuICAgIH07XFxuICB9O1xcbn0oalF1ZXJ5KSwgIWZ1bmN0aW9uICh0KSB7XFxuICBmdW5jdGlvbiBlKCkge1xcbiAgICBvKCksIG4oKSwgcygpLCBpKCk7XFxuICB9ZnVuY3Rpb24gaShlKSB7XFxuICAgIHZhciBpID0gdChcXFwiW2RhdGEteWV0aS1ib3hdXFxcIiksXFxuICAgICAgICBuID0gW1xcXCJkcm9wZG93blxcXCIsIFxcXCJ0b29sdGlwXFxcIiwgXFxcInJldmVhbFxcXCJdO2lmIChlICYmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgZSA/IG4ucHVzaChlKSA6IFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgZSA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YoZSkpICYmIFxcXCJzdHJpbmdcXFwiID09IHR5cGVvZiBlWzBdID8gbi5jb25jYXQoZSkgOiBjb25zb2xlLmVycm9yKFxcXCJQbHVnaW4gbmFtZXMgbXVzdCBiZSBzdHJpbmdzXFxcIikpLCBpLmxlbmd0aCkge1xcbiAgICAgIHZhciBzID0gbi5tYXAoZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgIHJldHVybiBcXFwiY2xvc2VtZS56Zi5cXFwiICsgdDtcXG4gICAgICB9KS5qb2luKFxcXCIgXFxcIik7dCh3aW5kb3cpLm9mZihzKS5vbihzLCBmdW5jdGlvbiAoZSwgaSkge1xcbiAgICAgICAgdmFyIG4gPSBlLm5hbWVzcGFjZS5zcGxpdChcXFwiLlxcXCIpWzBdLFxcbiAgICAgICAgICAgIHMgPSB0KFxcXCJbZGF0YS1cXFwiICsgbiArIFxcXCJdXFxcIikubm90KCdbZGF0YS15ZXRpLWJveD1cXFwiJyArIGkgKyAnXFxcIl0nKTtzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZSA9IHQodGhpcyk7ZS50cmlnZ2VySGFuZGxlcihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIsIFtlXSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfWZ1bmN0aW9uIG4oZSkge1xcbiAgICB2YXIgaSA9IHZvaWQgMCxcXG4gICAgICAgIG4gPSB0KFxcXCJbZGF0YS1yZXNpemVdXFxcIik7bi5sZW5ndGggJiYgdCh3aW5kb3cpLm9mZihcXFwicmVzaXplLnpmLnRyaWdnZXJcXFwiKS5vbihcXFwicmVzaXplLnpmLnRyaWdnZXJcXFwiLCBmdW5jdGlvbiAocykge1xcbiAgICAgIGkgJiYgY2xlYXJUaW1lb3V0KGkpLCBpID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICBhIHx8IG4uZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHQodGhpcykudHJpZ2dlckhhbmRsZXIoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiKTtcXG4gICAgICAgIH0pLCBuLmF0dHIoXFxcImRhdGEtZXZlbnRzXFxcIiwgXFxcInJlc2l6ZVxcXCIpO1xcbiAgICAgIH0sIGUgfHwgMTApO1xcbiAgICB9KTtcXG4gIH1mdW5jdGlvbiBzKGUpIHtcXG4gICAgdmFyIGkgPSB2b2lkIDAsXFxuICAgICAgICBuID0gdChcXFwiW2RhdGEtc2Nyb2xsXVxcXCIpO24ubGVuZ3RoICYmIHQod2luZG93KS5vZmYoXFxcInNjcm9sbC56Zi50cmlnZ2VyXFxcIikub24oXFxcInNjcm9sbC56Zi50cmlnZ2VyXFxcIiwgZnVuY3Rpb24gKHMpIHtcXG4gICAgICBpICYmIGNsZWFyVGltZW91dChpKSwgaSA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgYSB8fCBuLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0KHRoaXMpLnRyaWdnZXJIYW5kbGVyKFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIik7XFxuICAgICAgICB9KSwgbi5hdHRyKFxcXCJkYXRhLWV2ZW50c1xcXCIsIFxcXCJzY3JvbGxcXFwiKTtcXG4gICAgICB9LCBlIHx8IDEwKTtcXG4gICAgfSk7XFxuICB9ZnVuY3Rpb24gbygpIHtcXG4gICAgaWYgKCFhKSByZXR1cm4gITE7dmFyIGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFxcXCJbZGF0YS1yZXNpemVdLCBbZGF0YS1zY3JvbGxdLCBbZGF0YS1tdXRhdGVdXFxcIiksXFxuICAgICAgICBpID0gZnVuY3Rpb24gaShlKSB7XFxuICAgICAgdmFyIGkgPSB0KGVbMF0udGFyZ2V0KTtzd2l0Y2ggKGkuYXR0cihcXFwiZGF0YS1ldmVudHNcXFwiKSkge2Nhc2UgXFxcInJlc2l6ZVxcXCI6XFxuICAgICAgICAgIGkudHJpZ2dlckhhbmRsZXIoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLCBbaV0pO2JyZWFrO2Nhc2UgXFxcInNjcm9sbFxcXCI6XFxuICAgICAgICAgIGkudHJpZ2dlckhhbmRsZXIoXFxcInNjcm9sbG1lLnpmLnRyaWdnZXJcXFwiLCBbaSwgd2luZG93LnBhZ2VZT2Zmc2V0XSk7YnJlYWs7ZGVmYXVsdDpcXG4gICAgICAgICAgcmV0dXJuICExO31cXG4gICAgfTtpZiAoZS5sZW5ndGgpIGZvciAodmFyIG4gPSAwOyBuIDw9IGUubGVuZ3RoIC0gMTsgbisrKSB7XFxuICAgICAgdmFyIHMgPSBuZXcgYShpKTtzLm9ic2VydmUoZVtuXSwgeyBhdHRyaWJ1dGVzOiAhMCwgY2hpbGRMaXN0OiAhMSwgY2hhcmFjdGVyRGF0YTogITEsIHN1YnRyZWU6ICExLCBhdHRyaWJ1dGVGaWx0ZXI6IFtcXFwiZGF0YS1ldmVudHNcXFwiXSB9KTtcXG4gICAgfVxcbiAgfXZhciBhID0gZnVuY3Rpb24gKCkge1xcbiAgICBmb3IgKHZhciB0ID0gW1xcXCJXZWJLaXRcXFwiLCBcXFwiTW96XFxcIiwgXFxcIk9cXFwiLCBcXFwiTXNcXFwiLCBcXFwiXFxcIl0sIGUgPSAwOyBlIDwgdC5sZW5ndGg7IGUrKykge1xcbiAgICAgIGlmICh0W2VdICsgXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiIGluIHdpbmRvdykgcmV0dXJuIHdpbmRvd1t0W2VdICsgXFxcIk11dGF0aW9uT2JzZXJ2ZXJcXFwiXTtcXG4gICAgfXJldHVybiAhMTtcXG4gIH0oKSxcXG4gICAgICByID0gZnVuY3Rpb24gcihlLCBpKSB7XFxuICAgIGUuZGF0YShpKS5zcGxpdChcXFwiIFxcXCIpLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcXG4gICAgICB0KFxcXCIjXFxcIiArIG4pW1xcXCJjbG9zZVxcXCIgPT09IGkgPyBcXFwidHJpZ2dlclxcXCIgOiBcXFwidHJpZ2dlckhhbmRsZXJcXFwiXShpICsgXFxcIi56Zi50cmlnZ2VyXFxcIiwgW2VdKTtcXG4gICAgfSk7XFxuICB9O3QoZG9jdW1lbnQpLm9uKFxcXCJjbGljay56Zi50cmlnZ2VyXFxcIiwgXFxcIltkYXRhLW9wZW5dXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICByKHQodGhpcyksIFxcXCJvcGVuXFxcIik7XFxuICB9KSwgdChkb2N1bWVudCkub24oXFxcImNsaWNrLnpmLnRyaWdnZXJcXFwiLCBcXFwiW2RhdGEtY2xvc2VdXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZSA9IHQodGhpcykuZGF0YShcXFwiY2xvc2VcXFwiKTtlID8gcih0KHRoaXMpLCBcXFwiY2xvc2VcXFwiKSA6IHQodGhpcykudHJpZ2dlcihcXFwiY2xvc2UuemYudHJpZ2dlclxcXCIpO1xcbiAgfSksIHQoZG9jdW1lbnQpLm9uKFxcXCJjbGljay56Zi50cmlnZ2VyXFxcIiwgXFxcIltkYXRhLXRvZ2dsZV1cXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgIHIodCh0aGlzKSwgXFxcInRvZ2dsZVxcXCIpO1xcbiAgfSksIHQoZG9jdW1lbnQpLm9uKFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIiwgXFxcIltkYXRhLWNsb3NhYmxlXVxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7dmFyIGkgPSB0KHRoaXMpLmRhdGEoXFxcImNsb3NhYmxlXFxcIik7XFxcIlxcXCIgIT09IGkgPyBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlT3V0KHQodGhpcyksIGksIGZ1bmN0aW9uICgpIHtcXG4gICAgICB0KHRoaXMpLnRyaWdnZXIoXFxcImNsb3NlZC56ZlxcXCIpO1xcbiAgICB9KSA6IHQodGhpcykuZmFkZU91dCgpLnRyaWdnZXIoXFxcImNsb3NlZC56ZlxcXCIpO1xcbiAgfSksIHQoZG9jdW1lbnQpLm9uKFxcXCJmb2N1cy56Zi50cmlnZ2VyIGJsdXIuemYudHJpZ2dlclxcXCIsIFxcXCJbZGF0YS10b2dnbGUtZm9jdXNdXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgZSA9IHQodGhpcykuZGF0YShcXFwidG9nZ2xlLWZvY3VzXFxcIik7dChcXFwiI1xcXCIgKyBlKS50cmlnZ2VySGFuZGxlcihcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiLCBbdCh0aGlzKV0pO1xcbiAgfSksIHQod2luZG93KS5vbihcXFwibG9hZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgZSgpO1xcbiAgfSksIEZvdW5kYXRpb24uSUhlYXJZb3UgPSBlO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpKSB7XFxuICAgICAgdmFyIG4gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiB2b2lkIDAgIT09IGFyZ3VtZW50c1sxXSA/IGFyZ3VtZW50c1sxXSA6IHt9O19jbGFzc0NhbGxDaGVjayh0aGlzLCBlKSwgdGhpcy4kZWxlbWVudCA9IGksIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCBlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgbiksIHRoaXMuX2luaXQoKSwgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCBcXFwiQWJpZGVcXFwiKTtcXG4gICAgfXJldHVybiBfY3JlYXRlQ2xhc3MoZSwgW3sga2V5OiBcXFwiX2luaXRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRpbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImlucHV0LCB0ZXh0YXJlYSwgc2VsZWN0XFxcIiksIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCIuYWJpZGVcXFwiKS5vbihcXFwicmVzZXQuemYuYWJpZGVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGUucmVzZXRGb3JtKCk7XFxuICAgICAgICB9KS5vbihcXFwic3VibWl0LnpmLmFiaWRlXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gZS52YWxpZGF0ZUZvcm0oKTtcXG4gICAgICAgIH0pLCBcXFwiZmllbGRDaGFuZ2VcXFwiID09PSB0aGlzLm9wdGlvbnMudmFsaWRhdGVPbiAmJiB0aGlzLiRpbnB1dHMub2ZmKFxcXCJjaGFuZ2UuemYuYWJpZGVcXFwiKS5vbihcXFwiY2hhbmdlLnpmLmFiaWRlXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgZS52YWxpZGF0ZUlucHV0KHQoaS50YXJnZXQpKTtcXG4gICAgICAgIH0pLCB0aGlzLm9wdGlvbnMubGl2ZVZhbGlkYXRlICYmIHRoaXMuJGlucHV0cy5vZmYoXFxcImlucHV0LnpmLmFiaWRlXFxcIikub24oXFxcImlucHV0LnpmLmFiaWRlXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgZS52YWxpZGF0ZUlucHV0KHQoaS50YXJnZXQpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfcmVmbG93XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy5faW5pdCgpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJyZXF1aXJlZENoZWNrXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIGlmICghdC5hdHRyKFxcXCJyZXF1aXJlZFxcXCIpKSByZXR1cm4gITA7dmFyIGUgPSAhMDtzd2l0Y2ggKHRbMF0udHlwZSkge2Nhc2UgXFxcImNoZWNrYm94XFxcIjpcXG4gICAgICAgICAgICBlID0gdFswXS5jaGVja2VkO2JyZWFrO2Nhc2UgXFxcInNlbGVjdFxcXCI6Y2FzZSBcXFwic2VsZWN0LW9uZVxcXCI6Y2FzZSBcXFwic2VsZWN0LW11bHRpcGxlXFxcIjpcXG4gICAgICAgICAgICB2YXIgaSA9IHQuZmluZChcXFwib3B0aW9uOnNlbGVjdGVkXFxcIik7aS5sZW5ndGggJiYgaS52YWwoKSB8fCAoZSA9ICExKTticmVhaztkZWZhdWx0OlxcbiAgICAgICAgICAgIHQudmFsKCkgJiYgdC52YWwoKS5sZW5ndGggfHwgKGUgPSAhMSk7fXJldHVybiBlO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJmaW5kRm9ybUVycm9yXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdC5zaWJsaW5ncyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpO3JldHVybiBlLmxlbmd0aCB8fCAoZSA9IHQucGFyZW50KCkuZmluZCh0aGlzLm9wdGlvbnMuZm9ybUVycm9yU2VsZWN0b3IpKSwgZTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZmluZExhYmVsXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdFswXS5pZCxcXG4gICAgICAgICAgICBpID0gdGhpcy4kZWxlbWVudC5maW5kKCdsYWJlbFtmb3I9XFxcIicgKyBlICsgJ1xcXCJdJyk7cmV0dXJuIGkubGVuZ3RoID8gaSA6IHQuY2xvc2VzdChcXFwibGFiZWxcXFwiKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZmluZFJhZGlvTGFiZWxzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcXG4gICAgICAgIHZhciBpID0gdGhpcyxcXG4gICAgICAgICAgICBuID0gZS5tYXAoZnVuY3Rpb24gKGUsIG4pIHtcXG4gICAgICAgICAgdmFyIHMgPSBuLmlkLFxcbiAgICAgICAgICAgICAgbyA9IGkuJGVsZW1lbnQuZmluZCgnbGFiZWxbZm9yPVxcXCInICsgcyArICdcXFwiXScpO3JldHVybiBvLmxlbmd0aCB8fCAobyA9IHQobikuY2xvc2VzdChcXFwibGFiZWxcXFwiKSksIG9bMF07XFxuICAgICAgICB9KTtyZXR1cm4gdChuKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy5maW5kTGFiZWwodCksXFxuICAgICAgICAgICAgaSA9IHRoaXMuZmluZEZvcm1FcnJvcih0KTtlLmxlbmd0aCAmJiBlLmFkZENsYXNzKHRoaXMub3B0aW9ucy5sYWJlbEVycm9yQ2xhc3MpLCBpLmxlbmd0aCAmJiBpLmFkZENsYXNzKHRoaXMub3B0aW9ucy5mb3JtRXJyb3JDbGFzcyksIHQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmlucHV0RXJyb3JDbGFzcykuYXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiwgXFxcIlxcXCIpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJyZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlc1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXMuJGVsZW1lbnQuZmluZCgnOnJhZGlvW25hbWU9XFxcIicgKyB0ICsgJ1xcXCJdJyksXFxuICAgICAgICAgICAgaSA9IHRoaXMuZmluZFJhZGlvTGFiZWxzKGUpLFxcbiAgICAgICAgICAgIG4gPSB0aGlzLmZpbmRGb3JtRXJyb3IoZSk7aS5sZW5ndGggJiYgaS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMubGFiZWxFcnJvckNsYXNzKSwgbi5sZW5ndGggJiYgbi5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuZm9ybUVycm9yQ2xhc3MpLCBlLnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5pbnB1dEVycm9yQ2xhc3MpLnJlbW92ZUF0dHIoXFxcImRhdGEtaW52YWxpZFxcXCIpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJyZW1vdmVFcnJvckNsYXNzZXNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgaWYgKFxcXCJyYWRpb1xcXCIgPT0gdFswXS50eXBlKSByZXR1cm4gdGhpcy5yZW1vdmVSYWRpb0Vycm9yQ2xhc3Nlcyh0LmF0dHIoXFxcIm5hbWVcXFwiKSk7dmFyIGUgPSB0aGlzLmZpbmRMYWJlbCh0KSxcXG4gICAgICAgICAgICBpID0gdGhpcy5maW5kRm9ybUVycm9yKHQpO2UubGVuZ3RoICYmIGUucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmxhYmVsRXJyb3JDbGFzcyksIGkubGVuZ3RoICYmIGkucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmZvcm1FcnJvckNsYXNzKSwgdC5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuaW5wdXRFcnJvckNsYXNzKS5yZW1vdmVBdHRyKFxcXCJkYXRhLWludmFsaWRcXFwiKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwidmFsaWRhdGVJbnB1dFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXMucmVxdWlyZWRDaGVjayh0KSxcXG4gICAgICAgICAgICBpID0gITEsXFxuICAgICAgICAgICAgbiA9ICEwLFxcbiAgICAgICAgICAgIHMgPSB0LmF0dHIoXFxcImRhdGEtdmFsaWRhdG9yXFxcIiksXFxuICAgICAgICAgICAgbyA9ICEwO2lmICh0LmlzKFxcXCJbZGF0YS1hYmlkZS1pZ25vcmVdXFxcIikgfHwgdC5pcygnW3R5cGU9XFxcImhpZGRlblxcXCJdJykpIHJldHVybiAhMDtzd2l0Y2ggKHRbMF0udHlwZSkge2Nhc2UgXFxcInJhZGlvXFxcIjpcXG4gICAgICAgICAgICBpID0gdGhpcy52YWxpZGF0ZVJhZGlvKHQuYXR0cihcXFwibmFtZVxcXCIpKTticmVhaztjYXNlIFxcXCJjaGVja2JveFxcXCI6XFxuICAgICAgICAgICAgaSA9IGU7YnJlYWs7Y2FzZSBcXFwic2VsZWN0XFxcIjpjYXNlIFxcXCJzZWxlY3Qtb25lXFxcIjpjYXNlIFxcXCJzZWxlY3QtbXVsdGlwbGVcXFwiOlxcbiAgICAgICAgICAgIGkgPSBlO2JyZWFrO2RlZmF1bHQ6XFxuICAgICAgICAgICAgaSA9IHRoaXMudmFsaWRhdGVUZXh0KHQpO31zICYmIChuID0gdGhpcy5tYXRjaFZhbGlkYXRpb24odCwgcywgdC5hdHRyKFxcXCJyZXF1aXJlZFxcXCIpKSksIHQuYXR0cihcXFwiZGF0YS1lcXVhbHRvXFxcIikgJiYgKG8gPSB0aGlzLm9wdGlvbnMudmFsaWRhdG9ycy5lcXVhbFRvKHQpKTt2YXIgYSA9IFtlLCBpLCBuLCBvXS5pbmRleE9mKCExKSA9PT0gLTEsXFxuICAgICAgICAgICAgciA9IChhID8gXFxcInZhbGlkXFxcIiA6IFxcXCJpbnZhbGlkXFxcIikgKyBcXFwiLnpmLmFiaWRlXFxcIjtyZXR1cm4gdGhpc1thID8gXFxcInJlbW92ZUVycm9yQ2xhc3Nlc1xcXCIgOiBcXFwiYWRkRXJyb3JDbGFzc2VzXFxcIl0odCksIHQudHJpZ2dlcihyLCBbdF0pLCBhO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJ2YWxpZGF0ZUZvcm1cXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IFtdLFxcbiAgICAgICAgICAgIGkgPSB0aGlzO3RoaXMuJGlucHV0cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZS5wdXNoKGkudmFsaWRhdGVJbnB1dCh0KHRoaXMpKSk7XFxuICAgICAgICB9KTt2YXIgbiA9IGUuaW5kZXhPZighMSkgPT09IC0xO3JldHVybiB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsIG4gPyBcXFwibm9uZVxcXCIgOiBcXFwiYmxvY2tcXFwiKSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKChuID8gXFxcImZvcm12YWxpZFxcXCIgOiBcXFwiZm9ybWludmFsaWRcXFwiKSArIFxcXCIuemYuYWJpZGVcXFwiLCBbdGhpcy4kZWxlbWVudF0pLCBuO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJ2YWxpZGF0ZVRleHRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCwgZSkge1xcbiAgICAgICAgZSA9IGUgfHwgdC5hdHRyKFxcXCJwYXR0ZXJuXFxcIikgfHwgdC5hdHRyKFxcXCJ0eXBlXFxcIik7dmFyIGkgPSB0LnZhbCgpLFxcbiAgICAgICAgICAgIG4gPSAhMTtyZXR1cm4gaS5sZW5ndGggPyBuID0gdGhpcy5vcHRpb25zLnBhdHRlcm5zLmhhc093blByb3BlcnR5KGUpID8gdGhpcy5vcHRpb25zLnBhdHRlcm5zW2VdLnRlc3QoaSkgOiBlID09PSB0LmF0dHIoXFxcInR5cGVcXFwiKSB8fCBuZXcgUmVnRXhwKGUpLnRlc3QoaSkgOiB0LnByb3AoXFxcInJlcXVpcmVkXFxcIikgfHwgKG4gPSAhMCksIG47XFxuICAgICAgfSB9LCB7IGtleTogXFxcInZhbGlkYXRlUmFkaW9cXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xcbiAgICAgICAgdmFyIGkgPSB0aGlzLiRlbGVtZW50LmZpbmQoJzpyYWRpb1tuYW1lPVxcXCInICsgZSArICdcXFwiXScpLFxcbiAgICAgICAgICAgIG4gPSAhMSxcXG4gICAgICAgICAgICBzID0gITE7cmV0dXJuIGkuZWFjaChmdW5jdGlvbiAoZSwgaSkge1xcbiAgICAgICAgICB0KGkpLmF0dHIoXFxcInJlcXVpcmVkXFxcIikgJiYgKHMgPSAhMCk7XFxuICAgICAgICB9KSwgcyB8fCAobiA9ICEwKSwgbiB8fCBpLmVhY2goZnVuY3Rpb24gKGUsIGkpIHtcXG4gICAgICAgICAgdChpKS5wcm9wKFxcXCJjaGVja2VkXFxcIikgJiYgKG4gPSAhMCk7XFxuICAgICAgICB9KSwgbjtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwibWF0Y2hWYWxpZGF0aW9uXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIGUsIGkpIHtcXG4gICAgICAgIHZhciBuID0gdGhpcztpID0gISFpO3ZhciBzID0gZS5zcGxpdChcXFwiIFxcXCIpLm1hcChmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICByZXR1cm4gbi5vcHRpb25zLnZhbGlkYXRvcnNbZV0odCwgaSwgdC5wYXJlbnQoKSk7XFxuICAgICAgICB9KTtyZXR1cm4gcy5pbmRleE9mKCExKSA9PT0gLTE7XFxuICAgICAgfSB9LCB7IGtleTogXFxcInJlc2V0Rm9ybVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy4kZWxlbWVudCxcXG4gICAgICAgICAgICBpID0gdGhpcy5vcHRpb25zO3QoXFxcIi5cXFwiICsgaS5sYWJlbEVycm9yQ2xhc3MsIGUpLm5vdChcXFwic21hbGxcXFwiKS5yZW1vdmVDbGFzcyhpLmxhYmVsRXJyb3JDbGFzcyksIHQoXFxcIi5cXFwiICsgaS5pbnB1dEVycm9yQ2xhc3MsIGUpLm5vdChcXFwic21hbGxcXFwiKS5yZW1vdmVDbGFzcyhpLmlucHV0RXJyb3JDbGFzcyksIHQoaS5mb3JtRXJyb3JTZWxlY3RvciArIFxcXCIuXFxcIiArIGkuZm9ybUVycm9yQ2xhc3MpLnJlbW92ZUNsYXNzKGkuZm9ybUVycm9yQ2xhc3MpLCBlLmZpbmQoXFxcIltkYXRhLWFiaWRlLWVycm9yXVxcXCIpLmNzcyhcXFwiZGlzcGxheVxcXCIsIFxcXCJub25lXFxcIiksIHQoXFxcIjppbnB1dFxcXCIsIGUpLm5vdChcXFwiOmJ1dHRvbiwgOnN1Ym1pdCwgOnJlc2V0LCA6aGlkZGVuLCA6cmFkaW8sIDpjaGVja2JveCwgW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnZhbChcXFwiXFxcIikucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksIHQoXFxcIjppbnB1dDpyYWRpb1xcXCIsIGUpLm5vdChcXFwiW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnByb3AoXFxcImNoZWNrZWRcXFwiLCAhMSkucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksIHQoXFxcIjppbnB1dDpjaGVja2JveFxcXCIsIGUpLm5vdChcXFwiW2RhdGEtYWJpZGUtaWdub3JlXVxcXCIpLnByb3AoXFxcImNoZWNrZWRcXFwiLCAhMSkucmVtb3ZlQXR0cihcXFwiZGF0YS1pbnZhbGlkXFxcIiksIGUudHJpZ2dlcihcXFwiZm9ybXJlc2V0LnpmLmFiaWRlXFxcIiwgW2VdKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZGVzdHJveVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpczt0aGlzLiRlbGVtZW50Lm9mZihcXFwiLmFiaWRlXFxcIikuZmluZChcXFwiW2RhdGEtYWJpZGUtZXJyb3JdXFxcIikuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIm5vbmVcXFwiKSwgdGhpcy4kaW5wdXRzLm9mZihcXFwiLmFiaWRlXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGUucmVtb3ZlRXJyb3JDbGFzc2VzKHQodGhpcykpO1xcbiAgICAgICAgfSksIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9IH1dKSwgZTtcXG4gIH0oKTtlLmRlZmF1bHRzID0geyB2YWxpZGF0ZU9uOiBcXFwiZmllbGRDaGFuZ2VcXFwiLCBsYWJlbEVycm9yQ2xhc3M6IFxcXCJpcy1pbnZhbGlkLWxhYmVsXFxcIiwgaW5wdXRFcnJvckNsYXNzOiBcXFwiaXMtaW52YWxpZC1pbnB1dFxcXCIsIGZvcm1FcnJvclNlbGVjdG9yOiBcXFwiLmZvcm0tZXJyb3JcXFwiLCBmb3JtRXJyb3JDbGFzczogXFxcImlzLXZpc2libGVcXFwiLCBsaXZlVmFsaWRhdGU6ICExLCBwYXR0ZXJuczogeyBhbHBoYTogL15bYS16QS1aXSskLywgYWxwaGFfbnVtZXJpYzogL15bYS16QS1aMC05XSskLywgaW50ZWdlcjogL15bLStdP1xcXFxkKyQvLCBudW1iZXI6IC9eWy0rXT9cXFxcZCooPzpbXFxcXC5cXFxcLF1cXFxcZCspPyQvLCBjYXJkOiAvXig/OjRbMC05XXsxMn0oPzpbMC05XXszfSk/fDVbMS01XVswLTldezE0fXw2KD86MDExfDVbMC05XVswLTldKVswLTldezEyfXwzWzQ3XVswLTldezEzfXwzKD86MFswLTVdfFs2OF1bMC05XSlbMC05XXsxMX18KD86MjEzMXwxODAwfDM1XFxcXGR7M30pXFxcXGR7MTF9KSQvLCBjdnY6IC9eKFswLTldKXszLDR9JC8sIGVtYWlsOiAvXlthLXpBLVowLTkuISMkJSYnKitcXFxcLz0/Xl9ge3x9fi1dK0BbYS16QS1aMC05XSg/OlthLXpBLVowLTktXXswLDYxfVthLXpBLVowLTldKT8oPzpcXFxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykrJC8sIHVybDogL14oaHR0cHM/fGZ0cHxmaWxlfHNzaCk6XFxcXC9cXFxcLygoKChbYS16QS1aXXxcXFxcZHwtfFxcXFwufF98fnxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KCVbXFxcXGRhLWZdezJ9KXxbIVxcXFwkJidcXFxcKFxcXFwpXFxcXCpcXFxcKyw7PV18OikqQCk/KCgoXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKVxcXFwuKFxcXFxkfFsxLTldXFxcXGR8MVxcXFxkXFxcXGR8MlswLTRdXFxcXGR8MjVbMC01XSlcXFxcLihcXFxcZHxbMS05XVxcXFxkfDFcXFxcZFxcXFxkfDJbMC00XVxcXFxkfDI1WzAtNV0pXFxcXC4oXFxcXGR8WzEtOV1cXFxcZHwxXFxcXGRcXFxcZHwyWzAtNF1cXFxcZHwyNVswLTVdKSl8KCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCgoW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKSooW2EtekEtWl18XFxcXGR8W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKSlcXFxcLikrKChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSl8KChbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pKihbYS16QS1aXXxbXFxcXHUwMEEwLVxcXFx1RDdGRlxcXFx1RjkwMC1cXFxcdUZEQ0ZcXFxcdUZERjAtXFxcXHVGRkVGXSkpKVxcXFwuPykoOlxcXFxkKik/KShcXFxcLygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApKyhcXFxcLygoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCkqKSopPyk/KFxcXFw/KCgoW2EtekEtWl18XFxcXGR8LXxcXFxcLnxffH58W1xcXFx1MDBBMC1cXFxcdUQ3RkZcXFxcdUY5MDAtXFxcXHVGRENGXFxcXHVGREYwLVxcXFx1RkZFRl0pfCglW1xcXFxkYS1mXXsyfSl8WyFcXFxcJCYnXFxcXChcXFxcKVxcXFwqXFxcXCssOz1dfDp8QCl8W1xcXFx1RTAwMC1cXFxcdUY4RkZdfFxcXFwvfFxcXFw/KSopPyhcXFxcIygoKFthLXpBLVpdfFxcXFxkfC18XFxcXC58X3x+fFtcXFxcdTAwQTAtXFxcXHVEN0ZGXFxcXHVGOTAwLVxcXFx1RkRDRlxcXFx1RkRGMC1cXFxcdUZGRUZdKXwoJVtcXFxcZGEtZl17Mn0pfFshXFxcXCQmJ1xcXFwoXFxcXClcXFxcKlxcXFwrLDs9XXw6fEApfFxcXFwvfFxcXFw/KSopPyQvLCBkb21haW46IC9eKFthLXpBLVowLTldKFthLXpBLVowLTlcXFxcLV17MCw2MX1bYS16QS1aMC05XSk/XFxcXC4pK1thLXpBLVpdezIsOH0kLywgZGF0ZXRpbWU6IC9eKFswLTJdWzAtOV17M30pXFxcXC0oWzAtMV1bMC05XSlcXFxcLShbMC0zXVswLTldKVQoWzAtNV1bMC05XSlcXFxcOihbMC01XVswLTldKVxcXFw6KFswLTVdWzAtOV0pKFp8KFtcXFxcLVxcXFwrXShbMC0xXVswLTldKVxcXFw6MDApKSQvLCBkYXRlOiAvKD86MTl8MjApWzAtOV17Mn0tKD86KD86MFsxLTldfDFbMC0yXSktKD86MFsxLTldfDFbMC05XXwyWzAtOV0pfCg/Oig/ITAyKSg/OjBbMS05XXwxWzAtMl0pLSg/OjMwKSl8KD86KD86MFsxMzU3OF18MVswMl0pLTMxKSkkLywgdGltZTogL14oMFswLTldfDFbMC05XXwyWzAtM10pKDpbMC01XVswLTldKXsyfSQvLCBkYXRlSVNPOiAvXlxcXFxkezR9W1xcXFwvXFxcXC1dXFxcXGR7MSwyfVtcXFxcL1xcXFwtXVxcXFxkezEsMn0kLywgbW9udGhfZGF5X3llYXI6IC9eKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXSgwWzEtOV18WzEyXVswLTldfDNbMDFdKVstIFxcXFwvLl1cXFxcZHs0fSQvLCBkYXlfbW9udGhfeWVhcjogL14oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbLSBcXFxcLy5dKDBbMS05XXwxWzAxMl0pWy0gXFxcXC8uXVxcXFxkezR9JC8sIGNvbG9yOiAvXiM/KFthLWZBLUYwLTldezZ9fFthLWZBLUYwLTldezN9KSQvIH0sIHZhbGlkYXRvcnM6IHsgZXF1YWxUbzogZnVuY3Rpb24gZXF1YWxUbyhlLCBpLCBuKSB7XFxuICAgICAgICByZXR1cm4gdChcXFwiI1xcXCIgKyBlLmF0dHIoXFxcImRhdGEtZXF1YWx0b1xcXCIpKS52YWwoKSA9PT0gZS52YWwoKTtcXG4gICAgICB9IH0gfSwgRm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIkFiaWRlXFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIkFjY29yZGlvblxcXCIpLCBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJBY2NvcmRpb25cXFwiLCB7IEVOVEVSOiBcXFwidG9nZ2xlXFxcIiwgU1BBQ0U6IFxcXCJ0b2dnbGVcXFwiLCBBUlJPV19ET1dOOiBcXFwibmV4dFxcXCIsIEFSUk9XX1VQOiBcXFwicHJldmlvdXNcXFwiIH0pO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJ0YWJsaXN0XFxcIiksIHRoaXMuJHRhYnMgPSB0aGlzLiRlbGVtZW50LmNoaWxkcmVuKFxcXCJsaSwgW2RhdGEtYWNjb3JkaW9uLWl0ZW1dXFxcIiksIHRoaXMuJHRhYnMuZWFjaChmdW5jdGlvbiAoZSwgaSkge1xcbiAgICAgICAgICB2YXIgbiA9IHQoaSksXFxuICAgICAgICAgICAgICBzID0gbi5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIiksXFxuICAgICAgICAgICAgICBvID0gc1swXS5pZCB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsIFxcXCJhY2NvcmRpb25cXFwiKSxcXG4gICAgICAgICAgICAgIGEgPSBpLmlkIHx8IG8gKyBcXFwiLWxhYmVsXFxcIjtuLmZpbmQoXFxcImE6Zmlyc3RcXFwiKS5hdHRyKHsgXFxcImFyaWEtY29udHJvbHNcXFwiOiBvLCByb2xlOiBcXFwidGFiXFxcIiwgaWQ6IGEsIFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogITEsIFxcXCJhcmlhLXNlbGVjdGVkXFxcIjogITEgfSksIHMuYXR0cih7IHJvbGU6IFxcXCJ0YWJwYW5lbFxcXCIsIFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOiBhLCBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhMCwgaWQ6IG8gfSk7XFxuICAgICAgICB9KTt2YXIgZSA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtlLmxlbmd0aCAmJiB0aGlzLmRvd24oZSwgITApLCB0aGlzLl9ldmVudHMoKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2V2ZW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpczt0aGlzLiR0YWJzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgaSA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBuID0gaS5jaGlsZHJlbihcXFwiW2RhdGEtdGFiLWNvbnRlbnRdXFxcIik7bi5sZW5ndGggJiYgaS5jaGlsZHJlbihcXFwiYVxcXCIpLm9mZihcXFwiY2xpY2suemYuYWNjb3JkaW9uIGtleWRvd24uemYuYWNjb3JkaW9uXFxcIikub24oXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLnRvZ2dsZShuKTtcXG4gICAgICAgICAgfSkub24oXFxcImtleWRvd24uemYuYWNjb3JkaW9uXFxcIiwgZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgICAgICBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleSh0LCBcXFwiQWNjb3JkaW9uXFxcIiwgeyB0b2dnbGU6IGZ1bmN0aW9uIHRvZ2dsZSgpIHtcXG4gICAgICAgICAgICAgICAgZS50b2dnbGUobik7XFxuICAgICAgICAgICAgICB9LCBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGkubmV4dCgpLmZpbmQoXFxcImFcXFwiKS5mb2N1cygpO2Uub3B0aW9ucy5tdWx0aUV4cGFuZCB8fCB0LnRyaWdnZXIoXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIpO1xcbiAgICAgICAgICAgICAgfSwgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xcbiAgICAgICAgICAgICAgICB2YXIgdCA9IGkucHJldigpLmZpbmQoXFxcImFcXFwiKS5mb2N1cygpO2Uub3B0aW9ucy5tdWx0aUV4cGFuZCB8fCB0LnRyaWdnZXIoXFxcImNsaWNrLnpmLmFjY29yZGlvblxcXCIpO1xcbiAgICAgICAgICAgICAgfSwgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCB0LnN0b3BQcm9wYWdhdGlvbigpO1xcbiAgICAgICAgICAgICAgfSB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwidG9nZ2xlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHQucGFyZW50KCkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpID8gdGhpcy51cCh0KSA6IHRoaXMuZG93bih0KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZG93blxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlLCBpKSB7XFxuICAgICAgICB2YXIgbiA9IHRoaXM7aWYgKGUuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCAhMSkucGFyZW50KFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKS5hZGRCYWNrKCkucGFyZW50KCkuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLCAhdGhpcy5vcHRpb25zLm11bHRpRXhwYW5kICYmICFpKSB7XFxuICAgICAgICAgIHZhciBzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbihcXFwiLmlzLWFjdGl2ZVxcXCIpLmNoaWxkcmVuKFxcXCJbZGF0YS10YWItY29udGVudF1cXFwiKTtzLmxlbmd0aCAmJiB0aGlzLnVwKHMubm90KGUpKTtcXG4gICAgICAgIH1lLnNsaWRlRG93bih0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBuLiRlbGVtZW50LnRyaWdnZXIoXFxcImRvd24uemYuYWNjb3JkaW9uXFxcIiwgW2VdKTtcXG4gICAgICAgIH0pLCB0KFxcXCIjXFxcIiArIGUuYXR0cihcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIikpLmF0dHIoeyBcXFwiYXJpYS1leHBhbmRlZFxcXCI6ICEwLCBcXFwiYXJpYS1zZWxlY3RlZFxcXCI6ICEwIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJ1cFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICB2YXIgaSA9IGUucGFyZW50KCkuc2libGluZ3MoKSxcXG4gICAgICAgICAgICBuID0gdGhpczsodGhpcy5vcHRpb25zLmFsbG93QWxsQ2xvc2VkIHx8IGkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpKSAmJiBlLnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSAmJiAoZS5zbGlkZVVwKG4ub3B0aW9ucy5zbGlkZVNwZWVkLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIG4uJGVsZW1lbnQudHJpZ2dlcihcXFwidXAuemYuYWNjb3JkaW9uXFxcIiwgW2VdKTtcXG4gICAgICAgIH0pLCBlLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwgITApLnBhcmVudCgpLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSwgdChcXFwiI1xcXCIgKyBlLmF0dHIoXFxcImFyaWEtbGFiZWxsZWRieVxcXCIpKS5hdHRyKHsgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiAhMSwgXFxcImFyaWEtc2VsZWN0ZWRcXFwiOiAhMSB9KSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXRhYi1jb250ZW50XVxcXCIpLnN0b3AoITApLnNsaWRlVXAoMCkuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIlxcXCIpLCB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5vZmYoXFxcIi56Zi5hY2NvcmRpb25cXFwiKSwgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH0gfV0pLCBlO1xcbiAgfSgpO2UuZGVmYXVsdHMgPSB7IHNsaWRlU3BlZWQ6IDI1MCwgbXVsdGlFeHBhbmQ6ICExLCBhbGxvd0FsbENsb3NlZDogITEgfSwgRm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIkFjY29yZGlvblxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpLCBuKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGUpLCB0aGlzLiRlbGVtZW50ID0gaSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBuKSwgRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgXFxcImFjY29yZGlvblxcXCIpLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIkFjY29yZGlvbk1lbnVcXFwiKSwgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiQWNjb3JkaW9uTWVudVxcXCIsIHsgRU5URVI6IFxcXCJ0b2dnbGVcXFwiLCBTUEFDRTogXFxcInRvZ2dsZVxcXCIsIEFSUk9XX1JJR0hUOiBcXFwib3BlblxcXCIsIEFSUk9XX1VQOiBcXFwidXBcXFwiLCBBUlJPV19ET1dOOiBcXFwiZG93blxcXCIsIEFSUk9XX0xFRlQ6IFxcXCJjbG9zZVxcXCIsIEVTQ0FQRTogXFxcImNsb3NlQWxsXFxcIiB9KTtcXG4gICAgfXJldHVybiBfY3JlYXRlQ2xhc3MoZSwgW3sga2V5OiBcXFwiX2luaXRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubm90KFxcXCIuaXMtYWN0aXZlXFxcIikuc2xpZGVVcCgwKSwgdGhpcy4kZWxlbWVudC5hdHRyKHsgcm9sZTogXFxcIm1lbnVcXFwiLCBcXFwiYXJpYS1tdWx0aXNlbGVjdGFibGVcXFwiOiB0aGlzLm9wdGlvbnMubXVsdGlPcGVuIH0pLCB0aGlzLiRtZW51TGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcXFwiKSwgdGhpcy4kbWVudUxpbmtzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgZSA9IHRoaXMuaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCBcXFwiYWNjLW1lbnUtbGlua1xcXCIpLFxcbiAgICAgICAgICAgICAgaSA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBuID0gaS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSxcXG4gICAgICAgICAgICAgIHMgPSBuWzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgXFxcImFjYy1tZW51XFxcIiksXFxuICAgICAgICAgICAgICBvID0gbi5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIik7aS5hdHRyKHsgXFxcImFyaWEtY29udHJvbHNcXFwiOiBzLCBcXFwiYXJpYS1leHBhbmRlZFxcXCI6IG8sIHJvbGU6IFxcXCJtZW51aXRlbVxcXCIsIGlkOiBlIH0pLCBuLmF0dHIoeyBcXFwiYXJpYS1sYWJlbGxlZGJ5XFxcIjogZSwgXFxcImFyaWEtaGlkZGVuXFxcIjogIW8sIHJvbGU6IFxcXCJtZW51XFxcIiwgaWQ6IHMgfSk7XFxuICAgICAgICB9KTt2YXIgZSA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLmlzLWFjdGl2ZVxcXCIpO2lmIChlLmxlbmd0aCkge1xcbiAgICAgICAgICB2YXIgaSA9IHRoaXM7ZS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpLmRvd24odCh0aGlzKSk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfXRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMuJGVsZW1lbnQuZmluZChcXFwibGlcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGkgPSB0KHRoaXMpLmNoaWxkcmVuKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpO2kubGVuZ3RoICYmIHQodGhpcykuY2hpbGRyZW4oXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcXFwiKS5vbihcXFwiY2xpY2suemYuYWNjb3JkaW9uTWVudVxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLnRvZ2dsZShpKTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9KS5vbihcXFwia2V5ZG93bi56Zi5hY2NvcmRpb25tZW51XFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdmFyIG4sXFxuICAgICAgICAgICAgICBzLFxcbiAgICAgICAgICAgICAgbyA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBhID0gby5wYXJlbnQoXFxcInVsXFxcIikuY2hpbGRyZW4oXFxcImxpXFxcIiksXFxuICAgICAgICAgICAgICByID0gby5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKTthLmVhY2goZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICBpZiAodCh0aGlzKS5pcyhvKSkgcmV0dXJuIG4gPSBhLmVxKE1hdGgubWF4KDAsIGUgLSAxKSkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCksIHMgPSBhLmVxKE1hdGgubWluKGUgKyAxLCBhLmxlbmd0aCAtIDEpKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSwgdCh0aGlzKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV06dmlzaWJsZVxcXCIpLmxlbmd0aCAmJiAocyA9IG8uZmluZChcXFwibGk6Zmlyc3QtY2hpbGRcXFwiKS5maW5kKFxcXCJhXFxcIikuZmlyc3QoKSksIHQodGhpcykuaXMoXFxcIjpmaXJzdC1jaGlsZFxcXCIpID8gbiA9IG8ucGFyZW50cyhcXFwibGlcXFwiKS5maXJzdCgpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpIDogbi5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdOnZpc2libGVcXFwiKS5sZW5ndGggJiYgKG4gPSBuLnBhcmVudHMoXFxcImxpXFxcIikuZmluZChcXFwibGk6bGFzdC1jaGlsZFxcXCIpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpKSwgdm9pZCAodCh0aGlzKS5pcyhcXFwiOmxhc3QtY2hpbGRcXFwiKSAmJiAocyA9IG8ucGFyZW50cyhcXFwibGlcXFwiKS5maXJzdCgpLm5leHQoXFxcImxpXFxcIikuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkpKTtcXG4gICAgICAgICAgfSksIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksIFxcXCJBY2NvcmRpb25NZW51XFxcIiwgeyBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgICAgICAgICAgci5pcyhcXFwiOmhpZGRlblxcXCIpICYmIChlLmRvd24ociksIHIuZmluZChcXFwibGlcXFwiKS5maXJzdCgpLmZpbmQoXFxcImFcXFwiKS5maXJzdCgpLmZvY3VzKCkpO1xcbiAgICAgICAgICAgIH0sIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgICAgICAgIHIubGVuZ3RoICYmICFyLmlzKFxcXCI6aGlkZGVuXFxcIikgPyBlLnVwKHIpIDogby5wYXJlbnQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikubGVuZ3RoICYmIChlLnVwKG8ucGFyZW50KFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpKSwgby5wYXJlbnRzKFxcXCJsaVxcXCIpLmZpcnN0KCkuZmluZChcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKSk7XFxuICAgICAgICAgICAgfSwgdXA6IGZ1bmN0aW9uIHVwKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIG4uZm9jdXMoKSwgITA7XFxuICAgICAgICAgICAgfSwgZG93bjogZnVuY3Rpb24gZG93bigpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBzLmZvY3VzKCksICEwO1xcbiAgICAgICAgICAgIH0sIHRvZ2dsZTogZnVuY3Rpb24gdG9nZ2xlKCkge1xcbiAgICAgICAgICAgICAgby5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5sZW5ndGggJiYgZS50b2dnbGUoby5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSk7XFxuICAgICAgICAgICAgfSwgY2xvc2VBbGw6IGZ1bmN0aW9uIGNsb3NlQWxsKCkge1xcbiAgICAgICAgICAgICAgZS5oaWRlQWxsKCk7XFxuICAgICAgICAgICAgfSwgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCh0KSB7XFxuICAgICAgICAgICAgICB0ICYmIGkucHJldmVudERlZmF1bHQoKSwgaS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICB9IH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImhpZGVBbGxcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuc2xpZGVVcCh0aGlzLm9wdGlvbnMuc2xpZGVTcGVlZCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcInRvZ2dsZVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB0LmlzKFxcXCI6YW5pbWF0ZWRcXFwiKSB8fCAodC5pcyhcXFwiOmhpZGRlblxcXCIpID8gdGhpcy5kb3duKHQpIDogdGhpcy51cCh0KSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRvd25cXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMub3B0aW9ucy5tdWx0aU9wZW4gfHwgdGhpcy51cCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5pcy1hY3RpdmVcXFwiKS5ub3QodC5wYXJlbnRzVW50aWwodGhpcy4kZWxlbWVudCkuYWRkKHQpKSksIHQuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoeyBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhMSB9KS5wYXJlbnQoXFxcIi5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRcXFwiKS5hdHRyKHsgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiAhMCB9KSwgdC5zbGlkZURvd24oZS5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZS4kZWxlbWVudC50cmlnZ2VyKFxcXCJkb3duLnpmLmFjY29yZGlvbk1lbnVcXFwiLCBbdF0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcInVwXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdGhpczt0LnNsaWRlVXAoZS5vcHRpb25zLnNsaWRlU3BlZWQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZS4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cC56Zi5hY2NvcmRpb25NZW51XFxcIiwgW3RdKTtcXG4gICAgICAgIH0pO3ZhciBpID0gdC5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnNsaWRlVXAoMCkuYWRkQmFjaygpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwgITApO2kucGFyZW50KFxcXCIuaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50XFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsICExKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZGVzdHJveVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5zbGlkZURvd24oMCkuY3NzKFxcXCJkaXNwbGF5XFxcIiwgXFxcIlxcXCIpLCB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKS5vZmYoXFxcImNsaWNrLnpmLmFjY29yZGlvbk1lbnVcXFwiKSwgRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCwgXFxcImFjY29yZGlvblxcXCIpLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGU7XFxuICB9KCk7ZS5kZWZhdWx0cyA9IHsgc2xpZGVTcGVlZDogMjUwLCBtdWx0aU9wZW46ICEwIH0sIEZvdW5kYXRpb24ucGx1Z2luKGUsIFxcXCJBY2NvcmRpb25NZW51XFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCBGb3VuZGF0aW9uLk5lc3QuRmVhdGhlcih0aGlzLiRlbGVtZW50LCBcXFwiZHJpbGxkb3duXFxcIiksIHRoaXMuX2luaXQoKSwgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCBcXFwiRHJpbGxkb3duXFxcIiksIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkRyaWxsZG93blxcXCIsIHsgRU5URVI6IFxcXCJvcGVuXFxcIiwgU1BBQ0U6IFxcXCJvcGVuXFxcIiwgQVJST1dfUklHSFQ6IFxcXCJuZXh0XFxcIiwgQVJST1dfVVA6IFxcXCJ1cFxcXCIsIEFSUk9XX0RPV046IFxcXCJkb3duXFxcIiwgQVJST1dfTEVGVDogXFxcInByZXZpb3VzXFxcIiwgRVNDQVBFOiBcXFwiY2xvc2VcXFwiLCBUQUI6IFxcXCJkb3duXFxcIiwgU0hJRlRfVEFCOiBcXFwidXBcXFwiIH0pO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJHN1Ym1lbnVBbmNob3JzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaS5pcy1kcmlsbGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpLCB0aGlzLiRzdWJtZW51cyA9IHRoaXMuJHN1Ym1lbnVBbmNob3JzLnBhcmVudChcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKSwgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaVxcXCIpLm5vdChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIikuYXR0cihcXFwicm9sZVxcXCIsIFxcXCJtZW51aXRlbVxcXCIpLmZpbmQoXFxcImFcXFwiKSwgdGhpcy5fcHJlcGFyZU1lbnUoKSwgdGhpcy5fa2V5Ym9hcmRFdmVudHMoKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX3ByZXBhcmVNZW51XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMuJHN1Ym1lbnVBbmNob3JzLmVhY2goZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB2YXIgaSA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBuID0gaS5wYXJlbnQoKTtlLm9wdGlvbnMucGFyZW50TGluayAmJiBpLmNsb25lKCkucHJlcGVuZFRvKG4uY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikpLndyYXAoJzxsaSBjbGFzcz1cXFwiaXMtc3VibWVudS1wYXJlbnQtaXRlbSBpcy1zdWJtZW51LWl0ZW0gaXMtZHJpbGxkb3duLXN1Ym1lbnUtaXRlbVxcXCIgcm9sZT1cXFwibWVudS1pdGVtXFxcIj48L2xpPicpLCBpLmRhdGEoXFxcInNhdmVkSHJlZlxcXCIsIGkuYXR0cihcXFwiaHJlZlxcXCIpKS5yZW1vdmVBdHRyKFxcXCJocmVmXFxcIikuYXR0cihcXFwidGFiaW5kZXhcXFwiLCAwKSwgaS5jaGlsZHJlbihcXFwiW2RhdGEtc3VibWVudV1cXFwiKS5hdHRyKHsgXFxcImFyaWEtaGlkZGVuXFxcIjogITAsIHRhYmluZGV4OiAwLCByb2xlOiBcXFwibWVudVxcXCIgfSksIGUuX2V2ZW50cyhpKTtcXG4gICAgICAgIH0pLCB0aGlzLiRzdWJtZW51cy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGkgPSB0KHRoaXMpLFxcbiAgICAgICAgICAgICAgbiA9IGkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrXFxcIik7bi5sZW5ndGggfHwgaS5wcmVwZW5kKGUub3B0aW9ucy5iYWNrQnV0dG9uKSwgZS5fYmFjayhpKTtcXG4gICAgICAgIH0pLCB0aGlzLiRlbGVtZW50LnBhcmVudCgpLmhhc0NsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKSB8fCAodGhpcy4kd3JhcHBlciA9IHQodGhpcy5vcHRpb25zLndyYXBwZXIpLmFkZENsYXNzKFxcXCJpcy1kcmlsbGRvd25cXFwiKSwgdGhpcy4kd3JhcHBlciA9IHRoaXMuJGVsZW1lbnQud3JhcCh0aGlzLiR3cmFwcGVyKS5wYXJlbnQoKS5jc3ModGhpcy5fZ2V0TWF4RGltcygpKSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9ldmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xcbiAgICAgICAgdmFyIGkgPSB0aGlzO2Uub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIiwgZnVuY3Rpb24gKG4pIHtcXG4gICAgICAgICAgaWYgKHQobi50YXJnZXQpLnBhcmVudHNVbnRpbChcXFwidWxcXFwiLCBcXFwibGlcXFwiKS5oYXNDbGFzcyhcXFwiaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikgJiYgKG4uc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIG4ucHJldmVudERlZmF1bHQoKSksIGkuX3Nob3coZS5wYXJlbnQoXFxcImxpXFxcIikpLCBpLm9wdGlvbnMuY2xvc2VPbkNsaWNrKSB7XFxuICAgICAgICAgICAgdmFyIHMgPSB0KFxcXCJib2R5XFxcIik7cy5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgICAgIGUudGFyZ2V0ID09PSBpLiRlbGVtZW50WzBdIHx8IHQuY29udGFpbnMoaS4kZWxlbWVudFswXSwgZS50YXJnZXQpIHx8IChlLnByZXZlbnREZWZhdWx0KCksIGkuX2hpZGVBbGwoKSwgcy5vZmYoXFxcIi56Zi5kcmlsbGRvd25cXFwiKSk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfa2V5Ym9hcmRFdmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXM7dGhpcy4kbWVudUl0ZW1zLmFkZCh0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5qcy1kcmlsbGRvd24tYmFjayA+IGFcXFwiKSkub24oXFxcImtleWRvd24uemYuZHJpbGxkb3duXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdmFyIG4sXFxuICAgICAgICAgICAgICBzLFxcbiAgICAgICAgICAgICAgbyA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBhID0gby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLmNoaWxkcmVuKFxcXCJsaVxcXCIpLmNoaWxkcmVuKFxcXCJhXFxcIik7YS5lYWNoKGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgICAgaWYgKHQodGhpcykuaXMobykpIHJldHVybiBuID0gYS5lcShNYXRoLm1heCgwLCBlIC0gMSkpLCB2b2lkIChzID0gYS5lcShNYXRoLm1pbihlICsgMSwgYS5sZW5ndGggLSAxKSkpO1xcbiAgICAgICAgICB9KSwgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSwgXFxcIkRyaWxsZG93blxcXCIsIHsgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICAgIGlmIChvLmlzKGUuJHN1Ym1lbnVBbmNob3JzKSkgcmV0dXJuIGUuX3Nob3coby5wYXJlbnQoXFxcImxpXFxcIikpLCBvLnBhcmVudChcXFwibGlcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIG8ucGFyZW50KFxcXCJsaVxcXCIpLmZpbmQoXFxcInVsIGxpIGFcXFwiKS5maWx0ZXIoZS4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICB9KSwgITA7XFxuICAgICAgICAgICAgfSwgcHJldmlvdXM6IGZ1bmN0aW9uIHByZXZpb3VzKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIGUuX2hpZGUoby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpKSwgby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfSwgMSk7XFxuICAgICAgICAgICAgICB9KSwgITA7XFxuICAgICAgICAgICAgfSwgdXA6IGZ1bmN0aW9uIHVwKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIG4uZm9jdXMoKSwgITA7XFxuICAgICAgICAgICAgfSwgZG93bjogZnVuY3Rpb24gZG93bigpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBzLmZvY3VzKCksICEwO1xcbiAgICAgICAgICAgIH0sIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgICAgICAgIGUuX2JhY2soKTtcXG4gICAgICAgICAgICB9LCBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgICAgICAgICAgcmV0dXJuIG8uaXMoZS4kbWVudUl0ZW1zKSA/IG8uaXMoZS4kc3VibWVudUFuY2hvcnMpID8gKGUuX3Nob3coby5wYXJlbnQoXFxcImxpXFxcIikpLCBvLnBhcmVudChcXFwibGlcXFwiKS5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKG8pLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgIG8ucGFyZW50KFxcXCJsaVxcXCIpLmZpbmQoXFxcInVsIGxpIGFcXFwiKS5maWx0ZXIoZS4kbWVudUl0ZW1zKS5maXJzdCgpLmZvY3VzKCk7XFxuICAgICAgICAgICAgICB9KSwgITApIDogdm9pZCAwIDogKGUuX2hpZGUoby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpKSwgby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQobyksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICAgICAgby5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKS5jaGlsZHJlbihcXFwiYVxcXCIpLmZpcnN0KCkuZm9jdXMoKTtcXG4gICAgICAgICAgICAgICAgfSwgMSk7XFxuICAgICAgICAgICAgICB9KSwgITApO1xcbiAgICAgICAgICAgIH0sIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQodCkge1xcbiAgICAgICAgICAgICAgdCAmJiBpLnByZXZlbnREZWZhdWx0KCksIGkuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XFxuICAgICAgICAgICAgfSB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfaGlkZUFsbFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuaXMtZHJpbGxkb3duLXN1Ym1lbnUuaXMtYWN0aXZlXFxcIikuYWRkQ2xhc3MoXFxcImlzLWNsb3NpbmdcXFwiKTt0Lm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodCksIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHQucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1jbG9zaW5nXFxcIik7XFxuICAgICAgICB9KSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJjbG9zZWQuemYuZHJpbGxkb3duXFxcIik7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9iYWNrXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdGhpczt0Lm9mZihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIiksIHQuY2hpbGRyZW4oXFxcIi5qcy1kcmlsbGRvd24tYmFja1xcXCIpLm9uKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBlLl9oaWRlKHQpO3ZhciBuID0gdC5wYXJlbnQoXFxcImxpXFxcIikucGFyZW50KFxcXCJ1bFxcXCIpLnBhcmVudChcXFwibGlcXFwiKTtuLmxlbmd0aCAmJiBlLl9zaG93KG4pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9tZW51TGlua0V2ZW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gdGhpczt0aGlzLiRtZW51SXRlbXMubm90KFxcXCIuaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50XFxcIikub2ZmKFxcXCJjbGljay56Zi5kcmlsbGRvd25cXFwiKS5vbihcXFwiY2xpY2suemYuZHJpbGxkb3duXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdC5faGlkZUFsbCgpO1xcbiAgICAgICAgICB9LCAwKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2hvd1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB0LmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCAhMCksIHQuY2hpbGRyZW4oXFxcIltkYXRhLXN1Ym1lbnVdXFxcIikuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwgITEpLCB0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcIm9wZW4uemYuZHJpbGxkb3duXFxcIiwgW3RdKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2hpZGVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgdC5wYXJlbnQoXFxcImxpXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsICExKSwgdC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsICEwKS5hZGRDbGFzcyhcXFwiaXMtY2xvc2luZ1xcXCIpLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQodCksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdC5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmdcXFwiKSwgdC5ibHVyKCk7XFxuICAgICAgICB9KSwgdC50cmlnZ2VyKFxcXCJoaWRlLnpmLmRyaWxsZG93blxcXCIsIFt0XSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9nZXRNYXhEaW1zXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIHQgPSAwLFxcbiAgICAgICAgICAgIGUgPSB7fTtyZXR1cm4gdGhpcy4kc3VibWVudXMuYWRkKHRoaXMuJGVsZW1lbnQpLmVhY2goZnVuY3Rpb24gKGUsIGkpIHtcXG4gICAgICAgICAgdmFyIG4gPSBpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodDtuID4gdCAmJiAodCA9IG4pO1xcbiAgICAgICAgfSksIGVbXFxcIm1pbi1oZWlnaHRcXFwiXSA9IHQgKyBcXFwicHhcXFwiLCBlW1xcXCJtYXgtd2lkdGhcXFwiXSA9IHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGggKyBcXFwicHhcXFwiLCBlO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJkZXN0cm95XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy5faGlkZUFsbCgpLCBGb3VuZGF0aW9uLk5lc3QuQnVybih0aGlzLiRlbGVtZW50LCBcXFwiZHJpbGxkb3duXFxcIiksIHRoaXMuJGVsZW1lbnQudW53cmFwKCkuZmluZChcXFwiLmpzLWRyaWxsZG93bi1iYWNrLCAuaXMtc3VibWVudS1wYXJlbnQtaXRlbVxcXCIpLnJlbW92ZSgpLmVuZCgpLmZpbmQoXFxcIi5pcy1hY3RpdmUsIC5pcy1jbG9zaW5nLCAuaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWNsb3NpbmcgaXMtZHJpbGxkb3duLXN1Ym1lbnVcXFwiKS5lbmQoKS5maW5kKFxcXCJbZGF0YS1zdWJtZW51XVxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtaGlkZGVuIHRhYmluZGV4IHJvbGVcXFwiKSwgdGhpcy4kc3VibWVudUFuY2hvcnMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHQodGhpcykub2ZmKFxcXCIuemYuZHJpbGxkb3duXFxcIik7XFxuICAgICAgICB9KSwgdGhpcy4kZWxlbWVudC5maW5kKFxcXCJhXFxcIikuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBlID0gdCh0aGlzKTtlLnJlbW92ZUF0dHIoXFxcInRhYmluZGV4XFxcIiksIGUuZGF0YShcXFwic2F2ZWRIcmVmXFxcIikgJiYgZS5hdHRyKFxcXCJocmVmXFxcIiwgZS5kYXRhKFxcXCJzYXZlZEhyZWZcXFwiKSkucmVtb3ZlRGF0YShcXFwic2F2ZWRIcmVmXFxcIik7XFxuICAgICAgICB9KSwgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH0gfV0pLCBlO1xcbiAgfSgpO2UuZGVmYXVsdHMgPSB7IGJhY2tCdXR0b246ICc8bGkgY2xhc3M9XFxcImpzLWRyaWxsZG93bi1iYWNrXFxcIj48YSB0YWJpbmRleD1cXFwiMFxcXCI+QmFjazwvYT48L2xpPicsIHdyYXBwZXI6IFxcXCI8ZGl2PjwvZGl2PlxcXCIsIHBhcmVudExpbms6ICExLCBjbG9zZU9uQ2xpY2s6ICExIH0sIEZvdW5kYXRpb24ucGx1Z2luKGUsIFxcXCJEcmlsbGRvd25cXFwiKTtcXG59KGpRdWVyeSk7dmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcXG4gIGZ1bmN0aW9uIHQodCwgZSkge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGUubGVuZ3RoOyBpKyspIHtcXG4gICAgICB2YXIgbiA9IGVbaV07bi5lbnVtZXJhYmxlID0gbi5lbnVtZXJhYmxlIHx8ICExLCBuLmNvbmZpZ3VyYWJsZSA9ICEwLCBcXFwidmFsdWVcXFwiIGluIG4gJiYgKG4ud3JpdGFibGUgPSAhMCksIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0LCBuLmtleSwgbik7XFxuICAgIH1cXG4gIH1yZXR1cm4gZnVuY3Rpb24gKGUsIGksIG4pIHtcXG4gICAgcmV0dXJuIGkgJiYgdChlLnByb3RvdHlwZSwgaSksIG4gJiYgdChlLCBuKSwgZTtcXG4gIH07XFxufSgpOyFmdW5jdGlvbiAodCkge1xcbiAgdmFyIGUgPSBmdW5jdGlvbiAoKSB7XFxuICAgIGZ1bmN0aW9uIGUoaSwgbikge1xcbiAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBlKSwgdGhpcy4kZWxlbWVudCA9IGksIHRoaXMub3B0aW9ucyA9IHQuZXh0ZW5kKHt9LCBlLmRlZmF1bHRzLCB0aGlzLiRlbGVtZW50LmRhdGEoKSwgbiksIHRoaXMuX2luaXQoKSwgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCBcXFwiRHJvcGRvd25cXFwiKSwgRm91bmRhdGlvbi5LZXlib2FyZC5yZWdpc3RlcihcXFwiRHJvcGRvd25cXFwiLCB7IEVOVEVSOiBcXFwib3BlblxcXCIsIFNQQUNFOiBcXFwib3BlblxcXCIsIEVTQ0FQRTogXFxcImNsb3NlXFxcIiwgVEFCOiBcXFwidGFiX2ZvcndhcmRcXFwiLCBTSElGVF9UQUI6IFxcXCJ0YWJfYmFja3dhcmRcXFwiIH0pO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJpZFxcXCIpO3RoaXMuJGFuY2hvciA9IHQodCgnW2RhdGEtdG9nZ2xlPVxcXCInICsgZSArICdcXFwiXScpLmxlbmd0aCA/ICdbZGF0YS10b2dnbGU9XFxcIicgKyBlICsgJ1xcXCJdJyA6ICdbZGF0YS1vcGVuPVxcXCInICsgZSArICdcXFwiXScpLCB0aGlzLiRhbmNob3IuYXR0cih7IFxcXCJhcmlhLWNvbnRyb2xzXFxcIjogZSwgXFxcImRhdGEtaXMtZm9jdXNcXFwiOiAhMSwgXFxcImRhdGEteWV0aS1ib3hcXFwiOiBlLCBcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ICEwLCBcXFwiYXJpYS1leHBhbmRlZFxcXCI6ICExIH0pLCB0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyA9IHRoaXMuZ2V0UG9zaXRpb25DbGFzcygpLCB0aGlzLmNvdW50ZXIgPSA0LCB0aGlzLnVzZWRQb3NpdGlvbnMgPSBbXSwgdGhpcy4kZWxlbWVudC5hdHRyKHsgXFxcImFyaWEtaGlkZGVuXFxcIjogXFxcInRydWVcXFwiLCBcXFwiZGF0YS15ZXRpLWJveFxcXCI6IGUsIFxcXCJkYXRhLXJlc2l6ZVxcXCI6IGUsIFxcXCJhcmlhLWxhYmVsbGVkYnlcXFwiOiB0aGlzLiRhbmNob3JbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCBcXFwiZGQtYW5jaG9yXFxcIikgfSksIHRoaXMuX2V2ZW50cygpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJnZXRQb3NpdGlvbkNsYXNzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIHQgPSB0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZS5tYXRjaCgvKHRvcHxsZWZ0fHJpZ2h0fGJvdHRvbSkvZyk7dCA9IHQgPyB0WzBdIDogXFxcIlxcXCI7dmFyIGUgPSAvZmxvYXQtKFxcXFxTKykvLmV4ZWModGhpcy4kYW5jaG9yWzBdLmNsYXNzTmFtZSk7ZSA9IGUgPyBlWzFdIDogXFxcIlxcXCI7dmFyIGkgPSBlID8gZSArIFxcXCIgXFxcIiArIHQgOiB0O3JldHVybiBpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfcmVwb3NpdGlvblxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB0aGlzLnVzZWRQb3NpdGlvbnMucHVzaCh0ID8gdCA6IFxcXCJib3R0b21cXFwiKSwgIXQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInRvcFxcXCIpIDwgMCA/IHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcInRvcFxcXCIpIDogXFxcInRvcFxcXCIgPT09IHQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpIDwgMCA/IHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkgOiBcXFwibGVmdFxcXCIgPT09IHQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIikgPCAwID8gdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwicmlnaHRcXFwiKSA6IFxcXCJyaWdodFxcXCIgPT09IHQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKSA8IDAgPyB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIikgOiAhdCAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIikgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpIDwgMCA/IHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKSA6IFxcXCJ0b3BcXFwiID09PSB0ICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIikgPCAwID8gdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpIDogXFxcImxlZnRcXFwiID09PSB0ICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJyaWdodFxcXCIpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpIDwgMCA/IHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCkgOiBcXFwicmlnaHRcXFwiID09PSB0ICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIikgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIikgPCAwID8gdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyh0KSA6IHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCksIHRoaXMuY2xhc3NDaGFuZ2VkID0gITAsIHRoaXMuY291bnRlci0tO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2V0UG9zaXRpb25cXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICBpZiAoXFxcImZhbHNlXFxcIiA9PT0gdGhpcy4kYW5jaG9yLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiKSkgcmV0dXJuICExO3ZhciB0ID0gdGhpcy5nZXRQb3NpdGlvbkNsYXNzKCksXFxuICAgICAgICAgICAgZSA9IEZvdW5kYXRpb24uQm94LkdldERpbWVuc2lvbnModGhpcy4kZWxlbWVudCksXFxuICAgICAgICAgICAgaSA9IChGb3VuZGF0aW9uLkJveC5HZXREaW1lbnNpb25zKHRoaXMuJGFuY2hvciksIFxcXCJsZWZ0XFxcIiA9PT0gdCA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJyaWdodFxcXCIgPT09IHQgPyBcXFwibGVmdFxcXCIgOiBcXFwidG9wXFxcIiksXFxuICAgICAgICAgICAgbiA9IFxcXCJ0b3BcXFwiID09PSBpID8gXFxcImhlaWdodFxcXCIgOiBcXFwid2lkdGhcXFwiO1xcXCJoZWlnaHRcXFwiID09PSBuID8gdGhpcy5vcHRpb25zLnZPZmZzZXQgOiB0aGlzLm9wdGlvbnMuaE9mZnNldDtpZiAoZS53aWR0aCA+PSBlLndpbmRvd0RpbXMud2lkdGggfHwgIXRoaXMuY291bnRlciAmJiAhRm91bmRhdGlvbi5Cb3guSW1Ob3RUb3VjaGluZ1lvdSh0aGlzLiRlbGVtZW50KSkgcmV0dXJuIHRoaXMuJGVsZW1lbnQub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy4kZWxlbWVudCwgdGhpcy4kYW5jaG9yLCBcXFwiY2VudGVyIGJvdHRvbVxcXCIsIHRoaXMub3B0aW9ucy52T2Zmc2V0LCB0aGlzLm9wdGlvbnMuaE9mZnNldCwgITApKS5jc3MoeyB3aWR0aDogZS53aW5kb3dEaW1zLndpZHRoIC0gMiAqIHRoaXMub3B0aW9ucy5oT2Zmc2V0LCBoZWlnaHQ6IFxcXCJhdXRvXFxcIiB9KSwgdGhpcy5jbGFzc0NoYW5nZWQgPSAhMCwgITE7Zm9yICh0aGlzLiRlbGVtZW50Lm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMuJGVsZW1lbnQsIHRoaXMuJGFuY2hvciwgdCwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0KSk7ICFGb3VuZGF0aW9uLkJveC5JbU5vdFRvdWNoaW5nWW91KHRoaXMuJGVsZW1lbnQsICExLCAhMCkgJiYgdGhpcy5jb3VudGVyOykge1xcbiAgICAgICAgICB0aGlzLl9yZXBvc2l0aW9uKHQpLCB0aGlzLl9zZXRQb3NpdGlvbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMuJGVsZW1lbnQub24oeyBcXFwib3Blbi56Zi50cmlnZ2VyXFxcIjogdGhpcy5vcGVuLmJpbmQodGhpcyksIFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjogdGhpcy5jbG9zZS5iaW5kKHRoaXMpLCBcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpLCBcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6IHRoaXMuX3NldFBvc2l0aW9uLmJpbmQodGhpcykgfSksIHRoaXMub3B0aW9ucy5ob3ZlciAmJiAodGhpcy4kYW5jaG9yLm9mZihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93biBtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIikub24oXFxcIm1vdXNlZW50ZXIuemYuZHJvcGRvd25cXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHQoJ2JvZHlbZGF0YS13aGF0aW5wdXQ9XFxcIm1vdXNlXFxcIl0nKS5pcyhcXFwiKlxcXCIpICYmIChjbGVhclRpbWVvdXQoZS50aW1lb3V0KSwgZS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZS5vcGVuKCksIGUuJGFuY2hvci5kYXRhKFxcXCJob3ZlclxcXCIsICEwKTtcXG4gICAgICAgICAgfSwgZS5vcHRpb25zLmhvdmVyRGVsYXkpKTtcXG4gICAgICAgIH0pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLmRyb3Bkb3duXFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQoZS50aW1lb3V0KSwgZS50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZS5jbG9zZSgpLCBlLiRhbmNob3IuZGF0YShcXFwiaG92ZXJcXFwiLCAhMSk7XFxuICAgICAgICAgIH0sIGUub3B0aW9ucy5ob3ZlckRlbGF5KTtcXG4gICAgICAgIH0pLCB0aGlzLm9wdGlvbnMuaG92ZXJQYW5lICYmIHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJtb3VzZWVudGVyLnpmLmRyb3Bkb3duIG1vdXNlbGVhdmUuemYuZHJvcGRvd25cXFwiKS5vbihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93blxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGUudGltZW91dCk7XFxuICAgICAgICB9KS5vbihcXFwibW91c2VsZWF2ZS56Zi5kcm9wZG93blxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KGUudGltZW91dCksIGUudGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGUuY2xvc2UoKSwgZS4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIiwgITEpO1xcbiAgICAgICAgICB9LCBlLm9wdGlvbnMuaG92ZXJEZWxheSk7XFxuICAgICAgICB9KSksIHRoaXMuJGFuY2hvci5hZGQodGhpcy4kZWxlbWVudCkub24oXFxcImtleWRvd24uemYuZHJvcGRvd25cXFwiLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICB2YXIgbiA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksIFxcXCJEcm9wZG93blxcXCIsIHsgdGFiX2ZvcndhcmQ6IGZ1bmN0aW9uIHRhYl9mb3J3YXJkKCkge1xcbiAgICAgICAgICAgICAgZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhzLmVxKC0xKSkgJiYgKGUub3B0aW9ucy50cmFwRm9jdXMgPyAocy5lcSgwKS5mb2N1cygpLCBpLnByZXZlbnREZWZhdWx0KCkpIDogZS5jbG9zZSgpKTtcXG4gICAgICAgICAgICB9LCB0YWJfYmFja3dhcmQ6IGZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpIHtcXG4gICAgICAgICAgICAgIChlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKHMuZXEoMCkpIHx8IGUuJGVsZW1lbnQuaXMoXFxcIjpmb2N1c1xcXCIpKSAmJiAoZS5vcHRpb25zLnRyYXBGb2N1cyA/IChzLmVxKC0xKS5mb2N1cygpLCBpLnByZXZlbnREZWZhdWx0KCkpIDogZS5jbG9zZSgpKTtcXG4gICAgICAgICAgICB9LCBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgICAgICAgICAgbi5pcyhlLiRhbmNob3IpICYmIChlLm9wZW4oKSwgZS4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIsIC0xKS5mb2N1cygpLCBpLnByZXZlbnREZWZhdWx0KCkpO1xcbiAgICAgICAgICAgIH0sIGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgICAgICAgIGUuY2xvc2UoKSwgZS4kYW5jaG9yLmZvY3VzKCk7XFxuICAgICAgICAgICAgfSB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfYWRkQm9keUhhbmRsZXJcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IHQoZG9jdW1lbnQuYm9keSkubm90KHRoaXMuJGVsZW1lbnQpLFxcbiAgICAgICAgICAgIGkgPSB0aGlzO2Uub2ZmKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIpLm9uKFxcXCJjbGljay56Zi5kcm9wZG93blxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgIGkuJGFuY2hvci5pcyh0LnRhcmdldCkgfHwgaS4kYW5jaG9yLmZpbmQodC50YXJnZXQpLmxlbmd0aCB8fCBpLiRlbGVtZW50LmZpbmQodC50YXJnZXQpLmxlbmd0aCB8fCAoaS5jbG9zZSgpLCBlLm9mZihcXFwiY2xpY2suemYuZHJvcGRvd25cXFwiKSk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwib3BlblxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcImNsb3NlbWUuemYuZHJvcGRvd25cXFwiLCB0aGlzLiRlbGVtZW50LmF0dHIoXFxcImlkXFxcIikpLCB0aGlzLiRhbmNob3IuYWRkQ2xhc3MoXFxcImhvdmVyXFxcIikuYXR0cih7IFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogITAgfSksIHRoaXMuX3NldFBvc2l0aW9uKCksIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3MoXFxcImlzLW9wZW5cXFwiKS5hdHRyKHsgXFxcImFyaWEtaGlkZGVuXFxcIjogITEgfSksIHRoaXMub3B0aW9ucy5hdXRvRm9jdXMpIHtcXG4gICAgICAgICAgdmFyIHQgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCk7dC5sZW5ndGggJiYgdC5lcSgwKS5mb2N1cygpO1xcbiAgICAgICAgfXRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5fYWRkQm9keUhhbmRsZXIoKSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3duXFxcIiwgW3RoaXMuJGVsZW1lbnRdKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiY2xvc2VcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSkgcmV0dXJuICExO2lmICh0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1vcGVuXFxcIikuYXR0cih7IFxcXCJhcmlhLWhpZGRlblxcXCI6ICEwIH0pLCB0aGlzLiRhbmNob3IucmVtb3ZlQ2xhc3MoXFxcImhvdmVyXFxcIikuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsICExKSwgdGhpcy5jbGFzc0NoYW5nZWQpIHtcXG4gICAgICAgICAgdmFyIHQgPSB0aGlzLmdldFBvc2l0aW9uQ2xhc3MoKTt0ICYmIHRoaXMuJGVsZW1lbnQucmVtb3ZlQ2xhc3ModCksIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MpLmNzcyh7IGhlaWdodDogXFxcIlxcXCIsIHdpZHRoOiBcXFwiXFxcIiB9KSwgdGhpcy5jbGFzc0NoYW5nZWQgPSAhMSwgdGhpcy5jb3VudGVyID0gNCwgdGhpcy51c2VkUG9zaXRpb25zLmxlbmd0aCA9IDA7XFxuICAgICAgICB9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJoaWRlLnpmLmRyb3Bkb3duXFxcIiwgW3RoaXMuJGVsZW1lbnRdKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwidG9nZ2xlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgaWYgKHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSkge1xcbiAgICAgICAgICBpZiAodGhpcy4kYW5jaG9yLmRhdGEoXFxcImhvdmVyXFxcIikpIHJldHVybjt0aGlzLmNsb3NlKCk7XFxuICAgICAgICB9IGVsc2UgdGhpcy5vcGVuKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLnRyaWdnZXJcXFwiKS5oaWRlKCksIHRoaXMuJGFuY2hvci5vZmYoXFxcIi56Zi5kcm9wZG93blxcXCIpLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGU7XFxuICB9KCk7ZS5kZWZhdWx0cyA9IHsgaG92ZXJEZWxheTogMjUwLCBob3ZlcjogITEsIGhvdmVyUGFuZTogITEsIHZPZmZzZXQ6IDEsIGhPZmZzZXQ6IDEsIHBvc2l0aW9uQ2xhc3M6IFxcXCJcXFwiLCB0cmFwRm9jdXM6ICExLCBhdXRvRm9jdXM6ICExLCBjbG9zZU9uQ2xpY2s6ICExIH0sIEZvdW5kYXRpb24ucGx1Z2luKGUsIFxcXCJEcm9wZG93blxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpLCBuKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGUpLCB0aGlzLiRlbGVtZW50ID0gaSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBuKSwgRm91bmRhdGlvbi5OZXN0LkZlYXRoZXIodGhpcy4kZWxlbWVudCwgXFxcImRyb3Bkb3duXFxcIiksIHRoaXMuX2luaXQoKSwgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCBcXFwiRHJvcGRvd25NZW51XFxcIiksIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIkRyb3Bkb3duTWVudVxcXCIsIHsgRU5URVI6IFxcXCJvcGVuXFxcIiwgU1BBQ0U6IFxcXCJvcGVuXFxcIiwgQVJST1dfUklHSFQ6IFxcXCJuZXh0XFxcIiwgQVJST1dfVVA6IFxcXCJ1cFxcXCIsIEFSUk9XX0RPV046IFxcXCJkb3duXFxcIiwgQVJST1dfTEVGVDogXFxcInByZXZpb3VzXFxcIiwgRVNDQVBFOiBcXFwiY2xvc2VcXFwiIH0pO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpO3RoaXMuJGVsZW1lbnQuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmNoaWxkcmVuKFxcXCIuaXMtZHJvcGRvd24tc3VibWVudVxcXCIpLmFkZENsYXNzKFxcXCJmaXJzdC1zdWJcXFwiKSwgdGhpcy4kbWVudUl0ZW1zID0gdGhpcy4kZWxlbWVudC5maW5kKCdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLCB0aGlzLiR0YWJzID0gdGhpcy4kZWxlbWVudC5jaGlsZHJlbignW3JvbGU9XFxcIm1lbnVpdGVtXFxcIl0nKSwgdGhpcy4kdGFicy5maW5kKFxcXCJ1bC5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikuYWRkQ2xhc3ModGhpcy5vcHRpb25zLnZlcnRpY2FsQ2xhc3MpLCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKHRoaXMub3B0aW9ucy5yaWdodENsYXNzKSB8fCBcXFwicmlnaHRcXFwiID09PSB0aGlzLm9wdGlvbnMuYWxpZ25tZW50IHx8IEZvdW5kYXRpb24ucnRsKCkgfHwgdGhpcy4kZWxlbWVudC5wYXJlbnRzKFxcXCIudG9wLWJhci1yaWdodFxcXCIpLmlzKFxcXCIqXFxcIikgPyAodGhpcy5vcHRpb25zLmFsaWdubWVudCA9IFxcXCJyaWdodFxcXCIsIHQuYWRkQ2xhc3MoXFxcIm9wZW5zLWxlZnRcXFwiKSkgOiB0LmFkZENsYXNzKFxcXCJvcGVucy1yaWdodFxcXCIpLCB0aGlzLmNoYW5nZWQgPSAhMSwgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9pc1ZlcnRpY2FsXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgcmV0dXJuIFxcXCJibG9ja1xcXCIgPT09IHRoaXMuJHRhYnMuY3NzKFxcXCJkaXNwbGF5XFxcIik7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9ldmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXMsXFxuICAgICAgICAgICAgaSA9IFxcXCJvbnRvdWNoc3RhcnRcXFwiIGluIHdpbmRvdyB8fCBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2Ygd2luZG93Lm9udG91Y2hzdGFydCxcXG4gICAgICAgICAgICBuID0gXFxcImlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIixcXG4gICAgICAgICAgICBzID0gZnVuY3Rpb24gcyhfcykge1xcbiAgICAgICAgICB2YXIgbyA9IHQoX3MudGFyZ2V0KS5wYXJlbnRzVW50aWwoXFxcInVsXFxcIiwgXFxcIi5cXFwiICsgbiksXFxuICAgICAgICAgICAgICBhID0gby5oYXNDbGFzcyhuKSxcXG4gICAgICAgICAgICAgIHIgPSBcXFwidHJ1ZVxcXCIgPT09IG8uYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpLFxcbiAgICAgICAgICAgICAgbCA9IG8uY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7aWYgKCFhKSByZXR1cm4gdm9pZCAoZS5vcHRpb25zLmNsb3NlT25DbGlja0luc2lkZSAmJiBlLl9oaWRlKG8pKTtpZiAocikge1xcbiAgICAgICAgICAgIGlmICghZS5vcHRpb25zLmNsb3NlT25DbGljayB8fCAhZS5vcHRpb25zLmNsaWNrT3BlbiAmJiAhaSB8fCBlLm9wdGlvbnMuZm9yY2VGb2xsb3cgJiYgaSkgcmV0dXJuO19zLnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpLCBfcy5wcmV2ZW50RGVmYXVsdCgpLCBlLl9oaWRlKG8pO1xcbiAgICAgICAgICB9IGVsc2UgX3MucHJldmVudERlZmF1bHQoKSwgX3Muc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIGUuX3Nob3cobCksIG8uYWRkKG8ucGFyZW50c1VudGlsKGUuJGVsZW1lbnQsIFxcXCIuXFxcIiArIG4pKS5hdHRyKFxcXCJkYXRhLWlzLWNsaWNrXFxcIiwgITApO1xcbiAgICAgICAgfTsodGhpcy5vcHRpb25zLmNsaWNrT3BlbiB8fCBpKSAmJiB0aGlzLiRtZW51SXRlbXMub24oXFxcImNsaWNrLnpmLmRyb3Bkb3dubWVudSB0b3VjaHN0YXJ0LnpmLmRyb3Bkb3dubWVudVxcXCIsIHMpLCB0aGlzLm9wdGlvbnMuZGlzYWJsZUhvdmVyIHx8IHRoaXMuJG1lbnVJdGVtcy5vbihcXFwibW91c2VlbnRlci56Zi5kcm9wZG93bm1lbnVcXFwiLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICB2YXIgcyA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBvID0gcy5oYXNDbGFzcyhuKTtvICYmIChjbGVhclRpbWVvdXQoZS5kZWxheSksIGUuZGVsYXkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBlLl9zaG93KHMuY2hpbGRyZW4oXFxcIi5pcy1kcm9wZG93bi1zdWJtZW51XFxcIikpO1xcbiAgICAgICAgICB9LCBlLm9wdGlvbnMuaG92ZXJEZWxheSkpO1xcbiAgICAgICAgfSkub24oXFxcIm1vdXNlbGVhdmUuemYuZHJvcGRvd25tZW51XFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdmFyIHMgPSB0KHRoaXMpLFxcbiAgICAgICAgICAgICAgbyA9IHMuaGFzQ2xhc3Mobik7aWYgKG8gJiYgZS5vcHRpb25zLmF1dG9jbG9zZSkge1xcbiAgICAgICAgICAgIGlmIChcXFwidHJ1ZVxcXCIgPT09IHMuYXR0cihcXFwiZGF0YS1pcy1jbGlja1xcXCIpICYmIGUub3B0aW9ucy5jbGlja09wZW4pIHJldHVybiAhMTtjbGVhclRpbWVvdXQoZS5kZWxheSksIGUuZGVsYXkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICAgIGUuX2hpZGUocyk7XFxuICAgICAgICAgICAgfSwgZS5vcHRpb25zLmNsb3NpbmdUaW1lKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfSksIHRoaXMuJG1lbnVJdGVtcy5vbihcXFwia2V5ZG93bi56Zi5kcm9wZG93bm1lbnVcXFwiLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICB2YXIgbixcXG4gICAgICAgICAgICAgIHMsXFxuICAgICAgICAgICAgICBvID0gdChpLnRhcmdldCkucGFyZW50c1VudGlsKFxcXCJ1bFxcXCIsICdbcm9sZT1cXFwibWVudWl0ZW1cXFwiXScpLFxcbiAgICAgICAgICAgICAgYSA9IGUuJHRhYnMuaW5kZXgobykgPiAtMSxcXG4gICAgICAgICAgICAgIHIgPSBhID8gZS4kdGFicyA6IG8uc2libGluZ3MoXFxcImxpXFxcIikuYWRkKG8pO3IuZWFjaChmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICAgIGlmICh0KHRoaXMpLmlzKG8pKSByZXR1cm4gbiA9IHIuZXEoZSAtIDEpLCB2b2lkIChzID0gci5lcShlICsgMSkpO1xcbiAgICAgICAgICB9KTt2YXIgbCA9IGZ1bmN0aW9uIGwoKSB7XFxuICAgICAgICAgICAgby5pcyhcXFwiOmxhc3QtY2hpbGRcXFwiKSB8fCAocy5jaGlsZHJlbihcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksIGkucHJldmVudERlZmF1bHQoKSk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICB1ID0gZnVuY3Rpb24gdSgpIHtcXG4gICAgICAgICAgICBuLmNoaWxkcmVuKFxcXCJhOmZpcnN0XFxcIikuZm9jdXMoKSwgaS5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICAgICAgICB9LFxcbiAgICAgICAgICAgICAgZCA9IGZ1bmN0aW9uIGQoKSB7XFxuICAgICAgICAgICAgdmFyIHQgPSBvLmNoaWxkcmVuKFxcXCJ1bC5pcy1kcm9wZG93bi1zdWJtZW51XFxcIik7dC5sZW5ndGggJiYgKGUuX3Nob3codCksIG8uZmluZChcXFwibGkgPiBhOmZpcnN0XFxcIikuZm9jdXMoKSwgaS5wcmV2ZW50RGVmYXVsdCgpKTtcXG4gICAgICAgICAgfSxcXG4gICAgICAgICAgICAgIGggPSBmdW5jdGlvbiBoKCkge1xcbiAgICAgICAgICAgIHZhciB0ID0gby5wYXJlbnQoXFxcInVsXFxcIikucGFyZW50KFxcXCJsaVxcXCIpO3QuY2hpbGRyZW4oXFxcImE6Zmlyc3RcXFwiKS5mb2N1cygpLCBlLl9oaWRlKHQpLCBpLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH0sXFxuICAgICAgICAgICAgICBjID0geyBvcGVuOiBkLCBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgICAgICBlLl9oaWRlKGUuJGVsZW1lbnQpLCBlLiRtZW51SXRlbXMuZmluZChcXFwiYTpmaXJzdFxcXCIpLmZvY3VzKCksIGkucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9LCBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKCkge1xcbiAgICAgICAgICAgICAgaS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcXG4gICAgICAgICAgICB9IH07YSA/IGUuX2lzVmVydGljYWwoKSA/IEZvdW5kYXRpb24ucnRsKCkgPyB0LmV4dGVuZChjLCB7IGRvd246IGwsIHVwOiB1LCBuZXh0OiBoLCBwcmV2aW91czogZCB9KSA6IHQuZXh0ZW5kKGMsIHsgZG93bjogbCwgdXA6IHUsIG5leHQ6IGQsIHByZXZpb3VzOiBoIH0pIDogRm91bmRhdGlvbi5ydGwoKSA/IHQuZXh0ZW5kKGMsIHsgbmV4dDogdSwgcHJldmlvdXM6IGwsIGRvd246IGQsIHVwOiBoIH0pIDogdC5leHRlbmQoYywgeyBuZXh0OiBsLCBwcmV2aW91czogdSwgZG93bjogZCwgdXA6IGggfSkgOiBGb3VuZGF0aW9uLnJ0bCgpID8gdC5leHRlbmQoYywgeyBuZXh0OiBoLCBwcmV2aW91czogZCwgZG93bjogbCwgdXA6IHUgfSkgOiB0LmV4dGVuZChjLCB7IG5leHQ6IGQsIHByZXZpb3VzOiBoLCBkb3duOiBsLCB1cDogdSB9KSwgRm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkoaSwgXFxcIkRyb3Bkb3duTWVudVxcXCIsIGMpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9hZGRCb2R5SGFuZGxlclxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdChkb2N1bWVudC5ib2R5KSxcXG4gICAgICAgICAgICBpID0gdGhpcztlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikub24oXFxcIm1vdXNldXAuemYuZHJvcGRvd25tZW51IHRvdWNoZW5kLnpmLmRyb3Bkb3dubWVudVxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgIHZhciBuID0gaS4kZWxlbWVudC5maW5kKHQudGFyZ2V0KTtuLmxlbmd0aCB8fCAoaS5faGlkZSgpLCBlLm9mZihcXFwibW91c2V1cC56Zi5kcm9wZG93bm1lbnUgdG91Y2hlbmQuemYuZHJvcGRvd25tZW51XFxcIikpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9zaG93XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcXG4gICAgICAgIHZhciBpID0gdGhpcy4kdGFicy5pbmRleCh0aGlzLiR0YWJzLmZpbHRlcihmdW5jdGlvbiAoaSwgbikge1xcbiAgICAgICAgICByZXR1cm4gdChuKS5maW5kKGUpLmxlbmd0aCA+IDA7XFxuICAgICAgICB9KSksXFxuICAgICAgICAgICAgbiA9IGUucGFyZW50KFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLnNpYmxpbmdzKFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpO3RoaXMuX2hpZGUobiwgaSksIGUuY3NzKFxcXCJ2aXNpYmlsaXR5XFxcIiwgXFxcImhpZGRlblxcXCIpLmFkZENsYXNzKFxcXCJqcy1kcm9wZG93bi1hY3RpdmVcXFwiKS5hdHRyKHsgXFxcImFyaWEtaGlkZGVuXFxcIjogITEgfSkucGFyZW50KFxcXCJsaS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudFxcXCIpLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hdHRyKHsgXFxcImFyaWEtZXhwYW5kZWRcXFwiOiAhMCB9KTt2YXIgcyA9IEZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoZSwgbnVsbCwgITApO2lmICghcykge1xcbiAgICAgICAgICB2YXIgbyA9IFxcXCJsZWZ0XFxcIiA9PT0gdGhpcy5vcHRpb25zLmFsaWdubWVudCA/IFxcXCItcmlnaHRcXFwiIDogXFxcIi1sZWZ0XFxcIixcXG4gICAgICAgICAgICAgIGEgPSBlLnBhcmVudChcXFwiLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50XFxcIik7YS5yZW1vdmVDbGFzcyhcXFwib3BlbnNcXFwiICsgbykuYWRkQ2xhc3MoXFxcIm9wZW5zLVxcXCIgKyB0aGlzLm9wdGlvbnMuYWxpZ25tZW50KSwgcyA9IEZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UoZSwgbnVsbCwgITApLCBzIHx8IGEucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLVxcXCIgKyB0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcXFwib3BlbnMtaW5uZXJcXFwiKSwgdGhpcy5jaGFuZ2VkID0gITA7XFxuICAgICAgICB9ZS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLCBcXFwiXFxcIiksIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5fYWRkQm9keUhhbmRsZXIoKSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzaG93LnpmLmRyb3Bkb3dubWVudVxcXCIsIFtlXSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9oaWRlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIGUpIHtcXG4gICAgICAgIHZhciBpO2kgPSB0ICYmIHQubGVuZ3RoID8gdCA6IHZvaWQgMCAhPT0gZSA/IHRoaXMuJHRhYnMubm90KGZ1bmN0aW9uICh0LCBpKSB7XFxuICAgICAgICAgIHJldHVybiB0ID09PSBlO1xcbiAgICAgICAgfSkgOiB0aGlzLiRlbGVtZW50O3ZhciBuID0gaS5oYXNDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikgfHwgaS5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikubGVuZ3RoID4gMDtpZiAobikge1xcbiAgICAgICAgICBpZiAoaS5maW5kKFxcXCJsaS5pcy1hY3RpdmVcXFwiKS5hZGQoaSkuYXR0cih7IFxcXCJhcmlhLWV4cGFuZGVkXFxcIjogITEsIFxcXCJkYXRhLWlzLWNsaWNrXFxcIjogITEgfSkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLCBpLmZpbmQoXFxcInVsLmpzLWRyb3Bkb3duLWFjdGl2ZVxcXCIpLmF0dHIoeyBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhMCB9KS5yZW1vdmVDbGFzcyhcXFwianMtZHJvcGRvd24tYWN0aXZlXFxcIiksIHRoaXMuY2hhbmdlZCB8fCBpLmZpbmQoXFxcIm9wZW5zLWlubmVyXFxcIikubGVuZ3RoKSB7XFxuICAgICAgICAgICAgdmFyIHMgPSBcXFwibGVmdFxcXCIgPT09IHRoaXMub3B0aW9ucy5hbGlnbm1lbnQgPyBcXFwicmlnaHRcXFwiIDogXFxcImxlZnRcXFwiO2kuZmluZChcXFwibGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnRcXFwiKS5hZGQoaSkucmVtb3ZlQ2xhc3MoXFxcIm9wZW5zLWlubmVyIG9wZW5zLVxcXCIgKyB0aGlzLm9wdGlvbnMuYWxpZ25tZW50KS5hZGRDbGFzcyhcXFwib3BlbnMtXFxcIiArIHMpLCB0aGlzLmNoYW5nZWQgPSAhMTtcXG4gICAgICAgICAgfXRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi5kcm9wZG93bm1lbnVcXFwiLCBbaV0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJkZXN0cm95XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy4kbWVudUl0ZW1zLm9mZihcXFwiLnpmLmRyb3Bkb3dubWVudVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtaXMtY2xpY2tcXFwiKS5yZW1vdmVDbGFzcyhcXFwiaXMtcmlnaHQtYXJyb3cgaXMtbGVmdC1hcnJvdyBpcy1kb3duLWFycm93IG9wZW5zLXJpZ2h0IG9wZW5zLWxlZnQgb3BlbnMtaW5uZXJcXFwiKSwgdChkb2N1bWVudC5ib2R5KS5vZmYoXFxcIi56Zi5kcm9wZG93bm1lbnVcXFwiKSwgRm91bmRhdGlvbi5OZXN0LkJ1cm4odGhpcy4kZWxlbWVudCwgXFxcImRyb3Bkb3duXFxcIiksIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9IH1dKSwgZTtcXG4gIH0oKTtlLmRlZmF1bHRzID0geyBkaXNhYmxlSG92ZXI6ICExLCBhdXRvY2xvc2U6ICEwLCBob3ZlckRlbGF5OiA1MCwgY2xpY2tPcGVuOiAhMSwgY2xvc2luZ1RpbWU6IDUwMCwgYWxpZ25tZW50OiBcXFwibGVmdFxcXCIsIGNsb3NlT25DbGljazogITAsIGNsb3NlT25DbGlja0luc2lkZTogITAsIHZlcnRpY2FsQ2xhc3M6IFxcXCJ2ZXJ0aWNhbFxcXCIsIHJpZ2h0Q2xhc3M6IFxcXCJhbGlnbi1yaWdodFxcXCIsIGZvcmNlRm9sbG93OiAhMCB9LCBGb3VuZGF0aW9uLnBsdWdpbihlLCBcXFwiRHJvcGRvd25NZW51XFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIkVxdWFsaXplclxcXCIpO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJkYXRhLWVxdWFsaXplclxcXCIpIHx8IFxcXCJcXFwiLFxcbiAgICAgICAgICAgIGkgPSB0aGlzLiRlbGVtZW50LmZpbmQoJ1tkYXRhLWVxdWFsaXplci13YXRjaD1cXFwiJyArIGUgKyAnXFxcIl0nKTt0aGlzLiR3YXRjaGVkID0gaS5sZW5ndGggPyBpIDogdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1lcXVhbGl6ZXItd2F0Y2hdXFxcIiksIHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiZGF0YS1yZXNpemVcXFwiLCBlIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgXFxcImVxXFxcIikpLCB0aGlzLmhhc05lc3RlZCA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtZXF1YWxpemVyXVxcXCIpLmxlbmd0aCA+IDAsIHRoaXMuaXNOZXN0ZWQgPSB0aGlzLiRlbGVtZW50LnBhcmVudHNVbnRpbChkb2N1bWVudC5ib2R5LCBcXFwiW2RhdGEtZXF1YWxpemVyXVxcXCIpLmxlbmd0aCA+IDAsIHRoaXMuaXNPbiA9ICExLCB0aGlzLl9iaW5kSGFuZGxlciA9IHsgb25SZXNpemVNZUJvdW5kOiB0aGlzLl9vblJlc2l6ZU1lLmJpbmQodGhpcyksIG9uUG9zdEVxdWFsaXplZEJvdW5kOiB0aGlzLl9vblBvc3RFcXVhbGl6ZWQuYmluZCh0aGlzKSB9O3ZhciBuLFxcbiAgICAgICAgICAgIHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImltZ1xcXCIpO3RoaXMub3B0aW9ucy5lcXVhbGl6ZU9uID8gKG4gPSB0aGlzLl9jaGVja01RKCksIHQod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIiwgdGhpcy5fY2hlY2tNUS5iaW5kKHRoaXMpKSkgOiB0aGlzLl9ldmVudHMoKSwgKHZvaWQgMCAhPT0gbiAmJiBuID09PSAhMSB8fCB2b2lkIDAgPT09IG4pICYmIChzLmxlbmd0aCA/IEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQocywgdGhpcy5fcmVmbG93LmJpbmQodGhpcykpIDogdGhpcy5fcmVmbG93KCkpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfcGF1c2VFdmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLmlzT24gPSAhMSwgdGhpcy4kZWxlbWVudC5vZmYoeyBcXFwiLnpmLmVxdWFsaXplclxcXCI6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUG9zdEVxdWFsaXplZEJvdW5kLCBcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6IHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX29uUmVzaXplTWVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgdGhpcy5fcmVmbG93KCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9vblBvc3RFcXVhbGl6ZWRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgdC50YXJnZXQgIT09IHRoaXMuJGVsZW1lbnRbMF0gJiYgdGhpcy5fcmVmbG93KCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9ldmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLl9wYXVzZUV2ZW50cygpLCB0aGlzLmhhc05lc3RlZCA/IHRoaXMuJGVsZW1lbnQub24oXFxcInBvc3RlcXVhbGl6ZWQuemYuZXF1YWxpemVyXFxcIiwgdGhpcy5fYmluZEhhbmRsZXIub25Qb3N0RXF1YWxpemVkQm91bmQpIDogdGhpcy4kZWxlbWVudC5vbihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIsIHRoaXMuX2JpbmRIYW5kbGVyLm9uUmVzaXplTWVCb3VuZCksIHRoaXMuaXNPbiA9ICEwO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfY2hlY2tNUVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gIUZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5lcXVhbGl6ZU9uKTtyZXR1cm4gdCA/IHRoaXMuaXNPbiAmJiAodGhpcy5fcGF1c2VFdmVudHMoKSwgdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsIFxcXCJhdXRvXFxcIikpIDogdGhpcy5pc09uIHx8IHRoaXMuX2V2ZW50cygpLCB0O1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfa2lsbHN3aXRjaFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHt9IH0sIHsga2V5OiBcXFwiX3JlZmxvd1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHJldHVybiAhdGhpcy5vcHRpb25zLmVxdWFsaXplT25TdGFjayAmJiB0aGlzLl9pc1N0YWNrZWQoKSA/ICh0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIiwgXFxcImF1dG9cXFwiKSwgITEpIDogdm9pZCAodGhpcy5vcHRpb25zLmVxdWFsaXplQnlSb3cgPyB0aGlzLmdldEhlaWdodHNCeVJvdyh0aGlzLmFwcGx5SGVpZ2h0QnlSb3cuYmluZCh0aGlzKSkgOiB0aGlzLmdldEhlaWdodHModGhpcy5hcHBseUhlaWdodC5iaW5kKHRoaXMpKSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9pc1N0YWNrZWRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICByZXR1cm4gdGhpcy4kd2F0Y2hlZFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3AgIT09IHRoaXMuJHdhdGNoZWRbMV0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkudG9wO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJnZXRIZWlnaHRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIGZvciAodmFyIGUgPSBbXSwgaSA9IDAsIG4gPSB0aGlzLiR3YXRjaGVkLmxlbmd0aDsgaSA8IG47IGkrKykge1xcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkW2ldLnN0eWxlLmhlaWdodCA9IFxcXCJhdXRvXFxcIiwgZS5wdXNoKHRoaXMuJHdhdGNoZWRbaV0ub2Zmc2V0SGVpZ2h0KTtcXG4gICAgICAgIH10KGUpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJnZXRIZWlnaHRzQnlSb3dcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xcbiAgICAgICAgdmFyIGkgPSB0aGlzLiR3YXRjaGVkLmxlbmd0aCA/IHRoaXMuJHdhdGNoZWQuZmlyc3QoKS5vZmZzZXQoKS50b3AgOiAwLFxcbiAgICAgICAgICAgIG4gPSBbXSxcXG4gICAgICAgICAgICBzID0gMDtuW3NdID0gW107Zm9yICh2YXIgbyA9IDAsIGEgPSB0aGlzLiR3YXRjaGVkLmxlbmd0aDsgbyA8IGE7IG8rKykge1xcbiAgICAgICAgICB0aGlzLiR3YXRjaGVkW29dLnN0eWxlLmhlaWdodCA9IFxcXCJhdXRvXFxcIjt2YXIgciA9IHQodGhpcy4kd2F0Y2hlZFtvXSkub2Zmc2V0KCkudG9wO3IgIT0gaSAmJiAocysrLCBuW3NdID0gW10sIGkgPSByKSwgbltzXS5wdXNoKFt0aGlzLiR3YXRjaGVkW29dLCB0aGlzLiR3YXRjaGVkW29dLm9mZnNldEhlaWdodF0pO1xcbiAgICAgICAgfWZvciAodmFyIGwgPSAwLCB1ID0gbi5sZW5ndGg7IGwgPCB1OyBsKyspIHtcXG4gICAgICAgICAgdmFyIGQgPSB0KG5bbF0pLm1hcChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXNbMV07XFxuICAgICAgICAgIH0pLmdldCgpLFxcbiAgICAgICAgICAgICAgaCA9IE1hdGgubWF4LmFwcGx5KG51bGwsIGQpO25bbF0ucHVzaChoKTtcXG4gICAgICAgIH1lKG4pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJhcHBseUhlaWdodFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB2YXIgZSA9IE1hdGgubWF4LmFwcGx5KG51bGwsIHQpO3RoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicHJlZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpLCB0aGlzLiR3YXRjaGVkLmNzcyhcXFwiaGVpZ2h0XFxcIiwgZSksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicG9zdGVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiYXBwbHlIZWlnaHRCeVJvd1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInByZWVxdWFsaXplZC56Zi5lcXVhbGl6ZXJcXFwiKTtmb3IgKHZhciBpID0gMCwgbiA9IGUubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XFxuICAgICAgICAgIHZhciBzID0gZVtpXS5sZW5ndGgsXFxuICAgICAgICAgICAgICBvID0gZVtpXVtzIC0gMV07aWYgKHMgPD0gMikgdChlW2ldWzBdWzBdKS5jc3MoeyBoZWlnaHQ6IFxcXCJhdXRvXFxcIiB9KTtlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInByZWVxdWFsaXplZHJvdy56Zi5lcXVhbGl6ZXJcXFwiKTtmb3IgKHZhciBhID0gMCwgciA9IHMgLSAxOyBhIDwgcjsgYSsrKSB7XFxuICAgICAgICAgICAgICB0KGVbaV1bYV1bMF0pLmNzcyh7IGhlaWdodDogbyB9KTtcXG4gICAgICAgICAgICB9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwb3N0ZXF1YWxpemVkcm93LnpmLmVxdWFsaXplclxcXCIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9dGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJwb3N0ZXF1YWxpemVkLnpmLmVxdWFsaXplclxcXCIpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJkZXN0cm95XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy5fcGF1c2VFdmVudHMoKSwgdGhpcy4kd2F0Y2hlZC5jc3MoXFxcImhlaWdodFxcXCIsIFxcXCJhdXRvXFxcIiksIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9IH1dKSwgZTtcXG4gIH0oKTtlLmRlZmF1bHRzID0geyBlcXVhbGl6ZU9uU3RhY2s6ICExLCBlcXVhbGl6ZUJ5Um93OiAhMSwgZXF1YWxpemVPbjogXFxcIlxcXCIgfSwgRm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIkVxdWFsaXplclxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpLCBuKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGUpLCB0aGlzLiRlbGVtZW50ID0gaSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIGUuZGVmYXVsdHMsIG4pLCB0aGlzLnJ1bGVzID0gW10sIHRoaXMuY3VycmVudFBhdGggPSBcXFwiXFxcIiwgdGhpcy5faW5pdCgpLCB0aGlzLl9ldmVudHMoKSwgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCBcXFwiSW50ZXJjaGFuZ2VcXFwiKTtcXG4gICAgfXJldHVybiBfY3JlYXRlQ2xhc3MoZSwgW3sga2V5OiBcXFwiX2luaXRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLl9hZGRCcmVha3BvaW50cygpLCB0aGlzLl9nZW5lcmF0ZVJ1bGVzKCksIHRoaXMuX3JlZmxvdygpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdCh3aW5kb3cpLm9uKFxcXCJyZXNpemUuemYuaW50ZXJjaGFuZ2VcXFwiLCBGb3VuZGF0aW9uLnV0aWwudGhyb3R0bGUodGhpcy5fcmVmbG93LmJpbmQodGhpcyksIDUwKSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9yZWZsb3dcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgdDtmb3IgKHZhciBlIGluIHRoaXMucnVsZXMpIHtcXG4gICAgICAgICAgaWYgKHRoaXMucnVsZXMuaGFzT3duUHJvcGVydHkoZSkpIHtcXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMucnVsZXNbZV07d2luZG93Lm1hdGNoTWVkaWEoaS5xdWVyeSkubWF0Y2hlcyAmJiAodCA9IGkpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9dCAmJiB0aGlzLnJlcGxhY2UodC5wYXRoKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2FkZEJyZWFrcG9pbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgZm9yICh2YXIgdCBpbiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkucXVlcmllcykge1xcbiAgICAgICAgICBpZiAoRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LnF1ZXJpZXMuaGFzT3duUHJvcGVydHkodCkpIHtcXG4gICAgICAgICAgICB2YXIgaSA9IEZvdW5kYXRpb24uTWVkaWFRdWVyeS5xdWVyaWVzW3RdO2UuU1BFQ0lBTF9RVUVSSUVTW2kubmFtZV0gPSBpLnZhbHVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9nZW5lcmF0ZVJ1bGVzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgIG4gPSBbXTtpID0gdGhpcy5vcHRpb25zLnJ1bGVzID8gdGhpcy5vcHRpb25zLnJ1bGVzIDogdGhpcy4kZWxlbWVudC5kYXRhKFxcXCJpbnRlcmNoYW5nZVxcXCIpLm1hdGNoKC9cXFxcWy4qP1xcXFxdL2cpO2ZvciAodmFyIHMgaW4gaSkge1xcbiAgICAgICAgICBpZiAoaS5oYXNPd25Qcm9wZXJ0eShzKSkge1xcbiAgICAgICAgICAgIHZhciBvID0gaVtzXS5zbGljZSgxLCAtMSkuc3BsaXQoXFxcIiwgXFxcIiksXFxuICAgICAgICAgICAgICAgIGEgPSBvLnNsaWNlKDAsIC0xKS5qb2luKFxcXCJcXFwiKSxcXG4gICAgICAgICAgICAgICAgciA9IG9bby5sZW5ndGggLSAxXTtlLlNQRUNJQUxfUVVFUklFU1tyXSAmJiAociA9IGUuU1BFQ0lBTF9RVUVSSUVTW3JdKSwgbi5wdXNoKHsgcGF0aDogYSwgcXVlcnk6IHIgfSk7XFxuICAgICAgICAgIH1cXG4gICAgICAgIH10aGlzLnJ1bGVzID0gbjtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwicmVwbGFjZVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICBpZiAodGhpcy5jdXJyZW50UGF0aCAhPT0gZSkge1xcbiAgICAgICAgICB2YXIgaSA9IHRoaXMsXFxuICAgICAgICAgICAgICBuID0gXFxcInJlcGxhY2VkLnpmLmludGVyY2hhbmdlXFxcIjtcXFwiSU1HXFxcIiA9PT0gdGhpcy4kZWxlbWVudFswXS5ub2RlTmFtZSA/IHRoaXMuJGVsZW1lbnQuYXR0cihcXFwic3JjXFxcIiwgZSkub24oXFxcImxvYWRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgaS5jdXJyZW50UGF0aCA9IGU7XFxuICAgICAgICAgIH0pLnRyaWdnZXIobikgOiBlLm1hdGNoKC9cXFxcLihnaWZ8anBnfGpwZWd8cG5nfHN2Z3x0aWZmKShbPyNdLiopPy9pKSA/IHRoaXMuJGVsZW1lbnQuY3NzKHsgXFxcImJhY2tncm91bmQtaW1hZ2VcXFwiOiBcXFwidXJsKFxcXCIgKyBlICsgXFxcIilcXFwiIH0pLnRyaWdnZXIobikgOiB0LmdldChlLCBmdW5jdGlvbiAocykge1xcbiAgICAgICAgICAgIGkuJGVsZW1lbnQuaHRtbChzKS50cmlnZ2VyKG4pLCB0KHMpLmZvdW5kYXRpb24oKSwgaS5jdXJyZW50UGF0aCA9IGU7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJkZXN0cm95XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge30gfV0pLCBlO1xcbiAgfSgpO2UuZGVmYXVsdHMgPSB7IHJ1bGVzOiBudWxsIH0sIGUuU1BFQ0lBTF9RVUVSSUVTID0geyBsYW5kc2NhcGU6IFxcXCJzY3JlZW4gYW5kIChvcmllbnRhdGlvbjogbGFuZHNjYXBlKVxcXCIsIHBvcnRyYWl0OiBcXFwic2NyZWVuIGFuZCAob3JpZW50YXRpb246IHBvcnRyYWl0KVxcXCIsIHJldGluYTogXFxcIm9ubHkgc2NyZWVuIGFuZCAoLXdlYmtpdC1taW4tZGV2aWNlLXBpeGVsLXJhdGlvOiAyKSwgb25seSBzY3JlZW4gYW5kIChtaW4tLW1vei1kZXZpY2UtcGl4ZWwtcmF0aW86IDIpLCBvbmx5IHNjcmVlbiBhbmQgKC1vLW1pbi1kZXZpY2UtcGl4ZWwtcmF0aW86IDIvMSksIG9ubHkgc2NyZWVuIGFuZCAobWluLWRldmljZS1waXhlbC1yYXRpbzogMiksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDE5MmRwaSksIG9ubHkgc2NyZWVuIGFuZCAobWluLXJlc29sdXRpb246IDJkcHB4KVxcXCIgfSwgRm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIkludGVyY2hhbmdlXFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIk1hZ2VsbGFuXFxcIik7XFxuICAgIH1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsIFt7IGtleTogXFxcIl9pbml0XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzLiRlbGVtZW50WzBdLmlkIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgXFxcIm1hZ2VsbGFuXFxcIik7dGhpcy4kdGFyZ2V0cyA9IHQoXFxcIltkYXRhLW1hZ2VsbGFuLXRhcmdldF1cXFwiKSwgdGhpcy4kbGlua3MgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImFcXFwiKSwgdGhpcy4kZWxlbWVudC5hdHRyKHsgXFxcImRhdGEtcmVzaXplXFxcIjogZSwgXFxcImRhdGEtc2Nyb2xsXFxcIjogZSwgaWQ6IGUgfSksIHRoaXMuJGFjdGl2ZSA9IHQoKSwgdGhpcy5zY3JvbGxQb3MgPSBwYXJzZUludCh3aW5kb3cucGFnZVlPZmZzZXQsIDEwKSwgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImNhbGNQb2ludHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXMsXFxuICAgICAgICAgICAgaSA9IGRvY3VtZW50LmJvZHksXFxuICAgICAgICAgICAgbiA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDt0aGlzLnBvaW50cyA9IFtdLCB0aGlzLndpbkhlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgod2luZG93LmlubmVySGVpZ2h0LCBuLmNsaWVudEhlaWdodCkpLCB0aGlzLmRvY0hlaWdodCA9IE1hdGgucm91bmQoTWF0aC5tYXgoaS5zY3JvbGxIZWlnaHQsIGkub2Zmc2V0SGVpZ2h0LCBuLmNsaWVudEhlaWdodCwgbi5zY3JvbGxIZWlnaHQsIG4ub2Zmc2V0SGVpZ2h0KSksIHRoaXMuJHRhcmdldHMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHZhciBpID0gdCh0aGlzKSxcXG4gICAgICAgICAgICAgIG4gPSBNYXRoLnJvdW5kKGkub2Zmc2V0KCkudG9wIC0gZS5vcHRpb25zLnRocmVzaG9sZCk7aS50YXJnZXRQb2ludCA9IG4sIGUucG9pbnRzLnB1c2gobik7XFxuICAgICAgICB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2V2ZW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpczt0KFxcXCJodG1sLCBib2R5XFxcIiksIHsgZHVyYXRpb246IGUub3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbiwgZWFzaW5nOiBlLm9wdGlvbnMuYW5pbWF0aW9uRWFzaW5nIH07dCh3aW5kb3cpLm9uZShcXFwibG9hZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZS5vcHRpb25zLmRlZXBMaW5raW5nICYmIGxvY2F0aW9uLmhhc2ggJiYgZS5zY3JvbGxUb0xvYyhsb2NhdGlvbi5oYXNoKSwgZS5jYWxjUG9pbnRzKCksIGUuX3VwZGF0ZUFjdGl2ZSgpO1xcbiAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQub24oeyBcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCI6IHRoaXMucmVmbG93LmJpbmQodGhpcyksIFxcXCJzY3JvbGxtZS56Zi50cmlnZ2VyXFxcIjogdGhpcy5fdXBkYXRlQWN0aXZlLmJpbmQodGhpcykgfSkub24oXFxcImNsaWNrLnpmLm1hZ2VsbGFuXFxcIiwgJ2FbaHJlZl49XFxcIiNcXFwiXScsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKTt2YXIgaSA9IHRoaXMuZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7ZS5zY3JvbGxUb0xvYyhpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJzY3JvbGxUb0xvY1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICBpZiAoIXQoZSkubGVuZ3RoKSByZXR1cm4gITE7dmFyIGkgPSBNYXRoLnJvdW5kKHQoZSkub2Zmc2V0KCkudG9wIC0gdGhpcy5vcHRpb25zLnRocmVzaG9sZCAvIDIgLSB0aGlzLm9wdGlvbnMuYmFyT2Zmc2V0KTt0KFxcXCJodG1sLCBib2R5XFxcIikuc3RvcCghMCkuYW5pbWF0ZSh7IHNjcm9sbFRvcDogaSB9LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24sIHRoaXMub3B0aW9ucy5hbmltYXRpb25FYXNpbmcpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJyZWZsb3dcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLmNhbGNQb2ludHMoKSwgdGhpcy5fdXBkYXRlQWN0aXZlKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl91cGRhdGVBY3RpdmVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgdCxcXG4gICAgICAgICAgICBlID0gcGFyc2VJbnQod2luZG93LnBhZ2VZT2Zmc2V0LCAxMCk7aWYgKGUgKyB0aGlzLndpbkhlaWdodCA9PT0gdGhpcy5kb2NIZWlnaHQpIHQgPSB0aGlzLnBvaW50cy5sZW5ndGggLSAxO2Vsc2UgaWYgKGUgPCB0aGlzLnBvaW50c1swXSkgdCA9IDA7ZWxzZSB7XFxuICAgICAgICAgIHZhciBpID0gdGhpcy5zY3JvbGxQb3MgPCBlLFxcbiAgICAgICAgICAgICAgbiA9IHRoaXMsXFxuICAgICAgICAgICAgICBzID0gdGhpcy5wb2ludHMuZmlsdGVyKGZ1bmN0aW9uICh0LCBzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGkgPyB0IC0gbi5vcHRpb25zLmJhck9mZnNldCA8PSBlIDogdCAtIG4ub3B0aW9ucy5iYXJPZmZzZXQgLSBuLm9wdGlvbnMudGhyZXNob2xkIDw9IGU7XFxuICAgICAgICAgIH0pO3QgPSBzLmxlbmd0aCA/IHMubGVuZ3RoIC0gMSA6IDA7XFxuICAgICAgICB9aWYgKHRoaXMuJGFjdGl2ZS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLCB0aGlzLiRhY3RpdmUgPSB0aGlzLiRsaW5rcy5maWx0ZXIoJ1tocmVmPVxcXCIjJyArIHRoaXMuJHRhcmdldHMuZXEodCkuZGF0YShcXFwibWFnZWxsYW4tdGFyZ2V0XFxcIikgKyAnXFxcIl0nKS5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLCB0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgICAgdmFyIG8gPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7d2luZG93Lmhpc3RvcnkucHVzaFN0YXRlID8gd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKG51bGwsIG51bGwsIG8pIDogd2luZG93LmxvY2F0aW9uLmhhc2ggPSBvO1xcbiAgICAgICAgfXRoaXMuc2Nyb2xsUG9zID0gZSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJ1cGRhdGUuemYubWFnZWxsYW5cXFwiLCBbdGhpcy4kYWN0aXZlXSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICBpZiAodGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5tYWdlbGxhblxcXCIpLmZpbmQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLmFjdGl2ZUNsYXNzKS5yZW1vdmVDbGFzcyh0aGlzLm9wdGlvbnMuYWN0aXZlQ2xhc3MpLCB0aGlzLm9wdGlvbnMuZGVlcExpbmtpbmcpIHtcXG4gICAgICAgICAgdmFyIHQgPSB0aGlzLiRhY3RpdmVbMF0uZ2V0QXR0cmlidXRlKFxcXCJocmVmXFxcIik7d2luZG93LmxvY2F0aW9uLmhhc2gucmVwbGFjZSh0LCBcXFwiXFxcIik7XFxuICAgICAgICB9Rm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH0gfV0pLCBlO1xcbiAgfSgpO2UuZGVmYXVsdHMgPSB7IGFuaW1hdGlvbkR1cmF0aW9uOiA1MDAsIGFuaW1hdGlvbkVhc2luZzogXFxcImxpbmVhclxcXCIsIHRocmVzaG9sZDogNTAsIGFjdGl2ZUNsYXNzOiBcXFwiYWN0aXZlXFxcIiwgZGVlcExpbmtpbmc6ICExLCBiYXJPZmZzZXQ6IDAgfSwgRm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIk1hZ2VsbGFuXFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLiRsYXN0VHJpZ2dlciA9IHQoKSwgdGhpcy4kdHJpZ2dlcnMgPSB0KCksIHRoaXMuX2luaXQoKSwgdGhpcy5fZXZlbnRzKCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIk9mZkNhbnZhc1xcXCIpLCBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJPZmZDYW52YXNcXFwiLCB7IEVTQ0FQRTogXFxcImNsb3NlXFxcIiB9KTtcXG4gICAgfXJldHVybiBfY3JlYXRlQ2xhc3MoZSwgW3sga2V5OiBcXFwiX2luaXRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiaWRcXFwiKTtpZiAodGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJ0cnVlXFxcIiksIHRoaXMuJHRyaWdnZXJzID0gdChkb2N1bWVudCkuZmluZCgnW2RhdGEtb3Blbj1cXFwiJyArIGUgKyAnXFxcIl0sIFtkYXRhLWNsb3NlPVxcXCInICsgZSArICdcXFwiXSwgW2RhdGEtdG9nZ2xlPVxcXCInICsgZSArICdcXFwiXScpLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCBcXFwiZmFsc2VcXFwiKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIiwgZSksIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2spIGlmICh0KFxcXCIuanMtb2ZmLWNhbnZhcy1leGl0XFxcIikubGVuZ3RoKSB0aGlzLiRleGl0ZXIgPSB0KFxcXCIuanMtb2ZmLWNhbnZhcy1leGl0XFxcIik7ZWxzZSB7XFxuICAgICAgICAgIHZhciBpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcXFwiZGl2XFxcIik7aS5zZXRBdHRyaWJ1dGUoXFxcImNsYXNzXFxcIiwgXFxcImpzLW9mZi1jYW52YXMtZXhpdFxcXCIpLCB0KFxcXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXFxcIikuYXBwZW5kKGkpLCB0aGlzLiRleGl0ZXIgPSB0KGkpO1xcbiAgICAgICAgfXRoaXMub3B0aW9ucy5pc1JldmVhbGVkID0gdGhpcy5vcHRpb25zLmlzUmV2ZWFsZWQgfHwgbmV3IFJlZ0V4cCh0aGlzLm9wdGlvbnMucmV2ZWFsQ2xhc3MsIFxcXCJnXFxcIikudGVzdCh0aGlzLiRlbGVtZW50WzBdLmNsYXNzTmFtZSksIHRoaXMub3B0aW9ucy5pc1JldmVhbGVkICYmICh0aGlzLm9wdGlvbnMucmV2ZWFsT24gPSB0aGlzLm9wdGlvbnMucmV2ZWFsT24gfHwgdGhpcy4kZWxlbWVudFswXS5jbGFzc05hbWUubWF0Y2goLyhyZXZlYWwtZm9yLW1lZGl1bXxyZXZlYWwtZm9yLWxhcmdlKS9nKVswXS5zcGxpdChcXFwiLVxcXCIpWzJdLCB0aGlzLl9zZXRNUUNoZWNrZXIoKSksIHRoaXMub3B0aW9ucy50cmFuc2l0aW9uVGltZSB8fCAodGhpcy5vcHRpb25zLnRyYW5zaXRpb25UaW1lID0gMWUzICogcGFyc2VGbG9hdCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0KFxcXCJbZGF0YS1vZmYtY2FudmFzLXdyYXBwZXJdXFxcIilbMF0pLnRyYW5zaXRpb25EdXJhdGlvbikpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXNcXFwiKS5vbih7IFxcXCJvcGVuLnpmLnRyaWdnZXJcXFwiOiB0aGlzLm9wZW4uYmluZCh0aGlzKSwgXFxcImNsb3NlLnpmLnRyaWdnZXJcXFwiOiB0aGlzLmNsb3NlLmJpbmQodGhpcyksIFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksIFxcXCJrZXlkb3duLnpmLm9mZmNhbnZhc1xcXCI6IHRoaXMuX2hhbmRsZUtleWJvYXJkLmJpbmQodGhpcykgfSksIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy4kZXhpdGVyLmxlbmd0aCAmJiB0aGlzLiRleGl0ZXIub24oeyBcXFwiY2xpY2suemYub2ZmY2FudmFzXFxcIjogdGhpcy5jbG9zZS5iaW5kKHRoaXMpIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2V0TVFDaGVja2VyXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3Qod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdChlLm9wdGlvbnMucmV2ZWFsT24pID8gZS5yZXZlYWwoITApIDogZS5yZXZlYWwoITEpO1xcbiAgICAgICAgfSkub25lKFxcXCJsb2FkLnpmLm9mZmNhbnZhc1xcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QoZS5vcHRpb25zLnJldmVhbE9uKSAmJiBlLnJldmVhbCghMCk7XFxuICAgICAgICB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwicmV2ZWFsXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS1jbG9zZV1cXFwiKTt0ID8gKHRoaXMuY2xvc2UoKSwgdGhpcy5pc1JldmVhbGVkID0gITAsIHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJvcGVuLnpmLnRyaWdnZXIgdG9nZ2xlLnpmLnRyaWdnZXJcXFwiKSwgZS5sZW5ndGggJiYgZS5oaWRlKCkpIDogKHRoaXMuaXNSZXZlYWxlZCA9ICExLCB0aGlzLiRlbGVtZW50Lm9uKHsgXFxcIm9wZW4uemYudHJpZ2dlclxcXCI6IHRoaXMub3Blbi5iaW5kKHRoaXMpLCBcXFwidG9nZ2xlLnpmLnRyaWdnZXJcXFwiOiB0aGlzLnRvZ2dsZS5iaW5kKHRoaXMpIH0pLCBlLmxlbmd0aCAmJiBlLnNob3coKSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIm9wZW5cXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSwgaSkge1xcbiAgICAgICAgaWYgKCF0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikgJiYgIXRoaXMuaXNSZXZlYWxlZCkge1xcbiAgICAgICAgICB2YXIgbiA9IHRoaXM7dChkb2N1bWVudC5ib2R5KTt0aGlzLm9wdGlvbnMuZm9yY2VUb3AgJiYgdChcXFwiYm9keVxcXCIpLnNjcm9sbFRvcCgwKTt2YXIgcyA9IHQoXFxcIltkYXRhLW9mZi1jYW52YXMtd3JhcHBlcl1cXFwiKTtzLmFkZENsYXNzKFxcXCJpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi1cXFwiICsgbi5vcHRpb25zLnBvc2l0aW9uKSwgbi4kZWxlbWVudC5hZGRDbGFzcyhcXFwiaXMtb3BlblxcXCIpLCB0aGlzLiR0cmlnZ2Vycy5hdHRyKFxcXCJhcmlhLWV4cGFuZGVkXFxcIiwgXFxcInRydWVcXFwiKSwgdGhpcy4kZWxlbWVudC5hdHRyKFxcXCJhcmlhLWhpZGRlblxcXCIsIFxcXCJmYWxzZVxcXCIpLnRyaWdnZXIoXFxcIm9wZW5lZC56Zi5vZmZjYW52YXNcXFwiKSwgdGhpcy5vcHRpb25zLmNsb3NlT25DbGljayAmJiB0aGlzLiRleGl0ZXIuYWRkQ2xhc3MoXFxcImlzLXZpc2libGVcXFwiKSwgaSAmJiAodGhpcy4kbGFzdFRyaWdnZXIgPSBpKSwgdGhpcy5vcHRpb25zLmF1dG9Gb2N1cyAmJiBzLm9uZShGb3VuZGF0aW9uLnRyYW5zaXRpb25lbmQocyksIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBuLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikgJiYgKG4uJGVsZW1lbnQuYXR0cihcXFwidGFiaW5kZXhcXFwiLCBcXFwiLTFcXFwiKSwgbi4kZWxlbWVudC5mb2N1cygpKTtcXG4gICAgICAgICAgfSksIHRoaXMub3B0aW9ucy50cmFwRm9jdXMgJiYgcy5vbmUoRm91bmRhdGlvbi50cmFuc2l0aW9uZW5kKHMpLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbi4kZWxlbWVudC5oYXNDbGFzcyhcXFwiaXMtb3BlblxcXCIpICYmIChuLiRlbGVtZW50LmF0dHIoXFxcInRhYmluZGV4XFxcIiwgXFxcIi0xXFxcIiksIG4udHJhcEZvY3VzKCkpO1xcbiAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX3RyYXBGb2N1c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKHRoaXMuJGVsZW1lbnQpLFxcbiAgICAgICAgICAgIGUgPSB0LmVxKDApLFxcbiAgICAgICAgICAgIGkgPSB0LmVxKC0xKTt0Lm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLm9uKFxcXCJrZXlkb3duLnpmLm9mZmNhbnZhc1xcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgIHZhciBuID0gRm91bmRhdGlvbi5LZXlib2FyZC5wYXJzZUtleSh0KTtcXFwiVEFCXFxcIiA9PT0gbiAmJiB0LnRhcmdldCA9PT0gaVswXSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCBlLmZvY3VzKCkpLCBcXFwiU0hJRlRfVEFCXFxcIiA9PT0gbiAmJiB0LnRhcmdldCA9PT0gZVswXSAmJiAodC5wcmV2ZW50RGVmYXVsdCgpLCBpLmZvY3VzKCkpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImNsb3NlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcXG4gICAgICAgIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1vcGVuXFxcIikgJiYgIXRoaXMuaXNSZXZlYWxlZCkge1xcbiAgICAgICAgICB2YXIgaSA9IHRoaXM7dChcXFwiW2RhdGEtb2ZmLWNhbnZhcy13cmFwcGVyXVxcXCIpLnJlbW92ZUNsYXNzKFxcXCJpcy1vZmYtY2FudmFzLW9wZW4gaXMtb3Blbi1cXFwiICsgaS5vcHRpb25zLnBvc2l0aW9uKSwgaS4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtb3BlblxcXCIpLCB0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtaGlkZGVuXFxcIiwgXFxcInRydWVcXFwiKS50cmlnZ2VyKFxcXCJjbG9zZWQuemYub2ZmY2FudmFzXFxcIiksIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy4kZXhpdGVyLnJlbW92ZUNsYXNzKFxcXCJpcy12aXNpYmxlXFxcIiksIHRoaXMuJHRyaWdnZXJzLmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCBcXFwiZmFsc2VcXFwiKSwgdGhpcy5vcHRpb25zLnRyYXBGb2N1cyAmJiB0KFxcXCJbZGF0YS1vZmYtY2FudmFzLWNvbnRlbnRdXFxcIikucmVtb3ZlQXR0cihcXFwidGFiaW5kZXhcXFwiKTtcXG4gICAgICAgIH1cXG4gICAgICB9IH0sIHsga2V5OiBcXFwidG9nZ2xlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIGUpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImlzLW9wZW5cXFwiKSA/IHRoaXMuY2xvc2UodCwgZSkgOiB0aGlzLm9wZW4odCwgZSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9oYW5kbGVLZXlib2FyZFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXM7Rm91bmRhdGlvbi5LZXlib2FyZC5oYW5kbGVLZXkodCwgXFxcIk9mZkNhbnZhc1xcXCIsIHsgY2xvc2U6IGZ1bmN0aW9uIGNsb3NlKCkge1xcbiAgICAgICAgICAgIHJldHVybiBlLmNsb3NlKCksIGUuJGxhc3RUcmlnZ2VyLmZvY3VzKCksICEwO1xcbiAgICAgICAgICB9LCBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKCkge1xcbiAgICAgICAgICAgIHQuc3RvcFByb3BhZ2F0aW9uKCksIHQucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgfSB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZGVzdHJveVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuY2xvc2UoKSwgdGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50cmlnZ2VyIC56Zi5vZmZjYW52YXNcXFwiKSwgdGhpcy4kZXhpdGVyLm9mZihcXFwiLnpmLm9mZmNhbnZhc1xcXCIpLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGU7XFxuICB9KCk7ZS5kZWZhdWx0cyA9IHsgY2xvc2VPbkNsaWNrOiAhMCwgdHJhbnNpdGlvblRpbWU6IDAsIHBvc2l0aW9uOiBcXFwibGVmdFxcXCIsIGZvcmNlVG9wOiAhMCwgaXNSZXZlYWxlZDogITEsIHJldmVhbE9uOiBudWxsLCBhdXRvRm9jdXM6ICEwLCByZXZlYWxDbGFzczogXFxcInJldmVhbC1mb3ItXFxcIiwgdHJhcEZvY3VzOiAhMSB9LCBGb3VuZGF0aW9uLnBsdWdpbihlLCBcXFwiT2ZmQ2FudmFzXFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIk9yYml0XFxcIiksIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIk9yYml0XFxcIiwgeyBsdHI6IHsgQVJST1dfUklHSFQ6IFxcXCJuZXh0XFxcIiwgQVJST1dfTEVGVDogXFxcInByZXZpb3VzXFxcIiB9LCBydGw6IHsgQVJST1dfTEVGVDogXFxcIm5leHRcXFwiLCBBUlJPV19SSUdIVDogXFxcInByZXZpb3VzXFxcIiB9IH0pO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJHdyYXBwZXIgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKSwgdGhpcy4kc2xpZGVzID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCIuXFxcIiArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKTt2YXIgdCA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiaW1nXFxcIiksXFxuICAgICAgICAgICAgZSA9IHRoaXMuJHNsaWRlcy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKTtlLmxlbmd0aCB8fCB0aGlzLiRzbGlkZXMuZXEoMCkuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLCB0aGlzLm9wdGlvbnMudXNlTVVJIHx8IHRoaXMuJHNsaWRlcy5hZGRDbGFzcyhcXFwibm8tbW90aW9udWlcXFwiKSwgdC5sZW5ndGggPyBGb3VuZGF0aW9uLm9uSW1hZ2VzTG9hZGVkKHQsIHRoaXMuX3ByZXBhcmVGb3JPcmJpdC5iaW5kKHRoaXMpKSA6IHRoaXMuX3ByZXBhcmVGb3JPcmJpdCgpLCB0aGlzLm9wdGlvbnMuYnVsbGV0cyAmJiB0aGlzLl9sb2FkQnVsbGV0cygpLCB0aGlzLl9ldmVudHMoKSwgdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmIHRoaXMuJHNsaWRlcy5sZW5ndGggPiAxICYmIHRoaXMuZ2VvU3luYygpLCB0aGlzLm9wdGlvbnMuYWNjZXNzaWJsZSAmJiB0aGlzLiR3cmFwcGVyLmF0dHIoXFxcInRhYmluZGV4XFxcIiwgMCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9sb2FkQnVsbGV0c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJGJ1bGxldHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLmJveE9mQnVsbGV0cykuZmluZChcXFwiYnV0dG9uXFxcIik7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImdlb1N5bmNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgdCA9IHRoaXM7dGhpcy50aW1lciA9IG5ldyBGb3VuZGF0aW9uLlRpbWVyKHRoaXMuJGVsZW1lbnQsIHsgZHVyYXRpb246IHRoaXMub3B0aW9ucy50aW1lckRlbGF5LCBpbmZpbml0ZTogITEgfSwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0LmNoYW5nZVNsaWRlKCEwKTtcXG4gICAgICAgIH0pLCB0aGlzLnRpbWVyLnN0YXJ0KCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9wcmVwYXJlRm9yT3JiaXRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgdCA9IHRoaXM7dGhpcy5fc2V0V3JhcHBlckhlaWdodChmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB0Ll9zZXRTbGlkZUhlaWdodChlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2V0V3JhcHBlckhlaWdodFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICB2YXIgaSxcXG4gICAgICAgICAgICBuID0gMCxcXG4gICAgICAgICAgICBzID0gMDt0aGlzLiRzbGlkZXMuZWFjaChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGkgPSB0aGlzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmhlaWdodCwgdCh0aGlzKS5hdHRyKFxcXCJkYXRhLXNsaWRlXFxcIiwgcyksIHMgJiYgdCh0aGlzKS5jc3MoeyBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIiwgZGlzcGxheTogXFxcIm5vbmVcXFwiIH0pLCBuID0gaSA+IG4gPyBpIDogbiwgcysrO1xcbiAgICAgICAgfSksIHMgPT09IHRoaXMuJHNsaWRlcy5sZW5ndGggJiYgKHRoaXMuJHdyYXBwZXIuY3NzKHsgaGVpZ2h0OiBuIH0pLCBlKG4pKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX3NldFNsaWRlSGVpZ2h0XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKGUpIHtcXG4gICAgICAgIHRoaXMuJHNsaWRlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdCh0aGlzKS5jc3MoXFxcIm1heC1oZWlnaHRcXFwiLCBlKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO2lmICh0aGlzLiRzbGlkZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnN3aXBlICYmIHRoaXMuJHNsaWRlcy5vZmYoXFxcInN3aXBlbGVmdC56Zi5vcmJpdCBzd2lwZXJpZ2h0LnpmLm9yYml0XFxcIikub24oXFxcInN3aXBlbGVmdC56Zi5vcmJpdFxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgdC5wcmV2ZW50RGVmYXVsdCgpLCBlLmNoYW5nZVNsaWRlKCEwKTtcXG4gICAgICAgICAgfSkub24oXFxcInN3aXBlcmlnaHQuemYub3JiaXRcXFwiLCBmdW5jdGlvbiAodCkge1xcbiAgICAgICAgICAgIHQucHJldmVudERlZmF1bHQoKSwgZS5jaGFuZ2VTbGlkZSghMSk7XFxuICAgICAgICAgIH0pLCB0aGlzLm9wdGlvbnMuYXV0b1BsYXkgJiYgKHRoaXMuJHNsaWRlcy5vbihcXFwiY2xpY2suemYub3JiaXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiLCAhZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiKSksIGUudGltZXJbZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiKSA/IFxcXCJwYXVzZVxcXCIgOiBcXFwic3RhcnRcXFwiXSgpO1xcbiAgICAgICAgICB9KSwgdGhpcy5vcHRpb25zLnBhdXNlT25Ib3ZlciAmJiB0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWVudGVyLnpmLm9yYml0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGUudGltZXIucGF1c2UoKTtcXG4gICAgICAgICAgfSkub24oXFxcIm1vdXNlbGVhdmUuemYub3JiaXRcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgZS4kZWxlbWVudC5kYXRhKFxcXCJjbGlja2VkT25cXFwiKSB8fCBlLnRpbWVyLnN0YXJ0KCk7XFxuICAgICAgICAgIH0pKSwgdGhpcy5vcHRpb25zLm5hdkJ1dHRvbnMpIHtcXG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMubmV4dENsYXNzICsgXFxcIiwgLlxcXCIgKyB0aGlzLm9wdGlvbnMucHJldkNsYXNzKTtpLmF0dHIoXFxcInRhYmluZGV4XFxcIiwgMCkub24oXFxcImNsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0XFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgICAgIGkucHJldmVudERlZmF1bHQoKSwgZS5jaGFuZ2VTbGlkZSh0KHRoaXMpLmhhc0NsYXNzKGUub3B0aW9ucy5uZXh0Q2xhc3MpKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfXRoaXMub3B0aW9ucy5idWxsZXRzICYmIHRoaXMuJGJ1bGxldHMub24oXFxcImNsaWNrLnpmLm9yYml0IHRvdWNoZW5kLnpmLm9yYml0XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGlmICgvaXMtYWN0aXZlL2cudGVzdCh0aGlzLmNsYXNzTmFtZSkpIHJldHVybiAhMTt2YXIgaSA9IHQodGhpcykuZGF0YShcXFwic2xpZGVcXFwiKSxcXG4gICAgICAgICAgICAgICAgbiA9IGkgPiBlLiRzbGlkZXMuZmlsdGVyKFxcXCIuaXMtYWN0aXZlXFxcIikuZGF0YShcXFwic2xpZGVcXFwiKSxcXG4gICAgICAgICAgICAgICAgcyA9IGUuJHNsaWRlcy5lcShpKTtlLmNoYW5nZVNsaWRlKG4sIHMsIGkpO1xcbiAgICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmFjY2Vzc2libGUgJiYgdGhpcy4kd3JhcHBlci5hZGQodGhpcy4kYnVsbGV0cykub24oXFxcImtleWRvd24uemYub3JiaXRcXFwiLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksIFxcXCJPcmJpdFxcXCIsIHsgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICAgICAgZS5jaGFuZ2VTbGlkZSghMCk7XFxuICAgICAgICAgICAgICB9LCBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XFxuICAgICAgICAgICAgICAgIGUuY2hhbmdlU2xpZGUoITEpO1xcbiAgICAgICAgICAgICAgfSwgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCgpIHtcXG4gICAgICAgICAgICAgICAgdChpLnRhcmdldCkuaXMoZS4kYnVsbGV0cykgJiYgZS4kYnVsbGV0cy5maWx0ZXIoXFxcIi5pcy1hY3RpdmVcXFwiKS5mb2N1cygpO1xcbiAgICAgICAgICAgICAgfSB9KTtcXG4gICAgICAgICAgfSk7XFxuICAgICAgICB9XFxuICAgICAgfSB9LCB7IGtleTogXFxcImNoYW5nZVNsaWRlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIGUsIGkpIHtcXG4gICAgICAgIHZhciBuID0gdGhpcy4kc2xpZGVzLmZpbHRlcihcXFwiLmlzLWFjdGl2ZVxcXCIpLmVxKDApO2lmICgvbXVpL2cudGVzdChuWzBdLmNsYXNzTmFtZSkpIHJldHVybiAhMTt2YXIgcyxcXG4gICAgICAgICAgICBvID0gdGhpcy4kc2xpZGVzLmZpcnN0KCksXFxuICAgICAgICAgICAgYSA9IHRoaXMuJHNsaWRlcy5sYXN0KCksXFxuICAgICAgICAgICAgciA9IHQgPyBcXFwiUmlnaHRcXFwiIDogXFxcIkxlZnRcXFwiLFxcbiAgICAgICAgICAgIGwgPSB0ID8gXFxcIkxlZnRcXFwiIDogXFxcIlJpZ2h0XFxcIixcXG4gICAgICAgICAgICB1ID0gdGhpcztzID0gZSA/IGUgOiB0ID8gdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/IG4ubmV4dChcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoID8gbi5uZXh0KFxcXCIuXFxcIiArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSA6IG8gOiBuLm5leHQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpIDogdGhpcy5vcHRpb25zLmluZmluaXRlV3JhcCA/IG4ucHJldihcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMuc2xpZGVDbGFzcykubGVuZ3RoID8gbi5wcmV2KFxcXCIuXFxcIiArIHRoaXMub3B0aW9ucy5zbGlkZUNsYXNzKSA6IGEgOiBuLnByZXYoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLnNsaWRlQ2xhc3MpLCBzLmxlbmd0aCAmJiAodGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJiZWZvcmVzbGlkZWNoYW5nZS56Zi5vcmJpdFxcXCIsIFtuLCBzXSksIHRoaXMub3B0aW9ucy5idWxsZXRzICYmIChpID0gaSB8fCB0aGlzLiRzbGlkZXMuaW5kZXgocyksIHRoaXMuX3VwZGF0ZUJ1bGxldHMoaSkpLCB0aGlzLm9wdGlvbnMudXNlTVVJID8gKEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihzLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5jc3MoeyBwb3NpdGlvbjogXFxcImFic29sdXRlXFxcIiwgdG9wOiAwIH0pLCB0aGlzLm9wdGlvbnNbXFxcImFuaW1JbkZyb21cXFwiICsgcl0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgcy5jc3MoeyBwb3NpdGlvbjogXFxcInJlbGF0aXZlXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9KS5hdHRyKFxcXCJhcmlhLWxpdmVcXFwiLCBcXFwicG9saXRlXFxcIik7XFxuICAgICAgICB9KSwgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dChuLnJlbW92ZUNsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKSwgdGhpcy5vcHRpb25zW1xcXCJhbmltT3V0VG9cXFwiICsgbF0sIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgbi5yZW1vdmVBdHRyKFxcXCJhcmlhLWxpdmVcXFwiKSwgdS5vcHRpb25zLmF1dG9QbGF5ICYmICF1LnRpbWVyLmlzUGF1c2VkICYmIHUudGltZXIucmVzdGFydCgpO1xcbiAgICAgICAgfSkpIDogKG4ucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZSBpcy1pblxcXCIpLnJlbW92ZUF0dHIoXFxcImFyaWEtbGl2ZVxcXCIpLmhpZGUoKSwgcy5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlIGlzLWluXFxcIikuYXR0cihcXFwiYXJpYS1saXZlXFxcIiwgXFxcInBvbGl0ZVxcXCIpLnNob3coKSwgdGhpcy5vcHRpb25zLmF1dG9QbGF5ICYmICF0aGlzLnRpbWVyLmlzUGF1c2VkICYmIHRoaXMudGltZXIucmVzdGFydCgpKSwgdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJzbGlkZWNoYW5nZS56Zi5vcmJpdFxcXCIsIFtzXSkpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfdXBkYXRlQnVsbGV0c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB2YXIgZSA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMuYm94T2ZCdWxsZXRzKS5maW5kKFxcXCIuaXMtYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmJsdXIoKSxcXG4gICAgICAgICAgICBpID0gZS5maW5kKFxcXCJzcGFuOmxhc3RcXFwiKS5kZXRhY2goKTt0aGlzLiRidWxsZXRzLmVxKHQpLmFkZENsYXNzKFxcXCJpcy1hY3RpdmVcXFwiKS5hcHBlbmQoaSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50Lm9mZihcXFwiLnpmLm9yYml0XFxcIikuZmluZChcXFwiKlxcXCIpLm9mZihcXFwiLnpmLm9yYml0XFxcIikuZW5kKCkuaGlkZSgpLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGU7XFxuICB9KCk7ZS5kZWZhdWx0cyA9IHsgYnVsbGV0czogITAsIG5hdkJ1dHRvbnM6ICEwLCBhbmltSW5Gcm9tUmlnaHQ6IFxcXCJzbGlkZS1pbi1yaWdodFxcXCIsIGFuaW1PdXRUb1JpZ2h0OiBcXFwic2xpZGUtb3V0LXJpZ2h0XFxcIiwgYW5pbUluRnJvbUxlZnQ6IFxcXCJzbGlkZS1pbi1sZWZ0XFxcIiwgYW5pbU91dFRvTGVmdDogXFxcInNsaWRlLW91dC1sZWZ0XFxcIiwgYXV0b1BsYXk6ICEwLCB0aW1lckRlbGF5OiA1ZTMsIGluZmluaXRlV3JhcDogITAsIHN3aXBlOiAhMCwgcGF1c2VPbkhvdmVyOiAhMCwgYWNjZXNzaWJsZTogITAsIGNvbnRhaW5lckNsYXNzOiBcXFwib3JiaXQtY29udGFpbmVyXFxcIiwgc2xpZGVDbGFzczogXFxcIm9yYml0LXNsaWRlXFxcIiwgYm94T2ZCdWxsZXRzOiBcXFwib3JiaXQtYnVsbGV0c1xcXCIsIG5leHRDbGFzczogXFxcIm9yYml0LW5leHRcXFwiLCBwcmV2Q2xhc3M6IFxcXCJvcmJpdC1wcmV2aW91c1xcXCIsIHVzZU1VSTogITAgfSwgRm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIk9yYml0XFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSB0KGkpLCB0aGlzLnJ1bGVzID0gdGhpcy4kZWxlbWVudC5kYXRhKFxcXCJyZXNwb25zaXZlLW1lbnVcXFwiKSwgdGhpcy5jdXJyZW50TXEgPSBudWxsLCB0aGlzLmN1cnJlbnRQbHVnaW4gPSBudWxsLCB0aGlzLl9pbml0KCksIHRoaXMuX2V2ZW50cygpLCBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsIFxcXCJSZXNwb25zaXZlTWVudVxcXCIpO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIGlmIChcXFwic3RyaW5nXFxcIiA9PSB0eXBlb2YgdGhpcy5ydWxlcykge1xcbiAgICAgICAgICBmb3IgKHZhciBlID0ge30sIG4gPSB0aGlzLnJ1bGVzLnNwbGl0KFxcXCIgXFxcIiksIHMgPSAwOyBzIDwgbi5sZW5ndGg7IHMrKykge1xcbiAgICAgICAgICAgIHZhciBvID0gbltzXS5zcGxpdChcXFwiLVxcXCIpLFxcbiAgICAgICAgICAgICAgICBhID0gby5sZW5ndGggPiAxID8gb1swXSA6IFxcXCJzbWFsbFxcXCIsXFxuICAgICAgICAgICAgICAgIHIgPSBvLmxlbmd0aCA+IDEgPyBvWzFdIDogb1swXTtudWxsICE9PSBpW3JdICYmIChlW2FdID0gaVtyXSk7XFxuICAgICAgICAgIH10aGlzLnJ1bGVzID0gZTtcXG4gICAgICAgIH10LmlzRW1wdHlPYmplY3QodGhpcy5ydWxlcykgfHwgdGhpcy5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2V2ZW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpczt0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZS5fY2hlY2tNZWRpYVF1ZXJpZXMoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfY2hlY2tNZWRpYVF1ZXJpZXNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSxcXG4gICAgICAgICAgICBuID0gdGhpczt0LmVhY2godGhpcy5ydWxlcywgZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgICAgRm91bmRhdGlvbi5NZWRpYVF1ZXJ5LmF0TGVhc3QodCkgJiYgKGUgPSB0KTtcXG4gICAgICAgIH0pLCBlICYmICh0aGlzLmN1cnJlbnRQbHVnaW4gaW5zdGFuY2VvZiB0aGlzLnJ1bGVzW2VdLnBsdWdpbiB8fCAodC5lYWNoKGksIGZ1bmN0aW9uICh0LCBlKSB7XFxuICAgICAgICAgIG4uJGVsZW1lbnQucmVtb3ZlQ2xhc3MoZS5jc3NDbGFzcyk7XFxuICAgICAgICB9KSwgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyh0aGlzLnJ1bGVzW2VdLmNzc0NsYXNzKSwgdGhpcy5jdXJyZW50UGx1Z2luICYmIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksIHRoaXMuY3VycmVudFBsdWdpbiA9IG5ldyB0aGlzLnJ1bGVzW2VdLnBsdWdpbih0aGlzLiRlbGVtZW50LCB7fSkpKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZGVzdHJveVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuY3VycmVudFBsdWdpbi5kZXN0cm95KCksIHQod2luZG93KS5vZmYoXFxcIi56Zi5SZXNwb25zaXZlTWVudVxcXCIpLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGU7XFxuICB9KCk7ZS5kZWZhdWx0cyA9IHt9O3ZhciBpID0geyBkcm9wZG93bjogeyBjc3NDbGFzczogXFxcImRyb3Bkb3duXFxcIiwgcGx1Z2luOiBGb3VuZGF0aW9uLl9wbHVnaW5zW1xcXCJkcm9wZG93bi1tZW51XFxcIl0gfHwgbnVsbCB9LCBkcmlsbGRvd246IHsgY3NzQ2xhc3M6IFxcXCJkcmlsbGRvd25cXFwiLCBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnMuZHJpbGxkb3duIHx8IG51bGwgfSwgYWNjb3JkaW9uOiB7IGNzc0NsYXNzOiBcXFwiYWNjb3JkaW9uLW1lbnVcXFwiLCBwbHVnaW46IEZvdW5kYXRpb24uX3BsdWdpbnNbXFxcImFjY29yZGlvbi1tZW51XFxcIl0gfHwgbnVsbCB9IH07Rm91bmRhdGlvbi5wbHVnaW4oZSwgXFxcIlJlc3BvbnNpdmVNZW51XFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIHZhciBlID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSB0KGkpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIHRoaXMuX2V2ZW50cygpLCBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsIFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIik7XFxuICAgIH1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsIFt7IGtleTogXFxcIl9pbml0XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzLiRlbGVtZW50LmRhdGEoXFxcInJlc3BvbnNpdmUtdG9nZ2xlXFxcIik7ZSB8fCBjb25zb2xlLmVycm9yKFxcXCJZb3VyIHRhYiBiYXIgbmVlZHMgYW4gSUQgb2YgYSBNZW51IGFzIHRoZSB2YWx1ZSBvZiBkYXRhLXRhYi1iYXIuXFxcIiksIHRoaXMuJHRhcmdldE1lbnUgPSB0KFxcXCIjXFxcIiArIGUpLCB0aGlzLiR0b2dnbGVyID0gdGhpcy4kZWxlbWVudC5maW5kKFxcXCJbZGF0YS10b2dnbGVdXFxcIiksIHRoaXMuX3VwZGF0ZSgpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy5fdXBkYXRlTXFIYW5kbGVyID0gdGhpcy5fdXBkYXRlLmJpbmQodGhpcyksIHQod2luZG93KS5vbihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIiwgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKSwgdGhpcy4kdG9nZ2xlci5vbihcXFwiY2xpY2suemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIsIHRoaXMudG9nZ2xlTWVudS5iaW5kKHRoaXMpKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX3VwZGF0ZVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIEZvdW5kYXRpb24uTWVkaWFRdWVyeS5hdExlYXN0KHRoaXMub3B0aW9ucy5oaWRlRm9yKSA/ICh0aGlzLiRlbGVtZW50LmhpZGUoKSwgdGhpcy4kdGFyZ2V0TWVudS5zaG93KCkpIDogKHRoaXMuJGVsZW1lbnQuc2hvdygpLCB0aGlzLiR0YXJnZXRNZW51LmhpZGUoKSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcInRvZ2dsZU1lbnVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuaGlkZUZvcikgfHwgKHRoaXMuJHRhcmdldE1lbnUudG9nZ2xlKDApLCB0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInRvZ2dsZWQuemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIpKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZGVzdHJveVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQub2ZmKFxcXCIuemYucmVzcG9uc2l2ZVRvZ2dsZVxcXCIpLCB0aGlzLiR0b2dnbGVyLm9mZihcXFwiLnpmLnJlc3BvbnNpdmVUb2dnbGVcXFwiKSwgdCh3aW5kb3cpLm9mZihcXFwiY2hhbmdlZC56Zi5tZWRpYXF1ZXJ5XFxcIiwgdGhpcy5fdXBkYXRlTXFIYW5kbGVyKSwgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH0gfV0pLCBlO1xcbiAgfSgpO2UuZGVmYXVsdHMgPSB7IGhpZGVGb3I6IFxcXCJtZWRpdW1cXFwiIH0sIEZvdW5kYXRpb24ucGx1Z2luKGUsIFxcXCJSZXNwb25zaXZlVG9nZ2xlXFxcIik7XFxufShqUXVlcnkpO3ZhciBfY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiB0KHQsIGUpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgdmFyIG4gPSBlW2ldO24uZW51bWVyYWJsZSA9IG4uZW51bWVyYWJsZSB8fCAhMSwgbi5jb25maWd1cmFibGUgPSAhMCwgXFxcInZhbHVlXFxcIiBpbiBuICYmIChuLndyaXRhYmxlID0gITApLCBPYmplY3QuZGVmaW5lUHJvcGVydHkodCwgbi5rZXksIG4pO1xcbiAgICB9XFxuICB9cmV0dXJuIGZ1bmN0aW9uIChlLCBpLCBuKSB7XFxuICAgIHJldHVybiBpICYmIHQoZS5wcm90b3R5cGUsIGkpLCBuICYmIHQoZSwgbiksIGU7XFxuICB9O1xcbn0oKTshZnVuY3Rpb24gKHQpIHtcXG4gIGZ1bmN0aW9uIGUoKSB7XFxuICAgIHJldHVybiAoL2lQKGFkfGhvbmV8b2QpLipPUy8udGVzdCh3aW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudClcXG4gICAgKTtcXG4gIH1mdW5jdGlvbiBpKCkge1xcbiAgICByZXR1cm4gKC9BbmRyb2lkLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KVxcbiAgICApO1xcbiAgfWZ1bmN0aW9uIG4oKSB7XFxuICAgIHJldHVybiBlKCkgfHwgaSgpO1xcbiAgfXZhciBzID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBlKGksIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgZSksIHRoaXMuJGVsZW1lbnQgPSBpLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgZS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIlJldmVhbFxcXCIpLCBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJSZXZlYWxcXFwiLCB7IEVOVEVSOiBcXFwib3BlblxcXCIsIFNQQUNFOiBcXFwib3BlblxcXCIsIEVTQ0FQRTogXFxcImNsb3NlXFxcIiwgVEFCOiBcXFwidGFiX2ZvcndhcmRcXFwiLCBTSElGVF9UQUI6IFxcXCJ0YWJfYmFja3dhcmRcXFwiIH0pO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuaWQgPSB0aGlzLiRlbGVtZW50LmF0dHIoXFxcImlkXFxcIiksIHRoaXMuaXNBY3RpdmUgPSAhMSwgdGhpcy5jYWNoZWQgPSB7IG1xOiBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuY3VycmVudCB9LCB0aGlzLmlzTW9iaWxlID0gbigpLCB0aGlzLiRhbmNob3IgPSB0KHQoJ1tkYXRhLW9wZW49XFxcIicgKyB0aGlzLmlkICsgJ1xcXCJdJykubGVuZ3RoID8gJ1tkYXRhLW9wZW49XFxcIicgKyB0aGlzLmlkICsgJ1xcXCJdJyA6ICdbZGF0YS10b2dnbGU9XFxcIicgKyB0aGlzLmlkICsgJ1xcXCJdJyksIHRoaXMuJGFuY2hvci5hdHRyKHsgXFxcImFyaWEtY29udHJvbHNcXFwiOiB0aGlzLmlkLCBcXFwiYXJpYS1oYXNwb3B1cFxcXCI6ICEwLCB0YWJpbmRleDogMCB9KSwgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3MoXFxcImZ1bGxcXFwiKSkgJiYgKHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuID0gITAsIHRoaXMub3B0aW9ucy5vdmVybGF5ID0gITEpLCB0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiAhdGhpcy4kb3ZlcmxheSAmJiAodGhpcy4kb3ZlcmxheSA9IHRoaXMuX21ha2VPdmVybGF5KHRoaXMuaWQpKSwgdGhpcy4kZWxlbWVudC5hdHRyKHsgcm9sZTogXFxcImRpYWxvZ1xcXCIsIFxcXCJhcmlhLWhpZGRlblxcXCI6ICEwLCBcXFwiZGF0YS15ZXRpLWJveFxcXCI6IHRoaXMuaWQsIFxcXCJkYXRhLXJlc2l6ZVxcXCI6IHRoaXMuaWQgfSksIHRoaXMuJG92ZXJsYXkgPyB0aGlzLiRlbGVtZW50LmRldGFjaCgpLmFwcGVuZFRvKHRoaXMuJG92ZXJsYXkpIDogKHRoaXMuJGVsZW1lbnQuZGV0YWNoKCkuYXBwZW5kVG8odChcXFwiYm9keVxcXCIpKSwgdGhpcy4kZWxlbWVudC5hZGRDbGFzcyhcXFwid2l0aG91dC1vdmVybGF5XFxcIikpLCB0aGlzLl9ldmVudHMoKSwgdGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHdpbmRvdy5sb2NhdGlvbi5oYXNoID09PSBcXFwiI1xcXCIgKyB0aGlzLmlkICYmIHQod2luZG93KS5vbmUoXFxcImxvYWQuemYucmV2ZWFsXFxcIiwgdGhpcy5vcGVuLmJpbmQodGhpcykpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfbWFrZU92ZXJsYXlcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xcbiAgICAgICAgdmFyIGkgPSB0KFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFkZENsYXNzKFxcXCJyZXZlYWwtb3ZlcmxheVxcXCIpLmFwcGVuZFRvKFxcXCJib2R5XFxcIik7cmV0dXJuIGk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl91cGRhdGVQb3NpdGlvblxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlLFxcbiAgICAgICAgICAgIGksXFxuICAgICAgICAgICAgbiA9IHRoaXMuJGVsZW1lbnQub3V0ZXJXaWR0aCgpLFxcbiAgICAgICAgICAgIHMgPSB0KHdpbmRvdykud2lkdGgoKSxcXG4gICAgICAgICAgICBvID0gdGhpcy4kZWxlbWVudC5vdXRlckhlaWdodCgpLFxcbiAgICAgICAgICAgIGEgPSB0KHdpbmRvdykuaGVpZ2h0KCk7ZSA9IFxcXCJhdXRvXFxcIiA9PT0gdGhpcy5vcHRpb25zLmhPZmZzZXQgPyBwYXJzZUludCgocyAtIG4pIC8gMiwgMTApIDogcGFyc2VJbnQodGhpcy5vcHRpb25zLmhPZmZzZXQsIDEwKSwgaSA9IFxcXCJhdXRvXFxcIiA9PT0gdGhpcy5vcHRpb25zLnZPZmZzZXQgPyBvID4gYSA/IHBhcnNlSW50KE1hdGgubWluKDEwMCwgYSAvIDEwKSwgMTApIDogcGFyc2VJbnQoKGEgLSBvKSAvIDQsIDEwKSA6IHBhcnNlSW50KHRoaXMub3B0aW9ucy52T2Zmc2V0LCAxMCksIHRoaXMuJGVsZW1lbnQuY3NzKHsgdG9wOiBpICsgXFxcInB4XFxcIiB9KSwgdGhpcy4kb3ZlcmxheSAmJiBcXFwiYXV0b1xcXCIgPT09IHRoaXMub3B0aW9ucy5oT2Zmc2V0IHx8ICh0aGlzLiRlbGVtZW50LmNzcyh7IGxlZnQ6IGUgKyBcXFwicHhcXFwiIH0pLCB0aGlzLiRlbGVtZW50LmNzcyh7IG1hcmdpbjogXFxcIjBweFxcXCIgfSkpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzLFxcbiAgICAgICAgICAgIGkgPSB0aGlzO3RoaXMuJGVsZW1lbnQub24oeyBcXFwib3Blbi56Zi50cmlnZ2VyXFxcIjogdGhpcy5vcGVuLmJpbmQodGhpcyksIFxcXCJjbG9zZS56Zi50cmlnZ2VyXFxcIjogZnVuY3Rpb24gY2xvc2VaZlRyaWdnZXIobiwgcykge1xcbiAgICAgICAgICAgIGlmIChuLnRhcmdldCA9PT0gaS4kZWxlbWVudFswXSB8fCB0KG4udGFyZ2V0KS5wYXJlbnRzKFxcXCJbZGF0YS1jbG9zYWJsZV1cXFwiKVswXSA9PT0gcykgcmV0dXJuIGUuY2xvc2UuYXBwbHkoZSk7XFxuICAgICAgICAgIH0sIFxcXCJ0b2dnbGUuemYudHJpZ2dlclxcXCI6IHRoaXMudG9nZ2xlLmJpbmQodGhpcyksIFxcXCJyZXNpemVtZS56Zi50cmlnZ2VyXFxcIjogZnVuY3Rpb24gcmVzaXplbWVaZlRyaWdnZXIoKSB7XFxuICAgICAgICAgICAgaS5fdXBkYXRlUG9zaXRpb24oKTtcXG4gICAgICAgICAgfSB9KSwgdGhpcy4kYW5jaG9yLmxlbmd0aCAmJiB0aGlzLiRhbmNob3Iub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIiwgZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgICAgMTMgIT09IHQud2hpY2ggJiYgMzIgIT09IHQud2hpY2ggfHwgKHQuc3RvcFByb3BhZ2F0aW9uKCksIHQucHJldmVudERlZmF1bHQoKSwgaS5vcGVuKCkpO1xcbiAgICAgICAgfSksIHRoaXMub3B0aW9ucy5jbG9zZU9uQ2xpY2sgJiYgdGhpcy5vcHRpb25zLm92ZXJsYXkgJiYgdGhpcy4kb3ZlcmxheS5vZmYoXFxcIi56Zi5yZXZlYWxcXFwiKS5vbihcXFwiY2xpY2suemYucmV2ZWFsXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS50YXJnZXQgIT09IGkuJGVsZW1lbnRbMF0gJiYgIXQuY29udGFpbnMoaS4kZWxlbWVudFswXSwgZS50YXJnZXQpICYmIHQuY29udGFpbnMoZG9jdW1lbnQsIGUudGFyZ2V0KSAmJiBpLmNsb3NlKCk7XFxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmRlZXBMaW5rICYmIHQod2luZG93KS5vbihcXFwicG9wc3RhdGUuemYucmV2ZWFsOlxcXCIgKyB0aGlzLmlkLCB0aGlzLl9oYW5kbGVTdGF0ZS5iaW5kKHRoaXMpKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2hhbmRsZVN0YXRlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoICE9PSBcXFwiI1xcXCIgKyB0aGlzLmlkIHx8IHRoaXMuaXNBY3RpdmUgPyB0aGlzLmNsb3NlKCkgOiB0aGlzLm9wZW4oKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwib3BlblxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcztpZiAodGhpcy5vcHRpb25zLmRlZXBMaW5rKSB7XFxuICAgICAgICAgIHZhciBpID0gXFxcIiNcXFwiICsgdGhpcy5pZDt3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUgPyB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaSkgOiB3aW5kb3cubG9jYXRpb24uaGFzaCA9IGk7XFxuICAgICAgICB9aWYgKHRoaXMuaXNBY3RpdmUgPSAhMCwgdGhpcy4kZWxlbWVudC5jc3MoeyB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiB9KS5zaG93KCkuc2Nyb2xsVG9wKDApLCB0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLiRvdmVybGF5LmNzcyh7IHZpc2liaWxpdHk6IFxcXCJoaWRkZW5cXFwiIH0pLnNob3coKSwgdGhpcy5fdXBkYXRlUG9zaXRpb24oKSwgdGhpcy4kZWxlbWVudC5oaWRlKCkuY3NzKHsgdmlzaWJpbGl0eTogXFxcIlxcXCIgfSksIHRoaXMuJG92ZXJsYXkgJiYgKHRoaXMuJG92ZXJsYXkuY3NzKHsgdmlzaWJpbGl0eTogXFxcIlxcXCIgfSkuaGlkZSgpLCB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJmYXN0XFxcIikgPyB0aGlzLiRvdmVybGF5LmFkZENsYXNzKFxcXCJmYXN0XFxcIikgOiB0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJzbG93XFxcIikgJiYgdGhpcy4kb3ZlcmxheS5hZGRDbGFzcyhcXFwic2xvd1xcXCIpKSwgdGhpcy5vcHRpb25zLm11bHRpcGxlT3BlbmVkIHx8IHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi5yZXZlYWxcXFwiLCB0aGlzLmlkKSwgdGhpcy5vcHRpb25zLmFuaW1hdGlvbkluKSB7XFxuICAgICAgICAgIHZhciBuOyFmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdmFyIHQgPSBmdW5jdGlvbiB0KCkge1xcbiAgICAgICAgICAgICAgbi4kZWxlbWVudC5hdHRyKHsgXFxcImFyaWEtaGlkZGVuXFxcIjogITEsIHRhYmluZGV4OiAtMSB9KS5mb2N1cygpO1xcbiAgICAgICAgICAgIH07biA9IGUsIGUub3B0aW9ucy5vdmVybGF5ICYmIEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVJbihlLiRvdmVybGF5LCBcXFwiZmFkZS1pblxcXCIpLCBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4oZS4kZWxlbWVudCwgZS5vcHRpb25zLmFuaW1hdGlvbkluLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgICBlLmZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpLCB0KCk7XFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgIH0oKTtcXG4gICAgICAgIH0gZWxzZSB0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLiRvdmVybGF5LnNob3coMCksIHRoaXMuJGVsZW1lbnQuc2hvdyh0aGlzLm9wdGlvbnMuc2hvd0RlbGF5KTt0aGlzLiRlbGVtZW50LmF0dHIoeyBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhMSwgdGFiaW5kZXg6IC0xIH0pLmZvY3VzKCksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib3Blbi56Zi5yZXZlYWxcXFwiKSwgdGhpcy5pc01vYmlsZSA/ICh0aGlzLm9yaWdpbmFsU2Nyb2xsUG9zID0gd2luZG93LnBhZ2VZT2Zmc2V0LCB0KFxcXCJodG1sLCBib2R5XFxcIikuYWRkQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIikpIDogdChcXFwiYm9keVxcXCIpLmFkZENsYXNzKFxcXCJpcy1yZXZlYWwtb3BlblxcXCIpLCBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZS5fZXh0cmFIYW5kbGVycygpO1xcbiAgICAgICAgfSwgMCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9leHRyYUhhbmRsZXJzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMuZm9jdXNhYmxlRWxlbWVudHMgPSBGb3VuZGF0aW9uLktleWJvYXJkLmZpbmRGb2N1c2FibGUodGhpcy4kZWxlbWVudCksIHRoaXMub3B0aW9ucy5vdmVybGF5IHx8ICF0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIHx8IHRoaXMub3B0aW9ucy5mdWxsU2NyZWVuIHx8IHQoXFxcImJvZHlcXFwiKS5vbihcXFwiY2xpY2suemYucmV2ZWFsXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgaS50YXJnZXQgIT09IGUuJGVsZW1lbnRbMF0gJiYgIXQuY29udGFpbnMoZS4kZWxlbWVudFswXSwgaS50YXJnZXQpICYmIHQuY29udGFpbnMoZG9jdW1lbnQsIGkudGFyZ2V0KSAmJiBlLmNsb3NlKCk7XFxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmNsb3NlT25Fc2MgJiYgdCh3aW5kb3cpLm9uKFxcXCJrZXlkb3duLnpmLnJldmVhbFxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgIEZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KHQsIFxcXCJSZXZlYWxcXFwiLCB7IGNsb3NlOiBmdW5jdGlvbiBjbG9zZSgpIHtcXG4gICAgICAgICAgICAgIGUub3B0aW9ucy5jbG9zZU9uRXNjICYmIChlLmNsb3NlKCksIGUuJGFuY2hvci5mb2N1cygpKTtcXG4gICAgICAgICAgICB9IH0pO1xcbiAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQub24oXFxcImtleWRvd24uemYucmV2ZWFsXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgdmFyIG4gPSB0KHRoaXMpO0ZvdW5kYXRpb24uS2V5Ym9hcmQuaGFuZGxlS2V5KGksIFxcXCJSZXZlYWxcXFwiLCB7IHRhYl9mb3J3YXJkOiBmdW5jdGlvbiB0YWJfZm9yd2FyZCgpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBlLmZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpLCBlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpKSA/IChlLmZvY3VzYWJsZUVsZW1lbnRzLmVxKDApLmZvY3VzKCksICEwKSA6IDAgPT09IGUuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIHx8IHZvaWQgMDtcXG4gICAgICAgICAgICB9LCB0YWJfYmFja3dhcmQ6IGZ1bmN0aW9uIHRhYl9iYWNrd2FyZCgpIHtcXG4gICAgICAgICAgICAgIHJldHVybiBlLmZvY3VzYWJsZUVsZW1lbnRzID0gRm91bmRhdGlvbi5LZXlib2FyZC5maW5kRm9jdXNhYmxlKGUuJGVsZW1lbnQpLCBlLiRlbGVtZW50LmZpbmQoXFxcIjpmb2N1c1xcXCIpLmlzKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoMCkpIHx8IGUuJGVsZW1lbnQuaXMoXFxcIjpmb2N1c1xcXCIpID8gKGUuZm9jdXNhYmxlRWxlbWVudHMuZXEoLTEpLmZvY3VzKCksICEwKSA6IDAgPT09IGUuZm9jdXNhYmxlRWxlbWVudHMubGVuZ3RoIHx8IHZvaWQgMDtcXG4gICAgICAgICAgICB9LCBvcGVuOiBmdW5jdGlvbiBvcGVuKCkge1xcbiAgICAgICAgICAgICAgZS4kZWxlbWVudC5maW5kKFxcXCI6Zm9jdXNcXFwiKS5pcyhlLiRlbGVtZW50LmZpbmQoXFxcIltkYXRhLWNsb3NlXVxcXCIpKSA/IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgICAgICBlLiRhbmNob3IuZm9jdXMoKTtcXG4gICAgICAgICAgICAgIH0sIDEpIDogbi5pcyhlLmZvY3VzYWJsZUVsZW1lbnRzKSAmJiBlLm9wZW4oKTtcXG4gICAgICAgICAgICB9LCBjbG9zZTogZnVuY3Rpb24gY2xvc2UoKSB7XFxuICAgICAgICAgICAgICBlLm9wdGlvbnMuY2xvc2VPbkVzYyAmJiAoZS5jbG9zZSgpLCBlLiRhbmNob3IuZm9jdXMoKSk7XFxuICAgICAgICAgICAgfSwgaGFuZGxlZDogZnVuY3Rpb24gaGFuZGxlZCh0KSB7XFxuICAgICAgICAgICAgICB0ICYmIGkucHJldmVudERlZmF1bHQoKTtcXG4gICAgICAgICAgICB9IH0pO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImNsb3NlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgZnVuY3Rpb24gZSgpIHtcXG4gICAgICAgICAgaS5pc01vYmlsZSA/ICh0KFxcXCJodG1sLCBib2R5XFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIiksIGkub3JpZ2luYWxTY3JvbGxQb3MgJiYgKHQoXFxcImJvZHlcXFwiKS5zY3JvbGxUb3AoaS5vcmlnaW5hbFNjcm9sbFBvcyksIGkub3JpZ2luYWxTY3JvbGxQb3MgPSBudWxsKSkgOiB0KFxcXCJib2R5XFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLXJldmVhbC1vcGVuXFxcIiksIGkuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1oaWRkZW5cXFwiLCAhMCksIGkuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VkLnpmLnJldmVhbFxcXCIpO1xcbiAgICAgICAgfWlmICghdGhpcy5pc0FjdGl2ZSB8fCAhdGhpcy4kZWxlbWVudC5pcyhcXFwiOnZpc2libGVcXFwiKSkgcmV0dXJuICExO3ZhciBpID0gdGhpczt0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0ID8gKHRoaXMub3B0aW9ucy5vdmVybGF5ID8gRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRvdmVybGF5LCBcXFwiZmFkZS1vdXRcXFwiLCBlKSA6IGUoKSwgRm91bmRhdGlvbi5Nb3Rpb24uYW5pbWF0ZU91dCh0aGlzLiRlbGVtZW50LCB0aGlzLm9wdGlvbnMuYW5pbWF0aW9uT3V0KSkgOiAodGhpcy5vcHRpb25zLm92ZXJsYXkgPyB0aGlzLiRvdmVybGF5LmhpZGUoMCwgZSkgOiBlKCksIHRoaXMuJGVsZW1lbnQuaGlkZSh0aGlzLm9wdGlvbnMuaGlkZURlbGF5KSksIHRoaXMub3B0aW9ucy5jbG9zZU9uRXNjICYmIHQod2luZG93KS5vZmYoXFxcImtleWRvd24uemYucmV2ZWFsXFxcIiksICF0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrICYmIHQoXFxcImJvZHlcXFwiKS5vZmYoXFxcImNsaWNrLnpmLnJldmVhbFxcXCIpLCB0aGlzLiRlbGVtZW50Lm9mZihcXFwia2V5ZG93bi56Zi5yZXZlYWxcXFwiKSwgdGhpcy5vcHRpb25zLnJlc2V0T25DbG9zZSAmJiB0aGlzLiRlbGVtZW50Lmh0bWwodGhpcy4kZWxlbWVudC5odG1sKCkpLCB0aGlzLmlzQWN0aXZlID0gITEsIGkub3B0aW9ucy5kZWVwTGluayAmJiAod2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlID8gd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKFxcXCJcXFwiLCBkb2N1bWVudC50aXRsZSwgd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lKSA6IHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gXFxcIlxcXCIpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJ0b2dnbGVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLmlzQWN0aXZlID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLm9wdGlvbnMub3ZlcmxheSAmJiAodGhpcy4kZWxlbWVudC5hcHBlbmRUbyh0KFxcXCJib2R5XFxcIikpLCB0aGlzLiRvdmVybGF5LmhpZGUoKS5vZmYoKS5yZW1vdmUoKSksIHRoaXMuJGVsZW1lbnQuaGlkZSgpLm9mZigpLCB0aGlzLiRhbmNob3Iub2ZmKFxcXCIuemZcXFwiKSwgdCh3aW5kb3cpLm9mZihcXFwiLnpmLnJldmVhbDpcXFwiICsgdGhpcy5pZCksIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9IH1dKSwgZTtcXG4gIH0oKTtzLmRlZmF1bHRzID0geyBhbmltYXRpb25JbjogXFxcIlxcXCIsIGFuaW1hdGlvbk91dDogXFxcIlxcXCIsIHNob3dEZWxheTogMCwgaGlkZURlbGF5OiAwLCBjbG9zZU9uQ2xpY2s6ICEwLCBjbG9zZU9uRXNjOiAhMCwgbXVsdGlwbGVPcGVuZWQ6ICExLCB2T2Zmc2V0OiBcXFwiYXV0b1xcXCIsIGhPZmZzZXQ6IFxcXCJhdXRvXFxcIiwgZnVsbFNjcmVlbjogITEsIGJ0bU9mZnNldFBjdDogMTAsIG92ZXJsYXk6ICEwLCByZXNldE9uQ2xvc2U6ICExLCBkZWVwTGluazogITEgfSwgRm91bmRhdGlvbi5wbHVnaW4ocywgXFxcIlJldmVhbFxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICBmdW5jdGlvbiBlKHQsIGUpIHtcXG4gICAgcmV0dXJuIHQgLyBlO1xcbiAgfWZ1bmN0aW9uIGkodCwgZSwgaSwgbikge1xcbiAgICByZXR1cm4gTWF0aC5hYnModC5wb3NpdGlvbigpW2VdICsgdFtuXSgpIC8gMiAtIGkpO1xcbiAgfXZhciBuID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBuKGUsIGkpIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgbiksIHRoaXMuJGVsZW1lbnQgPSBlLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgbi5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIGkpLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIlNsaWRlclxcXCIpLCBGb3VuZGF0aW9uLktleWJvYXJkLnJlZ2lzdGVyKFxcXCJTbGlkZXJcXFwiLCB7IGx0cjogeyBBUlJPV19SSUdIVDogXFxcImluY3JlYXNlXFxcIiwgQVJST1dfVVA6IFxcXCJpbmNyZWFzZVxcXCIsIEFSUk9XX0RPV046IFxcXCJkZWNyZWFzZVxcXCIsIEFSUk9XX0xFRlQ6IFxcXCJkZWNyZWFzZVxcXCIsIFNISUZUX0FSUk9XX1JJR0hUOiBcXFwiaW5jcmVhc2VfZmFzdFxcXCIsIFNISUZUX0FSUk9XX1VQOiBcXFwiaW5jcmVhc2VfZmFzdFxcXCIsIFNISUZUX0FSUk9XX0RPV046IFxcXCJkZWNyZWFzZV9mYXN0XFxcIiwgU0hJRlRfQVJST1dfTEVGVDogXFxcImRlY3JlYXNlX2Zhc3RcXFwiIH0sIHJ0bDogeyBBUlJPV19MRUZUOiBcXFwiaW5jcmVhc2VcXFwiLCBBUlJPV19SSUdIVDogXFxcImRlY3JlYXNlXFxcIiwgU0hJRlRfQVJST1dfTEVGVDogXFxcImluY3JlYXNlX2Zhc3RcXFwiLCBTSElGVF9BUlJPV19SSUdIVDogXFxcImRlY3JlYXNlX2Zhc3RcXFwiIH0gfSk7XFxuICAgIH1yZXR1cm4gX2NyZWF0ZUNsYXNzKG4sIFt7IGtleTogXFxcIl9pbml0XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy5pbnB1dHMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcImlucHV0XFxcIiksIHRoaXMuaGFuZGxlcyA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc2xpZGVyLWhhbmRsZV1cXFwiKSwgdGhpcy4kaGFuZGxlID0gdGhpcy5oYW5kbGVzLmVxKDApLCB0aGlzLiRpbnB1dCA9IHRoaXMuaW5wdXRzLmxlbmd0aCA/IHRoaXMuaW5wdXRzLmVxKDApIDogdChcXFwiI1xcXCIgKyB0aGlzLiRoYW5kbGUuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKSwgdGhpcy4kZmlsbCA9IHRoaXMuJGVsZW1lbnQuZmluZChcXFwiW2RhdGEtc2xpZGVyLWZpbGxdXFxcIikuY3NzKHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/IFxcXCJoZWlnaHRcXFwiIDogXFxcIndpZHRoXFxcIiwgMCk7dmFyIGUgPSAhMSxcXG4gICAgICAgICAgICBpID0gdGhpczsodGhpcy5vcHRpb25zLmRpc2FibGVkIHx8IHRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSAmJiAodGhpcy5vcHRpb25zLmRpc2FibGVkID0gITAsIHRoaXMuJGVsZW1lbnQuYWRkQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSwgdGhpcy5pbnB1dHMubGVuZ3RoIHx8ICh0aGlzLmlucHV0cyA9IHQoKS5hZGQodGhpcy4kaW5wdXQpLCB0aGlzLm9wdGlvbnMuYmluZGluZyA9ICEwKSwgdGhpcy5fc2V0SW5pdEF0dHIoMCksIHRoaXMuX2V2ZW50cyh0aGlzLiRoYW5kbGUpLCB0aGlzLmhhbmRsZXNbMV0gJiYgKHRoaXMub3B0aW9ucy5kb3VibGVTaWRlZCA9ICEwLCB0aGlzLiRoYW5kbGUyID0gdGhpcy5oYW5kbGVzLmVxKDEpLCB0aGlzLiRpbnB1dDIgPSB0aGlzLmlucHV0cy5sZW5ndGggPiAxID8gdGhpcy5pbnB1dHMuZXEoMSkgOiB0KFxcXCIjXFxcIiArIHRoaXMuJGhhbmRsZTIuYXR0cihcXFwiYXJpYS1jb250cm9sc1xcXCIpKSwgdGhpcy5pbnB1dHNbMV0gfHwgKHRoaXMuaW5wdXRzID0gdGhpcy5pbnB1dHMuYWRkKHRoaXMuJGlucHV0MikpLCBlID0gITAsIHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsICEwLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIGkuX3NldEhhbmRsZVBvcyhpLiRoYW5kbGUyLCBpLm9wdGlvbnMuaW5pdGlhbEVuZCwgITApO1xcbiAgICAgICAgfSksIHRoaXMuX3NldEluaXRBdHRyKDEpLCB0aGlzLl9ldmVudHModGhpcy4kaGFuZGxlMikpLCBlIHx8IHRoaXMuX3NldEhhbmRsZVBvcyh0aGlzLiRoYW5kbGUsIHRoaXMub3B0aW9ucy5pbml0aWFsU3RhcnQsICEwKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX3NldEhhbmRsZVBvc1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0LCBpLCBuLCBzKSB7XFxuICAgICAgICBpZiAoIXRoaXMuJGVsZW1lbnQuaGFzQ2xhc3ModGhpcy5vcHRpb25zLmRpc2FibGVkQ2xhc3MpKSB7XFxuICAgICAgICAgIGkgPSBwYXJzZUZsb2F0KGkpLCBpIDwgdGhpcy5vcHRpb25zLnN0YXJ0ID8gaSA9IHRoaXMub3B0aW9ucy5zdGFydCA6IGkgPiB0aGlzLm9wdGlvbnMuZW5kICYmIChpID0gdGhpcy5vcHRpb25zLmVuZCk7dmFyIG8gPSB0aGlzLm9wdGlvbnMuZG91YmxlU2lkZWQ7aWYgKG8pIGlmICgwID09PSB0aGlzLmhhbmRsZXMuaW5kZXgodCkpIHtcXG4gICAgICAgICAgICB2YXIgYSA9IHBhcnNlRmxvYXQodGhpcy4kaGFuZGxlMi5hdHRyKFxcXCJhcmlhLXZhbHVlbm93XFxcIikpO2kgPSBpID49IGEgPyBhIC0gdGhpcy5vcHRpb25zLnN0ZXAgOiBpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHZhciByID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpKTtpID0gaSA8PSByID8gciArIHRoaXMub3B0aW9ucy5zdGVwIDogaTtcXG4gICAgICAgICAgfXRoaXMub3B0aW9ucy52ZXJ0aWNhbCAmJiAhbiAmJiAoaSA9IHRoaXMub3B0aW9ucy5lbmQgLSBpKTt2YXIgbCA9IHRoaXMsXFxuICAgICAgICAgICAgICB1ID0gdGhpcy5vcHRpb25zLnZlcnRpY2FsLFxcbiAgICAgICAgICAgICAgZCA9IHUgPyBcXFwiaGVpZ2h0XFxcIiA6IFxcXCJ3aWR0aFxcXCIsXFxuICAgICAgICAgICAgICBoID0gdSA/IFxcXCJ0b3BcXFwiIDogXFxcImxlZnRcXFwiLFxcbiAgICAgICAgICAgICAgYyA9IHRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0sXFxuICAgICAgICAgICAgICBmID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSxcXG4gICAgICAgICAgICAgIHAgPSBlKGkgLSB0aGlzLm9wdGlvbnMuc3RhcnQsIHRoaXMub3B0aW9ucy5lbmQgLSB0aGlzLm9wdGlvbnMuc3RhcnQpLnRvRml4ZWQoMiksXFxuICAgICAgICAgICAgICBtID0gKGYgLSBjKSAqIHAsXFxuICAgICAgICAgICAgICB2ID0gKDEwMCAqIGUobSwgZikpLnRvRml4ZWQodGhpcy5vcHRpb25zLmRlY2ltYWwpO2kgPSBwYXJzZUZsb2F0KGkudG9GaXhlZCh0aGlzLm9wdGlvbnMuZGVjaW1hbCkpO3ZhciBnID0ge307aWYgKHRoaXMuX3NldFZhbHVlcyh0LCBpKSwgbykge1xcbiAgICAgICAgICAgIHZhciB3LFxcbiAgICAgICAgICAgICAgICB5ID0gMCA9PT0gdGhpcy5oYW5kbGVzLmluZGV4KHQpLFxcbiAgICAgICAgICAgICAgICBiID0gfn4oMTAwICogZShjLCBmKSk7aWYgKHkpIGdbaF0gPSB2ICsgXFxcIiVcXFwiLCB3ID0gcGFyc2VGbG9hdCh0aGlzLiRoYW5kbGUyWzBdLnN0eWxlW2hdKSAtIHYgKyBiLCBzICYmIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIHMgJiYgcygpO2Vsc2Uge1xcbiAgICAgICAgICAgICAgdmFyICQgPSBwYXJzZUZsb2F0KHRoaXMuJGhhbmRsZVswXS5zdHlsZVtoXSk7dyA9IHYgLSAoaXNOYU4oJCkgPyB0aGlzLm9wdGlvbnMuaW5pdGlhbFN0YXJ0IC8gKCh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAvIDEwMCkgOiAkKSArIGI7XFxuICAgICAgICAgICAgfWdbXFxcIm1pbi1cXFwiICsgZF0gPSB3ICsgXFxcIiVcXFwiO1xcbiAgICAgICAgICB9dGhpcy4kZWxlbWVudC5vbmUoXFxcImZpbmlzaGVkLnpmLmFuaW1hdGVcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbC4kZWxlbWVudC50cmlnZ2VyKFxcXCJtb3ZlZC56Zi5zbGlkZXJcXFwiLCBbdF0pO1xcbiAgICAgICAgICB9KTt2YXIgQyA9IHRoaXMuJGVsZW1lbnQuZGF0YShcXFwiZHJhZ2dpbmdcXFwiKSA/IDFlMyAvIDYwIDogdGhpcy5vcHRpb25zLm1vdmVUaW1lO0ZvdW5kYXRpb24uTW92ZShDLCB0LCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgdC5jc3MoaCwgdiArIFxcXCIlXFxcIiksIGwub3B0aW9ucy5kb3VibGVTaWRlZCA/IGwuJGZpbGwuY3NzKGcpIDogbC4kZmlsbC5jc3MoZCwgMTAwICogcCArIFxcXCIlXFxcIik7XFxuICAgICAgICAgIH0pLCBjbGVhclRpbWVvdXQobC50aW1lb3V0KSwgbC50aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbC4kZWxlbWVudC50cmlnZ2VyKFxcXCJjaGFuZ2VkLnpmLnNsaWRlclxcXCIsIFt0XSk7XFxuICAgICAgICAgIH0sIGwub3B0aW9ucy5jaGFuZ2VkRGVsYXkpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2V0SW5pdEF0dHJcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzLmlucHV0cy5lcSh0KS5hdHRyKFxcXCJpZFxcXCIpIHx8IEZvdW5kYXRpb24uR2V0WW9EaWdpdHMoNiwgXFxcInNsaWRlclxcXCIpO3RoaXMuaW5wdXRzLmVxKHQpLmF0dHIoeyBpZDogZSwgbWF4OiB0aGlzLm9wdGlvbnMuZW5kLCBtaW46IHRoaXMub3B0aW9ucy5zdGFydCwgc3RlcDogdGhpcy5vcHRpb25zLnN0ZXAgfSksIHRoaXMuaGFuZGxlcy5lcSh0KS5hdHRyKHsgcm9sZTogXFxcInNsaWRlclxcXCIsIFxcXCJhcmlhLWNvbnRyb2xzXFxcIjogZSwgXFxcImFyaWEtdmFsdWVtYXhcXFwiOiB0aGlzLm9wdGlvbnMuZW5kLCBcXFwiYXJpYS12YWx1ZW1pblxcXCI6IHRoaXMub3B0aW9ucy5zdGFydCwgXFxcImFyaWEtdmFsdWVub3dcXFwiOiAwID09PSB0ID8gdGhpcy5vcHRpb25zLmluaXRpYWxTdGFydCA6IHRoaXMub3B0aW9ucy5pbml0aWFsRW5kLCBcXFwiYXJpYS1vcmllbnRhdGlvblxcXCI6IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCA/IFxcXCJ2ZXJ0aWNhbFxcXCIgOiBcXFwiaG9yaXpvbnRhbFxcXCIsIHRhYmluZGV4OiAwIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2V0VmFsdWVzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIGUpIHtcXG4gICAgICAgIHZhciBpID0gdGhpcy5vcHRpb25zLmRvdWJsZVNpZGVkID8gdGhpcy5oYW5kbGVzLmluZGV4KHQpIDogMDt0aGlzLmlucHV0cy5lcShpKS52YWwoZSksIHQuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIsIGUpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfaGFuZGxlRXZlbnRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUobiwgcywgbykge1xcbiAgICAgICAgdmFyIGEsIHI7aWYgKG8pIGEgPSB0aGlzLl9hZGp1c3RWYWx1ZShudWxsLCBvKSwgciA9ICEwO2Vsc2Uge1xcbiAgICAgICAgICBuLnByZXZlbnREZWZhdWx0KCk7dmFyIGwgPSB0aGlzLFxcbiAgICAgICAgICAgICAgdSA9IHRoaXMub3B0aW9ucy52ZXJ0aWNhbCxcXG4gICAgICAgICAgICAgIGQgPSB1ID8gXFxcImhlaWdodFxcXCIgOiBcXFwid2lkdGhcXFwiLFxcbiAgICAgICAgICAgICAgaCA9IHUgPyBcXFwidG9wXFxcIiA6IFxcXCJsZWZ0XFxcIixcXG4gICAgICAgICAgICAgIGMgPSB1ID8gbi5wYWdlWSA6IG4ucGFnZVgsXFxuICAgICAgICAgICAgICBmID0gKHRoaXMuJGhhbmRsZVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkXSAvIDIsIHRoaXMuJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbZF0pLFxcbiAgICAgICAgICAgICAgcCA9IHUgPyB0KHdpbmRvdykuc2Nyb2xsVG9wKCkgOiB0KHdpbmRvdykuc2Nyb2xsTGVmdCgpLFxcbiAgICAgICAgICAgICAgbSA9IHRoaXMuJGVsZW1lbnQub2Zmc2V0KClbaF07bi5jbGllbnRZID09PSBuLnBhZ2VZICYmIChjICs9IHApO3ZhciB2LFxcbiAgICAgICAgICAgICAgZyA9IGMgLSBtO3YgPSBnIDwgMCA/IDAgOiBnID4gZiA/IGYgOiBnO3ZhciB3ID0gZSh2LCBmKTtpZiAoYSA9ICh0aGlzLm9wdGlvbnMuZW5kIC0gdGhpcy5vcHRpb25zLnN0YXJ0KSAqIHcgKyB0aGlzLm9wdGlvbnMuc3RhcnQsIEZvdW5kYXRpb24ucnRsKCkgJiYgIXRoaXMub3B0aW9ucy52ZXJ0aWNhbCAmJiAoYSA9IHRoaXMub3B0aW9ucy5lbmQgLSBhKSwgYSA9IGwuX2FkanVzdFZhbHVlKG51bGwsIGEpLCByID0gITEsICFzKSB7XFxuICAgICAgICAgICAgdmFyIHkgPSBpKHRoaXMuJGhhbmRsZSwgaCwgdiwgZCksXFxuICAgICAgICAgICAgICAgIGIgPSBpKHRoaXMuJGhhbmRsZTIsIGgsIHYsIGQpO3MgPSB5IDw9IGIgPyB0aGlzLiRoYW5kbGUgOiB0aGlzLiRoYW5kbGUyO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9dGhpcy5fc2V0SGFuZGxlUG9zKHMsIGEsIHIpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfYWRqdXN0VmFsdWVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCwgZSkge1xcbiAgICAgICAgdmFyIGksXFxuICAgICAgICAgICAgbixcXG4gICAgICAgICAgICBzLFxcbiAgICAgICAgICAgIG8sXFxuICAgICAgICAgICAgYSA9IHRoaXMub3B0aW9ucy5zdGVwLFxcbiAgICAgICAgICAgIHIgPSBwYXJzZUZsb2F0KGEgLyAyKTtyZXR1cm4gaSA9IHQgPyBwYXJzZUZsb2F0KHQuYXR0cihcXFwiYXJpYS12YWx1ZW5vd1xcXCIpKSA6IGUsIG4gPSBpICUgYSwgcyA9IGkgLSBuLCBvID0gcyArIGEsIDAgPT09IG4gPyBpIDogaSA9IGkgPj0gcyArIHIgPyBvIDogcztcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2V2ZW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICB2YXIgaSxcXG4gICAgICAgICAgICBuID0gdGhpcztpZiAodGhpcy5pbnB1dHMub2ZmKFxcXCJjaGFuZ2UuemYuc2xpZGVyXFxcIikub24oXFxcImNoYW5nZS56Zi5zbGlkZXJcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB2YXIgaSA9IG4uaW5wdXRzLmluZGV4KHQodGhpcykpO24uX2hhbmRsZUV2ZW50KGUsIG4uaGFuZGxlcy5lcShpKSwgdCh0aGlzKS52YWwoKSk7XFxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmNsaWNrU2VsZWN0ICYmIHRoaXMuJGVsZW1lbnQub2ZmKFxcXCJjbGljay56Zi5zbGlkZXJcXFwiKS5vbihcXFwiY2xpY2suemYuc2xpZGVyXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgcmV0dXJuICFuLiRlbGVtZW50LmRhdGEoXFxcImRyYWdnaW5nXFxcIikgJiYgdm9pZCAodChlLnRhcmdldCkuaXMoXFxcIltkYXRhLXNsaWRlci1oYW5kbGVdXFxcIikgfHwgKG4ub3B0aW9ucy5kb3VibGVTaWRlZCA/IG4uX2hhbmRsZUV2ZW50KGUpIDogbi5faGFuZGxlRXZlbnQoZSwgbi4kaGFuZGxlKSkpO1xcbiAgICAgICAgfSksIHRoaXMub3B0aW9ucy5kcmFnZ2FibGUpIHtcXG4gICAgICAgICAgdGhpcy5oYW5kbGVzLmFkZFRvdWNoKCk7dmFyIHMgPSB0KFxcXCJib2R5XFxcIik7ZS5vZmYoXFxcIm1vdXNlZG93bi56Zi5zbGlkZXJcXFwiKS5vbihcXFwibW91c2Vkb3duLnpmLnNsaWRlclxcXCIsIGZ1bmN0aW9uIChvKSB7XFxuICAgICAgICAgICAgZS5hZGRDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSwgbi4kZmlsbC5hZGRDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSwgbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsICEwKSwgaSA9IHQoby5jdXJyZW50VGFyZ2V0KSwgcy5vbihcXFwibW91c2Vtb3ZlLnpmLnNsaWRlclxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCksIG4uX2hhbmRsZUV2ZW50KHQsIGkpO1xcbiAgICAgICAgICAgIH0pLm9uKFxcXCJtb3VzZXVwLnpmLnNsaWRlclxcXCIsIGZ1bmN0aW9uICh0KSB7XFxuICAgICAgICAgICAgICBuLl9oYW5kbGVFdmVudCh0LCBpKSwgZS5yZW1vdmVDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSwgbi4kZmlsbC5yZW1vdmVDbGFzcyhcXFwiaXMtZHJhZ2dpbmdcXFwiKSwgbi4kZWxlbWVudC5kYXRhKFxcXCJkcmFnZ2luZ1xcXCIsICExKSwgcy5vZmYoXFxcIm1vdXNlbW92ZS56Zi5zbGlkZXIgbW91c2V1cC56Zi5zbGlkZXJcXFwiKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgfSkub24oXFxcInNlbGVjdHN0YXJ0LnpmLnNsaWRlciB0b3VjaG1vdmUuemYuc2xpZGVyXFxcIiwgZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgICAgICB0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfWUub2ZmKFxcXCJrZXlkb3duLnpmLnNsaWRlclxcXCIpLm9uKFxcXCJrZXlkb3duLnpmLnNsaWRlclxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHZhciBpLFxcbiAgICAgICAgICAgICAgcyA9IHQodGhpcyksXFxuICAgICAgICAgICAgICBvID0gbi5vcHRpb25zLmRvdWJsZVNpZGVkID8gbi5oYW5kbGVzLmluZGV4KHMpIDogMCxcXG4gICAgICAgICAgICAgIGEgPSBwYXJzZUZsb2F0KG4uaW5wdXRzLmVxKG8pLnZhbCgpKTtGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShlLCBcXFwiU2xpZGVyXFxcIiwgeyBkZWNyZWFzZTogZnVuY3Rpb24gZGVjcmVhc2UoKSB7XFxuICAgICAgICAgICAgICBpID0gYSAtIG4ub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICAgIH0sIGluY3JlYXNlOiBmdW5jdGlvbiBpbmNyZWFzZSgpIHtcXG4gICAgICAgICAgICAgIGkgPSBhICsgbi5vcHRpb25zLnN0ZXA7XFxuICAgICAgICAgICAgfSwgZGVjcmVhc2VfZmFzdDogZnVuY3Rpb24gZGVjcmVhc2VfZmFzdCgpIHtcXG4gICAgICAgICAgICAgIGkgPSBhIC0gMTAgKiBuLm9wdGlvbnMuc3RlcDtcXG4gICAgICAgICAgICB9LCBpbmNyZWFzZV9mYXN0OiBmdW5jdGlvbiBpbmNyZWFzZV9mYXN0KCkge1xcbiAgICAgICAgICAgICAgaSA9IGEgKyAxMCAqIG4ub3B0aW9ucy5zdGVwO1xcbiAgICAgICAgICAgIH0sIGhhbmRsZWQ6IGZ1bmN0aW9uIGhhbmRsZWQoKSB7XFxuICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCksIG4uX3NldEhhbmRsZVBvcyhzLCBpLCAhMCk7XFxuICAgICAgICAgICAgfSB9KTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJkZXN0cm95XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy5oYW5kbGVzLm9mZihcXFwiLnpmLnNsaWRlclxcXCIpLCB0aGlzLmlucHV0cy5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSwgdGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi5zbGlkZXJcXFwiKSwgRm91bmRhdGlvbi51bnJlZ2lzdGVyUGx1Z2luKHRoaXMpO1xcbiAgICAgIH0gfV0pLCBuO1xcbiAgfSgpO24uZGVmYXVsdHMgPSB7IHN0YXJ0OiAwLCBlbmQ6IDEwMCwgc3RlcDogMSwgaW5pdGlhbFN0YXJ0OiAwLCBpbml0aWFsRW5kOiAxMDAsIGJpbmRpbmc6ICExLCBjbGlja1NlbGVjdDogITAsIHZlcnRpY2FsOiAhMSwgZHJhZ2dhYmxlOiAhMCwgZGlzYWJsZWQ6ICExLCBkb3VibGVTaWRlZDogITEsIGRlY2ltYWw6IDIsIG1vdmVUaW1lOiAyMDAsIGRpc2FibGVkQ2xhc3M6IFxcXCJkaXNhYmxlZFxcXCIsIGludmVydFZlcnRpY2FsOiAhMSwgY2hhbmdlZERlbGF5OiA1MDAgfSwgRm91bmRhdGlvbi5wbHVnaW4obiwgXFxcIlNsaWRlclxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICBmdW5jdGlvbiBlKHQpIHtcXG4gICAgcmV0dXJuIHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmJvZHksIG51bGwpLmZvbnRTaXplLCAxMCkgKiB0O1xcbiAgfXZhciBpID0gZnVuY3Rpb24gKCkge1xcbiAgICBmdW5jdGlvbiBpKGUsIG4pIHtcXG4gICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgaSksIHRoaXMuJGVsZW1lbnQgPSBlLCB0aGlzLm9wdGlvbnMgPSB0LmV4dGVuZCh7fSwgaS5kZWZhdWx0cywgdGhpcy4kZWxlbWVudC5kYXRhKCksIG4pLCB0aGlzLl9pbml0KCksIEZvdW5kYXRpb24ucmVnaXN0ZXJQbHVnaW4odGhpcywgXFxcIlN0aWNreVxcXCIpO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhpLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy4kZWxlbWVudC5wYXJlbnQoXFxcIltkYXRhLXN0aWNreS1jb250YWluZXJdXFxcIiksXFxuICAgICAgICAgICAgaSA9IHRoaXMuJGVsZW1lbnRbMF0uaWQgfHwgRm91bmRhdGlvbi5HZXRZb0RpZ2l0cyg2LCBcXFwic3RpY2t5XFxcIiksXFxuICAgICAgICAgICAgbiA9IHRoaXM7ZS5sZW5ndGggfHwgKHRoaXMud2FzV3JhcHBlZCA9ICEwKSwgdGhpcy4kY29udGFpbmVyID0gZS5sZW5ndGggPyBlIDogdCh0aGlzLm9wdGlvbnMuY29udGFpbmVyKS53cmFwSW5uZXIodGhpcy4kZWxlbWVudCksIHRoaXMuJGNvbnRhaW5lci5hZGRDbGFzcyh0aGlzLm9wdGlvbnMuY29udGFpbmVyQ2xhc3MpLCB0aGlzLiRlbGVtZW50LmFkZENsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcykuYXR0cih7IFxcXCJkYXRhLXJlc2l6ZVxcXCI6IGkgfSksIHRoaXMuc2Nyb2xsQ291bnQgPSB0aGlzLm9wdGlvbnMuY2hlY2tFdmVyeSwgdGhpcy5pc1N0dWNrID0gITEsIHQod2luZG93KS5vbmUoXFxcImxvYWQuemYuc3RpY2t5XFxcIiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBuLmNvbnRhaW5lckhlaWdodCA9IFxcXCJub25lXFxcIiA9PSBuLiRlbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpID8gMCA6IG4uJGVsZW1lbnRbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0LCBuLiRjb250YWluZXIuY3NzKFxcXCJoZWlnaHRcXFwiLCBuLmNvbnRhaW5lckhlaWdodCksIG4uZWxlbUhlaWdodCA9IG4uY29udGFpbmVySGVpZ2h0LCBcXFwiXFxcIiAhPT0gbi5vcHRpb25zLmFuY2hvciA/IG4uJGFuY2hvciA9IHQoXFxcIiNcXFwiICsgbi5vcHRpb25zLmFuY2hvcikgOiBuLl9wYXJzZVBvaW50cygpLCBuLl9zZXRTaXplcyhmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgbi5fY2FsYyghMSk7XFxuICAgICAgICAgIH0pLCBuLl9ldmVudHMoaS5zcGxpdChcXFwiLVxcXCIpLnJldmVyc2UoKS5qb2luKFxcXCItXFxcIikpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9wYXJzZVBvaW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIGZvciAodmFyIGUgPSBcXFwiXFxcIiA9PSB0aGlzLm9wdGlvbnMudG9wQW5jaG9yID8gMSA6IHRoaXMub3B0aW9ucy50b3BBbmNob3IsIGkgPSBcXFwiXFxcIiA9PSB0aGlzLm9wdGlvbnMuYnRtQW5jaG9yID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCA6IHRoaXMub3B0aW9ucy5idG1BbmNob3IsIG4gPSBbZSwgaV0sIHMgPSB7fSwgbyA9IDAsIGEgPSBuLmxlbmd0aDsgbyA8IGEgJiYgbltvXTsgbysrKSB7XFxuICAgICAgICAgIHZhciByO2lmIChcXFwibnVtYmVyXFxcIiA9PSB0eXBlb2YgbltvXSkgciA9IG5bb107ZWxzZSB7XFxuICAgICAgICAgICAgdmFyIGwgPSBuW29dLnNwbGl0KFxcXCI6XFxcIiksXFxuICAgICAgICAgICAgICAgIHUgPSB0KFxcXCIjXFxcIiArIGxbMF0pO3IgPSB1Lm9mZnNldCgpLnRvcCwgbFsxXSAmJiBcXFwiYm90dG9tXFxcIiA9PT0gbFsxXS50b0xvd2VyQ2FzZSgpICYmIChyICs9IHVbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0KTtcXG4gICAgICAgICAgfXNbb10gPSByO1xcbiAgICAgICAgfXRoaXMucG9pbnRzID0gcztcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2V2ZW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICB2YXIgaSA9IHRoaXMsXFxuICAgICAgICAgICAgbiA9IHRoaXMuc2Nyb2xsTGlzdGVuZXIgPSBcXFwic2Nyb2xsLnpmLlxcXCIgKyBlO3RoaXMuaXNPbiB8fCAodGhpcy5jYW5TdGljayAmJiAodGhpcy5pc09uID0gITAsIHQod2luZG93KS5vZmYobikub24obiwgZnVuY3Rpb24gKHQpIHtcXG4gICAgICAgICAgMCA9PT0gaS5zY3JvbGxDb3VudCA/IChpLnNjcm9sbENvdW50ID0gaS5vcHRpb25zLmNoZWNrRXZlcnksIGkuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpLl9jYWxjKCExLCB3aW5kb3cucGFnZVlPZmZzZXQpO1xcbiAgICAgICAgICB9KSkgOiAoaS5zY3JvbGxDb3VudC0tLCBpLl9jYWxjKCExLCB3aW5kb3cucGFnZVlPZmZzZXQpKTtcXG4gICAgICAgIH0pKSwgdGhpcy4kZWxlbWVudC5vZmYoXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiKS5vbihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIsIGZ1bmN0aW9uICh0LCBzKSB7XFxuICAgICAgICAgIGkuX3NldFNpemVzKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICBpLl9jYWxjKCExKSwgaS5jYW5TdGljayA/IGkuaXNPbiB8fCBpLl9ldmVudHMoZSkgOiBpLmlzT24gJiYgaS5fcGF1c2VMaXN0ZW5lcnMobik7XFxuICAgICAgICAgIH0pO1xcbiAgICAgICAgfSkpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfcGF1c2VMaXN0ZW5lcnNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xcbiAgICAgICAgdGhpcy5pc09uID0gITEsIHQod2luZG93KS5vZmYoZSksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwicGF1c2UuemYuc3RpY2t5XFxcIik7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9jYWxjXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQsIGUpIHtcXG4gICAgICAgIHJldHVybiB0ICYmIHRoaXMuX3NldFNpemVzKCksIHRoaXMuY2FuU3RpY2sgPyAoZSB8fCAoZSA9IHdpbmRvdy5wYWdlWU9mZnNldCksIHZvaWQgKGUgPj0gdGhpcy50b3BQb2ludCA/IGUgPD0gdGhpcy5ib3R0b21Qb2ludCA/IHRoaXMuaXNTdHVjayB8fCB0aGlzLl9zZXRTdGlja3koKSA6IHRoaXMuaXNTdHVjayAmJiB0aGlzLl9yZW1vdmVTdGlja3koITEpIDogdGhpcy5pc1N0dWNrICYmIHRoaXMuX3JlbW92ZVN0aWNreSghMCkpKSA6ICh0aGlzLmlzU3R1Y2sgJiYgdGhpcy5fcmVtb3ZlU3RpY2t5KCEwKSwgITEpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfc2V0U3RpY2t5XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIHQgPSB0aGlzLFxcbiAgICAgICAgICAgIGUgPSB0aGlzLm9wdGlvbnMuc3RpY2tUbyxcXG4gICAgICAgICAgICBpID0gXFxcInRvcFxcXCIgPT09IGUgPyBcXFwibWFyZ2luVG9wXFxcIiA6IFxcXCJtYXJnaW5Cb3R0b21cXFwiLFxcbiAgICAgICAgICAgIG4gPSBcXFwidG9wXFxcIiA9PT0gZSA/IFxcXCJib3R0b21cXFwiIDogXFxcInRvcFxcXCIsXFxuICAgICAgICAgICAgcyA9IHt9O3NbaV0gPSB0aGlzLm9wdGlvbnNbaV0gKyBcXFwiZW1cXFwiLCBzW2VdID0gMCwgc1tuXSA9IFxcXCJhdXRvXFxcIiwgcy5sZWZ0ID0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpLmxlZnQgKyBwYXJzZUludCh3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRjb250YWluZXJbMF0pW1xcXCJwYWRkaW5nLWxlZnRcXFwiXSwgMTApLCB0aGlzLmlzU3R1Y2sgPSAhMCwgdGhpcy4kZWxlbWVudC5yZW1vdmVDbGFzcyhcXFwiaXMtYW5jaG9yZWQgaXMtYXQtXFxcIiArIG4pLmFkZENsYXNzKFxcXCJpcy1zdHVjayBpcy1hdC1cXFwiICsgZSkuY3NzKHMpLnRyaWdnZXIoXFxcInN0aWNreS56Zi5zdHVja3RvOlxcXCIgKyBlKSwgdGhpcy4kZWxlbWVudC5vbihcXFwidHJhbnNpdGlvbmVuZCB3ZWJraXRUcmFuc2l0aW9uRW5kIG9UcmFuc2l0aW9uRW5kIG90cmFuc2l0aW9uZW5kIE1TVHJhbnNpdGlvbkVuZFxcXCIsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdC5fc2V0U2l6ZXMoKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfcmVtb3ZlU3RpY2t5XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcy5vcHRpb25zLnN0aWNrVG8sXFxuICAgICAgICAgICAgaSA9IFxcXCJ0b3BcXFwiID09PSBlLFxcbiAgICAgICAgICAgIG4gPSB7fSxcXG4gICAgICAgICAgICBzID0gKHRoaXMucG9pbnRzID8gdGhpcy5wb2ludHNbMV0gLSB0aGlzLnBvaW50c1swXSA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodCxcXG4gICAgICAgICAgICBvID0gaSA/IFxcXCJtYXJnaW5Ub3BcXFwiIDogXFxcIm1hcmdpbkJvdHRvbVxcXCIsXFxuICAgICAgICAgICAgYSA9IHQgPyBcXFwidG9wXFxcIiA6IFxcXCJib3R0b21cXFwiO25bb10gPSAwLCBuLmJvdHRvbSA9IFxcXCJhdXRvXFxcIiwgdCA/IG4udG9wID0gMCA6IG4udG9wID0gcywgbi5sZWZ0ID0gXFxcIlxcXCIsIHRoaXMuaXNTdHVjayA9ICExLCB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKFxcXCJpcy1zdHVjayBpcy1hdC1cXFwiICsgZSkuYWRkQ2xhc3MoXFxcImlzLWFuY2hvcmVkIGlzLWF0LVxcXCIgKyBhKS5jc3MobikudHJpZ2dlcihcXFwic3RpY2t5LnpmLnVuc3R1Y2tmcm9tOlxcXCIgKyBhKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX3NldFNpemVzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHRoaXMuY2FuU3RpY2sgPSBGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc3RpY2t5T24pLCB0aGlzLmNhblN0aWNrIHx8IHQgJiYgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgdCAmJiB0KCk7dmFyIGUgPSB0aGlzLiRjb250YWluZXJbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkud2lkdGgsXFxuICAgICAgICAgICAgaSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMuJGNvbnRhaW5lclswXSksXFxuICAgICAgICAgICAgbiA9IHBhcnNlSW50KGlbXFxcInBhZGRpbmctcmlnaHRcXFwiXSwgMTApO3RoaXMuJGFuY2hvciAmJiB0aGlzLiRhbmNob3IubGVuZ3RoID8gdGhpcy5hbmNob3JIZWlnaHQgPSB0aGlzLiRhbmNob3JbMF0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IDogdGhpcy5fcGFyc2VQb2ludHMoKSwgdGhpcy4kZWxlbWVudC5jc3MoeyBcXFwibWF4LXdpZHRoXFxcIjogZSAtIG4gKyBcXFwicHhcXFwiIH0pO3ZhciBzID0gdGhpcy4kZWxlbWVudFswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgfHwgdGhpcy5jb250YWluZXJIZWlnaHQ7aWYgKFxcXCJub25lXFxcIiA9PSB0aGlzLiRlbGVtZW50LmNzcyhcXFwiZGlzcGxheVxcXCIpICYmIChzID0gMCksIHRoaXMuY29udGFpbmVySGVpZ2h0ID0gcywgdGhpcy4kY29udGFpbmVyLmNzcyh7IGhlaWdodDogcyB9KSwgdGhpcy5lbGVtSGVpZ2h0ID0gcywgdGhpcy5pc1N0dWNrKSB0aGlzLiRlbGVtZW50LmNzcyh7IGxlZnQ6IHRoaXMuJGNvbnRhaW5lci5vZmZzZXQoKS5sZWZ0ICsgcGFyc2VJbnQoaVtcXFwicGFkZGluZy1sZWZ0XFxcIl0sIDEwKSB9KTtlbHNlIGlmICh0aGlzLiRlbGVtZW50Lmhhc0NsYXNzKFxcXCJpcy1hdC1ib3R0b21cXFwiKSkge1xcbiAgICAgICAgICB2YXIgbyA9ICh0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzFdIC0gdGhpcy4kY29udGFpbmVyLm9mZnNldCgpLnRvcCA6IHRoaXMuYW5jaG9ySGVpZ2h0KSAtIHRoaXMuZWxlbUhlaWdodDt0aGlzLiRlbGVtZW50LmNzcyhcXFwidG9wXFxcIiwgbyk7XFxuICAgICAgICB9dGhpcy5fc2V0QnJlYWtQb2ludHMocywgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0ICYmIFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIHQgJiYgdCgpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9zZXRCcmVha1BvaW50c1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0LCBpKSB7XFxuICAgICAgICBpZiAoIXRoaXMuY2FuU3RpY2spIHtcXG4gICAgICAgICAgaWYgKCFpIHx8IFxcXCJmdW5jdGlvblxcXCIgIT0gdHlwZW9mIGkpIHJldHVybiAhMTtpKCk7XFxuICAgICAgICB9dmFyIG4gPSBlKHRoaXMub3B0aW9ucy5tYXJnaW5Ub3ApLFxcbiAgICAgICAgICAgIHMgPSBlKHRoaXMub3B0aW9ucy5tYXJnaW5Cb3R0b20pLFxcbiAgICAgICAgICAgIG8gPSB0aGlzLnBvaW50cyA/IHRoaXMucG9pbnRzWzBdIDogdGhpcy4kYW5jaG9yLm9mZnNldCgpLnRvcCxcXG4gICAgICAgICAgICBhID0gdGhpcy5wb2ludHMgPyB0aGlzLnBvaW50c1sxXSA6IG8gKyB0aGlzLmFuY2hvckhlaWdodCxcXG4gICAgICAgICAgICByID0gd2luZG93LmlubmVySGVpZ2h0O1xcbiAgICAgICAgXFxcInRvcFxcXCIgPT09IHRoaXMub3B0aW9ucy5zdGlja1RvID8gKG8gLT0gbiwgYSAtPSB0ICsgbikgOiBcXFwiYm90dG9tXFxcIiA9PT0gdGhpcy5vcHRpb25zLnN0aWNrVG8gJiYgKG8gLT0gciAtICh0ICsgcyksIGEgLT0gciAtIHMpLCB0aGlzLnRvcFBvaW50ID0gbywgdGhpcy5ib3R0b21Qb2ludCA9IGEsIGkgJiYgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgaSAmJiBpKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLl9yZW1vdmVTdGlja3koITApLCB0aGlzLiRlbGVtZW50LnJlbW92ZUNsYXNzKHRoaXMub3B0aW9ucy5zdGlja3lDbGFzcyArIFxcXCIgaXMtYW5jaG9yZWQgaXMtYXQtdG9wXFxcIikuY3NzKHsgaGVpZ2h0OiBcXFwiXFxcIiwgdG9wOiBcXFwiXFxcIiwgYm90dG9tOiBcXFwiXFxcIiwgXFxcIm1heC13aWR0aFxcXCI6IFxcXCJcXFwiIH0pLm9mZihcXFwicmVzaXplbWUuemYudHJpZ2dlclxcXCIpLCB0aGlzLiRhbmNob3IgJiYgdGhpcy4kYW5jaG9yLmxlbmd0aCAmJiB0aGlzLiRhbmNob3Iub2ZmKFxcXCJjaGFuZ2UuemYuc3RpY2t5XFxcIiksIHQod2luZG93KS5vZmYodGhpcy5zY3JvbGxMaXN0ZW5lciksIHRoaXMud2FzV3JhcHBlZCA/IHRoaXMuJGVsZW1lbnQudW53cmFwKCkgOiB0aGlzLiRjb250YWluZXIucmVtb3ZlQ2xhc3ModGhpcy5vcHRpb25zLmNvbnRhaW5lckNsYXNzKS5jc3MoeyBoZWlnaHQ6IFxcXCJcXFwiIH0pLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGk7XFxuICB9KCk7aS5kZWZhdWx0cyA9IHsgY29udGFpbmVyOiBcXFwiPGRpdiBkYXRhLXN0aWNreS1jb250YWluZXI+PC9kaXY+XFxcIiwgc3RpY2tUbzogXFxcInRvcFxcXCIsIGFuY2hvcjogXFxcIlxcXCIsIHRvcEFuY2hvcjogXFxcIlxcXCIsIGJ0bUFuY2hvcjogXFxcIlxcXCIsIG1hcmdpblRvcDogMSwgbWFyZ2luQm90dG9tOiAxLCBzdGlja3lPbjogXFxcIm1lZGl1bVxcXCIsIHN0aWNreUNsYXNzOiBcXFwic3RpY2t5XFxcIiwgY29udGFpbmVyQ2xhc3M6IFxcXCJzdGlja3ktY29udGFpbmVyXFxcIiwgY2hlY2tFdmVyeTogLTEgfSwgRm91bmRhdGlvbi5wbHVnaW4oaSwgXFxcIlN0aWNreVxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpLCBuKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGUpLCB0aGlzLiRlbGVtZW50ID0gaSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBuKSwgdGhpcy5faW5pdCgpLCBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsIFxcXCJUYWJzXFxcIiksIEZvdW5kYXRpb24uS2V5Ym9hcmQucmVnaXN0ZXIoXFxcIlRhYnNcXFwiLCB7IEVOVEVSOiBcXFwib3BlblxcXCIsIFNQQUNFOiBcXFwib3BlblxcXCIsIEFSUk9XX1JJR0hUOiBcXFwibmV4dFxcXCIsIEFSUk9XX1VQOiBcXFwicHJldmlvdXNcXFwiLCBBUlJPV19ET1dOOiBcXFwibmV4dFxcXCIsIEFSUk9XX0xFRlQ6IFxcXCJwcmV2aW91c1xcXCIgfSk7XFxuICAgIH1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsIFt7IGtleTogXFxcIl9pbml0XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO2lmICh0aGlzLiR0YWJUaXRsZXMgPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLmxpbmtDbGFzcyksIHRoaXMuJHRhYkNvbnRlbnQgPSB0KCdbZGF0YS10YWJzLWNvbnRlbnQ9XFxcIicgKyB0aGlzLiRlbGVtZW50WzBdLmlkICsgJ1xcXCJdJyksIHRoaXMuJHRhYlRpdGxlcy5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGkgPSB0KHRoaXMpLFxcbiAgICAgICAgICAgICAgbiA9IGkuZmluZChcXFwiYVxcXCIpLFxcbiAgICAgICAgICAgICAgcyA9IGkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLFxcbiAgICAgICAgICAgICAgbyA9IG5bMF0uaGFzaC5zbGljZSgxKSxcXG4gICAgICAgICAgICAgIGEgPSBuWzBdLmlkID8gblswXS5pZCA6IG8gKyBcXFwiLWxhYmVsXFxcIixcXG4gICAgICAgICAgICAgIHIgPSB0KFxcXCIjXFxcIiArIG8pO2kuYXR0cih7IHJvbGU6IFxcXCJwcmVzZW50YXRpb25cXFwiIH0pLCBuLmF0dHIoeyByb2xlOiBcXFwidGFiXFxcIiwgXFxcImFyaWEtY29udHJvbHNcXFwiOiBvLCBcXFwiYXJpYS1zZWxlY3RlZFxcXCI6IHMsIGlkOiBhIH0pLCByLmF0dHIoeyByb2xlOiBcXFwidGFicGFuZWxcXFwiLCBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhcywgXFxcImFyaWEtbGFiZWxsZWRieVxcXCI6IGEgfSksIHMgJiYgZS5vcHRpb25zLmF1dG9Gb2N1cyAmJiBuLmZvY3VzKCk7XFxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLm1hdGNoSGVpZ2h0KSB7XFxuICAgICAgICAgIHZhciBpID0gdGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCJpbWdcXFwiKTtpLmxlbmd0aCA/IEZvdW5kYXRpb24ub25JbWFnZXNMb2FkZWQoaSwgdGhpcy5fc2V0SGVpZ2h0LmJpbmQodGhpcykpIDogdGhpcy5fc2V0SGVpZ2h0KCk7XFxuICAgICAgICB9dGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9ldmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLl9hZGRLZXlIYW5kbGVyKCksIHRoaXMuX2FkZENsaWNrSGFuZGxlcigpLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIgPSBudWxsLCB0aGlzLm9wdGlvbnMubWF0Y2hIZWlnaHQgJiYgKHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciA9IHRoaXMuX3NldEhlaWdodC5iaW5kKHRoaXMpLCB0KHdpbmRvdykub24oXFxcImNoYW5nZWQuemYubWVkaWFxdWVyeVxcXCIsIHRoaXMuX3NldEhlaWdodE1xSGFuZGxlcikpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfYWRkQ2xpY2tIYW5kbGVyXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzO3RoaXMuJGVsZW1lbnQub2ZmKFxcXCJjbGljay56Zi50YWJzXFxcIikub24oXFxcImNsaWNrLnpmLnRhYnNcXFwiLCBcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBpLnByZXZlbnREZWZhdWx0KCksIGkuc3RvcFByb3BhZ2F0aW9uKCksIHQodGhpcykuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpIHx8IGUuX2hhbmRsZVRhYkNoYW5nZSh0KHRoaXMpKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfYWRkS2V5SGFuZGxlclxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlID0gdGhpcztlLiRlbGVtZW50LmZpbmQoXFxcImxpOmZpcnN0LW9mLXR5cGVcXFwiKSwgZS4kZWxlbWVudC5maW5kKFxcXCJsaTpsYXN0LW9mLXR5cGVcXFwiKTt0aGlzLiR0YWJUaXRsZXMub2ZmKFxcXCJrZXlkb3duLnpmLnRhYnNcXFwiKS5vbihcXFwia2V5ZG93bi56Zi50YWJzXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgaWYgKDkgIT09IGkud2hpY2gpIHtcXG4gICAgICAgICAgICB2YXIgbixcXG4gICAgICAgICAgICAgICAgcyxcXG4gICAgICAgICAgICAgICAgbyA9IHQodGhpcyksXFxuICAgICAgICAgICAgICAgIGEgPSBvLnBhcmVudChcXFwidWxcXFwiKS5jaGlsZHJlbihcXFwibGlcXFwiKTthLmVhY2goZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgICAgIGlmICh0KHRoaXMpLmlzKG8pKSByZXR1cm4gdm9pZCAoZS5vcHRpb25zLndyYXBPbktleXMgPyAobiA9IDAgPT09IGkgPyBhLmxhc3QoKSA6IGEuZXEoaSAtIDEpLCBzID0gaSA9PT0gYS5sZW5ndGggLSAxID8gYS5maXJzdCgpIDogYS5lcShpICsgMSkpIDogKG4gPSBhLmVxKE1hdGgubWF4KDAsIGkgLSAxKSksIHMgPSBhLmVxKE1hdGgubWluKGkgKyAxLCBhLmxlbmd0aCAtIDEpKSkpO1xcbiAgICAgICAgICAgIH0pLCBGb3VuZGF0aW9uLktleWJvYXJkLmhhbmRsZUtleShpLCBcXFwiVGFic1xcXCIsIHsgb3BlbjogZnVuY3Rpb24gb3BlbigpIHtcXG4gICAgICAgICAgICAgICAgby5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLCBlLl9oYW5kbGVUYWJDaGFuZ2Uobyk7XFxuICAgICAgICAgICAgICB9LCBwcmV2aW91czogZnVuY3Rpb24gcHJldmlvdXMoKSB7XFxuICAgICAgICAgICAgICAgIG4uZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJykuZm9jdXMoKSwgZS5faGFuZGxlVGFiQ2hhbmdlKG4pO1xcbiAgICAgICAgICAgICAgfSwgbmV4dDogZnVuY3Rpb24gbmV4dCgpIHtcXG4gICAgICAgICAgICAgICAgcy5maW5kKCdbcm9sZT1cXFwidGFiXFxcIl0nKS5mb2N1cygpLCBlLl9oYW5kbGVUYWJDaGFuZ2Uocyk7XFxuICAgICAgICAgICAgICB9LCBoYW5kbGVkOiBmdW5jdGlvbiBoYW5kbGVkKCkge1xcbiAgICAgICAgICAgICAgICBpLnN0b3BQcm9wYWdhdGlvbigpLCBpLnByZXZlbnREZWZhdWx0KCk7XFxuICAgICAgICAgICAgICB9IH0pO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2hhbmRsZVRhYkNoYW5nZVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShlKSB7XFxuICAgICAgICB2YXIgaSA9IGUuZmluZCgnW3JvbGU9XFxcInRhYlxcXCJdJyksXFxuICAgICAgICAgICAgbiA9IGlbMF0uaGFzaCxcXG4gICAgICAgICAgICBzID0gdGhpcy4kdGFiQ29udGVudC5maW5kKG4pLFxcbiAgICAgICAgICAgIG8gPSB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLmxpbmtDbGFzcyArIFxcXCIuaXMtYWN0aXZlXFxcIikucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmZpbmQoJ1tyb2xlPVxcXCJ0YWJcXFwiXScpLmF0dHIoeyBcXFwiYXJpYS1zZWxlY3RlZFxcXCI6IFxcXCJmYWxzZVxcXCIgfSk7dChcXFwiI1xcXCIgKyBvLmF0dHIoXFxcImFyaWEtY29udHJvbHNcXFwiKSkucmVtb3ZlQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLmF0dHIoeyBcXFwiYXJpYS1oaWRkZW5cXFwiOiBcXFwidHJ1ZVxcXCIgfSksIGUuYWRkQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpLCBpLmF0dHIoeyBcXFwiYXJpYS1zZWxlY3RlZFxcXCI6IFxcXCJ0cnVlXFxcIiB9KSwgcy5hZGRDbGFzcyhcXFwiaXMtYWN0aXZlXFxcIikuYXR0cih7IFxcXCJhcmlhLWhpZGRlblxcXCI6IFxcXCJmYWxzZVxcXCIgfSksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2hhbmdlLnpmLnRhYnNcXFwiLCBbZV0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJzZWxlY3RUYWJcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUodCkge1xcbiAgICAgICAgdmFyIGU7ZSA9IFxcXCJvYmplY3RcXFwiID09ICh0eXBlb2YgdCA9PT0gXFxcInVuZGVmaW5lZFxcXCIgPyBcXFwidW5kZWZpbmVkXFxcIiA6IF90eXBlb2YodCkpID8gdFswXS5pZCA6IHQsIGUuaW5kZXhPZihcXFwiI1xcXCIpIDwgMCAmJiAoZSA9IFxcXCIjXFxcIiArIGUpO3ZhciBpID0gdGhpcy4kdGFiVGl0bGVzLmZpbmQoJ1tocmVmPVxcXCInICsgZSArICdcXFwiXScpLnBhcmVudChcXFwiLlxcXCIgKyB0aGlzLm9wdGlvbnMubGlua0NsYXNzKTt0aGlzLl9oYW5kbGVUYWJDaGFuZ2UoaSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9zZXRIZWlnaHRcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgZSA9IDA7dGhpcy4kdGFiQ29udGVudC5maW5kKFxcXCIuXFxcIiArIHRoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5jc3MoXFxcImhlaWdodFxcXCIsIFxcXCJcXFwiKS5lYWNoKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdmFyIGkgPSB0KHRoaXMpLFxcbiAgICAgICAgICAgICAgbiA9IGkuaGFzQ2xhc3MoXFxcImlzLWFjdGl2ZVxcXCIpO24gfHwgaS5jc3MoeyB2aXNpYmlsaXR5OiBcXFwiaGlkZGVuXFxcIiwgZGlzcGxheTogXFxcImJsb2NrXFxcIiB9KTt2YXIgcyA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0O24gfHwgaS5jc3MoeyB2aXNpYmlsaXR5OiBcXFwiXFxcIiwgZGlzcGxheTogXFxcIlxcXCIgfSksIGUgPSBzID4gZSA/IHMgOiBlO1xcbiAgICAgICAgfSkuY3NzKFxcXCJoZWlnaHRcXFwiLCBlICsgXFxcInB4XFxcIik7XFxuICAgICAgfSB9LCB7IGtleTogXFxcImRlc3Ryb3lcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmZpbmQoXFxcIi5cXFwiICsgdGhpcy5vcHRpb25zLmxpbmtDbGFzcykub2ZmKFxcXCIuemYudGFic1xcXCIpLmhpZGUoKS5lbmQoKS5maW5kKFxcXCIuXFxcIiArIHRoaXMub3B0aW9ucy5wYW5lbENsYXNzKS5oaWRlKCksIHRoaXMub3B0aW9ucy5tYXRjaEhlaWdodCAmJiBudWxsICE9IHRoaXMuX3NldEhlaWdodE1xSGFuZGxlciAmJiB0KHdpbmRvdykub2ZmKFxcXCJjaGFuZ2VkLnpmLm1lZGlhcXVlcnlcXFwiLCB0aGlzLl9zZXRIZWlnaHRNcUhhbmRsZXIpLCBGb3VuZGF0aW9uLnVucmVnaXN0ZXJQbHVnaW4odGhpcyk7XFxuICAgICAgfSB9XSksIGU7XFxuICB9KCk7ZS5kZWZhdWx0cyA9IHsgYXV0b0ZvY3VzOiAhMSwgd3JhcE9uS2V5czogITAsIG1hdGNoSGVpZ2h0OiAhMSwgbGlua0NsYXNzOiBcXFwidGFicy10aXRsZVxcXCIsIHBhbmVsQ2xhc3M6IFxcXCJ0YWJzLXBhbmVsXFxcIiB9LCBGb3VuZGF0aW9uLnBsdWdpbihlLCBcXFwiVGFic1xcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpLCBuKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGUpLCB0aGlzLiRlbGVtZW50ID0gaSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIGUuZGVmYXVsdHMsIGkuZGF0YSgpLCBuKSwgdGhpcy5jbGFzc05hbWUgPSBcXFwiXFxcIiwgdGhpcy5faW5pdCgpLCB0aGlzLl9ldmVudHMoKSwgRm91bmRhdGlvbi5yZWdpc3RlclBsdWdpbih0aGlzLCBcXFwiVG9nZ2xlclxcXCIpO1xcbiAgICB9cmV0dXJuIF9jcmVhdGVDbGFzcyhlLCBbeyBrZXk6IFxcXCJfaW5pdFxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciBlO3RoaXMub3B0aW9ucy5hbmltYXRlID8gKGUgPSB0aGlzLm9wdGlvbnMuYW5pbWF0ZS5zcGxpdChcXFwiIFxcXCIpLCB0aGlzLmFuaW1hdGlvbkluID0gZVswXSwgdGhpcy5hbmltYXRpb25PdXQgPSBlWzFdIHx8IG51bGwpIDogKGUgPSB0aGlzLiRlbGVtZW50LmRhdGEoXFxcInRvZ2dsZXJcXFwiKSwgdGhpcy5jbGFzc05hbWUgPSBcXFwiLlxcXCIgPT09IGVbMF0gPyBlLnNsaWNlKDEpIDogZSk7dmFyIGkgPSB0aGlzLiRlbGVtZW50WzBdLmlkO3QoJ1tkYXRhLW9wZW49XFxcIicgKyBpICsgJ1xcXCJdLCBbZGF0YS1jbG9zZT1cXFwiJyArIGkgKyAnXFxcIl0sIFtkYXRhLXRvZ2dsZT1cXFwiJyArIGkgKyAnXFxcIl0nKS5hdHRyKFxcXCJhcmlhLWNvbnRyb2xzXFxcIiwgaSksIHRoaXMuJGVsZW1lbnQuYXR0cihcXFwiYXJpYS1leHBhbmRlZFxcXCIsICF0aGlzLiRlbGVtZW50LmlzKFxcXCI6aGlkZGVuXFxcIikpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfZXZlbnRzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIikub24oXFxcInRvZ2dsZS56Zi50cmlnZ2VyXFxcIiwgdGhpcy50b2dnbGUuYmluZCh0aGlzKSk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcInRvZ2dsZVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXNbdGhpcy5vcHRpb25zLmFuaW1hdGUgPyBcXFwiX3RvZ2dsZUFuaW1hdGVcXFwiIDogXFxcIl90b2dnbGVDbGFzc1xcXCJdKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl90b2dnbGVDbGFzc1xcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQudG9nZ2xlQ2xhc3ModGhpcy5jbGFzc05hbWUpO3ZhciB0ID0gdGhpcy4kZWxlbWVudC5oYXNDbGFzcyh0aGlzLmNsYXNzTmFtZSk7dCA/IHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwib24uemYudG9nZ2xlclxcXCIpIDogdGhpcy4kZWxlbWVudC50cmlnZ2VyKFxcXCJvZmYuemYudG9nZ2xlclxcXCIpLCB0aGlzLl91cGRhdGVBUklBKHQpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfdG9nZ2xlQW5pbWF0ZVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gdGhpczt0aGlzLiRlbGVtZW50LmlzKFxcXCI6aGlkZGVuXFxcIikgPyBGb3VuZGF0aW9uLk1vdGlvbi5hbmltYXRlSW4odGhpcy4kZWxlbWVudCwgdGhpcy5hbmltYXRpb25JbiwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICB0Ll91cGRhdGVBUklBKCEwKSwgdGhpcy50cmlnZ2VyKFxcXCJvbi56Zi50b2dnbGVyXFxcIik7XFxuICAgICAgICB9KSA6IEZvdW5kYXRpb24uTW90aW9uLmFuaW1hdGVPdXQodGhpcy4kZWxlbWVudCwgdGhpcy5hbmltYXRpb25PdXQsIGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgdC5fdXBkYXRlQVJJQSghMSksIHRoaXMudHJpZ2dlcihcXFwib2ZmLnpmLnRvZ2dsZXJcXFwiKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJfdXBkYXRlQVJJQVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSh0KSB7XFxuICAgICAgICB0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZXhwYW5kZWRcXFwiLCAhIXQpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJkZXN0cm95XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdGhpcy4kZWxlbWVudC5vZmYoXFxcIi56Zi50b2dnbGVyXFxcIiksIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9IH1dKSwgZTtcXG4gIH0oKTtlLmRlZmF1bHRzID0geyBhbmltYXRlOiAhMSB9LCBGb3VuZGF0aW9uLnBsdWdpbihlLCBcXFwiVG9nZ2xlclxcXCIpO1xcbn0oalF1ZXJ5KTt2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xcbiAgZnVuY3Rpb24gdCh0LCBlKSB7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZS5sZW5ndGg7IGkrKykge1xcbiAgICAgIHZhciBuID0gZVtpXTtuLmVudW1lcmFibGUgPSBuLmVudW1lcmFibGUgfHwgITEsIG4uY29uZmlndXJhYmxlID0gITAsIFxcXCJ2YWx1ZVxcXCIgaW4gbiAmJiAobi53cml0YWJsZSA9ICEwKSwgT2JqZWN0LmRlZmluZVByb3BlcnR5KHQsIG4ua2V5LCBuKTtcXG4gICAgfVxcbiAgfXJldHVybiBmdW5jdGlvbiAoZSwgaSwgbikge1xcbiAgICByZXR1cm4gaSAmJiB0KGUucHJvdG90eXBlLCBpKSwgbiAmJiB0KGUsIG4pLCBlO1xcbiAgfTtcXG59KCk7IWZ1bmN0aW9uICh0KSB7XFxuICB2YXIgZSA9IGZ1bmN0aW9uICgpIHtcXG4gICAgZnVuY3Rpb24gZShpLCBuKSB7XFxuICAgICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIGUpLCB0aGlzLiRlbGVtZW50ID0gaSwgdGhpcy5vcHRpb25zID0gdC5leHRlbmQoe30sIGUuZGVmYXVsdHMsIHRoaXMuJGVsZW1lbnQuZGF0YSgpLCBuKSwgdGhpcy5pc0FjdGl2ZSA9ICExLCB0aGlzLmlzQ2xpY2sgPSAhMSwgdGhpcy5faW5pdCgpLCBGb3VuZGF0aW9uLnJlZ2lzdGVyUGx1Z2luKHRoaXMsIFxcXCJUb29sdGlwXFxcIik7XFxuICAgIH1yZXR1cm4gX2NyZWF0ZUNsYXNzKGUsIFt7IGtleTogXFxcIl9pbml0XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIGUgPSB0aGlzLiRlbGVtZW50LmF0dHIoXFxcImFyaWEtZGVzY3JpYmVkYnlcXFwiKSB8fCBGb3VuZGF0aW9uLkdldFlvRGlnaXRzKDYsIFxcXCJ0b29sdGlwXFxcIik7dGhpcy5vcHRpb25zLnBvc2l0aW9uQ2xhc3MgPSB0aGlzLm9wdGlvbnMucG9zaXRpb25DbGFzcyB8fCB0aGlzLl9nZXRQb3NpdGlvbkNsYXNzKHRoaXMuJGVsZW1lbnQpLCB0aGlzLm9wdGlvbnMudGlwVGV4dCA9IHRoaXMub3B0aW9ucy50aXBUZXh0IHx8IHRoaXMuJGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiKSwgdGhpcy50ZW1wbGF0ZSA9IHRoaXMub3B0aW9ucy50ZW1wbGF0ZSA/IHQodGhpcy5vcHRpb25zLnRlbXBsYXRlKSA6IHRoaXMuX2J1aWxkVGVtcGxhdGUoZSksIHRoaXMudGVtcGxhdGUuYXBwZW5kVG8oZG9jdW1lbnQuYm9keSkudGV4dCh0aGlzLm9wdGlvbnMudGlwVGV4dCkuaGlkZSgpLCB0aGlzLiRlbGVtZW50LmF0dHIoeyB0aXRsZTogXFxcIlxcXCIsIFxcXCJhcmlhLWRlc2NyaWJlZGJ5XFxcIjogZSwgXFxcImRhdGEteWV0aS1ib3hcXFwiOiBlLCBcXFwiZGF0YS10b2dnbGVcXFwiOiBlLCBcXFwiZGF0YS1yZXNpemVcXFwiOiBlIH0pLmFkZENsYXNzKHRoaXMub3B0aW9ucy50cmlnZ2VyQ2xhc3MpLCB0aGlzLnVzZWRQb3NpdGlvbnMgPSBbXSwgdGhpcy5jb3VudGVyID0gNCwgdGhpcy5jbGFzc0NoYW5nZWQgPSAhMSwgdGhpcy5fZXZlbnRzKCk7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9nZXRQb3NpdGlvbkNsYXNzXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIGlmICghdCkgcmV0dXJuIFxcXCJcXFwiO3ZhciBlID0gdFswXS5jbGFzc05hbWUubWF0Y2goL1xcXFxiKHRvcHxsZWZ0fHJpZ2h0KVxcXFxiL2cpO3JldHVybiBlID0gZSA/IGVbMF0gOiBcXFwiXFxcIjtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiX2J1aWxkVGVtcGxhdGVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoZSkge1xcbiAgICAgICAgdmFyIGkgPSAodGhpcy5vcHRpb25zLnRvb2x0aXBDbGFzcyArIFxcXCIgXFxcIiArIHRoaXMub3B0aW9ucy5wb3NpdGlvbkNsYXNzICsgXFxcIiBcXFwiICsgdGhpcy5vcHRpb25zLnRlbXBsYXRlQ2xhc3NlcykudHJpbSgpLFxcbiAgICAgICAgICAgIG4gPSB0KFxcXCI8ZGl2PjwvZGl2PlxcXCIpLmFkZENsYXNzKGkpLmF0dHIoeyByb2xlOiBcXFwidG9vbHRpcFxcXCIsIFxcXCJhcmlhLWhpZGRlblxcXCI6ICEwLCBcXFwiZGF0YS1pcy1hY3RpdmVcXFwiOiAhMSwgXFxcImRhdGEtaXMtZm9jdXNcXFwiOiAhMSwgaWQ6IGUgfSk7cmV0dXJuIG47XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9yZXBvc2l0aW9uXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKHQpIHtcXG4gICAgICAgIHRoaXMudXNlZFBvc2l0aW9ucy5wdXNoKHQgPyB0IDogXFxcImJvdHRvbVxcXCIpLCAhdCAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwidG9wXFxcIikgPCAwID8gdGhpcy50ZW1wbGF0ZS5hZGRDbGFzcyhcXFwidG9wXFxcIikgOiBcXFwidG9wXFxcIiA9PT0gdCAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIikgPCAwID8gdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KSA6IFxcXCJsZWZ0XFxcIiA9PT0gdCAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwicmlnaHRcXFwiKSA8IDAgPyB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJyaWdodFxcXCIpIDogXFxcInJpZ2h0XFxcIiA9PT0gdCAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwibGVmdFxcXCIpIDwgMCA/IHRoaXMudGVtcGxhdGUucmVtb3ZlQ2xhc3ModCkuYWRkQ2xhc3MoXFxcImxlZnRcXFwiKSA6ICF0ICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJ0b3BcXFwiKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJsZWZ0XFxcIikgPCAwID8gdGhpcy50ZW1wbGF0ZS5hZGRDbGFzcyhcXFwibGVmdFxcXCIpIDogXFxcInRvcFxcXCIgPT09IHQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImJvdHRvbVxcXCIpID4gLTEgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKSA8IDAgPyB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpLmFkZENsYXNzKFxcXCJsZWZ0XFxcIikgOiBcXFwibGVmdFxcXCIgPT09IHQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcInJpZ2h0XFxcIikgPiAtMSAmJiB0aGlzLnVzZWRQb3NpdGlvbnMuaW5kZXhPZihcXFwiYm90dG9tXFxcIikgPCAwID8gdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KSA6IFxcXCJyaWdodFxcXCIgPT09IHQgJiYgdGhpcy51c2VkUG9zaXRpb25zLmluZGV4T2YoXFxcImxlZnRcXFwiKSA+IC0xICYmIHRoaXMudXNlZFBvc2l0aW9ucy5pbmRleE9mKFxcXCJib3R0b21cXFwiKSA8IDAgPyB0aGlzLnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQpIDogdGhpcy50ZW1wbGF0ZS5yZW1vdmVDbGFzcyh0KSwgdGhpcy5jbGFzc0NoYW5nZWQgPSAhMCwgdGhpcy5jb3VudGVyLS07XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9zZXRQb3NpdGlvblxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHZhciB0ID0gdGhpcy5fZ2V0UG9zaXRpb25DbGFzcyh0aGlzLnRlbXBsYXRlKSxcXG4gICAgICAgICAgICBlID0gRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLnRlbXBsYXRlKSxcXG4gICAgICAgICAgICBpID0gRm91bmRhdGlvbi5Cb3guR2V0RGltZW5zaW9ucyh0aGlzLiRlbGVtZW50KSxcXG4gICAgICAgICAgICBuID0gXFxcImxlZnRcXFwiID09PSB0ID8gXFxcImxlZnRcXFwiIDogXFxcInJpZ2h0XFxcIiA9PT0gdCA/IFxcXCJsZWZ0XFxcIiA6IFxcXCJ0b3BcXFwiLFxcbiAgICAgICAgICAgIHMgPSBcXFwidG9wXFxcIiA9PT0gbiA/IFxcXCJoZWlnaHRcXFwiIDogXFxcIndpZHRoXFxcIjtcXFwiaGVpZ2h0XFxcIiA9PT0gcyA/IHRoaXMub3B0aW9ucy52T2Zmc2V0IDogdGhpcy5vcHRpb25zLmhPZmZzZXQ7aWYgKGUud2lkdGggPj0gZS53aW5kb3dEaW1zLndpZHRoIHx8ICF0aGlzLmNvdW50ZXIgJiYgIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkpIHJldHVybiB0aGlzLnRlbXBsYXRlLm9mZnNldChGb3VuZGF0aW9uLkJveC5HZXRPZmZzZXRzKHRoaXMudGVtcGxhdGUsIHRoaXMuJGVsZW1lbnQsIFxcXCJjZW50ZXIgYm90dG9tXFxcIiwgdGhpcy5vcHRpb25zLnZPZmZzZXQsIHRoaXMub3B0aW9ucy5oT2Zmc2V0LCAhMCkpLmNzcyh7IHdpZHRoOiBpLndpbmRvd0RpbXMud2lkdGggLSAyICogdGhpcy5vcHRpb25zLmhPZmZzZXQsIGhlaWdodDogXFxcImF1dG9cXFwiIH0pLCAhMTtmb3IgKHRoaXMudGVtcGxhdGUub2Zmc2V0KEZvdW5kYXRpb24uQm94LkdldE9mZnNldHModGhpcy50ZW1wbGF0ZSwgdGhpcy4kZWxlbWVudCwgXFxcImNlbnRlciBcXFwiICsgKHQgfHwgXFxcImJvdHRvbVxcXCIpLCB0aGlzLm9wdGlvbnMudk9mZnNldCwgdGhpcy5vcHRpb25zLmhPZmZzZXQpKTsgIUZvdW5kYXRpb24uQm94LkltTm90VG91Y2hpbmdZb3UodGhpcy50ZW1wbGF0ZSkgJiYgdGhpcy5jb3VudGVyOykge1xcbiAgICAgICAgICB0aGlzLl9yZXBvc2l0aW9uKHQpLCB0aGlzLl9zZXRQb3NpdGlvbigpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJzaG93XFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgaWYgKFxcXCJhbGxcXFwiICE9PSB0aGlzLm9wdGlvbnMuc2hvd09uICYmICFGb3VuZGF0aW9uLk1lZGlhUXVlcnkuYXRMZWFzdCh0aGlzLm9wdGlvbnMuc2hvd09uKSkgcmV0dXJuICExO3ZhciB0ID0gdGhpczt0aGlzLnRlbXBsYXRlLmNzcyhcXFwidmlzaWJpbGl0eVxcXCIsIFxcXCJoaWRkZW5cXFwiKS5zaG93KCksIHRoaXMuX3NldFBvc2l0aW9uKCksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiY2xvc2VtZS56Zi50b29sdGlwXFxcIiwgdGhpcy50ZW1wbGF0ZS5hdHRyKFxcXCJpZFxcXCIpKSwgdGhpcy50ZW1wbGF0ZS5hdHRyKHsgXFxcImRhdGEtaXMtYWN0aXZlXFxcIjogITAsIFxcXCJhcmlhLWhpZGRlblxcXCI6ICExIH0pLCB0LmlzQWN0aXZlID0gITAsIHRoaXMudGVtcGxhdGUuc3RvcCgpLmhpZGUoKS5jc3MoXFxcInZpc2liaWxpdHlcXFwiLCBcXFwiXFxcIikuZmFkZUluKHRoaXMub3B0aW9ucy5mYWRlSW5EdXJhdGlvbiwgZnVuY3Rpb24gKCkge30pLCB0aGlzLiRlbGVtZW50LnRyaWdnZXIoXFxcInNob3cuemYudG9vbHRpcFxcXCIpO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJoaWRlXFxcIiwgdmFsdWU6IGZ1bmN0aW9uIHZhbHVlKCkge1xcbiAgICAgICAgdmFyIHQgPSB0aGlzO3RoaXMudGVtcGxhdGUuc3RvcCgpLmF0dHIoeyBcXFwiYXJpYS1oaWRkZW5cXFwiOiAhMCwgXFxcImRhdGEtaXMtYWN0aXZlXFxcIjogITEgfSkuZmFkZU91dCh0aGlzLm9wdGlvbnMuZmFkZU91dER1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHQuaXNBY3RpdmUgPSAhMSwgdC5pc0NsaWNrID0gITEsIHQuY2xhc3NDaGFuZ2VkICYmICh0LnRlbXBsYXRlLnJlbW92ZUNsYXNzKHQuX2dldFBvc2l0aW9uQ2xhc3ModC50ZW1wbGF0ZSkpLmFkZENsYXNzKHQub3B0aW9ucy5wb3NpdGlvbkNsYXNzKSwgdC51c2VkUG9zaXRpb25zID0gW10sIHQuY291bnRlciA9IDQsIHQuY2xhc3NDaGFuZ2VkID0gITEpO1xcbiAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQudHJpZ2dlcihcXFwiaGlkZS56Zi50b29sdGlwXFxcIik7XFxuICAgICAgfSB9LCB7IGtleTogXFxcIl9ldmVudHNcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB2YXIgdCA9IHRoaXMsXFxuICAgICAgICAgICAgZSA9ICh0aGlzLnRlbXBsYXRlLCAhMSk7dGhpcy5vcHRpb25zLmRpc2FibGVIb3ZlciB8fCB0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWVudGVyLnpmLnRvb2x0aXBcXFwiLCBmdW5jdGlvbiAoZSkge1xcbiAgICAgICAgICB0LmlzQWN0aXZlIHx8ICh0LnRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgICB0LnNob3coKTtcXG4gICAgICAgICAgfSwgdC5vcHRpb25zLmhvdmVyRGVsYXkpKTtcXG4gICAgICAgIH0pLm9uKFxcXCJtb3VzZWxlYXZlLnpmLnRvb2x0aXBcXFwiLCBmdW5jdGlvbiAoaSkge1xcbiAgICAgICAgICBjbGVhclRpbWVvdXQodC50aW1lb3V0KSwgKCFlIHx8IHQuaXNDbGljayAmJiAhdC5vcHRpb25zLmNsaWNrT3BlbikgJiYgdC5oaWRlKCk7XFxuICAgICAgICB9KSwgdGhpcy5vcHRpb25zLmNsaWNrT3BlbiA/IHRoaXMuJGVsZW1lbnQub24oXFxcIm1vdXNlZG93bi56Zi50b29sdGlwXFxcIiwgZnVuY3Rpb24gKGUpIHtcXG4gICAgICAgICAgZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKSwgdC5pc0NsaWNrIHx8ICh0LmlzQ2xpY2sgPSAhMCwgIXQub3B0aW9ucy5kaXNhYmxlSG92ZXIgJiYgdC4kZWxlbWVudC5hdHRyKFxcXCJ0YWJpbmRleFxcXCIpIHx8IHQuaXNBY3RpdmUgfHwgdC5zaG93KCkpO1xcbiAgICAgICAgfSkgOiB0aGlzLiRlbGVtZW50Lm9uKFxcXCJtb3VzZWRvd24uemYudG9vbHRpcFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCksIHQuaXNDbGljayA9ICEwO1xcbiAgICAgICAgfSksIHRoaXMub3B0aW9ucy5kaXNhYmxlRm9yVG91Y2ggfHwgdGhpcy4kZWxlbWVudC5vbihcXFwidGFwLnpmLnRvb2x0aXAgdG91Y2hlbmQuemYudG9vbHRpcFxcXCIsIGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHQuaXNBY3RpdmUgPyB0LmhpZGUoKSA6IHQuc2hvdygpO1xcbiAgICAgICAgfSksIHRoaXMuJGVsZW1lbnQub24oeyBcXFwiY2xvc2UuemYudHJpZ2dlclxcXCI6IHRoaXMuaGlkZS5iaW5kKHRoaXMpIH0pLCB0aGlzLiRlbGVtZW50Lm9uKFxcXCJmb2N1cy56Zi50b29sdGlwXFxcIiwgZnVuY3Rpb24gKGkpIHtcXG4gICAgICAgICAgcmV0dXJuIGUgPSAhMCwgdC5pc0NsaWNrID8gKHQub3B0aW9ucy5jbGlja09wZW4gfHwgKGUgPSAhMSksICExKSA6IHZvaWQgdC5zaG93KCk7XFxuICAgICAgICB9KS5vbihcXFwiZm9jdXNvdXQuemYudG9vbHRpcFxcXCIsIGZ1bmN0aW9uIChpKSB7XFxuICAgICAgICAgIGUgPSAhMSwgdC5pc0NsaWNrID0gITEsIHQuaGlkZSgpO1xcbiAgICAgICAgfSkub24oXFxcInJlc2l6ZW1lLnpmLnRyaWdnZXJcXFwiLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgIHQuaXNBY3RpdmUgJiYgdC5fc2V0UG9zaXRpb24oKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0gfSwgeyBrZXk6IFxcXCJ0b2dnbGVcXFwiLCB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoKSB7XFxuICAgICAgICB0aGlzLmlzQWN0aXZlID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcXG4gICAgICB9IH0sIHsga2V5OiBcXFwiZGVzdHJveVxcXCIsIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICAgIHRoaXMuJGVsZW1lbnQuYXR0cihcXFwidGl0bGVcXFwiLCB0aGlzLnRlbXBsYXRlLnRleHQoKSkub2ZmKFxcXCIuemYudHJpZ2dlciAuemYudG9vdGlwXFxcIikucmVtb3ZlQXR0cihcXFwiYXJpYS1kZXNjcmliZWRieVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEteWV0aS1ib3hcXFwiKS5yZW1vdmVBdHRyKFxcXCJkYXRhLXRvZ2dsZVxcXCIpLnJlbW92ZUF0dHIoXFxcImRhdGEtcmVzaXplXFxcIiksIHRoaXMudGVtcGxhdGUucmVtb3ZlKCksIEZvdW5kYXRpb24udW5yZWdpc3RlclBsdWdpbih0aGlzKTtcXG4gICAgICB9IH1dKSwgZTtcXG4gIH0oKTtlLmRlZmF1bHRzID0geyBkaXNhYmxlRm9yVG91Y2g6ICExLCBob3ZlckRlbGF5OiAyMDAsIGZhZGVJbkR1cmF0aW9uOiAxNTAsIGZhZGVPdXREdXJhdGlvbjogMTUwLCBkaXNhYmxlSG92ZXI6ICExLCB0ZW1wbGF0ZUNsYXNzZXM6IFxcXCJcXFwiLCB0b29sdGlwQ2xhc3M6IFxcXCJ0b29sdGlwXFxcIiwgdHJpZ2dlckNsYXNzOiBcXFwiaGFzLXRpcFxcXCIsIHNob3dPbjogXFxcInNtYWxsXFxcIiwgdGVtcGxhdGU6IFxcXCJcXFwiLCB0aXBUZXh0OiBcXFwiXFxcIiwgdG91Y2hDbG9zZVRleHQ6IFxcXCJUYXAgdG8gY2xvc2UuXFxcIiwgY2xpY2tPcGVuOiAhMCwgcG9zaXRpb25DbGFzczogXFxcIlxcXCIsIHZPZmZzZXQ6IDEwLCBoT2Zmc2V0OiAxMiB9LCBGb3VuZGF0aW9uLnBsdWdpbihlLCBcXFwiVG9vbHRpcFxcXCIpO1xcbn0oalF1ZXJ5KTtcIlxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zY3JpcHQtbG9hZGVyL34vcmF3LWxvYWRlciEuL34vYmFiZWwtbG9hZGVyL2xpYj97XCJwcmVzZXRzXCI6W1wicmVhY3RcIixcImVzMjAxNVwiLFwic3RhZ2UtMFwiXSxcImNvbXBhY3RcIjpmYWxzZX0hLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvL2thZGEgc2Uga29yaXN0aSBXZWJwYWNrIHN2YWtpIGZpbGUgc2UgcG9uYcWhYSBpbmRpcGVuZG5vIHRlIGdhIGplIHBvdHJlYm5vIGltcG9ydGlyYXRpIGV4cGxpY2l0bm9cclxudmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIFJlYWN0RE9NID0gcmVxdWlyZSgncmVhY3QtZG9tJyk7XHJcbnZhciB7Um91dGUsIFJvdXRlciwgSW5kZXhSb3V0ZSwgaGFzaEhpc3Rvcnl9ID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XHJcblxyXG4vL2NvbXBvbmVudGVcclxudmFyIE1haW4gPSByZXF1aXJlKCdNYWluJyk7XHJcbnZhciBUaW1lciA9IHJlcXVpcmUoJ1RpbWVyJyk7XHJcbnZhciBDb3VudGRvd24gPSByZXF1aXJlKCdDb3VudGRvd24nKTtcclxuXHJcbi8vTG9hZCBmb3VuZGF0aW9uXHJcbnJlcXVpcmUoJ3N0eWxlIWNzcyFmb3VuZGF0aW9uLXNpdGVzL2Rpc3QvZm91bmRhdGlvbi5taW4uY3NzJylcclxuJChkb2N1bWVudCkuZm91bmRhdGlvbigpO1xyXG5cclxuLy9BcHAgY3NzXHJcbnJlcXVpcmUoJ3N0eWxlIWNzcyFzYXNzIWFwbGljYXRpb25TdHlsZXMnKVxyXG5cclxuUmVhY3RET00ucmVuZGVyKFxyXG4gICAgPFJvdXRlciBoaXN0b3J5PXtoYXNoSGlzdG9yeX0+XHJcbiAgICAgICAgPFJvdXRlIHBhdGg9XCIvXCIgY29tcG9uZW50PXtNYWlufT5cclxuICAgICAgICAgICAgPFJvdXRlIHBhdGg9XCJjb3VudGRvd25cIiBjb21wb25lbnQ9e0NvdW50ZG93bn0gLz5cclxuICAgICAgICAgICAgPEluZGV4Um91dGUgY29tcG9uZW50PXtUaW1lcn0gLz5cclxuICAgICAgICA8L1JvdXRlPlxyXG4gICAgPC9Sb3V0ZXI+LFxyXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2FwcCcpXHJcbik7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9hcHAuanN4IiwibW9kdWxlLmV4cG9ydHMgPSBqUXVlcnk7XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gZXh0ZXJuYWwgXCJqUXVlcnlcIlxuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvUmVhY3QnKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvcmVhY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoJy4vUmVhY3RET00nKTtcbnZhciBSZWFjdERPTVNlcnZlciA9IHJlcXVpcmUoJy4vUmVhY3RET01TZXJ2ZXInKTtcbnZhciBSZWFjdElzb21vcnBoaWMgPSByZXF1aXJlKCcuL1JlYWN0SXNvbW9ycGhpYycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZGVwcmVjYXRlZCA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlZCcpO1xuXG4vLyBgdmVyc2lvbmAgd2lsbCBiZSBhZGRlZCBoZXJlIGJ5IFJlYWN0SXNvbW9ycGhpYy5cbnZhciBSZWFjdCA9IHt9O1xuXG5hc3NpZ24oUmVhY3QsIFJlYWN0SXNvbW9ycGhpYyk7XG5cbmFzc2lnbihSZWFjdCwge1xuICAvLyBSZWFjdERPTVxuICBmaW5kRE9NTm9kZTogZGVwcmVjYXRlZCgnZmluZERPTU5vZGUnLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLmZpbmRET01Ob2RlKSxcbiAgcmVuZGVyOiBkZXByZWNhdGVkKCdyZW5kZXInLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLnJlbmRlciksXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IGRlcHJlY2F0ZWQoJ3VubW91bnRDb21wb25lbnRBdE5vZGUnLCAnUmVhY3RET00nLCAncmVhY3QtZG9tJywgUmVhY3RET00sIFJlYWN0RE9NLnVubW91bnRDb21wb25lbnRBdE5vZGUpLFxuXG4gIC8vIFJlYWN0RE9NU2VydmVyXG4gIHJlbmRlclRvU3RyaW5nOiBkZXByZWNhdGVkKCdyZW5kZXJUb1N0cmluZycsICdSZWFjdERPTVNlcnZlcicsICdyZWFjdC1kb20vc2VydmVyJywgUmVhY3RET01TZXJ2ZXIsIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKSxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IGRlcHJlY2F0ZWQoJ3JlbmRlclRvU3RhdGljTWFya3VwJywgJ1JlYWN0RE9NU2VydmVyJywgJ3JlYWN0LWRvbS9zZXJ2ZXInLCBSZWFjdERPTVNlcnZlciwgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdGF0aWNNYXJrdXApXG59KTtcblxuUmVhY3QuX19TRUNSRVRfRE9NX0RPX05PVF9VU0VfT1JfWU9VX1dJTExfQkVfRklSRUQgPSBSZWFjdERPTTtcblJlYWN0Ll9fU0VDUkVUX0RPTV9TRVJWRVJfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRCA9IFJlYWN0RE9NU2VydmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NXG4gKi9cblxuLyogZ2xvYmFscyBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xudmFyIFJlYWN0VmVyc2lvbiA9IHJlcXVpcmUoJy4vUmVhY3RWZXJzaW9uJyk7XG5cbnZhciBmaW5kRE9NTm9kZSA9IHJlcXVpcmUoJy4vZmluZERPTU5vZGUnKTtcbnZhciByZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lciA9IHJlcXVpcmUoJy4vcmVuZGVyU3VidHJlZUludG9Db250YWluZXInKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5SZWFjdERlZmF1bHRJbmplY3Rpb24uaW5qZWN0KCk7XG5cbnZhciByZW5kZXIgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3QnLCAncmVuZGVyJywgUmVhY3RNb3VudC5yZW5kZXIpO1xuXG52YXIgUmVhY3QgPSB7XG4gIGZpbmRET01Ob2RlOiBmaW5kRE9NTm9kZSxcbiAgcmVuZGVyOiByZW5kZXIsXG4gIHVubW91bnRDb21wb25lbnRBdE5vZGU6IFJlYWN0TW91bnQudW5tb3VudENvbXBvbmVudEF0Tm9kZSxcbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8qIGVzbGludC1kaXNhYmxlIGNhbWVsY2FzZSAqL1xuICB1bnN0YWJsZV9iYXRjaGVkVXBkYXRlczogUmVhY3RVcGRhdGVzLmJhdGNoZWRVcGRhdGVzLFxuICB1bnN0YWJsZV9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogcmVuZGVyU3VidHJlZUludG9Db250YWluZXJcbn07XG5cbi8vIEluamVjdCB0aGUgcnVudGltZSBpbnRvIGEgZGV2dG9vbHMgZ2xvYmFsIGhvb2sgcmVnYXJkbGVzcyBvZiBicm93c2VyLlxuLy8gQWxsb3dzIGZvciBkZWJ1Z2dpbmcgd2hlbiB0aGUgaG9vayBpcyBpbmplY3RlZCBvbiB0aGUgcGFnZS5cbi8qIGVzbGludC1lbmFibGUgY2FtZWxjYXNlICovXG5pZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5pbmplY3QgPT09ICdmdW5jdGlvbicpIHtcbiAgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fLmluamVjdCh7XG4gICAgQ3VycmVudE93bmVyOiBSZWFjdEN1cnJlbnRPd25lcixcbiAgICBJbnN0YW5jZUhhbmRsZXM6IFJlYWN0SW5zdGFuY2VIYW5kbGVzLFxuICAgIE1vdW50OiBSZWFjdE1vdW50LFxuICAgIFJlY29uY2lsZXI6IFJlYWN0UmVjb25jaWxlcixcbiAgICBUZXh0Q29tcG9uZW50OiBSZWFjdERPTVRleHRDb21wb25lbnRcbiAgfSk7XG59XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG4gIGlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LnRvcCA9PT0gd2luZG93LnNlbGYpIHtcblxuICAgIC8vIEZpcnN0IGNoZWNrIGlmIGRldnRvb2xzIGlzIG5vdCBpbnN0YWxsZWRcbiAgICBpZiAodHlwZW9mIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIC8vIElmIHdlJ3JlIGluIENocm9tZSBvciBGaXJlZm94LCBwcm92aWRlIGEgZG93bmxvYWQgbGluayBpZiBub3QgaW5zdGFsbGVkLlxuICAgICAgaWYgKG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignQ2hyb21lJykgPiAtMSAmJiBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0VkZ2UnKSA9PT0gLTEgfHwgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdGaXJlZm94JykgPiAtMSkge1xuICAgICAgICBjb25zb2xlLmRlYnVnKCdEb3dubG9hZCB0aGUgUmVhY3QgRGV2VG9vbHMgZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6ICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1kZXZ0b29scycpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHdlJ3JlIGluIElFOCwgY2hlY2sgdG8gc2VlIGlmIHdlIGFyZSBpbiBjb21wYXRpYmlsaXR5IG1vZGUgYW5kIHByb3ZpZGVcbiAgICAvLyBpbmZvcm1hdGlvbiBvbiBwcmV2ZW50aW5nIGNvbXBhdGliaWxpdHkgbW9kZVxuICAgIHZhciBpZUNvbXBhdGliaWxpdHlNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlICYmIGRvY3VtZW50LmRvY3VtZW50TW9kZSA8IDg7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaWVDb21wYXRpYmlsaXR5TW9kZSwgJ0ludGVybmV0IEV4cGxvcmVyIGlzIHJ1bm5pbmcgaW4gY29tcGF0aWJpbGl0eSBtb2RlOyBwbGVhc2UgYWRkIHRoZSAnICsgJ2ZvbGxvd2luZyB0YWcgdG8geW91ciBIVE1MIHRvIHByZXZlbnQgdGhpcyBmcm9tIGhhcHBlbmluZzogJyArICc8bWV0YSBodHRwLWVxdWl2PVwiWC1VQS1Db21wYXRpYmxlXCIgY29udGVudD1cIklFPWVkZ2VcIiAvPicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGV4cGVjdGVkRmVhdHVyZXMgPSBbXG4gICAgLy8gc2hpbXNcbiAgICBBcnJheS5pc0FycmF5LCBBcnJheS5wcm90b3R5cGUuZXZlcnksIEFycmF5LnByb3RvdHlwZS5mb3JFYWNoLCBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgQXJyYXkucHJvdG90eXBlLm1hcCwgRGF0ZS5ub3csIEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kLCBPYmplY3Qua2V5cywgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgU3RyaW5nLnByb3RvdHlwZS50cmltLFxuXG4gICAgLy8gc2hhbXNcbiAgICBPYmplY3QuY3JlYXRlLCBPYmplY3QuZnJlZXplXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRGZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFleHBlY3RlZEZlYXR1cmVzW2ldKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ09uZSBvciBtb3JlIEVTNSBzaGltL3NoYW1zIGV4cGVjdGVkIGJ5IFJlYWN0IGFyZSBub3QgYXZhaWxhYmxlOiAnICsgJ2h0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1wb2x5ZmlsbHMnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET00uanMiLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9+L25vZGUtbGlicy1icm93c2VyL34vcHJvY2Vzcy9icm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q3VycmVudE93bmVyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEtlZXBzIHRyYWNrIG9mIHRoZSBjdXJyZW50IG93bmVyLlxuICpcbiAqIFRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBjb21wb25lbnQgd2hvIHNob3VsZCBvd24gYW55IGNvbXBvbmVudHMgdGhhdCBhcmVcbiAqIGN1cnJlbnRseSBiZWluZyBjb25zdHJ1Y3RlZC5cbiAqL1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0ge1xuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHR5cGUge1JlYWN0Q29tcG9uZW50fVxuICAgKi9cbiAgY3VycmVudDogbnVsbFxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q3VycmVudE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q3VycmVudE93bmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NVGV4dENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01DaGlsZHJlbk9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTUNoaWxkcmVuT3BlcmF0aW9ucycpO1xudmFyIERPTVByb3BlcnR5T3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHlPcGVyYXRpb25zJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyID0gcmVxdWlyZSgnLi9lc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXInKTtcbnZhciBzZXRUZXh0Q29udGVudCA9IHJlcXVpcmUoJy4vc2V0VGV4dENvbnRlbnQnKTtcbnZhciB2YWxpZGF0ZURPTU5lc3RpbmcgPSByZXF1aXJlKCcuL3ZhbGlkYXRlRE9NTmVzdGluZycpO1xuXG4vKipcbiAqIFRleHQgbm9kZXMgdmlvbGF0ZSBhIGNvdXBsZSBhc3N1bXB0aW9ucyB0aGF0IFJlYWN0IG1ha2VzIGFib3V0IGNvbXBvbmVudHM6XG4gKlxuICogIC0gV2hlbiBtb3VudGluZyB0ZXh0IGludG8gdGhlIERPTSwgYWRqYWNlbnQgdGV4dCBub2RlcyBhcmUgbWVyZ2VkLlxuICogIC0gVGV4dCBub2RlcyBjYW5ub3QgYmUgYXNzaWduZWQgYSBSZWFjdCByb290IElELlxuICpcbiAqIFRoaXMgY29tcG9uZW50IGlzIHVzZWQgdG8gd3JhcCBzdHJpbmdzIGluIGVsZW1lbnRzIHNvIHRoYXQgdGhleSBjYW4gdW5kZXJnb1xuICogdGhlIHNhbWUgcmVjb25jaWxpYXRpb24gdGhhdCBpcyBhcHBsaWVkIHRvIGVsZW1lbnRzLlxuICpcbiAqIFRPRE86IEludmVzdGlnYXRlIHJlcHJlc2VudGluZyBSZWFjdCBjb21wb25lbnRzIGluIHRoZSBET00gd2l0aCB0ZXh0IG5vZGVzLlxuICpcbiAqIEBjbGFzcyBSZWFjdERPTVRleHRDb21wb25lbnRcbiAqIEBleHRlbmRzIFJlYWN0Q29tcG9uZW50XG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0RE9NVGV4dENvbXBvbmVudCA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAvLyBUaGlzIGNvbnN0cnVjdG9yIGFuZCBpdHMgYXJndW1lbnQgaXMgY3VycmVudGx5IHVzZWQgYnkgbW9ja3MuXG59O1xuXG5hc3NpZ24oUmVhY3RET01UZXh0Q29tcG9uZW50LnByb3RvdHlwZSwge1xuXG4gIC8qKlxuICAgKiBAcGFyYW0ge1JlYWN0VGV4dH0gdGV4dFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKHRleHQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIHJlYWxseSBhIFJlYWN0VGV4dCAoUmVhY3ROb2RlKSwgbm90IGEgUmVhY3RFbGVtZW50XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSB0ZXh0O1xuICAgIHRoaXMuX3N0cmluZ1RleHQgPSAnJyArIHRleHQ7XG5cbiAgICAvLyBQcm9wZXJ0aWVzXG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRJbmRleCA9IDA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgdGhlIG1hcmt1cCBmb3IgdGhpcyB0ZXh0IG5vZGUuIFRoaXMgbm9kZSBpcyBub3QgaW50ZW5kZWQgdG8gaGF2ZVxuICAgKiBhbnkgZmVhdHVyZXMgYmVzaWRlcyBjb250YWluaW5nIHRleHQgY29udGVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIGZvciB0aGlzIHRleHQgbm9kZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKSB7XG4gICAgICAgIHZhbGlkYXRlRE9NTmVzdGluZygnc3BhbicsIG51bGwsIGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRBdHRyaWJ1dGVGb3JJRChlbCwgcm9vdElEKTtcbiAgICAgIC8vIFBvcHVsYXRlIG5vZGUgY2FjaGVcbiAgICAgIFJlYWN0TW91bnQuZ2V0SUQoZWwpO1xuICAgICAgc2V0VGV4dENvbnRlbnQoZWwsIHRoaXMuX3N0cmluZ1RleHQpO1xuICAgICAgcmV0dXJuIGVsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZXNjYXBlZFRleHQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIodGhpcy5fc3RyaW5nVGV4dCk7XG5cbiAgICAgIGlmICh0cmFuc2FjdGlvbi5yZW5kZXJUb1N0YXRpY01hcmt1cCkge1xuICAgICAgICAvLyBOb3JtYWxseSB3ZSdkIHdyYXAgdGhpcyBpbiBhIGBzcGFuYCBmb3IgdGhlIHJlYXNvbnMgc3RhdGVkIGFib3ZlLCBidXRcbiAgICAgICAgLy8gc2luY2UgdGhpcyBpcyBhIHNpdHVhdGlvbiB3aGVyZSBSZWFjdCB3b24ndCB0YWtlIG92ZXIgKHN0YXRpYyBwYWdlcyksXG4gICAgICAgIC8vIHdlIGNhbiBzaW1wbHkgcmV0dXJuIHRoZSB0ZXh0IGFzIGl0IGlzLlxuICAgICAgICByZXR1cm4gZXNjYXBlZFRleHQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAnPHNwYW4gJyArIERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JJRChyb290SUQpICsgJz4nICsgZXNjYXBlZFRleHQgKyAnPC9zcGFuPic7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoaXMgY29tcG9uZW50IGJ5IHVwZGF0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RUZXh0fSBuZXh0VGV4dCBUaGUgbmV4dCB0ZXh0IGNvbnRlbnRcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0VGV4dCwgdHJhbnNhY3Rpb24pIHtcbiAgICBpZiAobmV4dFRleHQgIT09IHRoaXMuX2N1cnJlbnRFbGVtZW50KSB7XG4gICAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRUZXh0O1xuICAgICAgdmFyIG5leHRTdHJpbmdUZXh0ID0gJycgKyBuZXh0VGV4dDtcbiAgICAgIGlmIChuZXh0U3RyaW5nVGV4dCAhPT0gdGhpcy5fc3RyaW5nVGV4dCkge1xuICAgICAgICAvLyBUT0RPOiBTYXZlIHRoaXMgYXMgcGVuZGluZyBwcm9wcyBhbmQgdXNlIHBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeVxuICAgICAgICAvLyBhbmQvb3IgdXBkYXRlQ29tcG9uZW50IHRvIGRvIHRoZSBhY3R1YWwgdXBkYXRlIGZvciBjb25zaXN0ZW5jeSB3aXRoXG4gICAgICAgIC8vIG90aGVyIGNvbXBvbmVudCB0eXBlcz9cbiAgICAgICAgdGhpcy5fc3RyaW5nVGV4dCA9IG5leHRTdHJpbmdUZXh0O1xuICAgICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnVwZGF0ZVRleHRDb250ZW50KG5vZGUsIG5leHRTdHJpbmdUZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTVRleHRDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTUNoaWxkcmVuT3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBEYW5nZXIgPSByZXF1aXJlKCcuL0RhbmdlcicpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIEluc2VydHMgYGNoaWxkTm9kZWAgYXMgYSBjaGlsZCBvZiBgcGFyZW50Tm9kZWAgYXQgdGhlIGBpbmRleGAuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBwYXJlbnROb2RlIFBhcmVudCBub2RlIGluIHdoaWNoIHRvIGluc2VydC5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY2hpbGROb2RlIENoaWxkIG5vZGUgdG8gaW5zZXJ0LlxuICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaW5zZXJ0Q2hpbGRBdChwYXJlbnROb2RlLCBjaGlsZE5vZGUsIGluZGV4KSB7XG4gIC8vIEJ5IGV4cGxvaXRpbmcgYXJyYXlzIHJldHVybmluZyBgdW5kZWZpbmVkYCBmb3IgYW4gdW5kZWZpbmVkIGluZGV4LCB3ZSBjYW5cbiAgLy8gcmVseSBleGNsdXNpdmVseSBvbiBgaW5zZXJ0QmVmb3JlKG5vZGUsIG51bGwpYCBpbnN0ZWFkIG9mIGFsc28gdXNpbmdcbiAgLy8gYGFwcGVuZENoaWxkKG5vZGUpYC4gSG93ZXZlciwgdXNpbmcgYHVuZGVmaW5lZGAgaXMgbm90IGFsbG93ZWQgYnkgYWxsXG4gIC8vIGJyb3dzZXJzIHNvIHdlIG11c3QgcmVwbGFjZSBpdCB3aXRoIGBudWxsYC5cblxuICAvLyBmaXggcmVuZGVyIG9yZGVyIGVycm9yIGluIHNhZmFyaVxuICAvLyBJRTggd2lsbCB0aHJvdyBlcnJvciB3aGVuIGluZGV4IG91dCBvZiBsaXN0IHNpemUuXG4gIHZhciBiZWZvcmVDaGlsZCA9IGluZGV4ID49IHBhcmVudE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPyBudWxsIDogcGFyZW50Tm9kZS5jaGlsZE5vZGVzLml0ZW0oaW5kZXgpO1xuXG4gIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkTm9kZSwgYmVmb3JlQ2hpbGQpO1xufVxuXG4vKipcbiAqIE9wZXJhdGlvbnMgZm9yIHVwZGF0aW5nIHdpdGggRE9NIGNoaWxkcmVuLlxuICovXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0ge1xuXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwOiBEYW5nZXIuZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAsXG5cbiAgdXBkYXRlVGV4dENvbnRlbnQ6IHNldFRleHRDb250ZW50LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgY29tcG9uZW50J3MgY2hpbGRyZW4gYnkgcHJvY2Vzc2luZyBhIHNlcmllcyBvZiB1cGRhdGVzLiBUaGVcbiAgICogdXBkYXRlIGNvbmZpZ3VyYXRpb25zIGFyZSBlYWNoIGV4cGVjdGVkIHRvIGhhdmUgYSBgcGFyZW50Tm9kZWAgcHJvcGVydHkuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJvY2Vzc1VwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXBMaXN0KSB7XG4gICAgdmFyIHVwZGF0ZTtcbiAgICAvLyBNYXBwaW5nIGZyb20gcGFyZW50IElEcyB0byBpbml0aWFsIGNoaWxkIG9yZGVyaW5ncy5cbiAgICB2YXIgaW5pdGlhbENoaWxkcmVuID0gbnVsbDtcbiAgICAvLyBMaXN0IG9mIGNoaWxkcmVuIHRoYXQgd2lsbCBiZSBtb3ZlZCBvciByZW1vdmVkLlxuICAgIHZhciB1cGRhdGVkQ2hpbGRyZW4gPSBudWxsO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1cGRhdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2ldO1xuICAgICAgaWYgKHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5NT1ZFX0VYSVNUSU5HIHx8IHVwZGF0ZS50eXBlID09PSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5SRU1PVkVfTk9ERSkge1xuICAgICAgICB2YXIgdXBkYXRlZEluZGV4ID0gdXBkYXRlLmZyb21JbmRleDtcbiAgICAgICAgdmFyIHVwZGF0ZWRDaGlsZCA9IHVwZGF0ZS5wYXJlbnROb2RlLmNoaWxkTm9kZXNbdXBkYXRlZEluZGV4XTtcbiAgICAgICAgdmFyIHBhcmVudElEID0gdXBkYXRlLnBhcmVudElEO1xuXG4gICAgICAgICF1cGRhdGVkQ2hpbGQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc1VwZGF0ZXMoKTogVW5hYmxlIHRvIGZpbmQgY2hpbGQgJXMgb2YgZWxlbWVudC4gVGhpcyAnICsgJ3Byb2JhYmx5IG1lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgJyArICdicm93c2VyKSwgdXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsICcgKyAnbmVzdGluZyB0YWdzIGxpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyAnICsgJ2luIGFuIDxzdmc+IHBhcmVudC4gVHJ5IGluc3BlY3RpbmcgdGhlIGNoaWxkIG5vZGVzIG9mIHRoZSBlbGVtZW50ICcgKyAnd2l0aCBSZWFjdCBJRCBgJXNgLicsIHVwZGF0ZWRJbmRleCwgcGFyZW50SUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpbml0aWFsQ2hpbGRyZW4gPSBpbml0aWFsQ2hpbGRyZW4gfHwge307XG4gICAgICAgIGluaXRpYWxDaGlsZHJlbltwYXJlbnRJRF0gPSBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdIHx8IFtdO1xuICAgICAgICBpbml0aWFsQ2hpbGRyZW5bcGFyZW50SURdW3VwZGF0ZWRJbmRleF0gPSB1cGRhdGVkQ2hpbGQ7XG5cbiAgICAgICAgdXBkYXRlZENoaWxkcmVuID0gdXBkYXRlZENoaWxkcmVuIHx8IFtdO1xuICAgICAgICB1cGRhdGVkQ2hpbGRyZW4ucHVzaCh1cGRhdGVkQ2hpbGQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciByZW5kZXJlZE1hcmt1cDtcbiAgICAvLyBtYXJrdXBMaXN0IGlzIGVpdGhlciBhIGxpc3Qgb2YgbWFya3VwIG9yIGp1c3QgYSBsaXN0IG9mIGVsZW1lbnRzXG4gICAgaWYgKG1hcmt1cExpc3QubGVuZ3RoICYmIHR5cGVvZiBtYXJrdXBMaXN0WzBdID09PSAnc3RyaW5nJykge1xuICAgICAgcmVuZGVyZWRNYXJrdXAgPSBEYW5nZXIuZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAobWFya3VwTGlzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbmRlcmVkTWFya3VwID0gbWFya3VwTGlzdDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdXBkYXRlZCBjaGlsZHJlbiBmaXJzdCBzbyB0aGF0IGB0b0luZGV4YCBpcyBjb25zaXN0ZW50LlxuICAgIGlmICh1cGRhdGVkQ2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdXBkYXRlZENoaWxkcmVuLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHVwZGF0ZWRDaGlsZHJlbltqXS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHVwZGF0ZWRDaGlsZHJlbltqXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCB1cGRhdGVzLmxlbmd0aDsgaysrKSB7XG4gICAgICB1cGRhdGUgPSB1cGRhdGVzW2tdO1xuICAgICAgc3dpdGNoICh1cGRhdGUudHlwZSkge1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVA6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgcmVuZGVyZWRNYXJrdXBbdXBkYXRlLm1hcmt1cEluZGV4XSwgdXBkYXRlLnRvSW5kZXgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLk1PVkVfRVhJU1RJTkc6XG4gICAgICAgICAgaW5zZXJ0Q2hpbGRBdCh1cGRhdGUucGFyZW50Tm9kZSwgaW5pdGlhbENoaWxkcmVuW3VwZGF0ZS5wYXJlbnRJRF1bdXBkYXRlLmZyb21JbmRleF0sIHVwZGF0ZS50b0luZGV4KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQOlxuICAgICAgICAgIHNldElubmVySFRNTCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlRFWFRfQ09OVEVOVDpcbiAgICAgICAgICBzZXRUZXh0Q29udGVudCh1cGRhdGUucGFyZW50Tm9kZSwgdXBkYXRlLmNvbnRlbnQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFOlxuICAgICAgICAgIC8vIEFscmVhZHkgcmVtb3ZlZCBieSB0aGUgZm9yLWxvb3AgYWJvdmUuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhET01DaGlsZHJlbk9wZXJhdGlvbnMsICdET01DaGlsZHJlbk9wZXJhdGlvbnMnLCB7XG4gIHVwZGF0ZVRleHRDb250ZW50OiAndXBkYXRlVGV4dENvbnRlbnQnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01DaGlsZHJlbk9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERhbmdlclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBjcmVhdGVOb2Rlc0Zyb21NYXJrdXAgPSByZXF1aXJlKCdmYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAnKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldE1hcmt1cFdyYXAgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRNYXJrdXBXcmFwJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBPUEVOX1RBR19OQU1FX0VYUCA9IC9eKDxbXiBcXC8+XSspLztcbnZhciBSRVNVTFRfSU5ERVhfQVRUUiA9ICdkYXRhLWRhbmdlci1pbmRleCc7XG5cbi8qKlxuICogRXh0cmFjdHMgdGhlIGBub2RlTmFtZWAgZnJvbSBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogTk9URTogRXh0cmFjdGluZyB0aGUgYG5vZGVOYW1lYCBkb2VzIG5vdCByZXF1aXJlIGEgcmVndWxhciBleHByZXNzaW9uIG1hdGNoXG4gKiBiZWNhdXNlIHdlIG1ha2UgYXNzdW1wdGlvbnMgYWJvdXQgUmVhY3QtZ2VuZXJhdGVkIG1hcmt1cCAoaS5lLiB0aGVyZSBhcmUgbm9cbiAqIHNwYWNlcyBzdXJyb3VuZGluZyB0aGUgb3BlbmluZyB0YWcgYW5kIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBhdHRyaWJ1dGUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgU3RyaW5nIG9mIG1hcmt1cC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2V4dHJhY3Qtbm9kZW5hbWVcbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU5hbWUobWFya3VwKSB7XG4gIHJldHVybiBtYXJrdXAuc3Vic3RyaW5nKDEsIG1hcmt1cC5pbmRleE9mKCcgJykpO1xufVxuXG52YXIgRGFuZ2VyID0ge1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIG1hcmt1cCBpbnRvIGFuIGFycmF5IG9mIG5vZGVzLiBUaGUgbWFya3VwIGlzIGV4cGVjdGVkIHRvIHJlbmRlclxuICAgKiBpbnRvIGEgbGlzdCBvZiByb290IG5vZGVzLiBBbHNvLCB0aGUgbGVuZ3RoIG9mIGByZXN1bHRMaXN0YCBhbmRcbiAgICogYG1hcmt1cExpc3RgIHNob3VsZCBiZSB0aGUgc2FtZS5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXBMaXN0IExpc3Qgb2YgbWFya3VwIHN0cmluZ3MgdG8gcmVuZGVyLlxuICAgKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50Pn0gTGlzdCBvZiByZW5kZXJlZCBub2Rlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVJlbmRlck1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cExpc3QpIHtcbiAgICAhRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVuZGVyTWFya3VwKC4uLik6IENhbm5vdCByZW5kZXIgbWFya3VwIGluIGEgd29ya2VyICcgKyAndGhyZWFkLiBNYWtlIHN1cmUgYHdpbmRvd2AgYW5kIGBkb2N1bWVudGAgYXJlIGF2YWlsYWJsZSBnbG9iYWxseSAnICsgJ2JlZm9yZSByZXF1aXJpbmcgUmVhY3Qgd2hlbiB1bml0IHRlc3Rpbmcgb3IgdXNlICcgKyAnUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBub2RlTmFtZTtcbiAgICB2YXIgbWFya3VwQnlOb2RlTmFtZSA9IHt9O1xuICAgIC8vIEdyb3VwIG1hcmt1cCBieSBgbm9kZU5hbWVgIGlmIGEgd3JhcCBpcyBuZWNlc3NhcnksIGVsc2UgYnkgJyonLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWFya3VwTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgIW1hcmt1cExpc3RbaV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZW5kZXJNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgbm9kZU5hbWUgPSBnZXROb2RlTmFtZShtYXJrdXBMaXN0W2ldKTtcbiAgICAgIG5vZGVOYW1lID0gZ2V0TWFya3VwV3JhcChub2RlTmFtZSkgPyBub2RlTmFtZSA6ICcqJztcbiAgICAgIG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdID0gbWFya3VwQnlOb2RlTmFtZVtub2RlTmFtZV0gfHwgW107XG4gICAgICBtYXJrdXBCeU5vZGVOYW1lW25vZGVOYW1lXVtpXSA9IG1hcmt1cExpc3RbaV07XG4gICAgfVxuICAgIHZhciByZXN1bHRMaXN0ID0gW107XG4gICAgdmFyIHJlc3VsdExpc3RBc3NpZ25tZW50Q291bnQgPSAwO1xuICAgIGZvciAobm9kZU5hbWUgaW4gbWFya3VwQnlOb2RlTmFtZSkge1xuICAgICAgaWYgKCFtYXJrdXBCeU5vZGVOYW1lLmhhc093blByb3BlcnR5KG5vZGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtYXJrdXBMaXN0QnlOb2RlTmFtZSA9IG1hcmt1cEJ5Tm9kZU5hbWVbbm9kZU5hbWVdO1xuXG4gICAgICAvLyBUaGlzIGZvci1pbiBsb29wIHNraXBzIHRoZSBob2xlcyBvZiB0aGUgc3BhcnNlIGFycmF5LiBUaGUgb3JkZXIgb2ZcbiAgICAgIC8vIGl0ZXJhdGlvbiBzaG91bGQgZm9sbG93IHRoZSBvcmRlciBvZiBhc3NpZ25tZW50LCB3aGljaCBoYXBwZW5zIHRvIG1hdGNoXG4gICAgICAvLyBudW1lcmljYWwgaW5kZXggb3JkZXIsIGJ1dCB3ZSBkb24ndCByZWx5IG9uIHRoYXQuXG4gICAgICB2YXIgcmVzdWx0SW5kZXg7XG4gICAgICBmb3IgKHJlc3VsdEluZGV4IGluIG1hcmt1cExpc3RCeU5vZGVOYW1lKSB7XG4gICAgICAgIGlmIChtYXJrdXBMaXN0QnlOb2RlTmFtZS5oYXNPd25Qcm9wZXJ0eShyZXN1bHRJbmRleCkpIHtcbiAgICAgICAgICB2YXIgbWFya3VwID0gbWFya3VwTGlzdEJ5Tm9kZU5hbWVbcmVzdWx0SW5kZXhdO1xuXG4gICAgICAgICAgLy8gUHVzaCB0aGUgcmVxdWVzdGVkIG1hcmt1cCB3aXRoIGFuIGFkZGl0aW9uYWwgUkVTVUxUX0lOREVYX0FUVFJcbiAgICAgICAgICAvLyBhdHRyaWJ1dGUuICBJZiB0aGUgbWFya3VwIGRvZXMgbm90IHN0YXJ0IHdpdGggYSA8IGNoYXJhY3RlciwgaXRcbiAgICAgICAgICAvLyB3aWxsIGJlIGRpc2NhcmRlZCBiZWxvdyAod2l0aCBhbiBhcHByb3ByaWF0ZSBjb25zb2xlLmVycm9yKS5cbiAgICAgICAgICBtYXJrdXBMaXN0QnlOb2RlTmFtZVtyZXN1bHRJbmRleF0gPSBtYXJrdXAucmVwbGFjZShPUEVOX1RBR19OQU1FX0VYUCxcbiAgICAgICAgICAvLyBUaGlzIGluZGV4IHdpbGwgYmUgcGFyc2VkIGJhY2sgb3V0IGJlbG93LlxuICAgICAgICAgICckMSAnICsgUkVTVUxUX0lOREVYX0FUVFIgKyAnPVwiJyArIHJlc3VsdEluZGV4ICsgJ1wiICcpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBlYWNoIGdyb3VwIG9mIG1hcmt1cCB3aXRoIHNpbWlsYXIgd3JhcHBpbmcgYG5vZGVOYW1lYC5cbiAgICAgIHZhciByZW5kZXJOb2RlcyA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXBMaXN0QnlOb2RlTmFtZS5qb2luKCcnKSwgZW1wdHlGdW5jdGlvbiAvLyBEbyBub3RoaW5nIHNwZWNpYWwgd2l0aCA8c2NyaXB0PiB0YWdzLlxuICAgICAgKTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByZW5kZXJOb2Rlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgcmVuZGVyTm9kZSA9IHJlbmRlck5vZGVzW2pdO1xuICAgICAgICBpZiAocmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUgJiYgcmVuZGVyTm9kZS5oYXNBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpKSB7XG5cbiAgICAgICAgICByZXN1bHRJbmRleCA9ICtyZW5kZXJOb2RlLmdldEF0dHJpYnV0ZShSRVNVTFRfSU5ERVhfQVRUUik7XG4gICAgICAgICAgcmVuZGVyTm9kZS5yZW1vdmVBdHRyaWJ1dGUoUkVTVUxUX0lOREVYX0FUVFIpO1xuXG4gICAgICAgICAgISFyZXN1bHRMaXN0Lmhhc093blByb3BlcnR5KHJlc3VsdEluZGV4KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IEFzc2lnbmluZyB0byBhbiBhbHJlYWR5LW9jY3VwaWVkIHJlc3VsdCBpbmRleC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICByZXN1bHRMaXN0W3Jlc3VsdEluZGV4XSA9IHJlbmRlck5vZGU7XG5cbiAgICAgICAgICAvLyBUaGlzIHNob3VsZCBtYXRjaCByZXN1bHRMaXN0Lmxlbmd0aCBhbmQgbWFya3VwTGlzdC5sZW5ndGggd2hlblxuICAgICAgICAgIC8vIHdlJ3JlIGRvbmUuXG4gICAgICAgICAgcmVzdWx0TGlzdEFzc2lnbm1lbnRDb3VudCArPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdEYW5nZXI6IERpc2NhcmRpbmcgdW5leHBlY3RlZCBub2RlOicsIHJlbmRlck5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWx0aG91Z2ggcmVzdWx0TGlzdCB3YXMgcG9wdWxhdGVkIG91dCBvZiBvcmRlciwgaXQgc2hvdWxkIG5vdyBiZSBhIGRlbnNlXG4gICAgLy8gYXJyYXkuXG4gICAgIShyZXN1bHRMaXN0QXNzaWdubWVudENvdW50ID09PSByZXN1bHRMaXN0Lmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRGFuZ2VyOiBEaWQgbm90IGFzc2lnbiB0byBldmVyeSBpbmRleCBvZiByZXN1bHRMaXN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICEocmVzdWx0TGlzdC5sZW5ndGggPT09IG1hcmt1cExpc3QubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdEYW5nZXI6IEV4cGVjdGVkIG1hcmt1cCB0byByZW5kZXIgJXMgbm9kZXMsIGJ1dCByZW5kZXJlZCAlcy4nLCBtYXJrdXBMaXN0Lmxlbmd0aCwgcmVzdWx0TGlzdC5sZW5ndGgpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHJldHVybiByZXN1bHRMaXN0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlcyBhIG5vZGUgd2l0aCBhIHN0cmluZyBvZiBtYXJrdXAgYXQgaXRzIGN1cnJlbnQgcG9zaXRpb24gd2l0aGluIGl0c1xuICAgKiBwYXJlbnQuIFRoZSBtYXJrdXAgbXVzdCByZW5kZXIgaW50byBhIHNpbmdsZSByb290IG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gb2xkQ2hpbGQgQ2hpbGQgbm9kZSB0byByZXBsYWNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIE1hcmt1cCB0byByZW5kZXIgaW4gcGxhY2Ugb2YgdGhlIGNoaWxkIG5vZGUuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXA6IGZ1bmN0aW9uIChvbGRDaGlsZCwgbWFya3VwKSB7XG4gICAgIUV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cCguLi4pOiBDYW5ub3QgcmVuZGVyIG1hcmt1cCBpbiBhICcgKyAnd29ya2VyIHRocmVhZC4gTWFrZSBzdXJlIGB3aW5kb3dgIGFuZCBgZG9jdW1lbnRgIGFyZSBhdmFpbGFibGUgJyArICdnbG9iYWxseSBiZWZvcmUgcmVxdWlyaW5nIFJlYWN0IHdoZW4gdW5pdCB0ZXN0aW5nIG9yIHVzZSAnICsgJ1JlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RyaW5nKCkgZm9yIHNlcnZlciByZW5kZXJpbmcuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICFtYXJrdXAgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZGFuZ2Vyb3VzbHlSZXBsYWNlTm9kZVdpdGhNYXJrdXAoLi4uKTogTWlzc2luZyBtYXJrdXAuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEob2xkQ2hpbGQudGFnTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnaHRtbCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2Rhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKC4uLik6IENhbm5vdCByZXBsYWNlIG1hcmt1cCBvZiB0aGUgJyArICc8aHRtbD4gbm9kZS4gVGhpcyBpcyBiZWNhdXNlIGJyb3dzZXIgcXVpcmtzIG1ha2UgdGhpcyB1bnJlbGlhYmxlICcgKyAnYW5kL29yIHNsb3cuIElmIHlvdSB3YW50IHRvIHJlbmRlciB0byB0aGUgcm9vdCB5b3UgbXVzdCB1c2UgJyArICdzZXJ2ZXIgcmVuZGVyaW5nLiBTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKS4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgbmV3Q2hpbGQ7XG4gICAgaWYgKHR5cGVvZiBtYXJrdXAgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuZXdDaGlsZCA9IGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGVtcHR5RnVuY3Rpb24pWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdDaGlsZCA9IG1hcmt1cDtcbiAgICB9XG4gICAgb2xkQ2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobmV3Q2hpbGQsIG9sZENoaWxkKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhbmdlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9EYW5nZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXhlY3V0aW9uRW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBjYW5Vc2VET00gPSAhISh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuZG9jdW1lbnQgJiYgd2luZG93LmRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xuXG4vKipcbiAqIFNpbXBsZSwgbGlnaHR3ZWlnaHQgbW9kdWxlIGFzc2lzdGluZyB3aXRoIHRoZSBkZXRlY3Rpb24gYW5kIGNvbnRleHQgb2ZcbiAqIFdvcmtlci4gSGVscHMgYXZvaWQgY2lyY3VsYXIgZGVwZW5kZW5jaWVzIGFuZCBhbGxvd3MgY29kZSB0byByZWFzb24gYWJvdXRcbiAqIHdoZXRoZXIgb3Igbm90IHRoZXkgYXJlIGluIGEgV29ya2VyLCBldmVuIGlmIHRoZXkgbmV2ZXIgaW5jbHVkZSB0aGUgbWFpblxuICogYFJlYWN0V29ya2VyYCBkZXBlbmRlbmN5LlxuICovXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSB7XG5cbiAgY2FuVXNlRE9NOiBjYW5Vc2VET00sXG5cbiAgY2FuVXNlV29ya2VyczogdHlwZW9mIFdvcmtlciAhPT0gJ3VuZGVmaW5lZCcsXG5cbiAgY2FuVXNlRXZlbnRMaXN0ZW5lcnM6IGNhblVzZURPTSAmJiAhISh3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciB8fCB3aW5kb3cuYXR0YWNoRXZlbnQpLFxuXG4gIGNhblVzZVZpZXdwb3J0OiBjYW5Vc2VET00gJiYgISF3aW5kb3cuc2NyZWVuLFxuXG4gIGlzSW5Xb3JrZXI6ICFjYW5Vc2VET00gLy8gRm9yIG5vdywgdGhpcyBpcyB0cnVlIC0gbWlnaHQgY2hhbmdlIGluIHRoZSBmdXR1cmUuXG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKmVzbGludC1kaXNhYmxlIGZiLXd3dy91bnNhZmUtaHRtbCovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY3JlYXRlQXJyYXlGcm9tTWl4ZWQgPSByZXF1aXJlKCcuL2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG52YXIgZ2V0TWFya3VwV3JhcCA9IHJlcXVpcmUoJy4vZ2V0TWFya3VwV3JhcCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRHVtbXkgY29udGFpbmVyIHVzZWQgdG8gcmVuZGVyIGFsbCBtYXJrdXAuXG4gKi9cbnZhciBkdW1teU5vZGUgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSA6IG51bGw7XG5cbi8qKlxuICogUGF0dGVybiB1c2VkIGJ5IGBnZXROb2RlTmFtZWAuXG4gKi9cbnZhciBub2RlTmFtZVBhdHRlcm4gPSAvXlxccyo8KFxcdyspLztcblxuLyoqXG4gKiBFeHRyYWN0cyB0aGUgYG5vZGVOYW1lYCBvZiB0aGUgZmlyc3QgZWxlbWVudCBpbiBhIHN0cmluZyBvZiBtYXJrdXAuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICogQHJldHVybiB7P3N0cmluZ30gTm9kZSBuYW1lIG9mIHRoZSBzdXBwbGllZCBtYXJrdXAuXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVOYW1lKG1hcmt1cCkge1xuICB2YXIgbm9kZU5hbWVNYXRjaCA9IG1hcmt1cC5tYXRjaChub2RlTmFtZVBhdHRlcm4pO1xuICByZXR1cm4gbm9kZU5hbWVNYXRjaCAmJiBub2RlTmFtZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBub2RlcyByZW5kZXJlZCBmcm9tIHRoZSBzdXBwbGllZCBtYXJrdXAuIFRoZVxuICogb3B0aW9uYWxseSBzdXBwbGllZCBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiB3aWxsIGJlIGludm9rZWQgb25jZSBmb3IgZWFjaFxuICogPHNjcmlwdD4gZWxlbWVudCB0aGF0IGlzIHJlbmRlcmVkLiBJZiBubyBgaGFuZGxlU2NyaXB0YCBmdW5jdGlvbiBpcyBzdXBwbGllZCxcbiAqIGFuIGV4Y2VwdGlvbiBpcyB0aHJvd24gaWYgYW55IDxzY3JpcHQ+IGVsZW1lbnRzIGFyZSByZW5kZXJlZC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIEEgc3RyaW5nIG9mIHZhbGlkIEhUTUwgbWFya3VwLlxuICogQHBhcmFtIHs/ZnVuY3Rpb259IGhhbmRsZVNjcmlwdCBJbnZva2VkIG9uY2UgZm9yIGVhY2ggcmVuZGVyZWQgPHNjcmlwdD4uXG4gKiBAcmV0dXJuIHthcnJheTxET01FbGVtZW50fERPTVRleHROb2RlPn0gQW4gYXJyYXkgb2YgcmVuZGVyZWQgbm9kZXMuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU5vZGVzRnJvbU1hcmt1cChtYXJrdXAsIGhhbmRsZVNjcmlwdCkge1xuICB2YXIgbm9kZSA9IGR1bW15Tm9kZTtcbiAgISEhZHVtbXlOb2RlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2NyZWF0ZU5vZGVzRnJvbU1hcmt1cCBkdW1teSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciBub2RlTmFtZSA9IGdldE5vZGVOYW1lKG1hcmt1cCk7XG5cbiAgdmFyIHdyYXAgPSBub2RlTmFtZSAmJiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKTtcbiAgaWYgKHdyYXApIHtcbiAgICBub2RlLmlubmVySFRNTCA9IHdyYXBbMV0gKyBtYXJrdXAgKyB3cmFwWzJdO1xuXG4gICAgdmFyIHdyYXBEZXB0aCA9IHdyYXBbMF07XG4gICAgd2hpbGUgKHdyYXBEZXB0aC0tKSB7XG4gICAgICBub2RlID0gbm9kZS5sYXN0Q2hpbGQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vZGUuaW5uZXJIVE1MID0gbWFya3VwO1xuICB9XG5cbiAgdmFyIHNjcmlwdHMgPSBub2RlLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKTtcbiAgaWYgKHNjcmlwdHMubGVuZ3RoKSB7XG4gICAgIWhhbmRsZVNjcmlwdCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdjcmVhdGVOb2Rlc0Zyb21NYXJrdXAoLi4uKTogVW5leHBlY3RlZCA8c2NyaXB0PiBlbGVtZW50IHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBjcmVhdGVBcnJheUZyb21NaXhlZChzY3JpcHRzKS5mb3JFYWNoKGhhbmRsZVNjcmlwdCk7XG4gIH1cblxuICB2YXIgbm9kZXMgPSBjcmVhdGVBcnJheUZyb21NaXhlZChub2RlLmNoaWxkTm9kZXMpO1xuICB3aGlsZSAobm9kZS5sYXN0Q2hpbGQpIHtcbiAgICBub2RlLnJlbW92ZUNoaWxkKG5vZGUubGFzdENoaWxkKTtcbiAgfVxuICByZXR1cm4gbm9kZXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlTm9kZXNGcm9tTWFya3VwO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVOb2Rlc0Zyb21NYXJrdXAuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY3JlYXRlQXJyYXlGcm9tTWl4ZWRcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdG9BcnJheSA9IHJlcXVpcmUoJy4vdG9BcnJheScpO1xuXG4vKipcbiAqIFBlcmZvcm0gYSBoZXVyaXN0aWMgdGVzdCB0byBkZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIFwiYXJyYXktbGlrZVwiLlxuICpcbiAqICAgQSBtb25rIGFza2VkIEpvc2h1LCBhIFplbiBtYXN0ZXIsIFwiSGFzIGEgZG9nIEJ1ZGRoYSBuYXR1cmU/XCJcbiAqICAgSm9zaHUgcmVwbGllZDogXCJNdS5cIlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gZGV0ZXJtaW5lcyBpZiBpdHMgYXJndW1lbnQgaGFzIFwiYXJyYXkgbmF0dXJlXCI6IGl0IHJldHVybnNcbiAqIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGFuIGFjdHVhbCBhcnJheSwgYW4gYGFyZ3VtZW50cycgb2JqZWN0LCBvciBhblxuICogSFRNTENvbGxlY3Rpb24gKGUuZy4gbm9kZS5jaGlsZE5vZGVzIG9yIG5vZGUuZ2V0RWxlbWVudHNCeVRhZ05hbWUoKSkuXG4gKlxuICogSXQgd2lsbCByZXR1cm4gZmFsc2UgZm9yIG90aGVyIGFycmF5LWxpa2Ugb2JqZWN0cyBsaWtlIEZpbGVsaXN0LlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBoYXNBcnJheU5hdHVyZShvYmopIHtcbiAgcmV0dXJuKFxuICAgIC8vIG5vdCBudWxsL2ZhbHNlXG4gICAgISFvYmogJiYgKFxuICAgIC8vIGFycmF5cyBhcmUgb2JqZWN0cywgTm9kZUxpc3RzIGFyZSBmdW5jdGlvbnMgaW4gU2FmYXJpXG4gICAgdHlwZW9mIG9iaiA9PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicpICYmXG4gICAgLy8gcXVhY2tzIGxpa2UgYW4gYXJyYXlcbiAgICAnbGVuZ3RoJyBpbiBvYmogJiZcbiAgICAvLyBub3Qgd2luZG93XG4gICAgISgnc2V0SW50ZXJ2YWwnIGluIG9iaikgJiZcbiAgICAvLyBubyBET00gbm9kZSBzaG91bGQgYmUgY29uc2lkZXJlZCBhbiBhcnJheS1saWtlXG4gICAgLy8gYSAnc2VsZWN0JyBlbGVtZW50IGhhcyAnbGVuZ3RoJyBhbmQgJ2l0ZW0nIHByb3BlcnRpZXMgb24gSUU4XG4gICAgdHlwZW9mIG9iai5ub2RlVHlwZSAhPSAnbnVtYmVyJyAmJiAoXG4gICAgLy8gYSByZWFsIGFycmF5XG4gICAgQXJyYXkuaXNBcnJheShvYmopIHx8XG4gICAgLy8gYXJndW1lbnRzXG4gICAgJ2NhbGxlZScgaW4gb2JqIHx8XG4gICAgLy8gSFRNTENvbGxlY3Rpb24vTm9kZUxpc3RcbiAgICAnaXRlbScgaW4gb2JqKVxuICApO1xufVxuXG4vKipcbiAqIEVuc3VyZSB0aGF0IHRoZSBhcmd1bWVudCBpcyBhbiBhcnJheSBieSB3cmFwcGluZyBpdCBpbiBhbiBhcnJheSBpZiBpdCBpcyBub3QuXG4gKiBDcmVhdGVzIGEgY29weSBvZiB0aGUgYXJndW1lbnQgaWYgaXQgaXMgYWxyZWFkeSBhbiBhcnJheS5cbiAqXG4gKiBUaGlzIGlzIG1vc3RseSB1c2VmdWwgaWRpb21hdGljYWxseTpcbiAqXG4gKiAgIHZhciBjcmVhdGVBcnJheUZyb21NaXhlZCA9IHJlcXVpcmUoJ2NyZWF0ZUFycmF5RnJvbU1peGVkJyk7XG4gKlxuICogICBmdW5jdGlvbiB0YWtlc09uZU9yTW9yZVRoaW5ncyh0aGluZ3MpIHtcbiAqICAgICB0aGluZ3MgPSBjcmVhdGVBcnJheUZyb21NaXhlZCh0aGluZ3MpO1xuICogICAgIC4uLlxuICogICB9XG4gKlxuICogVGhpcyBhbGxvd3MgeW91IHRvIHRyZWF0IGB0aGluZ3MnIGFzIGFuIGFycmF5LCBidXQgYWNjZXB0IHNjYWxhcnMgaW4gdGhlIEFQSS5cbiAqXG4gKiBJZiB5b3UgbmVlZCB0byBjb252ZXJ0IGFuIGFycmF5LWxpa2Ugb2JqZWN0LCBsaWtlIGBhcmd1bWVudHNgLCBpbnRvIGFuIGFycmF5XG4gKiB1c2UgdG9BcnJheSBpbnN0ZWFkLlxuICpcbiAqIEBwYXJhbSB7Kn0gb2JqXG4gKiBAcmV0dXJuIHthcnJheX1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlQXJyYXlGcm9tTWl4ZWQob2JqKSB7XG4gIGlmICghaGFzQXJyYXlOYXR1cmUob2JqKSkge1xuICAgIHJldHVybiBbb2JqXTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICByZXR1cm4gb2JqLnNsaWNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHRvQXJyYXkob2JqKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUFycmF5RnJvbU1peGVkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jcmVhdGVBcnJheUZyb21NaXhlZC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSB0b0FycmF5XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJy4vaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQ29udmVydCBhcnJheS1saWtlIG9iamVjdHMgdG8gYXJyYXlzLlxuICpcbiAqIFRoaXMgQVBJIGFzc3VtZXMgdGhlIGNhbGxlciBrbm93cyB0aGUgY29udGVudHMgb2YgdGhlIGRhdGEgdHlwZS4gRm9yIGxlc3NcbiAqIHdlbGwgZGVmaW5lZCBpbnB1dHMgdXNlIGNyZWF0ZUFycmF5RnJvbU1peGVkLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufGZpbGVsaXN0fSBvYmpcbiAqIEByZXR1cm4ge2FycmF5fVxuICovXG5mdW5jdGlvbiB0b0FycmF5KG9iaikge1xuICB2YXIgbGVuZ3RoID0gb2JqLmxlbmd0aDtcblxuICAvLyBTb21lIGJyb3dzZSBidWlsdGluIG9iamVjdHMgY2FuIHJlcG9ydCB0eXBlb2YgJ2Z1bmN0aW9uJyAoZS5nLiBOb2RlTGlzdCBpblxuICAvLyBvbGQgdmVyc2lvbnMgb2YgU2FmYXJpKS5cbiAgISghQXJyYXkuaXNBcnJheShvYmopICYmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogQXJyYXktbGlrZSBvYmplY3QgZXhwZWN0ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgISh0eXBlb2YgbGVuZ3RoID09PSAnbnVtYmVyJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndG9BcnJheTogT2JqZWN0IG5lZWRzIGEgbGVuZ3RoIHByb3BlcnR5JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICEobGVuZ3RoID09PSAwIHx8IGxlbmd0aCAtIDEgaW4gb2JqKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0b0FycmF5OiBPYmplY3Qgc2hvdWxkIGhhdmUga2V5cyBmb3IgaW5kaWNlcycpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAvLyBPbGQgSUUgZG9lc24ndCBnaXZlIGNvbGxlY3Rpb25zIGFjY2VzcyB0byBoYXNPd25Qcm9wZXJ0eS4gQXNzdW1lIGlucHV0c1xuICAvLyB3aXRob3V0IG1ldGhvZCB3aWxsIHRocm93IGR1cmluZyB0aGUgc2xpY2UgY2FsbCBhbmQgc2tpcCBzdHJhaWdodCB0byB0aGVcbiAgLy8gZmFsbGJhY2suXG4gIGlmIChvYmouaGFzT3duUHJvcGVydHkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKG9iaik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgLy8gSUUgPCA5IGRvZXMgbm90IHN1cHBvcnQgQXJyYXkjc2xpY2Ugb24gY29sbGVjdGlvbnMgb2JqZWN0c1xuICAgIH1cbiAgfVxuXG4gIC8vIEZhbGwgYmFjayB0byBjb3B5aW5nIGtleSBieSBrZXkuIFRoaXMgYXNzdW1lcyBhbGwga2V5cyBoYXZlIGEgdmFsdWUsXG4gIC8vIHNvIHdpbGwgbm90IHByZXNlcnZlIHNwYXJzZWx5IHBvcHVsYXRlZCBpbnB1dHMuXG4gIHZhciByZXQgPSBBcnJheShsZW5ndGgpO1xuICBmb3IgKHZhciBpaSA9IDA7IGlpIDwgbGVuZ3RoOyBpaSsrKSB7XG4gICAgcmV0W2lpXSA9IG9ialtpaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB0b0FycmF5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi90b0FycmF5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGludmFyaWFudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBVc2UgaW52YXJpYW50KCkgdG8gYXNzZXJ0IHN0YXRlIHdoaWNoIHlvdXIgcHJvZ3JhbSBhc3N1bWVzIHRvIGJlIHRydWUuXG4gKlxuICogUHJvdmlkZSBzcHJpbnRmLXN0eWxlIGZvcm1hdCAob25seSAlcyBpcyBzdXBwb3J0ZWQpIGFuZCBhcmd1bWVudHNcbiAqIHRvIHByb3ZpZGUgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBicm9rZSBhbmQgd2hhdCB5b3Ugd2VyZVxuICogZXhwZWN0aW5nLlxuICpcbiAqIFRoZSBpbnZhcmlhbnQgbWVzc2FnZSB3aWxsIGJlIHN0cmlwcGVkIGluIHByb2R1Y3Rpb24sIGJ1dCB0aGUgaW52YXJpYW50XG4gKiB3aWxsIHJlbWFpbiB0byBlbnN1cmUgbG9naWMgZG9lcyBub3QgZGlmZmVyIGluIHByb2R1Y3Rpb24uXG4gKi9cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFyaWFudCByZXF1aXJlcyBhbiBlcnJvciBtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0TWFya3VwV3JhcFxuICovXG5cbi8qZXNsaW50LWRpc2FibGUgZmItd3d3L3Vuc2FmZS1odG1sICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnLi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBEdW1teSBjb250YWluZXIgdXNlZCB0byBkZXRlY3Qgd2hpY2ggd3JhcHMgYXJlIG5lY2Vzc2FyeS5cbiAqL1xudmFyIGR1bW15Tm9kZSA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpIDogbnVsbDtcblxuLyoqXG4gKiBTb21lIGJyb3dzZXJzIGNhbm5vdCB1c2UgYGlubmVySFRNTGAgdG8gcmVuZGVyIGNlcnRhaW4gZWxlbWVudHMgc3RhbmRhbG9uZSxcbiAqIHNvIHdlIHdyYXAgdGhlbSwgcmVuZGVyIHRoZSB3cmFwcGVkIG5vZGVzLCB0aGVuIGV4dHJhY3QgdGhlIGRlc2lyZWQgbm9kZS5cbiAqXG4gKiBJbiBJRTgsIGNlcnRhaW4gZWxlbWVudHMgY2Fubm90IHJlbmRlciBhbG9uZSwgc28gd3JhcCBhbGwgZWxlbWVudHMgKCcqJykuXG4gKi9cblxudmFyIHNob3VsZFdyYXAgPSB7fTtcblxudmFyIHNlbGVjdFdyYXAgPSBbMSwgJzxzZWxlY3QgbXVsdGlwbGU9XCJ0cnVlXCI+JywgJzwvc2VsZWN0PiddO1xudmFyIHRhYmxlV3JhcCA9IFsxLCAnPHRhYmxlPicsICc8L3RhYmxlPiddO1xudmFyIHRyV3JhcCA9IFszLCAnPHRhYmxlPjx0Ym9keT48dHI+JywgJzwvdHI+PC90Ym9keT48L3RhYmxlPiddO1xuXG52YXIgc3ZnV3JhcCA9IFsxLCAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JywgJzwvc3ZnPiddO1xuXG52YXIgbWFya3VwV3JhcCA9IHtcbiAgJyonOiBbMSwgJz88ZGl2PicsICc8L2Rpdj4nXSxcblxuICAnYXJlYSc6IFsxLCAnPG1hcD4nLCAnPC9tYXA+J10sXG4gICdjb2wnOiBbMiwgJzx0YWJsZT48dGJvZHk+PC90Ym9keT48Y29sZ3JvdXA+JywgJzwvY29sZ3JvdXA+PC90YWJsZT4nXSxcbiAgJ2xlZ2VuZCc6IFsxLCAnPGZpZWxkc2V0PicsICc8L2ZpZWxkc2V0PiddLFxuICAncGFyYW0nOiBbMSwgJzxvYmplY3Q+JywgJzwvb2JqZWN0PiddLFxuICAndHInOiBbMiwgJzx0YWJsZT48dGJvZHk+JywgJzwvdGJvZHk+PC90YWJsZT4nXSxcblxuICAnb3B0Z3JvdXAnOiBzZWxlY3RXcmFwLFxuICAnb3B0aW9uJzogc2VsZWN0V3JhcCxcblxuICAnY2FwdGlvbic6IHRhYmxlV3JhcCxcbiAgJ2NvbGdyb3VwJzogdGFibGVXcmFwLFxuICAndGJvZHknOiB0YWJsZVdyYXAsXG4gICd0Zm9vdCc6IHRhYmxlV3JhcCxcbiAgJ3RoZWFkJzogdGFibGVXcmFwLFxuXG4gICd0ZCc6IHRyV3JhcCxcbiAgJ3RoJzogdHJXcmFwXG59O1xuXG4vLyBJbml0aWFsaXplIHRoZSBTVkcgZWxlbWVudHMgc2luY2Ugd2Uga25vdyB0aGV5J2xsIGFsd2F5cyBuZWVkIHRvIGJlIHdyYXBwZWRcbi8vIGNvbnNpc3RlbnRseS4gSWYgdGhleSBhcmUgY3JlYXRlZCBpbnNpZGUgYSA8ZGl2PiB0aGV5IHdpbGwgYmUgaW5pdGlhbGl6ZWQgaW5cbi8vIHRoZSB3cm9uZyBuYW1lc3BhY2UgKGFuZCB3aWxsIG5vdCBkaXNwbGF5KS5cbnZhciBzdmdFbGVtZW50cyA9IFsnY2lyY2xlJywgJ2NsaXBQYXRoJywgJ2RlZnMnLCAnZWxsaXBzZScsICdnJywgJ2ltYWdlJywgJ2xpbmUnLCAnbGluZWFyR3JhZGllbnQnLCAnbWFzaycsICdwYXRoJywgJ3BhdHRlcm4nLCAncG9seWdvbicsICdwb2x5bGluZScsICdyYWRpYWxHcmFkaWVudCcsICdyZWN0JywgJ3N0b3AnLCAndGV4dCcsICd0c3BhbiddO1xuc3ZnRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAobm9kZU5hbWUpIHtcbiAgbWFya3VwV3JhcFtub2RlTmFtZV0gPSBzdmdXcmFwO1xuICBzaG91bGRXcmFwW25vZGVOYW1lXSA9IHRydWU7XG59KTtcblxuLyoqXG4gKiBHZXRzIHRoZSBtYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uIGZvciB0aGUgc3VwcGxpZWQgYG5vZGVOYW1lYC5cbiAqXG4gKiBOT1RFOiBUaGlzIGxhemlseSBkZXRlY3RzIHdoaWNoIHdyYXBzIGFyZSBuZWNlc3NhcnkgZm9yIHRoZSBjdXJyZW50IGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG5vZGVOYW1lIExvd2VyY2FzZSBgbm9kZU5hbWVgLlxuICogQHJldHVybiB7P2FycmF5fSBNYXJrdXAgd3JhcCBjb25maWd1cmF0aW9uLCBpZiBhcHBsaWNhYmxlLlxuICovXG5mdW5jdGlvbiBnZXRNYXJrdXBXcmFwKG5vZGVOYW1lKSB7XG4gICEhIWR1bW15Tm9kZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdNYXJrdXAgd3JhcHBpbmcgbm9kZSBub3QgaW5pdGlhbGl6ZWQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmICghbWFya3VwV3JhcC5oYXNPd25Qcm9wZXJ0eShub2RlTmFtZSkpIHtcbiAgICBub2RlTmFtZSA9ICcqJztcbiAgfVxuICBpZiAoIXNob3VsZFdyYXAuaGFzT3duUHJvcGVydHkobm9kZU5hbWUpKSB7XG4gICAgaWYgKG5vZGVOYW1lID09PSAnKicpIHtcbiAgICAgIGR1bW15Tm9kZS5pbm5lckhUTUwgPSAnPGxpbmsgLz4nO1xuICAgIH0gZWxzZSB7XG4gICAgICBkdW1teU5vZGUuaW5uZXJIVE1MID0gJzwnICsgbm9kZU5hbWUgKyAnPjwvJyArIG5vZGVOYW1lICsgJz4nO1xuICAgIH1cbiAgICBzaG91bGRXcmFwW25vZGVOYW1lXSA9ICFkdW1teU5vZGUuZmlyc3RDaGlsZDtcbiAgfVxuICByZXR1cm4gc2hvdWxkV3JhcFtub2RlTmFtZV0gPyBtYXJrdXBXcmFwW25vZGVOYW1lXSA6IG51bGw7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0TWFya3VwV3JhcDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIvZ2V0TWFya3VwV3JhcC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eUZ1bmN0aW9uXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbmZ1bmN0aW9uIG1ha2VFbXB0eUZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhcmc7XG4gIH07XG59XG5cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGFuZCBkaXNjYXJkcyBpbnB1dHM7IGl0IGhhcyBubyBzaWRlIGVmZmVjdHMuIFRoaXMgaXNcbiAqIHByaW1hcmlseSB1c2VmdWwgaWRpb21hdGljYWxseSBmb3Igb3ZlcnJpZGFibGUgZnVuY3Rpb24gZW5kcG9pbnRzIHdoaWNoXG4gKiBhbHdheXMgbmVlZCB0byBiZSBjYWxsYWJsZSwgc2luY2UgSlMgbGFja3MgYSBudWxsLWNhbGwgaWRpb20gYWxhIENvY29hLlxuICovXG5mdW5jdGlvbiBlbXB0eUZ1bmN0aW9uKCkge31cblxuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJucyA9IG1ha2VFbXB0eUZ1bmN0aW9uO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlID0gbWFrZUVtcHR5RnVuY3Rpb24oZmFsc2UpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWUgPSBtYWtlRW1wdHlGdW5jdGlvbih0cnVlKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsID0gbWFrZUVtcHR5RnVuY3Rpb24obnVsbCk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVGhpcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59O1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50ID0gZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gYXJnO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBlbXB0eUZ1bmN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eUZ1bmN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIga2V5TWlycm9yID0gcmVxdWlyZSgnZmJqcy9saWIva2V5TWlycm9yJyk7XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCdzIGNoaWxkcmVuIGFyZSB1cGRhdGVkLCBhIHNlcmllcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvblxuICogb2JqZWN0cyBhcmUgY3JlYXRlZCBpbiBvcmRlciB0byBiYXRjaCBhbmQgc2VyaWFsaXplIHRoZSByZXF1aXJlZCBjaGFuZ2VzLlxuICpcbiAqIEVudW1lcmF0ZXMgYWxsIHRoZSBwb3NzaWJsZSB0eXBlcyBvZiB1cGRhdGUgY29uZmlndXJhdGlvbnMuXG4gKlxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcyA9IGtleU1pcnJvcih7XG4gIElOU0VSVF9NQVJLVVA6IG51bGwsXG4gIE1PVkVfRVhJU1RJTkc6IG51bGwsXG4gIFJFTU9WRV9OT0RFOiBudWxsLFxuICBTRVRfTUFSS1VQOiBudWxsLFxuICBURVhUX0NPTlRFTlQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGtleU1pcnJvclxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCcuL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIENvbnN0cnVjdHMgYW4gZW51bWVyYXRpb24gd2l0aCBrZXlzIGVxdWFsIHRvIHRoZWlyIHZhbHVlLlxuICpcbiAqIEZvciBleGFtcGxlOlxuICpcbiAqICAgdmFyIENPTE9SUyA9IGtleU1pcnJvcih7Ymx1ZTogbnVsbCwgcmVkOiBudWxsfSk7XG4gKiAgIHZhciBteUNvbG9yID0gQ09MT1JTLmJsdWU7XG4gKiAgIHZhciBpc0NvbG9yVmFsaWQgPSAhIUNPTE9SU1tteUNvbG9yXTtcbiAqXG4gKiBUaGUgbGFzdCBsaW5lIGNvdWxkIG5vdCBiZSBwZXJmb3JtZWQgaWYgdGhlIHZhbHVlcyBvZiB0aGUgZ2VuZXJhdGVkIGVudW0gd2VyZVxuICogbm90IGVxdWFsIHRvIHRoZWlyIGtleXMuXG4gKlxuICogICBJbnB1dDogIHtrZXkxOiB2YWwxLCBrZXkyOiB2YWwyfVxuICogICBPdXRwdXQ6IHtrZXkxOiBrZXkxLCBrZXkyOiBrZXkyfVxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBvYmpcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xudmFyIGtleU1pcnJvciA9IGZ1bmN0aW9uIChvYmopIHtcbiAgdmFyIHJldCA9IHt9O1xuICB2YXIga2V5O1xuICAhKG9iaiBpbnN0YW5jZW9mIE9iamVjdCAmJiAhQXJyYXkuaXNBcnJheShvYmopKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdrZXlNaXJyb3IoLi4uKTogQXJndW1lbnQgbXVzdCBiZSBhbiBvYmplY3QuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBmb3IgKGtleSBpbiBvYmopIHtcbiAgICBpZiAoIW9iai5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcmV0W2tleV0gPSBrZXk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0ga2V5TWlycm9yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9rZXlNaXJyb3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBSZWFjdFBlcmYgaXMgYSBnZW5lcmFsIEFPUCBzeXN0ZW0gZGVzaWduZWQgdG8gbWVhc3VyZSBwZXJmb3JtYW5jZS4gVGhpc1xuICogbW9kdWxlIG9ubHkgaGFzIHRoZSBob29rczogc2VlIFJlYWN0RGVmYXVsdFBlcmYgZm9yIHRoZSBhbmFseXNpcyB0b29sLlxuICovXG52YXIgUmVhY3RQZXJmID0ge1xuICAvKipcbiAgICogQm9vbGVhbiB0byBlbmFibGUvZGlzYWJsZSBtZWFzdXJlbWVudC4gU2V0IHRvIGZhbHNlIGJ5IGRlZmF1bHQgdG8gcHJldmVudFxuICAgKiBhY2NpZGVudGFsIGxvZ2dpbmcgYW5kIHBlcmYgbG9zcy5cbiAgICovXG4gIGVuYWJsZU1lYXN1cmU6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBIb2xkcyBvbnRvIHRoZSBtZWFzdXJlIGZ1bmN0aW9uIGluIHVzZS4gQnkgZGVmYXVsdCwgZG9uJ3QgbWVhc3VyZVxuICAgKiBhbnl0aGluZywgYnV0IHdlJ2xsIG92ZXJyaWRlIHRoaXMgaWYgd2UgaW5qZWN0IGEgbWVhc3VyZSBmdW5jdGlvbi5cbiAgICovXG4gIHN0b3JlZE1lYXN1cmU6IF9ub01lYXN1cmUsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBvYmplY3RcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9iamVjdE5hbWVcbiAgICogQHBhcmFtIHtvYmplY3Q8c3RyaW5nPn0gbWV0aG9kTmFtZXNcbiAgICovXG4gIG1lYXN1cmVNZXRob2RzOiBmdW5jdGlvbiAob2JqZWN0LCBvYmplY3ROYW1lLCBtZXRob2ROYW1lcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kTmFtZXMpIHtcbiAgICAgICAgaWYgKCFtZXRob2ROYW1lcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBSZWFjdFBlcmYubWVhc3VyZShvYmplY3ROYW1lLCBtZXRob2ROYW1lc1trZXldLCBvYmplY3Rba2V5XSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBVc2UgdGhpcyB0byB3cmFwIG1ldGhvZHMgeW91IHdhbnQgdG8gbWVhc3VyZS4gWmVybyBvdmVyaGVhZCBpbiBwcm9kdWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2JqTmFtZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAgICogQHJldHVybiB7ZnVuY3Rpb259XG4gICAqL1xuICBtZWFzdXJlOiBmdW5jdGlvbiAob2JqTmFtZSwgZm5OYW1lLCBmdW5jKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtZWFzdXJlZEZ1bmMgPSBudWxsO1xuICAgICAgdmFyIHdyYXBwZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSkge1xuICAgICAgICAgIGlmICghbWVhc3VyZWRGdW5jKSB7XG4gICAgICAgICAgICBtZWFzdXJlZEZ1bmMgPSBSZWFjdFBlcmYuc3RvcmVkTWVhc3VyZShvYmpOYW1lLCBmbk5hbWUsIGZ1bmMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbWVhc3VyZWRGdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgICB3cmFwcGVyLmRpc3BsYXlOYW1lID0gb2JqTmFtZSArICdfJyArIGZuTmFtZTtcbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbiAgfSxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBtZWFzdXJlXG4gICAgICovXG4gICAgaW5qZWN0TWVhc3VyZTogZnVuY3Rpb24gKG1lYXN1cmUpIHtcbiAgICAgIFJlYWN0UGVyZi5zdG9yZWRNZWFzdXJlID0gbWVhc3VyZTtcbiAgICB9XG4gIH1cbn07XG5cbi8qKlxuICogU2ltcGx5IHBhc3NlcyB0aHJvdWdoIHRoZSBtZWFzdXJlZCBmdW5jdGlvbiwgd2l0aG91dCBtZWFzdXJpbmcgaXQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG9iak5hbWVcbiAqIEBwYXJhbSB7c3RyaW5nfSBmbk5hbWVcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmNcbiAqIEByZXR1cm4ge2Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBfbm9NZWFzdXJlKG9iak5hbWUsIGZuTmFtZSwgZnVuYykge1xuICByZXR1cm4gZnVuYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFBlcmY7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RQZXJmLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldElubmVySFRNTFxuICovXG5cbi8qIGdsb2JhbHMgTVNBcHAgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgV0hJVEVTUEFDRV9URVNUID0gL15bIFxcclxcblxcdFxcZl0vO1xudmFyIE5PTlZJU0lCTEVfVEVTVCA9IC88KCEtLXxsaW5rfG5vc2NyaXB0fG1ldGF8c2NyaXB0fHN0eWxlKVsgXFxyXFxuXFx0XFxmXFwvPl0vO1xuXG4vKipcbiAqIFNldCB0aGUgaW5uZXJIVE1MIHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gaHRtbFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICBub2RlLmlubmVySFRNTCA9IGh0bWw7XG59O1xuXG4vLyBXaW44IGFwcHM6IEFsbG93IGFsbCBodG1sIHRvIGJlIGluc2VydGVkXG5pZiAodHlwZW9mIE1TQXBwICE9PSAndW5kZWZpbmVkJyAmJiBNU0FwcC5leGVjVW5zYWZlTG9jYWxGdW5jdGlvbikge1xuICBzZXRJbm5lckhUTUwgPSBmdW5jdGlvbiAobm9kZSwgaHRtbCkge1xuICAgIE1TQXBwLmV4ZWNVbnNhZmVMb2NhbEZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcbiAgICAgIG5vZGUuaW5uZXJIVE1MID0gaHRtbDtcbiAgICB9KTtcbiAgfTtcbn1cblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTg6IFdoZW4gdXBkYXRpbmcgYSBqdXN0IGNyZWF0ZWQgbm9kZSB3aXRoIGlubmVySFRNTCBvbmx5IGxlYWRpbmdcbiAgLy8gd2hpdGVzcGFjZSBpcyByZW1vdmVkLiBXaGVuIHVwZGF0aW5nIGFuIGV4aXN0aW5nIG5vZGUgd2l0aCBpbm5lckhUTUxcbiAgLy8gd2hpdGVzcGFjZSBpbiByb290IFRleHROb2RlcyBpcyBhbHNvIGNvbGxhcHNlZC5cbiAgLy8gQHNlZSBxdWlya3Ntb2RlLm9yZy9idWdyZXBvcnRzL2FyY2hpdmVzLzIwMDQvMTEvaW5uZXJodG1sX2FuZF90Lmh0bWxcblxuICAvLyBGZWF0dXJlIGRldGVjdGlvbjsgb25seSBJRTggaXMga25vd24gdG8gYmVoYXZlIGltcHJvcGVybHkgbGlrZSB0aGlzLlxuICB2YXIgdGVzdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgdGVzdEVsZW1lbnQuaW5uZXJIVE1MID0gJyAnO1xuICBpZiAodGVzdEVsZW1lbnQuaW5uZXJIVE1MID09PSAnJykge1xuICAgIHNldElubmVySFRNTCA9IGZ1bmN0aW9uIChub2RlLCBodG1sKSB7XG4gICAgICAvLyBNYWdpYyB0aGVvcnk6IElFOCBzdXBwb3NlZGx5IGRpZmZlcmVudGlhdGVzIGJldHdlZW4gYWRkZWQgYW5kIHVwZGF0ZWRcbiAgICAgIC8vIG5vZGVzIHdoZW4gcHJvY2Vzc2luZyBpbm5lckhUTUwsIGlubmVySFRNTCBvbiB1cGRhdGVkIG5vZGVzIHN1ZmZlcnNcbiAgICAgIC8vIGZyb20gd29yc2Ugd2hpdGVzcGFjZSBiZWhhdmlvci4gUmUtYWRkaW5nIGEgbm9kZSBsaWtlIHRoaXMgdHJpZ2dlcnNcbiAgICAgIC8vIHRoZSBpbml0aWFsIGFuZCBtb3JlIGZhdm9yYWJsZSB3aGl0ZXNwYWNlIGJlaGF2aW9yLlxuICAgICAgLy8gVE9ETzogV2hhdCB0byBkbyBvbiBhIGRldGFjaGVkIG5vZGU/XG4gICAgICBpZiAobm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQobm9kZSwgbm9kZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIGFsc28gaW1wbGVtZW50IGEgd29ya2Fyb3VuZCBmb3Igbm9uLXZpc2libGUgdGFncyBkaXNhcHBlYXJpbmcgaW50b1xuICAgICAgLy8gdGhpbiBhaXIgb24gSUU4LCB0aGlzIG9ubHkgaGFwcGVucyBpZiB0aGVyZSBpcyBubyB2aXNpYmxlIHRleHRcbiAgICAgIC8vIGluLWZyb250IG9mIHRoZSBub24tdmlzaWJsZSB0YWdzLiBQaWdneWJhY2sgb24gdGhlIHdoaXRlc3BhY2UgZml4XG4gICAgICAvLyBhbmQgc2ltcGx5IGNoZWNrIGlmIGFueSBub24tdmlzaWJsZSB0YWdzIGFwcGVhciBpbiB0aGUgc291cmNlLlxuICAgICAgaWYgKFdISVRFU1BBQ0VfVEVTVC50ZXN0KGh0bWwpIHx8IGh0bWxbMF0gPT09ICc8JyAmJiBOT05WSVNJQkxFX1RFU1QudGVzdChodG1sKSkge1xuICAgICAgICAvLyBSZWNvdmVyIGxlYWRpbmcgd2hpdGVzcGFjZSBieSB0ZW1wb3JhcmlseSBwcmVwZW5kaW5nIGFueSBjaGFyYWN0ZXIuXG4gICAgICAgIC8vIFxcdUZFRkYgaGFzIHRoZSBwb3RlbnRpYWwgYWR2YW50YWdlIG9mIGJlaW5nIHplcm8td2lkdGgvaW52aXNpYmxlLlxuICAgICAgICAvLyBVZ2xpZnlKUyBkcm9wcyBVK0ZFRkYgY2hhcnMgd2hlbiBwYXJzaW5nLCBzbyB1c2UgU3RyaW5nLmZyb21DaGFyQ29kZVxuICAgICAgICAvLyBpbiBob3BlcyB0aGF0IHRoaXMgaXMgcHJlc2VydmVkIGV2ZW4gaWYgXCJcXHVGRUZGXCIgaXMgdHJhbnNmb3JtZWQgdG9cbiAgICAgICAgLy8gdGhlIGFjdHVhbCBVbmljb2RlIGNoYXJhY3RlciAoYnkgQmFiZWwsIGZvciBleGFtcGxlKS5cbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21pc2hvby9VZ2xpZnlKUzIvYmxvYi92Mi40LjIwL2xpYi9wYXJzZS5qcyNMMjE2XG4gICAgICAgIG5vZGUuaW5uZXJIVE1MID0gU3RyaW5nLmZyb21DaGFyQ29kZSgweEZFRkYpICsgaHRtbDtcblxuICAgICAgICAvLyBkZWxldGVEYXRhIGxlYXZlcyBhbiBlbXB0eSBgVGV4dE5vZGVgIHdoaWNoIG9mZnNldHMgdGhlIGluZGV4IG9mIGFsbFxuICAgICAgICAvLyBjaGlsZHJlbi4gRGVmaW5pdGVseSB3YW50IHRvIGF2b2lkIHRoaXMuXG4gICAgICAgIHZhciB0ZXh0Tm9kZSA9IG5vZGUuZmlyc3RDaGlsZDtcbiAgICAgICAgaWYgKHRleHROb2RlLmRhdGEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZCh0ZXh0Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGV4dE5vZGUuZGVsZXRlRGF0YSgwLCAxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZS5pbm5lckhUTUwgPSBodG1sO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXRJbm5lckhUTUw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvc2V0SW5uZXJIVE1MLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHNldFRleHRDb250ZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgc2V0SW5uZXJIVE1MID0gcmVxdWlyZSgnLi9zZXRJbm5lckhUTUwnKTtcblxuLyoqXG4gKiBTZXQgdGhlIHRleHRDb250ZW50IHByb3BlcnR5IG9mIGEgbm9kZSwgZW5zdXJpbmcgdGhhdCB3aGl0ZXNwYWNlIGlzIHByZXNlcnZlZFxuICogZXZlbiBpbiBJRTguIGlubmVyVGV4dCBpcyBhIHBvb3Igc3Vic3RpdHV0ZSBmb3IgdGV4dENvbnRlbnQgYW5kLCBhbW9uZyBtYW55XG4gKiBpc3N1ZXMsIGluc2VydHMgPGJyPiBpbnN0ZWFkIG9mIHRoZSBsaXRlcmFsIG5ld2xpbmUgY2hhcnMuIGlubmVySFRNTCBiZWhhdmVzXG4gKiBhcyBpdCBzaG91bGQuXG4gKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICogQGludGVybmFsXG4gKi9cbnZhciBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gIG5vZGUudGV4dENvbnRlbnQgPSB0ZXh0O1xufTtcblxuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICBpZiAoISgndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkpIHtcbiAgICBzZXRUZXh0Q29udGVudCA9IGZ1bmN0aW9uIChub2RlLCB0ZXh0KSB7XG4gICAgICBzZXRJbm5lckhUTUwobm9kZSwgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0VGV4dENvbnRlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvc2V0VGV4dENvbnRlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVNDQVBFX0xPT0tVUCA9IHtcbiAgJyYnOiAnJmFtcDsnLFxuICAnPic6ICcmZ3Q7JyxcbiAgJzwnOiAnJmx0OycsXG4gICdcIic6ICcmcXVvdDsnLFxuICAnXFwnJzogJyYjeDI3Oydcbn07XG5cbnZhciBFU0NBUEVfUkVHRVggPSAvWyY+PFwiJ10vZztcblxuZnVuY3Rpb24gZXNjYXBlcihtYXRjaCkge1xuICByZXR1cm4gRVNDQVBFX0xPT0tVUFttYXRjaF07XG59XG5cbi8qKlxuICogRXNjYXBlcyB0ZXh0IHRvIHByZXZlbnQgc2NyaXB0aW5nIGF0dGFja3MuXG4gKlxuICogQHBhcmFtIHsqfSB0ZXh0IFRleHQgdmFsdWUgdG8gZXNjYXBlLlxuICogQHJldHVybiB7c3RyaW5nfSBBbiBlc2NhcGVkIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UoRVNDQVBFX1JFR0VYLCBlc2NhcGVyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5T3BlcmF0aW9uc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIgPSByZXF1aXJlKCcuL3F1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gU2ltcGxpZmllZCBzdWJzZXRcbnZhciBWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWCA9IC9eW2EtekEtWl9dW1xcd1xcLlxcLV0qJC87XG52YXIgaWxsZWdhbEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xudmFyIHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZSA9IHt9O1xuXG5mdW5jdGlvbiBpc0F0dHJpYnV0ZU5hbWVTYWZlKGF0dHJpYnV0ZU5hbWUpIHtcbiAgaWYgKHZhbGlkYXRlZEF0dHJpYnV0ZU5hbWVDYWNoZS5oYXNPd25Qcm9wZXJ0eShhdHRyaWJ1dGVOYW1lKSkge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlLmhhc093blByb3BlcnR5KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChWQUxJRF9BVFRSSUJVVEVfTkFNRV9SRUdFWC50ZXN0KGF0dHJpYnV0ZU5hbWUpKSB7XG4gICAgdmFsaWRhdGVkQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpbGxlZ2FsQXR0cmlidXRlTmFtZUNhY2hlW2F0dHJpYnV0ZU5hbWVdID0gdHJ1ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdJbnZhbGlkIGF0dHJpYnV0ZSBuYW1lOiBgJXNgJywgYXR0cmlidXRlTmFtZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBwcm9wZXJ0eUluZm8uaGFzQm9vbGVhblZhbHVlICYmICF2YWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzTnVtZXJpY1ZhbHVlICYmIGlzTmFOKHZhbHVlKSB8fCBwcm9wZXJ0eUluZm8uaGFzUG9zaXRpdmVOdW1lcmljVmFsdWUgJiYgdmFsdWUgPCAxIHx8IHByb3BlcnR5SW5mby5oYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlICYmIHZhbHVlID09PSBmYWxzZTtcbn1cblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHJlYWN0UHJvcHMgPSB7XG4gICAgY2hpbGRyZW46IHRydWUsXG4gICAgZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw6IHRydWUsXG4gICAga2V5OiB0cnVlLFxuICAgIHJlZjogdHJ1ZVxuICB9O1xuICB2YXIgd2FybmVkUHJvcGVydGllcyA9IHt9O1xuXG4gIHZhciB3YXJuVW5rbm93blByb3BlcnR5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAocmVhY3RQcm9wcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiByZWFjdFByb3BzW25hbWVdIHx8IHdhcm5lZFByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgd2FybmVkUHJvcGVydGllc1tuYW1lXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdhcm5lZFByb3BlcnRpZXNbbmFtZV0gPSB0cnVlO1xuICAgIHZhciBsb3dlckNhc2VkTmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblxuICAgIC8vIGRhdGEtKiBhdHRyaWJ1dGVzIHNob3VsZCBiZSBsb3dlcmNhc2U7IHN1Z2dlc3QgdGhlIGxvd2VyY2FzZSB2ZXJzaW9uXG4gICAgdmFyIHN0YW5kYXJkTmFtZSA9IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKGxvd2VyQ2FzZWROYW1lKSA/IGxvd2VyQ2FzZWROYW1lIDogRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWUuaGFzT3duUHJvcGVydHkobG93ZXJDYXNlZE5hbWUpID8gRE9NUHJvcGVydHkuZ2V0UG9zc2libGVTdGFuZGFyZE5hbWVbbG93ZXJDYXNlZE5hbWVdIDogbnVsbDtcblxuICAgIC8vIEZvciBub3csIG9ubHkgd2FybiB3aGVuIHdlIGhhdmUgYSBzdWdnZXN0ZWQgY29ycmVjdGlvbi4gVGhpcyBwcmV2ZW50c1xuICAgIC8vIGxvZ2dpbmcgdG9vIG11Y2ggd2hlbiB1c2luZyB0cmFuc2ZlclByb3BzVG8uXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoc3RhbmRhcmROYW1lID09IG51bGwsICdVbmtub3duIERPTSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIHN0YW5kYXJkTmFtZSkgOiB1bmRlZmluZWQ7XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIERPTSBwcm9wZXJ0aWVzLlxuICovXG52YXIgRE9NUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgdGhlIElEIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgVW5lc2NhcGVkIElELlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBzdHJpbmcuXG4gICAqL1xuICBjcmVhdGVNYXJrdXBGb3JJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgcmV0dXJuIERPTVByb3BlcnR5LklEX0FUVFJJQlVURV9OQU1FICsgJz0nICsgcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIoaWQpO1xuICB9LFxuXG4gIHNldEF0dHJpYnV0ZUZvcklEOiBmdW5jdGlvbiAobm9kZSwgaWQpIHtcbiAgICBub2RlLnNldEF0dHJpYnV0ZShET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRSwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIG1hcmt1cCBmb3IgYSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBNYXJrdXAgc3RyaW5nLCBvciBudWxsIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclByb3BlcnR5OiBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIGlmIChzaG91bGRJZ25vcmVWYWx1ZShwcm9wZXJ0eUluZm8sIHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gJyc7XG4gICAgICB9XG4gICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgaWYgKHByb3BlcnR5SW5mby5oYXNCb29sZWFuVmFsdWUgfHwgcHJvcGVydHlJbmZvLmhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWUgJiYgdmFsdWUgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPVwiXCInO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZU5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5pc0N1c3RvbUF0dHJpYnV0ZShuYW1lKSkge1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIGEgY3VzdG9tIHByb3BlcnR5LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZywgb3IgZW1wdHkgc3RyaW5nIGlmIHRoZSBwcm9wZXJ0eSB3YXMgaW52YWxpZC5cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvckN1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpIHx8IHZhbHVlID09IG51bGwpIHtcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIG5hbWUgKyAnPScgKyBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3Nlcih2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBhIHByb3BlcnR5IG9uIGEgbm9kZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICovXG4gIHNldFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlLCBuYW1lLCB2YWx1ZSkge1xuICAgIHZhciBwcm9wZXJ0eUluZm8gPSBET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KG5hbWUpID8gRE9NUHJvcGVydHkucHJvcGVydGllc1tuYW1lXSA6IG51bGw7XG4gICAgaWYgKHByb3BlcnR5SW5mbykge1xuICAgICAgdmFyIG11dGF0aW9uTWV0aG9kID0gcHJvcGVydHlJbmZvLm11dGF0aW9uTWV0aG9kO1xuICAgICAgaWYgKG11dGF0aW9uTWV0aG9kKSB7XG4gICAgICAgIG11dGF0aW9uTWV0aG9kKG5vZGUsIHZhbHVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc2hvdWxkSWdub3JlVmFsdWUocHJvcGVydHlJbmZvLCB2YWx1ZSkpIHtcbiAgICAgICAgdGhpcy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSkge1xuICAgICAgICB2YXIgYXR0cmlidXRlTmFtZSA9IHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lO1xuICAgICAgICB2YXIgbmFtZXNwYWNlID0gcHJvcGVydHlJbmZvLmF0dHJpYnV0ZU5hbWVzcGFjZTtcbiAgICAgICAgLy8gYHNldEF0dHJpYnV0ZWAgd2l0aCBvYmplY3RzIGJlY29tZXMgb25seSBgW29iamVjdF1gIGluIElFOC85LFxuICAgICAgICAvLyAoJycgKyB2YWx1ZSkgbWFrZXMgaXQgb3V0cHV0IHRoZSBjb3JyZWN0IHRvU3RyaW5nKCktdmFsdWUuXG4gICAgICAgIGlmIChuYW1lc3BhY2UpIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZU5TKG5hbWVzcGFjZSwgYXR0cmlidXRlTmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSB8fCBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSAmJiB2YWx1ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUsICcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lLCAnJyArIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHByb3BOYW1lID0gcHJvcGVydHlJbmZvLnByb3BlcnR5TmFtZTtcbiAgICAgICAgLy8gTXVzdCBleHBsaWNpdGx5IGNhc3QgdmFsdWVzIGZvciBIQVNfU0lERV9FRkZFQ1RTLXByb3BlcnRpZXMgdG8gdGhlXG4gICAgICAgIC8vIHByb3BlcnR5IHR5cGUgYmVmb3JlIGNvbXBhcmluZzsgb25seSBgdmFsdWVgIGRvZXMgYW5kIGlzIHN0cmluZy5cbiAgICAgICAgaWYgKCFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMgfHwgJycgKyBub2RlW3Byb3BOYW1lXSAhPT0gJycgKyB2YWx1ZSkge1xuICAgICAgICAgIC8vIENvbnRyYXJ5IHRvIGBzZXRBdHRyaWJ1dGVgLCBvYmplY3QgcHJvcGVydGllcyBhcmUgcHJvcGVybHlcbiAgICAgICAgICAvLyBgdG9TdHJpbmdgZWQgYnkgSUU4LzkuXG4gICAgICAgICAgbm9kZVtwcm9wTmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuVW5rbm93blByb3BlcnR5KG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKCFpc0F0dHJpYnV0ZU5hbWVTYWZlKG5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShuYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUobmFtZSwgJycgKyB2YWx1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBvbiBhIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogZnVuY3Rpb24gKG5vZGUsIG5hbWUpIHtcbiAgICB2YXIgcHJvcGVydHlJbmZvID0gRE9NUHJvcGVydHkucHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IERPTVByb3BlcnR5LnByb3BlcnRpZXNbbmFtZV0gOiBudWxsO1xuICAgIGlmIChwcm9wZXJ0eUluZm8pIHtcbiAgICAgIHZhciBtdXRhdGlvbk1ldGhvZCA9IHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZDtcbiAgICAgIGlmIChtdXRhdGlvbk1ldGhvZCkge1xuICAgICAgICBtdXRhdGlvbk1ldGhvZChub2RlLCB1bmRlZmluZWQpO1xuICAgICAgfSBlbHNlIGlmIChwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSkge1xuICAgICAgICBub2RlLnJlbW92ZUF0dHJpYnV0ZShwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcHJvcE5hbWUgPSBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lO1xuICAgICAgICB2YXIgZGVmYXVsdFZhbHVlID0gRE9NUHJvcGVydHkuZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHkobm9kZS5ub2RlTmFtZSwgcHJvcE5hbWUpO1xuICAgICAgICBpZiAoIXByb3BlcnR5SW5mby5oYXNTaWRlRWZmZWN0cyB8fCAnJyArIG5vZGVbcHJvcE5hbWVdICE9PSBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgICBub2RlW3Byb3BOYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUobmFtZSkpIHtcbiAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblVua25vd25Qcm9wZXJ0eShuYW1lKTtcbiAgICB9XG4gIH1cblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKERPTVByb3BlcnR5T3BlcmF0aW9ucywgJ0RPTVByb3BlcnR5T3BlcmF0aW9ucycsIHtcbiAgc2V0VmFsdWVGb3JQcm9wZXJ0eTogJ3NldFZhbHVlRm9yUHJvcGVydHknLFxuICBzZXRWYWx1ZUZvckF0dHJpYnV0ZTogJ3NldFZhbHVlRm9yQXR0cmlidXRlJyxcbiAgZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eTogJ2RlbGV0ZVZhbHVlRm9yUHJvcGVydHknXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eU9wZXJhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvRE9NUHJvcGVydHlPcGVyYXRpb25zLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIERPTVByb3BlcnR5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG5mdW5jdGlvbiBjaGVja01hc2sodmFsdWUsIGJpdG1hc2spIHtcbiAgcmV0dXJuICh2YWx1ZSAmIGJpdG1hc2spID09PSBiaXRtYXNrO1xufVxuXG52YXIgRE9NUHJvcGVydHlJbmplY3Rpb24gPSB7XG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbm9ybWFsaXplZCwgY2FtZWxjYXNlZCBwcm9wZXJ0eSBuYW1lcyB0byBhIGNvbmZpZ3VyYXRpb24gdGhhdFxuICAgKiBzcGVjaWZpZXMgaG93IHRoZSBhc3NvY2lhdGVkIERPTSBwcm9wZXJ0eSBzaG91bGQgYmUgYWNjZXNzZWQgb3IgcmVuZGVyZWQuXG4gICAqL1xuICBNVVNUX1VTRV9BVFRSSUJVVEU6IDB4MSxcbiAgTVVTVF9VU0VfUFJPUEVSVFk6IDB4MixcbiAgSEFTX1NJREVfRUZGRUNUUzogMHg0LFxuICBIQVNfQk9PTEVBTl9WQUxVRTogMHg4LFxuICBIQVNfTlVNRVJJQ19WQUxVRTogMHgxMCxcbiAgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUU6IDB4MjAgfCAweDEwLFxuICBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFOiAweDQwLFxuXG4gIC8qKlxuICAgKiBJbmplY3Qgc29tZSBzcGVjaWFsaXplZCBrbm93bGVkZ2UgYWJvdXQgdGhlIERPTS4gVGhpcyB0YWtlcyBhIGNvbmZpZyBvYmplY3RcbiAgICogd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gICAqXG4gICAqIGlzQ3VzdG9tQXR0cmlidXRlOiBmdW5jdGlvbiB0aGF0IGdpdmVuIGFuIGF0dHJpYnV0ZSBuYW1lIHdpbGwgcmV0dXJuIHRydWVcbiAgICogaWYgaXQgY2FuIGJlIGluc2VydGVkIGludG8gdGhlIERPTSB2ZXJiYXRpbS4gVXNlZnVsIGZvciBkYXRhLSogb3IgYXJpYS0qXG4gICAqIGF0dHJpYnV0ZXMgd2hlcmUgaXQncyBpbXBvc3NpYmxlIHRvIGVudW1lcmF0ZSBhbGwgb2YgdGhlIHBvc3NpYmxlXG4gICAqIGF0dHJpYnV0ZSBuYW1lcyxcbiAgICpcbiAgICogUHJvcGVydGllczogb2JqZWN0IG1hcHBpbmcgRE9NIHByb3BlcnR5IG5hbWUgdG8gb25lIG9mIHRoZVxuICAgKiBET01Qcm9wZXJ0eUluamVjdGlvbiBjb25zdGFudHMgb3IgbnVsbC4gSWYgeW91ciBhdHRyaWJ1dGUgaXNuJ3QgaW4gaGVyZSxcbiAgICogaXQgd29uJ3QgZ2V0IHdyaXR0ZW4gdG8gdGhlIERPTS5cbiAgICpcbiAgICogRE9NQXR0cmlidXRlTmFtZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWUuIEF0dHJpYnV0ZSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgKipsb3dlcmNhc2UqKlxuICAgKiBub3JtYWxpemVkIG5hbWUuXG4gICAqXG4gICAqIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXM6IG9iamVjdCBtYXBwaW5nIFJlYWN0IGF0dHJpYnV0ZSBuYW1lIHRvIHRoZSBET01cbiAgICogYXR0cmlidXRlIG5hbWVzcGFjZSBVUkwuIChBdHRyaWJ1dGUgbmFtZXMgbm90IHNwZWNpZmllZCB1c2Ugbm8gbmFtZXNwYWNlLilcbiAgICpcbiAgICogRE9NUHJvcGVydHlOYW1lczogc2ltaWxhciB0byBET01BdHRyaWJ1dGVOYW1lcyBidXQgZm9yIERPTSBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBub3Qgc3BlY2lmaWVkIHVzZSB0aGUgbm9ybWFsaXplZCBuYW1lLlxuICAgKlxuICAgKiBET01NdXRhdGlvbk1ldGhvZHM6IFByb3BlcnRpZXMgdGhhdCByZXF1aXJlIHNwZWNpYWwgbXV0YXRpb24gbWV0aG9kcy4gSWZcbiAgICogYHZhbHVlYCBpcyB1bmRlZmluZWQsIHRoZSBtdXRhdGlvbiBtZXRob2Qgc2hvdWxkIHVuc2V0IHRoZSBwcm9wZXJ0eS5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGRvbVByb3BlcnR5Q29uZmlnIHRoZSBjb25maWcgYXMgZGVzY3JpYmVkIGFib3ZlLlxuICAgKi9cbiAgaW5qZWN0RE9NUHJvcGVydHlDb25maWc6IGZ1bmN0aW9uIChkb21Qcm9wZXJ0eUNvbmZpZykge1xuICAgIHZhciBJbmplY3Rpb24gPSBET01Qcm9wZXJ0eUluamVjdGlvbjtcbiAgICB2YXIgUHJvcGVydGllcyA9IGRvbVByb3BlcnR5Q29uZmlnLlByb3BlcnRpZXMgfHwge307XG4gICAgdmFyIERPTUF0dHJpYnV0ZU5hbWVzcGFjZXMgPSBkb21Qcm9wZXJ0eUNvbmZpZy5ET01BdHRyaWJ1dGVOYW1lc3BhY2VzIHx8IHt9O1xuICAgIHZhciBET01BdHRyaWJ1dGVOYW1lcyA9IGRvbVByb3BlcnR5Q29uZmlnLkRPTUF0dHJpYnV0ZU5hbWVzIHx8IHt9O1xuICAgIHZhciBET01Qcm9wZXJ0eU5hbWVzID0gZG9tUHJvcGVydHlDb25maWcuRE9NUHJvcGVydHlOYW1lcyB8fCB7fTtcbiAgICB2YXIgRE9NTXV0YXRpb25NZXRob2RzID0gZG9tUHJvcGVydHlDb25maWcuRE9NTXV0YXRpb25NZXRob2RzIHx8IHt9O1xuXG4gICAgaWYgKGRvbVByb3BlcnR5Q29uZmlnLmlzQ3VzdG9tQXR0cmlidXRlKSB7XG4gICAgICBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnMucHVzaChkb21Qcm9wZXJ0eUNvbmZpZy5pc0N1c3RvbUF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gUHJvcGVydGllcykge1xuICAgICAgISFET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdpbmplY3RET01Qcm9wZXJ0eUNvbmZpZyguLi4pOiBZb3VcXCdyZSB0cnlpbmcgdG8gaW5qZWN0IERPTSBwcm9wZXJ0eSAnICsgJ1xcJyVzXFwnIHdoaWNoIGhhcyBhbHJlYWR5IGJlZW4gaW5qZWN0ZWQuIFlvdSBtYXkgYmUgYWNjaWRlbnRhbGx5ICcgKyAnaW5qZWN0aW5nIHRoZSBzYW1lIERPTSBwcm9wZXJ0eSBjb25maWcgdHdpY2UsIG9yIHlvdSBtYXkgYmUgJyArICdpbmplY3RpbmcgdHdvIGNvbmZpZ3MgdGhhdCBoYXZlIGNvbmZsaWN0aW5nIHByb3BlcnR5IG5hbWVzLicsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBsb3dlckNhc2VkID0gcHJvcE5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwcm9wQ29uZmlnID0gUHJvcGVydGllc1twcm9wTmFtZV07XG5cbiAgICAgIHZhciBwcm9wZXJ0eUluZm8gPSB7XG4gICAgICAgIGF0dHJpYnV0ZU5hbWU6IGxvd2VyQ2FzZWQsXG4gICAgICAgIGF0dHJpYnV0ZU5hbWVzcGFjZTogbnVsbCxcbiAgICAgICAgcHJvcGVydHlOYW1lOiBwcm9wTmFtZSxcbiAgICAgICAgbXV0YXRpb25NZXRob2Q6IG51bGwsXG5cbiAgICAgICAgbXVzdFVzZUF0dHJpYnV0ZTogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5NVVNUX1VTRV9BVFRSSUJVVEUpLFxuICAgICAgICBtdXN0VXNlUHJvcGVydHk6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uTVVTVF9VU0VfUFJPUEVSVFkpLFxuICAgICAgICBoYXNTaWRlRWZmZWN0czogY2hlY2tNYXNrKHByb3BDb25maWcsIEluamVjdGlvbi5IQVNfU0lERV9FRkZFQ1RTKSxcbiAgICAgICAgaGFzQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFKSxcbiAgICAgICAgaGFzTnVtZXJpY1ZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19OVU1FUklDX1ZBTFVFKSxcbiAgICAgICAgaGFzUG9zaXRpdmVOdW1lcmljVmFsdWU6IGNoZWNrTWFzayhwcm9wQ29uZmlnLCBJbmplY3Rpb24uSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUpLFxuICAgICAgICBoYXNPdmVybG9hZGVkQm9vbGVhblZhbHVlOiBjaGVja01hc2socHJvcENvbmZpZywgSW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUUpXG4gICAgICB9O1xuXG4gICAgICAhKCFwcm9wZXJ0eUluZm8ubXVzdFVzZUF0dHJpYnV0ZSB8fCAhcHJvcGVydHlJbmZvLm11c3RVc2VQcm9wZXJ0eSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRE9NUHJvcGVydHk6IENhbm5vdCByZXF1aXJlIHVzaW5nIGJvdGggYXR0cmlidXRlIGFuZCBwcm9wZXJ0eTogJXMnLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgIShwcm9wZXJ0eUluZm8ubXVzdFVzZVByb3BlcnR5IHx8ICFwcm9wZXJ0eUluZm8uaGFzU2lkZUVmZmVjdHMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0RPTVByb3BlcnR5OiBQcm9wZXJ0aWVzIHRoYXQgaGF2ZSBzaWRlIGVmZmVjdHMgbXVzdCB1c2UgcHJvcGVydHk6ICVzJywgcHJvcE5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICEocHJvcGVydHlJbmZvLmhhc0Jvb2xlYW5WYWx1ZSArIHByb3BlcnR5SW5mby5oYXNOdW1lcmljVmFsdWUgKyBwcm9wZXJ0eUluZm8uaGFzT3ZlcmxvYWRlZEJvb2xlYW5WYWx1ZSA8PSAxKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdET01Qcm9wZXJ0eTogVmFsdWUgY2FuIGJlIG9uZSBvZiBib29sZWFuLCBvdmVybG9hZGVkIGJvb2xlYW4sIG9yICcgKyAnbnVtZXJpYyB2YWx1ZSwgYnV0IG5vdCBhIGNvbWJpbmF0aW9uOiAlcycsIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIERPTVByb3BlcnR5LmdldFBvc3NpYmxlU3RhbmRhcmROYW1lW2xvd2VyQ2FzZWRdID0gcHJvcE5hbWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZU5hbWUgPSBET01BdHRyaWJ1dGVOYW1lc1twcm9wTmFtZV07XG4gICAgICAgIHByb3BlcnR5SW5mby5hdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlTmFtZTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eS5nZXRQb3NzaWJsZVN0YW5kYXJkTmFtZVthdHRyaWJ1dGVOYW1lXSA9IHByb3BOYW1lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChET01BdHRyaWJ1dGVOYW1lc3BhY2VzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8uYXR0cmlidXRlTmFtZXNwYWNlID0gRE9NQXR0cmlidXRlTmFtZXNwYWNlc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01Qcm9wZXJ0eU5hbWVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICBwcm9wZXJ0eUluZm8ucHJvcGVydHlOYW1lID0gRE9NUHJvcGVydHlOYW1lc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIGlmIChET01NdXRhdGlvbk1ldGhvZHMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BlcnR5SW5mby5tdXRhdGlvbk1ldGhvZCA9IERPTU11dGF0aW9uTWV0aG9kc1twcm9wTmFtZV07XG4gICAgICB9XG5cbiAgICAgIERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcE5hbWVdID0gcHJvcGVydHlJbmZvO1xuICAgIH1cbiAgfVxufTtcbnZhciBkZWZhdWx0VmFsdWVDYWNoZSA9IHt9O1xuXG4vKipcbiAqIERPTVByb3BlcnR5IGV4cG9ydHMgbG9va3VwIG9iamVjdHMgdGhhdCBjYW4gYmUgdXNlZCBsaWtlIGZ1bmN0aW9uczpcbiAqXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnaWQnXVxuICogICB0cnVlXG4gKiAgID4gRE9NUHJvcGVydHkuaXNWYWxpZFsnZm9vYmFyJ11cbiAqICAgdW5kZWZpbmVkXG4gKlxuICogQWx0aG91Z2ggdGhpcyBtYXkgYmUgY29uZnVzaW5nLCBpdCBwZXJmb3JtcyBiZXR0ZXIgaW4gZ2VuZXJhbC5cbiAqXG4gKiBAc2VlIGh0dHA6Ly9qc3BlcmYuY29tL2tleS1leGlzdHNcbiAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20va2V5LW1pc3NpbmdcbiAqL1xudmFyIERPTVByb3BlcnR5ID0ge1xuXG4gIElEX0FUVFJJQlVURV9OQU1FOiAnZGF0YS1yZWFjdGlkJyxcblxuICAvKipcbiAgICogTWFwIGZyb20gcHJvcGVydHkgXCJzdGFuZGFyZCBuYW1lXCIgdG8gYW4gb2JqZWN0IHdpdGggaW5mbyBhYm91dCBob3cgdG8gc2V0XG4gICAqIHRoZSBwcm9wZXJ0eSBpbiB0aGUgRE9NLiBFYWNoIG9iamVjdCBjb250YWluczpcbiAgICpcbiAgICogYXR0cmlidXRlTmFtZTpcbiAgICogICBVc2VkIHdoZW4gcmVuZGVyaW5nIG1hcmt1cCBvciB3aXRoIGAqQXR0cmlidXRlKClgLlxuICAgKiBhdHRyaWJ1dGVOYW1lc3BhY2VcbiAgICogcHJvcGVydHlOYW1lOlxuICAgKiAgIFVzZWQgb24gRE9NIG5vZGUgaW5zdGFuY2VzLiAoVGhpcyBpbmNsdWRlcyBwcm9wZXJ0aWVzIHRoYXQgbXV0YXRlIGR1ZSB0b1xuICAgKiAgIGV4dGVybmFsIGZhY3RvcnMuKVxuICAgKiBtdXRhdGlvbk1ldGhvZDpcbiAgICogICBJZiBub24tbnVsbCwgdXNlZCBpbnN0ZWFkIG9mIHRoZSBwcm9wZXJ0eSBvciBgc2V0QXR0cmlidXRlKClgIGFmdGVyXG4gICAqICAgaW5pdGlhbCByZW5kZXIuXG4gICAqIG11c3RVc2VBdHRyaWJ1dGU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCB1c2luZyBgKkF0dHJpYnV0ZSgpYC5cbiAgICogICAoVGhpcyBpbmNsdWRlcyBhbnl0aGluZyB0aGF0IGZhaWxzIGA8cHJvcE5hbWU+IGluIDxlbGVtZW50PmAuKVxuICAgKiBtdXN0VXNlUHJvcGVydHk6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgbXVzdCBiZSBhY2Nlc3NlZCBhbmQgbXV0YXRlZCBhcyBhbiBvYmplY3QgcHJvcGVydHkuXG4gICAqIGhhc1NpZGVFZmZlY3RzOlxuICAgKiAgIFdoZXRoZXIgb3Igbm90IHNldHRpbmcgYSB2YWx1ZSBjYXVzZXMgc2lkZSBlZmZlY3RzIHN1Y2ggYXMgdHJpZ2dlcmluZ1xuICAgKiAgIHJlc291cmNlcyB0byBiZSBsb2FkZWQgb3IgdGV4dCBzZWxlY3Rpb24gY2hhbmdlcy4gSWYgdHJ1ZSwgd2UgcmVhZCBmcm9tXG4gICAqICAgdGhlIERPTSBiZWZvcmUgdXBkYXRpbmcgdG8gZW5zdXJlIHRoYXQgdGhlIHZhbHVlIGlzIG9ubHkgc2V0IGlmIGl0IGhhc1xuICAgKiAgIGNoYW5nZWQuXG4gICAqIGhhc0Jvb2xlYW5WYWx1ZTpcbiAgICogICBXaGV0aGVyIHRoZSBwcm9wZXJ0eSBzaG91bGQgYmUgcmVtb3ZlZCB3aGVuIHNldCB0byBhIGZhbHNleSB2YWx1ZS5cbiAgICogaGFzTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIG51bWVyaWMgYW5kIHNob3VsZCBiZVxuICAgKiAgIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc1Bvc2l0aXZlTnVtZXJpY1ZhbHVlOlxuICAgKiAgIFdoZXRoZXIgdGhlIHByb3BlcnR5IG11c3QgYmUgcG9zaXRpdmUgbnVtZXJpYyBvciBwYXJzZSBhcyBhIHBvc2l0aXZlXG4gICAqICAgbnVtZXJpYyBhbmQgc2hvdWxkIGJlIHJlbW92ZWQgd2hlbiBzZXQgdG8gYSBmYWxzZXkgdmFsdWUuXG4gICAqIGhhc092ZXJsb2FkZWRCb29sZWFuVmFsdWU6XG4gICAqICAgV2hldGhlciB0aGUgcHJvcGVydHkgY2FuIGJlIHVzZWQgYXMgYSBmbGFnIGFzIHdlbGwgYXMgd2l0aCBhIHZhbHVlLlxuICAgKiAgIFJlbW92ZWQgd2hlbiBzdHJpY3RseSBlcXVhbCB0byBmYWxzZTsgcHJlc2VudCB3aXRob3V0IGEgdmFsdWUgd2hlblxuICAgKiAgIHN0cmljdGx5IGVxdWFsIHRvIHRydWU7IHByZXNlbnQgd2l0aCBhIHZhbHVlIG90aGVyd2lzZS5cbiAgICovXG4gIHByb3BlcnRpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBNYXBwaW5nIGZyb20gbG93ZXJjYXNlIHByb3BlcnR5IG5hbWVzIHRvIHRoZSBwcm9wZXJseSBjYXNlZCB2ZXJzaW9uLCB1c2VkXG4gICAqIHRvIHdhcm4gaW4gdGhlIGNhc2Ugb2YgbWlzc2luZyBwcm9wZXJ0aWVzLiBBdmFpbGFibGUgb25seSBpbiBfX0RFVl9fLlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgZ2V0UG9zc2libGVTdGFuZGFyZE5hbWU6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB7fSA6IG51bGwsXG5cbiAgLyoqXG4gICAqIEFsbCBvZiB0aGUgaXNDdXN0b21BdHRyaWJ1dGUoKSBmdW5jdGlvbnMgdGhhdCBoYXZlIGJlZW4gaW5qZWN0ZWQuXG4gICAqL1xuICBfaXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnM6IFtdLFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBhIHByb3BlcnR5IG5hbWUgaXMgYSBjdXN0b20gYXR0cmlidXRlLlxuICAgKiBAbWV0aG9kXG4gICAqL1xuICBpc0N1c3RvbUF0dHJpYnV0ZTogZnVuY3Rpb24gKGF0dHJpYnV0ZU5hbWUpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IERPTVByb3BlcnR5Ll9pc0N1c3RvbUF0dHJpYnV0ZUZ1bmN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlzQ3VzdG9tQXR0cmlidXRlRm4gPSBET01Qcm9wZXJ0eS5faXNDdXN0b21BdHRyaWJ1dGVGdW5jdGlvbnNbaV07XG4gICAgICBpZiAoaXNDdXN0b21BdHRyaWJ1dGVGbihhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHByb3BlcnR5IHZhbHVlIGZvciBhIERPTSBwcm9wZXJ0eSAoaS5lLiwgbm90IGFuXG4gICAqIGF0dHJpYnV0ZSkuIE1vc3QgZGVmYXVsdCB2YWx1ZXMgYXJlICcnIG9yIGZhbHNlLCBidXQgbm90IGFsbC4gV29yc2UgeWV0LFxuICAgKiBzb21lIChpbiBwYXJ0aWN1bGFyLCBgdHlwZWApIHZhcnkgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIGVsZW1lbnQuXG4gICAqXG4gICAqIFRPRE86IElzIGl0IGJldHRlciB0byBncmFiIGFsbCB0aGUgcG9zc2libGUgcHJvcGVydGllcyB3aGVuIGNyZWF0aW5nIGFuXG4gICAqIGVsZW1lbnQgdG8gYXZvaWQgaGF2aW5nIHRvIGNyZWF0ZSB0aGUgc2FtZSBlbGVtZW50IHR3aWNlP1xuICAgKi9cbiAgZ2V0RGVmYXVsdFZhbHVlRm9yUHJvcGVydHk6IGZ1bmN0aW9uIChub2RlTmFtZSwgcHJvcCkge1xuICAgIHZhciBub2RlRGVmYXVsdHMgPSBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV07XG4gICAgdmFyIHRlc3RFbGVtZW50O1xuICAgIGlmICghbm9kZURlZmF1bHRzKSB7XG4gICAgICBkZWZhdWx0VmFsdWVDYWNoZVtub2RlTmFtZV0gPSBub2RlRGVmYXVsdHMgPSB7fTtcbiAgICB9XG4gICAgaWYgKCEocHJvcCBpbiBub2RlRGVmYXVsdHMpKSB7XG4gICAgICB0ZXN0RWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQobm9kZU5hbWUpO1xuICAgICAgbm9kZURlZmF1bHRzW3Byb3BdID0gdGVzdEVsZW1lbnRbcHJvcF07XG4gICAgfVxuICAgIHJldHVybiBub2RlRGVmYXVsdHNbcHJvcF07XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiBET01Qcm9wZXJ0eUluamVjdGlvblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBET01Qcm9wZXJ0eTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9ET01Qcm9wZXJ0eS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBxdW90ZUF0dHJpYnV0ZVZhbHVlRm9yQnJvd3NlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG5cbi8qKlxuICogRXNjYXBlcyBhdHRyaWJ1dGUgdmFsdWUgdG8gcHJldmVudCBzY3JpcHRpbmcgYXR0YWNrcy5cbiAqXG4gKiBAcGFyYW0geyp9IHZhbHVlIFZhbHVlIHRvIGVzY2FwZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gQW4gZXNjYXBlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIHF1b3RlQXR0cmlidXRlVmFsdWVGb3JCcm93c2VyKHZhbHVlKSB7XG4gIHJldHVybiAnXCInICsgZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyKHZhbHVlKSArICdcIic7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvcXVvdGVBdHRyaWJ1dGVWYWx1ZUZvckJyb3dzZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgd2FybmluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24gKGNvbmRpdGlvbiwgZm9ybWF0KSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuID4gMiA/IF9sZW4gLSAyIDogMCksIF9rZXkgPSAyOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICB2YXIgYXJnSW5kZXggPSAwO1xuICAgICAgdmFyIG1lc3NhZ2UgPSAnV2FybmluZzogJyArIGZvcm1hdC5yZXBsYWNlKC8lcy9nLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgfSk7XG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgICB9XG4gICAgICB0cnkge1xuICAgICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCAoeCkge31cbiAgICB9XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gd2FybmluZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIvd2FybmluZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NSURPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdERPTUlET3BlcmF0aW9ucycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxuLyoqXG4gKiBBYnN0cmFjdHMgYXdheSBhbGwgZnVuY3Rpb25hbGl0eSBvZiB0aGUgcmVjb25jaWxlciB0aGF0IHJlcXVpcmVzIGtub3dsZWRnZSBvZlxuICogdGhlIGJyb3dzZXIgY29udGV4dC4gVE9ETzogVGhlc2UgY2FsbGVycyBzaG91bGQgYmUgcmVmYWN0b3JlZCB0byBhdm9pZCB0aGVcbiAqIG5lZWQgZm9yIHRoaXMgaW5qZWN0aW9uLlxuICovXG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSB7XG5cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogUmVhY3RET01JRE9wZXJhdGlvbnMuZGFuZ2Vyb3VzbHlQcm9jZXNzQ2hpbGRyZW5VcGRhdGVzLFxuXG4gIHJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IFJlYWN0RE9NSURPcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRCxcblxuICAvKipcbiAgICogSWYgYSBwYXJ0aWN1bGFyIGVudmlyb25tZW50IHJlcXVpcmVzIHRoYXQgc29tZSByZXNvdXJjZXMgYmUgY2xlYW5lZCB1cCxcbiAgICogc3BlY2lmeSB0aGlzIGluIHRoZSBpbmplY3RlZCBNaXhpbi4gSW4gdGhlIERPTSwgd2Ugd291bGQgbGlrZWx5IHdhbnQgdG9cbiAgICogcHVyZ2UgYW55IGNhY2hlZCBub2RlIElEIGxvb2t1cHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IGZ1bmN0aW9uIChyb290Tm9kZUlEKSB7XG4gICAgUmVhY3RNb3VudC5wdXJnZUlEKHJvb3ROb2RlSUQpO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01JRE9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NQ2hpbGRyZW5PcGVyYXRpb25zID0gcmVxdWlyZSgnLi9ET01DaGlsZHJlbk9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogRXJyb3JzIGZvciBwcm9wZXJ0aWVzIHRoYXQgc2hvdWxkIG5vdCBiZSB1cGRhdGVkIHdpdGggYHVwZGF0ZVByb3BlcnR5QnlJRCgpYC5cbiAqXG4gKiBAdHlwZSB7b2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xudmFyIElOVkFMSURfUFJPUEVSVFlfRVJST1JTID0ge1xuICBkYW5nZXJvdXNseVNldElubmVySFRNTDogJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgbXVzdCBiZSBzZXQgdXNpbmcgYHVwZGF0ZUlubmVySFRNTEJ5SUQoKWAuJyxcbiAgc3R5bGU6ICdgc3R5bGVgIG11c3QgYmUgc2V0IHVzaW5nIGB1cGRhdGVTdHlsZXNCeUlEKClgLidcbn07XG5cbi8qKlxuICogT3BlcmF0aW9ucyB1c2VkIHRvIHByb2Nlc3MgdXBkYXRlcyB0byBET00gbm9kZXMuXG4gKi9cbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHtcblxuICAvKipcbiAgICogVXBkYXRlcyBhIERPTSBub2RlIHdpdGggbmV3IHByb3BlcnR5IHZhbHVlcy4gVGhpcyBzaG91bGQgb25seSBiZSB1c2VkIHRvXG4gICAqIHVwZGF0ZSBET00gcHJvcGVydGllcyBpbiBgRE9NUHJvcGVydHlgLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIG5vZGUgdG8gdXBkYXRlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBBIHZhbGlkIHByb3BlcnR5IG5hbWUsIHNlZSBgRE9NUHJvcGVydHlgLlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIE5ldyB2YWx1ZSBvZiB0aGUgcHJvcGVydHkuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdXBkYXRlUHJvcGVydHlCeUlEOiBmdW5jdGlvbiAoaWQsIG5hbWUsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUoaWQpO1xuICAgICEhSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlMuaGFzT3duUHJvcGVydHkobmFtZSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndXBkYXRlUHJvcGVydHlCeUlEKC4uLik6ICVzJywgSU5WQUxJRF9QUk9QRVJUWV9FUlJPUlNbbmFtZV0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIElmIHdlJ3JlIHVwZGF0aW5nIHRvIG51bGwgb3IgdW5kZWZpbmVkLCB3ZSBzaG91bGQgcmVtb3ZlIHRoZSBwcm9wZXJ0eVxuICAgIC8vIGZyb20gdGhlIERPTSBub2RlIGluc3RlYWQgb2YgaW5hZHZlcnRhbnRseSBzZXR0aW5nIHRvIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0VmFsdWVGb3JQcm9wZXJ0eShub2RlLCBuYW1lLCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5kZWxldGVWYWx1ZUZvclByb3BlcnR5KG5vZGUsIG5hbWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYSBET00gbm9kZSB0aGF0IGV4aXN0cyBpbiB0aGUgZG9jdW1lbnQgd2l0aCBtYXJrdXAuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBjaGlsZCB0byBiZSByZXBsYWNlZC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBEYW5nZXJvdXMgbWFya3VwIHRvIGluamVjdCBpbiBwbGFjZSBvZiBjaGlsZC5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0Rhbmdlci5kYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cH1cbiAgICovXG4gIGRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDogZnVuY3Rpb24gKGlkLCBtYXJrdXApIHtcbiAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpZCk7XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLmRhbmdlcm91c2x5UmVwbGFjZU5vZGVXaXRoTWFya3VwKG5vZGUsIG1hcmt1cCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZXMgYSBjb21wb25lbnQncyBjaGlsZHJlbiBieSBwcm9jZXNzaW5nIGEgc2VyaWVzIG9mIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7YXJyYXk8b2JqZWN0Pn0gdXBkYXRlcyBMaXN0IG9mIHVwZGF0ZSBjb25maWd1cmF0aW9ucy5cbiAgICogQHBhcmFtIHthcnJheTxzdHJpbmc+fSBtYXJrdXAgTGlzdCBvZiBtYXJrdXAgc3RyaW5ncy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6IGZ1bmN0aW9uICh1cGRhdGVzLCBtYXJrdXApIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHVwZGF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHVwZGF0ZXNbaV0ucGFyZW50Tm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh1cGRhdGVzW2ldLnBhcmVudElEKTtcbiAgICB9XG4gICAgRE9NQ2hpbGRyZW5PcGVyYXRpb25zLnByb2Nlc3NVcGRhdGVzKHVwZGF0ZXMsIG1hcmt1cCk7XG4gIH1cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUlET3BlcmF0aW9ucywgJ1JlYWN0RE9NSURPcGVyYXRpb25zJywge1xuICBkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6ICdkYW5nZXJvdXNseVJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQnLFxuICBkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXM6ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUlET3BlcmF0aW9ucztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdERPTUlET3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1vdW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdERPTUZlYXR1cmVGbGFncyA9IHJlcXVpcmUoJy4vUmVhY3RET01GZWF0dXJlRmxhZ3MnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNldElubmVySFRNTCA9IHJlcXVpcmUoJy4vc2V0SW5uZXJIVE1MJyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdmFsaWRhdGVET01OZXN0aW5nID0gcmVxdWlyZSgnLi92YWxpZGF0ZURPTU5lc3RpbmcnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgQVRUUl9OQU1FID0gRE9NUHJvcGVydHkuSURfQVRUUklCVVRFX05BTUU7XG52YXIgbm9kZUNhY2hlID0ge307XG5cbnZhciBFTEVNRU5UX05PREVfVFlQRSA9IDE7XG52YXIgRE9DX05PREVfVFlQRSA9IDk7XG52YXIgRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFID0gMTE7XG5cbnZhciBvd25lckRvY3VtZW50Q29udGV4dEtleSA9ICdfX1JlYWN0TW91bnRfb3duZXJEb2N1bWVudCQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbi8qKiBNYXBwaW5nIGZyb20gcmVhY3RSb290SUQgdG8gUmVhY3QgY29tcG9uZW50IGluc3RhbmNlLiAqL1xudmFyIGluc3RhbmNlc0J5UmVhY3RSb290SUQgPSB7fTtcblxuLyoqIE1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byBgY29udGFpbmVyYCBub2Rlcy4gKi9cbnZhciBjb250YWluZXJzQnlSZWFjdFJvb3RJRCA9IHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKiogX19ERVZfXy1vbmx5IG1hcHBpbmcgZnJvbSByZWFjdFJvb3RJRCB0byByb290IGVsZW1lbnRzLiAqL1xuICB2YXIgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRCA9IHt9O1xufVxuXG4vLyBVc2VkIHRvIHN0b3JlIGJyZWFkdGgtZmlyc3Qgc2VhcmNoIHN0YXRlIGluIGZpbmRDb21wb25lbnRSb290LlxudmFyIGZpbmRDb21wb25lbnRSb290UmV1c2FibGVBcnJheSA9IFtdO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyXG4gKiB0aGF0J3Mgbm90IGNvbW1vbiBiZXR3ZWVuIHRoZSB0d28gZ2l2ZW4gc3RyaW5ncy5cbiAqXG4gKiBAcmV0dXJuIHtudW1iZXJ9IHRoZSBpbmRleCBvZiB0aGUgY2hhcmFjdGVyIHdoZXJlIHRoZSBzdHJpbmdzIGRpdmVyZ2VcbiAqL1xuZnVuY3Rpb24gZmlyc3REaWZmZXJlbmNlSW5kZXgoc3RyaW5nMSwgc3RyaW5nMikge1xuICB2YXIgbWluTGVuID0gTWF0aC5taW4oc3RyaW5nMS5sZW5ndGgsIHN0cmluZzIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW5MZW47IGkrKykge1xuICAgIGlmIChzdHJpbmcxLmNoYXJBdChpKSAhPT0gc3RyaW5nMi5jaGFyQXQoaSkpIHtcbiAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RyaW5nMS5sZW5ndGggPT09IHN0cmluZzIubGVuZ3RoID8gLTEgOiBtaW5MZW47XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTURvY3VtZW50fSBjb250YWluZXIgRE9NIGVsZW1lbnQgdGhhdCBtYXkgY29udGFpblxuICogYSBSZWFjdCBjb21wb25lbnRcbiAqIEByZXR1cm4gez8qfSBET00gZWxlbWVudCB0aGF0IG1heSBoYXZlIHRoZSByZWFjdFJvb3QgSUQsIG9yIG51bGwuXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpIHtcbiAgaWYgKCFjb250YWluZXIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmIChjb250YWluZXIubm9kZVR5cGUgPT09IERPQ19OT0RFX1RZUEUpIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IG1heSBjb250YWluIGEgUmVhY3QgY29tcG9uZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gQSBcInJlYWN0Um9vdFwiIElELCBpZiBhIFJlYWN0IGNvbXBvbmVudCBpcyByZW5kZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKSB7XG4gIHZhciByb290RWxlbWVudCA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICByZXR1cm4gcm9vdEVsZW1lbnQgJiYgUmVhY3RNb3VudC5nZXRJRChyb290RWxlbWVudCk7XG59XG5cbi8qKlxuICogQWNjZXNzaW5nIG5vZGVbQVRUUl9OQU1FXSBvciBjYWxsaW5nIGdldEF0dHJpYnV0ZShBVFRSX05BTUUpIG9uIGEgZm9ybVxuICogZWxlbWVudCBjYW4gcmV0dXJuIGl0cyBjb250cm9sIHdob3NlIG5hbWUgb3IgSUQgZXF1YWxzIEFUVFJfTkFNRS4gQWxsXG4gKiBET00gbm9kZXMgc3VwcG9ydCBgZ2V0QXR0cmlidXRlTm9kZWAgYnV0IHRoaXMgY2FuIGFsc28gZ2V0IGNhbGxlZCBvblxuICogb3RoZXIgb2JqZWN0cyBzbyBqdXN0IHJldHVybiAnJyBpZiB3ZSdyZSBnaXZlbiBzb21ldGhpbmcgb3RoZXIgdGhhbiBhXG4gKiBET00gbm9kZSAoc3VjaCBhcyB3aW5kb3cpLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR8RE9NV2luZG93fERPTURvY3VtZW50fERPTVRleHROb2RlfSBub2RlIERPTSBub2RlLlxuICogQHJldHVybiB7c3RyaW5nfSBJRCBvZiB0aGUgc3VwcGxpZWQgYGRvbU5vZGVgLlxuICovXG5mdW5jdGlvbiBnZXRJRChub2RlKSB7XG4gIHZhciBpZCA9IGludGVybmFsR2V0SUQobm9kZSk7XG4gIGlmIChpZCkge1xuICAgIGlmIChub2RlQ2FjaGUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICB2YXIgY2FjaGVkID0gbm9kZUNhY2hlW2lkXTtcbiAgICAgIGlmIChjYWNoZWQgIT09IG5vZGUpIHtcbiAgICAgICAgISFpc1ZhbGlkKGNhY2hlZCwgaWQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0TW91bnQ6IFR3byB2YWxpZCBidXQgdW5lcXVhbCBub2RlcyB3aXRoIHRoZSBzYW1lIGAlc2A6ICVzJywgQVRUUl9OQU1FLCBpZCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlQ2FjaGVbaWRdID0gbm9kZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaWQ7XG59XG5cbmZ1bmN0aW9uIGludGVybmFsR2V0SUQobm9kZSkge1xuICAvLyBJZiBub2RlIGlzIHNvbWV0aGluZyBsaWtlIGEgd2luZG93LCBkb2N1bWVudCwgb3IgdGV4dCBub2RlLCBub25lIG9mXG4gIC8vIHdoaWNoIHN1cHBvcnQgYXR0cmlidXRlcyBvciBhIC5nZXRBdHRyaWJ1dGUgbWV0aG9kLCBncmFjZWZ1bGx5IHJldHVyblxuICAvLyB0aGUgZW1wdHkgc3RyaW5nLCBhcyBpZiB0aGUgYXR0cmlidXRlIHdlcmUgbWlzc2luZy5cbiAgcmV0dXJuIG5vZGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoQVRUUl9OQU1FKSB8fCAnJztcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSBSZWFjdC1zcGVjaWZpYyBJRCBvZiB0aGUgZ2l2ZW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IG5vZGUgVGhlIERPTSBub2RlIHdob3NlIElEIHdpbGwgYmUgc2V0LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSB2YWx1ZSBvZiB0aGUgSUQgYXR0cmlidXRlLlxuICovXG5mdW5jdGlvbiBzZXRJRChub2RlLCBpZCkge1xuICB2YXIgb2xkSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICBpZiAob2xkSUQgIT09IGlkKSB7XG4gICAgZGVsZXRlIG5vZGVDYWNoZVtvbGRJRF07XG4gIH1cbiAgbm9kZS5zZXRBdHRyaWJ1dGUoQVRUUl9OQU1FLCBpZCk7XG4gIG5vZGVDYWNoZVtpZF0gPSBub2RlO1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSBub2RlIHdpdGggdGhlIHN1cHBsaWVkIFJlYWN0LWdlbmVyYXRlZCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QtZ2VuZXJhdGVkIERPTSBJRC5cbiAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IERPTSBub2RlIHdpdGggdGhlIHN1cHBsZWQgYGlkYC5cbiAqIEBpbnRlcm5hbFxuICovXG5mdW5jdGlvbiBnZXROb2RlKGlkKSB7XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogRmluZHMgdGhlIG5vZGUgd2l0aCB0aGUgc3VwcGxpZWQgcHVibGljIFJlYWN0IGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7Kn0gaW5zdGFuY2UgQSBwdWJsaWMgUmVhY3QgaW5zdGFuY2UuXG4gKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIG5vZGUgd2l0aCB0aGUgc3VwcGxlZCBgaWRgLlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldE5vZGVGcm9tSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQoaW5zdGFuY2UpLl9yb290Tm9kZUlEO1xuICBpZiAoUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmlzTnVsbENvbXBvbmVudElEKGlkKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICghbm9kZUNhY2hlLmhhc093blByb3BlcnR5KGlkKSB8fCAhaXNWYWxpZChub2RlQ2FjaGVbaWRdLCBpZCkpIHtcbiAgICBub2RlQ2FjaGVbaWRdID0gUmVhY3RNb3VudC5maW5kUmVhY3ROb2RlQnlJRChpZCk7XG4gIH1cbiAgcmV0dXJuIG5vZGVDYWNoZVtpZF07XG59XG5cbi8qKlxuICogQSBub2RlIGlzIFwidmFsaWRcIiBpZiBpdCBpcyBjb250YWluZWQgYnkgYSBjdXJyZW50bHkgbW91bnRlZCBjb250YWluZXIuXG4gKlxuICogVGhpcyBtZWFucyB0aGF0IHRoZSBub2RlIGRvZXMgbm90IGhhdmUgdG8gYmUgY29udGFpbmVkIGJ5IGEgZG9jdW1lbnQgaW5cbiAqIG9yZGVyIHRvIGJlIGNvbnNpZGVyZWQgdmFsaWQuXG4gKlxuICogQHBhcmFtIHs/RE9NRWxlbWVudH0gbm9kZSBUaGUgY2FuZGlkYXRlIERPTSBub2RlLlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBleHBlY3RlZCBJRCBvZiB0aGUgbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFdoZXRoZXIgdGhlIG5vZGUgaXMgY29udGFpbmVkIGJ5IGEgbW91bnRlZCBjb250YWluZXIuXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWQobm9kZSwgaWQpIHtcbiAgaWYgKG5vZGUpIHtcbiAgICAhKGludGVybmFsR2V0SUQobm9kZSkgPT09IGlkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdE1vdW50OiBVbmV4cGVjdGVkIG1vZGlmaWNhdGlvbiBvZiBgJXNgJywgQVRUUl9OQU1FKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gICAgaWYgKGNvbnRhaW5lciAmJiBjb250YWluc05vZGUoY29udGFpbmVyLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIENhdXNlcyB0aGUgY2FjaGUgdG8gZm9yZ2V0IGFib3V0IG9uZSBSZWFjdC1zcGVjaWZpYyBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgVGhlIElEIHRvIGZvcmdldC5cbiAqL1xuZnVuY3Rpb24gcHVyZ2VJRChpZCkge1xuICBkZWxldGUgbm9kZUNhY2hlW2lkXTtcbn1cblxudmFyIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuZnVuY3Rpb24gZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwoYW5jZXN0b3JJRCkge1xuICB2YXIgYW5jZXN0b3IgPSBub2RlQ2FjaGVbYW5jZXN0b3JJRF07XG4gIGlmIChhbmNlc3RvciAmJiBpc1ZhbGlkKGFuY2VzdG9yLCBhbmNlc3RvcklEKSkge1xuICAgIGRlZXBlc3ROb2RlU29GYXIgPSBhbmNlc3RvcjtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIG5vZGUgaXNuJ3QgcG9wdWxhdGVkIGluIHRoZSBjYWNoZSwgc28gcHJlc3VtYWJseSBub25lIG9mIGl0c1xuICAgIC8vIGRlc2NlbmRhbnRzIGFyZS4gQnJlYWsgb3V0IG9mIHRoZSBsb29wLlxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIFJldHVybiB0aGUgZGVlcGVzdCBjYWNoZWQgbm9kZSB3aG9zZSBJRCBpcyBhIHByZWZpeCBvZiBgdGFyZ2V0SURgLlxuICovXG5mdW5jdGlvbiBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB7XG4gIGRlZXBlc3ROb2RlU29GYXIgPSBudWxsO1xuICBSZWFjdEluc3RhbmNlSGFuZGxlcy50cmF2ZXJzZUFuY2VzdG9ycyh0YXJnZXRJRCwgZmluZERlZXBlc3RDYWNoZWRBbmNlc3RvckltcGwpO1xuXG4gIHZhciBmb3VuZE5vZGUgPSBkZWVwZXN0Tm9kZVNvRmFyO1xuICBkZWVwZXN0Tm9kZVNvRmFyID0gbnVsbDtcbiAgcmV0dXJuIGZvdW5kTm9kZTtcbn1cblxuLyoqXG4gKiBNb3VudHMgdGhpcyBjb21wb25lbnQgYW5kIGluc2VydHMgaXQgaW50byB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudEludG9Ob2RlKGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIGlmIChSZWFjdERPTUZlYXR1cmVGbGFncy51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgY29udGV4dCA9IGFzc2lnbih7fSwgY29udGV4dCk7XG4gICAgaWYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSkge1xuICAgICAgY29udGV4dFtvd25lckRvY3VtZW50Q29udGV4dEtleV0gPSBjb250YWluZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRleHRbb3duZXJEb2N1bWVudENvbnRleHRLZXldID0gY29udGFpbmVyLm93bmVyRG9jdW1lbnQ7XG4gICAgfVxuICB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKGNvbnRleHQgPT09IGVtcHR5T2JqZWN0KSB7XG4gICAgICBjb250ZXh0ID0ge307XG4gICAgfVxuICAgIHZhciB0YWcgPSBjb250YWluZXIubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKG51bGwsIHRhZywgbnVsbCk7XG4gIH1cbiAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gIGNvbXBvbmVudEluc3RhbmNlLl9yZW5kZXJlZENvbXBvbmVudC5fdG9wTGV2ZWxXcmFwcGVyID0gY29tcG9uZW50SW5zdGFuY2U7XG4gIFJlYWN0TW91bnQuX21vdW50SW1hZ2VJbnRvTm9kZShtYXJrdXAsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHRyYW5zYWN0aW9uKTtcbn1cblxuLyoqXG4gKiBCYXRjaGVkIG1vdW50LlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudEluc3RhbmNlIFRoZSBpbnN0YW5jZSB0byBtb3VudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byBtb3VudCBpbnRvLlxuICogQHBhcmFtIHtib29sZWFufSBzaG91bGRSZXVzZU1hcmt1cCBJZiB0cnVlLCBkbyBub3QgaW5zZXJ0IG1hcmt1cFxuICovXG5mdW5jdGlvbiBiYXRjaGVkTW91bnRDb21wb25lbnRJbnRvTm9kZShjb21wb25lbnRJbnN0YW5jZSwgcm9vdElELCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KSB7XG4gIHZhciB0cmFuc2FjdGlvbiA9IFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uLmdldFBvb2xlZChcbiAgLyogZm9yY2VIVE1MICovc2hvdWxkUmV1c2VNYXJrdXApO1xuICB0cmFuc2FjdGlvbi5wZXJmb3JtKG1vdW50Q29tcG9uZW50SW50b05vZGUsIG51bGwsIGNvbXBvbmVudEluc3RhbmNlLCByb290SUQsIGNvbnRhaW5lciwgdHJhbnNhY3Rpb24sIHNob3VsZFJldXNlTWFya3VwLCBjb250ZXh0KTtcbiAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG59XG5cbi8qKlxuICogVW5tb3VudHMgYSBjb21wb25lbnQgYW5kIHJlbW92ZXMgaXQgZnJvbSB0aGUgRE9NLlxuICpcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGluc3RhbmNlIFJlYWN0IGNvbXBvbmVudCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHVubW91bnQgZnJvbS5cbiAqIEBmaW5hbFxuICogQGludGVybmFsXG4gKiBAc2VlIHtSZWFjdE1vdW50LnVubW91bnRDb21wb25lbnRBdE5vZGV9XG4gKi9cbmZ1bmN0aW9uIHVubW91bnRDb21wb25lbnRGcm9tTm9kZShpbnN0YW5jZSwgY29udGFpbmVyKSB7XG4gIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KGluc3RhbmNlKTtcblxuICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFKSB7XG4gICAgY29udGFpbmVyID0gY29udGFpbmVyLmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIGh0dHA6Ly9qc3BlcmYuY29tL2VtcHR5aW5nLWEtbm9kZVxuICB3aGlsZSAoY29udGFpbmVyLmxhc3RDaGlsZCkge1xuICAgIGNvbnRhaW5lci5yZW1vdmVDaGlsZChjb250YWluZXIubGFzdENoaWxkKTtcbiAgfVxufVxuXG4vKipcbiAqIFRydWUgaWYgdGhlIHN1cHBsaWVkIERPTSBub2RlIGhhcyBhIGRpcmVjdCBSZWFjdC1yZW5kZXJlZCBjaGlsZCB0aGF0IGlzXG4gKiBub3QgYSBSZWFjdCByb290IGVsZW1lbnQuIFVzZWZ1bCBmb3Igd2FybmluZyBpbiBgcmVuZGVyYCxcbiAqIGB1bm1vdW50Q29tcG9uZW50QXROb2RlYCwgZXRjLlxuICpcbiAqIEBwYXJhbSB7P0RPTUVsZW1lbnR9IG5vZGUgVGhlIGNhbmRpZGF0ZSBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIERPTSBlbGVtZW50IGNvbnRhaW5zIGEgZGlyZWN0IGNoaWxkIHRoYXQgd2FzXG4gKiByZW5kZXJlZCBieSBSZWFjdCBidXQgaXMgbm90IGEgcm9vdCBlbGVtZW50LlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGhhc05vblJvb3RSZWFjdENoaWxkKG5vZGUpIHtcbiAgdmFyIHJlYWN0Um9vdElEID0gZ2V0UmVhY3RSb290SUQobm9kZSk7XG4gIHJldHVybiByZWFjdFJvb3RJRCA/IHJlYWN0Um9vdElEICE9PSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpIDogZmFsc2U7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgKGRlZXBlc3QpIGFuY2VzdG9yIG9mIGEgbm9kZSB3aGljaCBpcyByZW5kZXJlZCBieSB0aGlzIGNvcHlcbiAqIG9mIFJlYWN0LlxuICovXG5mdW5jdGlvbiBmaW5kRmlyc3RSZWFjdERPTUltcGwobm9kZSkge1xuICAvLyBUaGlzIG5vZGUgbWlnaHQgYmUgZnJvbSBhbm90aGVyIFJlYWN0IGluc3RhbmNlLCBzbyB3ZSBtYWtlIHN1cmUgbm90IHRvXG4gIC8vIGV4YW1pbmUgdGhlIG5vZGUgY2FjaGUgaGVyZVxuICBmb3IgKDsgbm9kZSAmJiBub2RlLnBhcmVudE5vZGUgIT09IG5vZGU7IG5vZGUgPSBub2RlLnBhcmVudE5vZGUpIHtcbiAgICBpZiAobm9kZS5ub2RlVHlwZSAhPT0gMSkge1xuICAgICAgLy8gTm90IGEgRE9NRWxlbWVudCwgdGhlcmVmb3JlIG5vdCBhIFJlYWN0IGNvbXBvbmVudFxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIHZhciBub2RlSUQgPSBpbnRlcm5hbEdldElEKG5vZGUpO1xuICAgIGlmICghbm9kZUlEKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG5cbiAgICAvLyBJZiBjb250YWluZXJzQnlSZWFjdFJvb3RJRCBjb250YWlucyB0aGUgY29udGFpbmVyIHdlIGZpbmQgYnkgY3Jhd2xpbmcgdXBcbiAgICAvLyB0aGUgdHJlZSwgd2Uga25vdyB0aGF0IHRoaXMgaW5zdGFuY2Ugb2YgUmVhY3QgcmVuZGVyZWQgdGhlIG5vZGUuXG4gICAgLy8gbmIuIGlzVmFsaWQncyBzdHJhdGVneSAod2l0aCBjb250YWluc05vZGUpIGRvZXMgbm90IHdvcmsgYmVjYXVzZSByZW5kZXJcbiAgICAvLyB0cmVlcyBtYXkgYmUgbmVzdGVkIGFuZCB3ZSBkb24ndCB3YW50IGEgZmFsc2UgcG9zaXRpdmUgaW4gdGhhdCBjYXNlLlxuICAgIHZhciBjdXJyZW50ID0gbm9kZTtcbiAgICB2YXIgbGFzdElEO1xuICAgIGRvIHtcbiAgICAgIGxhc3RJRCA9IGludGVybmFsR2V0SUQoY3VycmVudCk7XG4gICAgICBjdXJyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgICAgICAvLyBUaGUgcGFzc2VkLWluIG5vZGUgaGFzIGJlZW4gZGV0YWNoZWQgZnJvbSB0aGUgY29udGFpbmVyIGl0IHdhc1xuICAgICAgICAvLyBvcmlnaW5hbGx5IHJlbmRlcmVkIGludG8uXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKGxhc3RJRCAhPT0gcmVhY3RSb290SUQpO1xuXG4gICAgaWYgKGN1cnJlbnQgPT09IGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSkge1xuICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIFRlbXBvcmFyeSAoPykgaGFjayBzbyB0aGF0IHdlIGNhbiBzdG9yZSBhbGwgdG9wLWxldmVsIHBlbmRpbmcgdXBkYXRlcyBvblxuICogY29tcG9zaXRlcyBpbnN0ZWFkIG9mIGhhdmluZyB0byB3b3JyeSBhYm91dCBkaWZmZXJlbnQgdHlwZXMgb2YgY29tcG9uZW50c1xuICogaGVyZS5cbiAqL1xudmFyIFRvcExldmVsV3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuVG9wTGV2ZWxXcmFwcGVyLnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBUb3BMZXZlbFdyYXBwZXIuZGlzcGxheU5hbWUgPSAnVG9wTGV2ZWxXcmFwcGVyJztcbn1cblRvcExldmVsV3JhcHBlci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAvLyB0aGlzLnByb3BzIGlzIGFjdHVhbGx5IGEgUmVhY3RFbGVtZW50XG4gIHJldHVybiB0aGlzLnByb3BzO1xufTtcblxuLyoqXG4gKiBNb3VudGluZyBpcyB0aGUgcHJvY2VzcyBvZiBpbml0aWFsaXppbmcgYSBSZWFjdCBjb21wb25lbnQgYnkgY3JlYXRpbmcgaXRzXG4gKiByZXByZXNlbnRhdGl2ZSBET00gZWxlbWVudHMgYW5kIGluc2VydGluZyB0aGVtIGludG8gYSBzdXBwbGllZCBgY29udGFpbmVyYC5cbiAqIEFueSBwcmlvciBjb250ZW50IGluc2lkZSBgY29udGFpbmVyYCBpcyBkZXN0cm95ZWQgaW4gdGhlIHByb2Nlc3MuXG4gKlxuICogICBSZWFjdE1vdW50LnJlbmRlcihcbiAqICAgICBjb21wb25lbnQsXG4gKiAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRhaW5lcicpXG4gKiAgICk7XG4gKlxuICogICA8ZGl2IGlkPVwiY29udGFpbmVyXCI+ICAgICAgICAgICAgICAgICAgIDwtLSBTdXBwbGllZCBgY29udGFpbmVyYC5cbiAqICAgICA8ZGl2IGRhdGEtcmVhY3RpZD1cIi4zXCI+ICAgICAgICAgICAgICA8LS0gUmVuZGVyZWQgcmVhY3RSb290IG9mIFJlYWN0XG4gKiAgICAgICAvLyAuLi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb21wb25lbnQuXG4gKiAgICAgPC9kaXY+XG4gKiAgIDwvZGl2PlxuICpcbiAqIEluc2lkZSBvZiBgY29udGFpbmVyYCwgdGhlIGZpcnN0IGVsZW1lbnQgcmVuZGVyZWQgaXMgdGhlIFwicmVhY3RSb290XCIuXG4gKi9cbnZhciBSZWFjdE1vdW50ID0ge1xuXG4gIFRvcExldmVsV3JhcHBlcjogVG9wTGV2ZWxXcmFwcGVyLFxuXG4gIC8qKiBFeHBvc2VkIGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMgKiovXG4gIF9pbnN0YW5jZXNCeVJlYWN0Um9vdElEOiBpbnN0YW5jZXNCeVJlYWN0Um9vdElELFxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGEgaG9vayBwcm92aWRlZCB0byBzdXBwb3J0IHJlbmRlcmluZyBSZWFjdCBjb21wb25lbnRzIHdoaWxlXG4gICAqIGVuc3VyaW5nIHRoYXQgdGhlIGFwcGFyZW50IHNjcm9sbCBwb3NpdGlvbiBvZiBpdHMgYGNvbnRhaW5lcmAgZG9lcyBub3RcbiAgICogY2hhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBUaGUgYGNvbnRhaW5lcmAgYmVpbmcgcmVuZGVyZWQgaW50by5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gcmVuZGVyQ2FsbGJhY2sgVGhpcyBtdXN0IGJlIGNhbGxlZCBvbmNlIHRvIGRvIHRoZSByZW5kZXIuXG4gICAqL1xuICBzY3JvbGxNb25pdG9yOiBmdW5jdGlvbiAoY29udGFpbmVyLCByZW5kZXJDYWxsYmFjaykge1xuICAgIHJlbmRlckNhbGxiYWNrKCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRha2UgYSBjb21wb25lbnQgdGhhdCdzIGFscmVhZHkgbW91bnRlZCBpbnRvIHRoZSBET00gYW5kIHJlcGxhY2UgaXRzIHByb3BzXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IHByZXZDb21wb25lbnQgY29tcG9uZW50IGluc3RhbmNlIGFscmVhZHkgaW4gdGhlIERPTVxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgY29tcG9uZW50IGluc3RhbmNlIHRvIHJlbmRlclxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBjb250YWluZXIgdG8gcmVuZGVyIGludG9cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqL1xuICBfdXBkYXRlUm9vdENvbXBvbmVudDogZnVuY3Rpb24gKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50LCBjb250YWluZXIsIGNhbGxiYWNrKSB7XG4gICAgUmVhY3RNb3VudC5zY3JvbGxNb25pdG9yKGNvbnRhaW5lciwgZnVuY3Rpb24gKCkge1xuICAgICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlRWxlbWVudEludGVybmFsKHByZXZDb21wb25lbnQsIG5leHRFbGVtZW50KTtcbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKHByZXZDb21wb25lbnQsIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBSZWNvcmQgdGhlIHJvb3QgZWxlbWVudCBpbiBjYXNlIGl0IGxhdGVyIGdldHMgdHJhbnNwbGFudGVkLlxuICAgICAgcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtnZXRSZWFjdFJvb3RJRChjb250YWluZXIpXSA9IGdldFJlYWN0Um9vdEVsZW1lbnRJbkNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIH1cblxuICAgIHJldHVybiBwcmV2Q29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZWdpc3RlciBhIGNvbXBvbmVudCBpbnRvIHRoZSBpbnN0YW5jZSBtYXAgYW5kIHN0YXJ0cyBzY3JvbGwgdmFsdWVcbiAgICogbW9uaXRvcmluZ1xuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBuZXh0Q29tcG9uZW50IGNvbXBvbmVudCBpbnN0YW5jZSB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEByZXR1cm4ge3N0cmluZ30gcmVhY3RSb290IElEIHByZWZpeFxuICAgKi9cbiAgX3JlZ2lzdGVyQ29tcG9uZW50OiBmdW5jdGlvbiAobmV4dENvbXBvbmVudCwgY29udGFpbmVyKSB7XG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnX3JlZ2lzdGVyQ29tcG9uZW50KC4uLik6IFRhcmdldCBjb250YWluZXIgaXMgbm90IGEgRE9NIGVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmVuc3VyZVNjcm9sbFZhbHVlTW9uaXRvcmluZygpO1xuXG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5yZWdpc3RlckNvbnRhaW5lcihjb250YWluZXIpO1xuICAgIGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gbmV4dENvbXBvbmVudDtcbiAgICByZXR1cm4gcmVhY3RSb290SUQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbmRlciBhIG5ldyBjb21wb25lbnQgaW50byB0aGUgRE9NLlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgZWxlbWVudCB0byByZW5kZXJcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBjb250YWluZXIgY29udGFpbmVyIHRvIHJlbmRlciBpbnRvXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2hvdWxkUmV1c2VNYXJrdXAgaWYgd2Ugc2hvdWxkIHNraXAgdGhlIG1hcmt1cCBpbnNlcnRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IG5leHRDb21wb25lbnRcbiAgICovXG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiBmdW5jdGlvbiAobmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIGNvbnRleHQpIHtcbiAgICAvLyBWYXJpb3VzIHBhcnRzIG9mIG91ciBjb2RlIChzdWNoIGFzIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50J3NcbiAgICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGF0J3MgdGhlIGNhc2UuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9PSBudWxsLCAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSAnICsgJ3JlbmRlciBpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChuZXh0RWxlbWVudCwgbnVsbCk7XG4gICAgdmFyIHJlYWN0Um9vdElEID0gUmVhY3RNb3VudC5fcmVnaXN0ZXJDb21wb25lbnQoY29tcG9uZW50SW5zdGFuY2UsIGNvbnRhaW5lcik7XG5cbiAgICAvLyBUaGUgaW5pdGlhbCByZW5kZXIgaXMgc3luY2hyb25vdXMgYnV0IGFueSB1cGRhdGVzIHRoYXQgaGFwcGVuIGR1cmluZ1xuICAgIC8vIHJlbmRlcmluZywgaW4gY29tcG9uZW50V2lsbE1vdW50IG9yIGNvbXBvbmVudERpZE1vdW50LCB3aWxsIGJlIGJhdGNoZWRcbiAgICAvLyBhY2NvcmRpbmcgdG8gdGhlIGN1cnJlbnQgYmF0Y2hpbmcgc3RyYXRlZ3kuXG5cbiAgICBSZWFjdFVwZGF0ZXMuYmF0Y2hlZFVwZGF0ZXMoYmF0Y2hlZE1vdW50Q29tcG9uZW50SW50b05vZGUsIGNvbXBvbmVudEluc3RhbmNlLCByZWFjdFJvb3RJRCwgY29udGFpbmVyLCBzaG91bGRSZXVzZU1hcmt1cCwgY29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gUmVjb3JkIHRoZSByb290IGVsZW1lbnQgaW4gY2FzZSBpdCBsYXRlciBnZXRzIHRyYW5zcGxhbnRlZC5cbiAgICAgIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdID0gZ2V0UmVhY3RSb290RWxlbWVudEluQ29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBvbmVudEluc3RhbmNlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBwYXJlbnRDb21wb25lbnQgVGhlIGNvbmNlcHR1YWwgcGFyZW50IG9mIHRoaXMgcmVuZGVyIHRyZWUuXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudCBDb21wb25lbnQgZWxlbWVudCB0byByZW5kZXIuXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IHRvIHJlbmRlciBpbnRvLlxuICAgKiBAcGFyYW0gez9mdW5jdGlvbn0gY2FsbGJhY2sgZnVuY3Rpb24gdHJpZ2dlcmVkIG9uIGNvbXBsZXRpb25cbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IENvbXBvbmVudCBpbnN0YW5jZSByZW5kZXJlZCBpbiBgY29udGFpbmVyYC5cbiAgICovXG4gIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyOiBmdW5jdGlvbiAocGFyZW50Q29tcG9uZW50LCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgICEocGFyZW50Q29tcG9uZW50ICE9IG51bGwgJiYgcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncGFyZW50Q29tcG9uZW50IG11c3QgYmUgYSB2YWxpZCBSZWFjdCBDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIFJlYWN0TW91bnQuX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spO1xuICB9LFxuXG4gIF9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjogZnVuY3Rpb24gKHBhcmVudENvbXBvbmVudCwgbmV4dEVsZW1lbnQsIGNvbnRhaW5lciwgY2FsbGJhY2spIHtcbiAgICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KG5leHRFbGVtZW50KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTS5yZW5kZXIoKTogSW52YWxpZCBjb21wb25lbnQgZWxlbWVudC4lcycsIHR5cGVvZiBuZXh0RWxlbWVudCA9PT0gJ3N0cmluZycgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhbiBlbGVtZW50IHN0cmluZywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOiB0eXBlb2YgbmV4dEVsZW1lbnQgPT09ICdmdW5jdGlvbicgPyAnIEluc3RlYWQgb2YgcGFzc2luZyBhIGNvbXBvbmVudCBjbGFzcywgbWFrZSBzdXJlIHRvIGluc3RhbnRpYXRlICcgKyAnaXQgYnkgcGFzc2luZyBpdCB0byBSZWFjdC5jcmVhdGVFbGVtZW50LicgOlxuICAgIC8vIENoZWNrIGlmIGl0IHF1YWNrcyBsaWtlIGFuIGVsZW1lbnRcbiAgICBuZXh0RWxlbWVudCAhPSBudWxsICYmIG5leHRFbGVtZW50LnByb3BzICE9PSB1bmRlZmluZWQgPyAnIFRoaXMgbWF5IGJlIGNhdXNlZCBieSB1bmludGVudGlvbmFsbHkgbG9hZGluZyB0d28gaW5kZXBlbmRlbnQgJyArICdjb3BpZXMgb2YgUmVhY3QuJyA6ICcnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY29udGFpbmVyIHx8ICFjb250YWluZXIudGFnTmFtZSB8fCBjb250YWluZXIudGFnTmFtZS50b1VwcGVyQ2FzZSgpICE9PSAnQk9EWScsICdyZW5kZXIoKTogUmVuZGVyaW5nIGNvbXBvbmVudHMgZGlyZWN0bHkgaW50byBkb2N1bWVudC5ib2R5IGlzICcgKyAnZGlzY291cmFnZWQsIHNpbmNlIGl0cyBjaGlsZHJlbiBhcmUgb2Z0ZW4gbWFuaXB1bGF0ZWQgYnkgdGhpcmQtcGFydHkgJyArICdzY3JpcHRzIGFuZCBicm93c2VyIGV4dGVuc2lvbnMuIFRoaXMgbWF5IGxlYWQgdG8gc3VidGxlICcgKyAncmVjb25jaWxpYXRpb24gaXNzdWVzLiBUcnkgcmVuZGVyaW5nIGludG8gYSBjb250YWluZXIgZWxlbWVudCBjcmVhdGVkICcgKyAnZm9yIHlvdXIgYXBwLicpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIG5leHRXcmFwcGVkRWxlbWVudCA9IG5ldyBSZWFjdEVsZW1lbnQoVG9wTGV2ZWxXcmFwcGVyLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBudWxsLCBuZXh0RWxlbWVudCk7XG5cbiAgICB2YXIgcHJldkNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbZ2V0UmVhY3RSb290SUQoY29udGFpbmVyKV07XG5cbiAgICBpZiAocHJldkNvbXBvbmVudCkge1xuICAgICAgdmFyIHByZXZXcmFwcGVkRWxlbWVudCA9IHByZXZDb21wb25lbnQuX2N1cnJlbnRFbGVtZW50O1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldldyYXBwZWRFbGVtZW50LnByb3BzO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50KHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCkpIHtcbiAgICAgICAgdmFyIHB1YmxpY0luc3QgPSBwcmV2Q29tcG9uZW50Ll9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgICAgICB2YXIgdXBkYXRlZENhbGxiYWNrID0gY2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNhbGxiYWNrLmNhbGwocHVibGljSW5zdCk7XG4gICAgICAgIH07XG4gICAgICAgIFJlYWN0TW91bnQuX3VwZGF0ZVJvb3RDb21wb25lbnQocHJldkNvbXBvbmVudCwgbmV4dFdyYXBwZWRFbGVtZW50LCBjb250YWluZXIsIHVwZGF0ZWRDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBwdWJsaWNJbnN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgUmVhY3RNb3VudC51bm1vdW50Q29tcG9uZW50QXROb2RlKGNvbnRhaW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHJlYWN0Um9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgY29udGFpbmVySGFzUmVhY3RNYXJrdXAgPSByZWFjdFJvb3RFbGVtZW50ICYmICEhaW50ZXJuYWxHZXRJRChyZWFjdFJvb3RFbGVtZW50KTtcbiAgICB2YXIgY29udGFpbmVySGFzTm9uUm9vdFJlYWN0Q2hpbGQgPSBoYXNOb25Sb290UmVhY3RDaGlsZChjb250YWluZXIpO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZCwgJ3JlbmRlciguLi4pOiBSZXBsYWNpbmcgUmVhY3QtcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG5ldyByb290ICcgKyAnY29tcG9uZW50LiBJZiB5b3UgaW50ZW5kZWQgdG8gdXBkYXRlIHRoZSBjaGlsZHJlbiBvZiB0aGlzIG5vZGUsICcgKyAneW91IHNob3VsZCBpbnN0ZWFkIGhhdmUgdGhlIGV4aXN0aW5nIGNoaWxkcmVuIHVwZGF0ZSB0aGVpciBzdGF0ZSAnICsgJ2FuZCByZW5kZXIgdGhlIG5ldyBjb21wb25lbnRzIGluc3RlYWQgb2YgY2FsbGluZyBSZWFjdERPTS5yZW5kZXIuJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICghY29udGFpbmVySGFzUmVhY3RNYXJrdXAgfHwgcmVhY3RSb290RWxlbWVudC5uZXh0U2libGluZykge1xuICAgICAgICB2YXIgcm9vdEVsZW1lbnRTaWJsaW5nID0gcmVhY3RSb290RWxlbWVudDtcbiAgICAgICAgd2hpbGUgKHJvb3RFbGVtZW50U2libGluZykge1xuICAgICAgICAgIGlmIChpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50U2libGluZykpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAncmVuZGVyKCk6IFRhcmdldCBub2RlIGhhcyBtYXJrdXAgcmVuZGVyZWQgYnkgUmVhY3QsIGJ1dCB0aGVyZSAnICsgJ2FyZSB1bnJlbGF0ZWQgbm9kZXMgYXMgd2VsbC4gVGhpcyBpcyBtb3N0IGNvbW1vbmx5IGNhdXNlZCBieSAnICsgJ3doaXRlLXNwYWNlIGluc2VydGVkIGFyb3VuZCBzZXJ2ZXItcmVuZGVyZWQgbWFya3VwLicpIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJvb3RFbGVtZW50U2libGluZyA9IHJvb3RFbGVtZW50U2libGluZy5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzaG91bGRSZXVzZU1hcmt1cCA9IGNvbnRhaW5lckhhc1JlYWN0TWFya3VwICYmICFwcmV2Q29tcG9uZW50ICYmICFjb250YWluZXJIYXNOb25Sb290UmVhY3RDaGlsZDtcbiAgICB2YXIgY29tcG9uZW50ID0gUmVhY3RNb3VudC5fcmVuZGVyTmV3Um9vdENvbXBvbmVudChuZXh0V3JhcHBlZEVsZW1lbnQsIGNvbnRhaW5lciwgc2hvdWxkUmV1c2VNYXJrdXAsIHBhcmVudENvbXBvbmVudCAhPSBudWxsID8gcGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX3Byb2Nlc3NDaGlsZENvbnRleHQocGFyZW50Q29tcG9uZW50Ll9yZWFjdEludGVybmFsSW5zdGFuY2UuX2NvbnRleHQpIDogZW1wdHlPYmplY3QpLl9yZW5kZXJlZENvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2suY2FsbChjb21wb25lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gY29tcG9uZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBSZW5kZXJzIGEgUmVhY3QgY29tcG9uZW50IGludG8gdGhlIERPTSBpbiB0aGUgc3VwcGxpZWQgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIElmIHRoZSBSZWFjdCBjb21wb25lbnQgd2FzIHByZXZpb3VzbHkgcmVuZGVyZWQgaW50byBgY29udGFpbmVyYCwgdGhpcyB3aWxsXG4gICAqIHBlcmZvcm0gYW4gdXBkYXRlIG9uIGl0IGFuZCBvbmx5IG11dGF0ZSB0aGUgRE9NIGFzIG5lY2Vzc2FyeSB0byByZWZsZWN0IHRoZVxuICAgKiBsYXRlc3QgUmVhY3QgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gbmV4dEVsZW1lbnQgQ29tcG9uZW50IGVsZW1lbnQgdG8gcmVuZGVyLlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZW5kZXIgaW50by5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIGZ1bmN0aW9uIHRyaWdnZXJlZCBvbiBjb21wbGV0aW9uXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBDb21wb25lbnQgaW5zdGFuY2UgcmVuZGVyZWQgaW4gYGNvbnRhaW5lcmAuXG4gICAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBSZWFjdE1vdW50Ll9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcihudWxsLCBuZXh0RWxlbWVudCwgY29udGFpbmVyLCBjYWxsYmFjayk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIGNvbnRhaW5lciBub2RlIGludG8gd2hpY2ggUmVhY3QgY29tcG9uZW50cyB3aWxsIGJlIHJlbmRlcmVkLlxuICAgKiBUaGlzIGFsc28gY3JlYXRlcyB0aGUgXCJyZWFjdFJvb3RcIiBJRCB0aGF0IHdpbGwgYmUgYXNzaWduZWQgdG8gdGhlIGVsZW1lbnRcbiAgICogcmVuZGVyZWQgd2l0aGluLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGNvbnRhaW5lciBET00gZWxlbWVudCB0byByZWdpc3RlciBhcyBhIGNvbnRhaW5lci5cbiAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgXCJyZWFjdFJvb3RcIiBJRCBvZiBlbGVtZW50cyByZW5kZXJlZCB3aXRoaW4uXG4gICAqL1xuICByZWdpc3RlckNvbnRhaW5lcjogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgaWYgKHJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBJZiBvbmUgZXhpc3RzLCBtYWtlIHN1cmUgaXQgaXMgYSB2YWxpZCBcInJlYWN0Um9vdFwiIElELlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQocmVhY3RSb290SUQpO1xuICAgIH1cbiAgICBpZiAoIXJlYWN0Um9vdElEKSB7XG4gICAgICAvLyBObyB2YWxpZCBcInJlYWN0Um9vdFwiIElEIGZvdW5kLCBjcmVhdGUgb25lLlxuICAgICAgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5jcmVhdGVSZWFjdFJvb3RJRCgpO1xuICAgIH1cbiAgICBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gPSBjb250YWluZXI7XG4gICAgcmV0dXJuIHJlYWN0Um9vdElEO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVbm1vdW50cyBhbmQgZGVzdHJveXMgdGhlIFJlYWN0IGNvbXBvbmVudCByZW5kZXJlZCBpbiB0aGUgYGNvbnRhaW5lcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gY29udGFpbmVyIERPTSBlbGVtZW50IGNvbnRhaW5pbmcgYSBSZWFjdCBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYSBjb21wb25lbnQgd2FzIGZvdW5kIGluIGFuZCB1bm1vdW50ZWQgZnJvbVxuICAgKiAgICAgICAgICAgICAgICAgICBgY29udGFpbmVyYFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudEF0Tm9kZTogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xuICAgIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAgIC8vIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQpIGFzc3VtZSB0aGF0IGNhbGxzIHRvIHJlbmRlciBhcmVuJ3QgbmVzdGVkO1xuICAgIC8vIHZlcmlmeSB0aGF0IHRoYXQncyB0aGUgY2FzZS4gKFN0cmljdGx5IHNwZWFraW5nLCB1bm1vdW50aW5nIHdvbid0IGNhdXNlIGFcbiAgICAvLyByZW5kZXIgYnV0IHdlIHN0aWxsIGRvbid0IGV4cGVjdCB0byBiZSBpbiBhIHJlbmRlciBjYWxsIGhlcmUuKVxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPT0gbnVsbCwgJ3VubW91bnRDb21wb25lbnRBdE5vZGUoKTogUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZTsgdHJpZ2dlcmluZyBuZXN0ZWQgY29tcG9uZW50IHVwZGF0ZXMgZnJvbSByZW5kZXIgJyArICdpcyBub3QgYWxsb3dlZC4gSWYgbmVjZXNzYXJ5LCB0cmlnZ2VyIG5lc3RlZCB1cGRhdGVzIGluICcgKyAnY29tcG9uZW50RGlkVXBkYXRlLiBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiAlcy4nLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuXG4gICAgIShjb250YWluZXIgJiYgKGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRUxFTUVOVF9OT0RFX1RZUEUgfHwgY29udGFpbmVyLm5vZGVUeXBlID09PSBET0NfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSguLi4pOiBUYXJnZXQgY29udGFpbmVyIGlzIG5vdCBhIERPTSBlbGVtZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHZhciByZWFjdFJvb3RJRCA9IGdldFJlYWN0Um9vdElEKGNvbnRhaW5lcik7XG4gICAgdmFyIGNvbXBvbmVudCA9IGluc3RhbmNlc0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIGlmICghY29tcG9uZW50KSB7XG4gICAgICAvLyBDaGVjayBpZiB0aGUgbm9kZSBiZWluZyB1bm1vdW50ZWQgd2FzIHJlbmRlcmVkIGJ5IFJlYWN0LCBidXQgaXNuJ3QgYVxuICAgICAgLy8gcm9vdCBub2RlLlxuICAgICAgdmFyIGNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkID0gaGFzTm9uUm9vdFJlYWN0Q2hpbGQoY29udGFpbmVyKTtcblxuICAgICAgLy8gQ2hlY2sgaWYgdGhlIGNvbnRhaW5lciBpdHNlbGYgaXMgYSBSZWFjdCByb290IG5vZGUuXG4gICAgICB2YXIgY29udGFpbmVySUQgPSBpbnRlcm5hbEdldElEKGNvbnRhaW5lcik7XG4gICAgICB2YXIgaXNDb250YWluZXJSZWFjdFJvb3QgPSBjb250YWluZXJJRCAmJiBjb250YWluZXJJRCA9PT0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKGNvbnRhaW5lcklEKTtcblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWNvbnRhaW5lckhhc05vblJvb3RSZWFjdENoaWxkLCAndW5tb3VudENvbXBvbmVudEF0Tm9kZSgpOiBUaGUgbm9kZSB5b3VcXCdyZSBhdHRlbXB0aW5nIHRvIHVubW91bnQgJyArICd3YXMgcmVuZGVyZWQgYnkgUmVhY3QgYW5kIGlzIG5vdCBhIHRvcC1sZXZlbCBjb250YWluZXIuICVzJywgaXNDb250YWluZXJSZWFjdFJvb3QgPyAnWW91IG1heSBoYXZlIGFjY2lkZW50YWxseSBwYXNzZWQgaW4gYSBSZWFjdCByb290IG5vZGUgaW5zdGVhZCAnICsgJ29mIGl0cyBjb250YWluZXIuJyA6ICdJbnN0ZWFkLCBoYXZlIHRoZSBwYXJlbnQgY29tcG9uZW50IHVwZGF0ZSBpdHMgc3RhdGUgYW5kICcgKyAncmVyZW5kZXIgaW4gb3JkZXIgdG8gcmVtb3ZlIHRoaXMgY29tcG9uZW50LicpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyh1bm1vdW50Q29tcG9uZW50RnJvbU5vZGUsIGNvbXBvbmVudCwgY29udGFpbmVyKTtcbiAgICBkZWxldGUgaW5zdGFuY2VzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgZGVsZXRlIGNvbnRhaW5lcnNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgZGVsZXRlIHJvb3RFbGVtZW50c0J5UmVhY3RSb290SURbcmVhY3RSb290SURdO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogRmluZHMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCB0aGF0IGNvbnRhaW5zIFJlYWN0IGNvbXBvbmVudCB0byB3aGljaCB0aGVcbiAgICogc3VwcGxpZWQgRE9NIGBpZGAgYmVsb25ncy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFRoZSBJRCBvZiBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/RE9NRWxlbWVudH0gRE9NIGVsZW1lbnQgdGhhdCBjb250YWlucyB0aGUgYGlkYC5cbiAgICovXG4gIGZpbmRSZWFjdENvbnRhaW5lckZvcklEOiBmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgcmVhY3RSb290SUQgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5nZXRSZWFjdFJvb3RJREZyb21Ob2RlSUQoaWQpO1xuICAgIHZhciBjb250YWluZXIgPSBjb250YWluZXJzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIHJvb3RFbGVtZW50ID0gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF07XG4gICAgICBpZiAocm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKFxuICAgICAgICAvLyBDYWxsIGludGVybmFsR2V0SUQgaGVyZSBiZWNhdXNlIGdldElEIGNhbGxzIGlzVmFsaWQgd2hpY2ggY2FsbHNcbiAgICAgICAgLy8gZmluZFJlYWN0Q29udGFpbmVyRm9ySUQgKHRoaXMgZnVuY3Rpb24pLlxuICAgICAgICBpbnRlcm5hbEdldElEKHJvb3RFbGVtZW50KSA9PT0gcmVhY3RSb290SUQsICdSZWFjdE1vdW50OiBSb290IGVsZW1lbnQgSUQgZGlmZmVyZWQgZnJvbSByZWFjdFJvb3RJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgdmFyIGNvbnRhaW5lckNoaWxkID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIGlmIChjb250YWluZXJDaGlsZCAmJiByZWFjdFJvb3RJRCA9PT0gaW50ZXJuYWxHZXRJRChjb250YWluZXJDaGlsZCkpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgY29udGFpbmVyIGhhcyBhIG5ldyBjaGlsZCB3aXRoIHRoZSBzYW1lIElEIGFzIHRoZSBvbGRcbiAgICAgICAgICAvLyByb290IGVsZW1lbnQsIHRoZW4gcm9vdEVsZW1lbnRzQnlSZWFjdFJvb3RJRFtyZWFjdFJvb3RJRF0gaXNcbiAgICAgICAgICAvLyBqdXN0IHN0YWxlIGFuZCBuZWVkcyB0byBiZSB1cGRhdGVkLiBUaGUgY2FzZSB0aGF0IGRlc2VydmVzIGFcbiAgICAgICAgICAvLyB3YXJuaW5nIGlzIHdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0eS5cbiAgICAgICAgICByb290RWxlbWVudHNCeVJlYWN0Um9vdElEW3JlYWN0Um9vdElEXSA9IGNvbnRhaW5lckNoaWxkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RNb3VudDogUm9vdCBlbGVtZW50IGhhcyBiZWVuIHJlbW92ZWQgZnJvbSBpdHMgb3JpZ2luYWwgJyArICdjb250YWluZXIuIE5ldyBjb250YWluZXI6ICVzJywgcm9vdEVsZW1lbnQucGFyZW50Tm9kZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9LFxuXG4gIC8qKlxuICAgKiBGaW5kcyBhbiBlbGVtZW50IHJlbmRlcmVkIGJ5IFJlYWN0IHdpdGggdGhlIHN1cHBsaWVkIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgYSBET00gbm9kZSBpbiB0aGUgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHtET01FbGVtZW50fSBSb290IERPTSBub2RlIG9mIHRoZSBSZWFjdCBjb21wb25lbnQuXG4gICAqL1xuICBmaW5kUmVhY3ROb2RlQnlJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIHJlYWN0Um9vdCA9IFJlYWN0TW91bnQuZmluZFJlYWN0Q29udGFpbmVyRm9ySUQoaWQpO1xuICAgIHJldHVybiBSZWFjdE1vdW50LmZpbmRDb21wb25lbnRSb290KHJlYWN0Um9vdCwgaWQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmF2ZXJzZXMgdXAgdGhlIGFuY2VzdG9ycyBvZiB0aGUgc3VwcGxpZWQgbm9kZSB0byBmaW5kIGEgbm9kZSB0aGF0IGlzIGFcbiAgICogRE9NIHJlcHJlc2VudGF0aW9uIG9mIGEgUmVhY3QgY29tcG9uZW50IHJlbmRlcmVkIGJ5IHRoaXMgY29weSBvZiBSZWFjdC5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBub2RlXG4gICAqIEByZXR1cm4gez9ET01FdmVudFRhcmdldH1cbiAgICogQGludGVybmFsXG4gICAqL1xuICBnZXRGaXJzdFJlYWN0RE9NOiBmdW5jdGlvbiAobm9kZSkge1xuICAgIHJldHVybiBmaW5kRmlyc3RSZWFjdERPTUltcGwobm9kZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbmRzIGEgbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgIGluc2lkZSBvZiB0aGUgc3VwcGxpZWRcbiAgICogYGFuY2VzdG9yTm9kZWAuICBFeHBsb2l0cyB0aGUgSUQgbmFtaW5nIHNjaGVtZSB0byBwZXJmb3JtIHRoZSBzZWFyY2hcbiAgICogcXVpY2tseS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gYW5jZXN0b3JOb2RlIFNlYXJjaCBmcm9tIHRoaXMgcm9vdC5cbiAgICogQHBhcmFybSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgRE9NIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjb21wb25lbnQuXG4gICAqIEByZXR1cm4ge0RPTUV2ZW50VGFyZ2V0fSBET00gbm9kZSB3aXRoIHRoZSBzdXBwbGllZCBgdGFyZ2V0SURgLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGZpbmRDb21wb25lbnRSb290OiBmdW5jdGlvbiAoYW5jZXN0b3JOb2RlLCB0YXJnZXRJRCkge1xuICAgIHZhciBmaXJzdENoaWxkcmVuID0gZmluZENvbXBvbmVudFJvb3RSZXVzYWJsZUFycmF5O1xuICAgIHZhciBjaGlsZEluZGV4ID0gMDtcblxuICAgIHZhciBkZWVwZXN0QW5jZXN0b3IgPSBmaW5kRGVlcGVzdENhY2hlZEFuY2VzdG9yKHRhcmdldElEKSB8fCBhbmNlc3Rvck5vZGU7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gVGhpcyB3aWxsIHRocm93IG9uIHRoZSBuZXh0IGxpbmU7IGdpdmUgYW4gZWFybHkgd2FybmluZ1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZGVlcGVzdEFuY2VzdG9yICE9IG51bGwsICdSZWFjdCBjYW5cXCd0IGZpbmQgdGhlIHJvb3QgY29tcG9uZW50IG5vZGUgZm9yIGRhdGEtcmVhY3RpZCB2YWx1ZSAnICsgJ2Alc2AuIElmIHlvdVxcJ3JlIHNlZWluZyB0aGlzIG1lc3NhZ2UsIGl0IHByb2JhYmx5IG1lYW5zIHRoYXQgJyArICd5b3VcXCd2ZSBsb2FkZWQgdHdvIGNvcGllcyBvZiBSZWFjdCBvbiB0aGUgcGFnZS4gQXQgdGhpcyB0aW1lLCBvbmx5ICcgKyAnYSBzaW5nbGUgY29weSBvZiBSZWFjdCBjYW4gYmUgbG9hZGVkIGF0IGEgdGltZS4nLCB0YXJnZXRJRCkgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgZmlyc3RDaGlsZHJlblswXSA9IGRlZXBlc3RBbmNlc3Rvci5maXJzdENoaWxkO1xuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMTtcblxuICAgIHdoaWxlIChjaGlsZEluZGV4IDwgZmlyc3RDaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHZhciBjaGlsZCA9IGZpcnN0Q2hpbGRyZW5bY2hpbGRJbmRleCsrXTtcbiAgICAgIHZhciB0YXJnZXRDaGlsZDtcblxuICAgICAgd2hpbGUgKGNoaWxkKSB7XG4gICAgICAgIHZhciBjaGlsZElEID0gUmVhY3RNb3VudC5nZXRJRChjaGlsZCk7XG4gICAgICAgIGlmIChjaGlsZElEKSB7XG4gICAgICAgICAgLy8gRXZlbiBpZiB3ZSBmaW5kIHRoZSBub2RlIHdlJ3JlIGxvb2tpbmcgZm9yLCB3ZSBmaW5pc2ggbG9vcGluZ1xuICAgICAgICAgIC8vIHRocm91Z2ggaXRzIHNpYmxpbmdzIHRvIGVuc3VyZSB0aGV5J3JlIGNhY2hlZCBzbyB0aGF0IHdlIGRvbid0IGhhdmVcbiAgICAgICAgICAvLyB0byByZXZpc2l0IHRoaXMgbm9kZSBhZ2Fpbi4gT3RoZXJ3aXNlLCB3ZSBtYWtlIG5eMiBjYWxscyB0byBnZXRJRFxuICAgICAgICAgIC8vIHdoZW4gdmlzaXRpbmcgdGhlIG1hbnkgY2hpbGRyZW4gb2YgYSBzaW5nbGUgbm9kZSBpbiBvcmRlci5cblxuICAgICAgICAgIGlmICh0YXJnZXRJRCA9PT0gY2hpbGRJRCkge1xuICAgICAgICAgICAgdGFyZ2V0Q2hpbGQgPSBjaGlsZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKFJlYWN0SW5zdGFuY2VIYW5kbGVzLmlzQW5jZXN0b3JJRE9mKGNoaWxkSUQsIHRhcmdldElEKSkge1xuICAgICAgICAgICAgLy8gSWYgd2UgZmluZCBhIGNoaWxkIHdob3NlIElEIGlzIGFuIGFuY2VzdG9yIG9mIHRoZSBnaXZlbiBJRCxcbiAgICAgICAgICAgIC8vIHRoZW4gd2UgY2FuIGJlIHN1cmUgdGhhdCB3ZSBvbmx5IHdhbnQgdG8gc2VhcmNoIHRoZSBzdWJ0cmVlXG4gICAgICAgICAgICAvLyByb290ZWQgYXQgdGhpcyBjaGlsZCwgc28gd2UgY2FuIHRocm93IG91dCB0aGUgcmVzdCBvZiB0aGVcbiAgICAgICAgICAgIC8vIHNlYXJjaCBzdGF0ZS5cbiAgICAgICAgICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gY2hpbGRJbmRleCA9IDA7XG4gICAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIElmIHRoaXMgY2hpbGQgaGFkIG5vIElELCB0aGVuIHRoZXJlJ3MgYSBjaGFuY2UgdGhhdCBpdCB3YXNcbiAgICAgICAgICAvLyBpbmplY3RlZCBhdXRvbWF0aWNhbGx5IGJ5IHRoZSBicm93c2VyLCBhcyB3aGVuIGEgYDx0YWJsZT5gXG4gICAgICAgICAgLy8gZWxlbWVudCBzcHJvdXRzIGFuIGV4dHJhIGA8dGJvZHk+YCBjaGlsZCBhcyBhIHNpZGUgZWZmZWN0IG9mXG4gICAgICAgICAgLy8gYC5pbm5lckhUTUxgIHBhcnNpbmcuIE9wdGltaXN0aWNhbGx5IGNvbnRpbnVlIGRvd24gdGhpc1xuICAgICAgICAgIC8vIGJyYW5jaCwgYnV0IG5vdCBiZWZvcmUgZXhhbWluaW5nIHRoZSBvdGhlciBzaWJsaW5ncy5cbiAgICAgICAgICBmaXJzdENoaWxkcmVuLnB1c2goY2hpbGQuZmlyc3RDaGlsZCk7XG4gICAgICAgIH1cblxuICAgICAgICBjaGlsZCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGFyZ2V0Q2hpbGQpIHtcbiAgICAgICAgLy8gRW1wdHlpbmcgZmlyc3RDaGlsZHJlbi9maW5kQ29tcG9uZW50Um9vdFJldXNhYmxlQXJyYXkgaXNcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSBmb3IgY29ycmVjdG5lc3MsIGJ1dCBpdCBoZWxwcyB0aGUgR0MgcmVjbGFpbVxuICAgICAgICAvLyBhbnkgbm9kZXMgdGhhdCB3ZXJlIGxlZnQgYXQgdGhlIGVuZCBvZiB0aGUgc2VhcmNoLlxuICAgICAgICBmaXJzdENoaWxkcmVuLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgcmV0dXJuIHRhcmdldENoaWxkO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZpcnN0Q2hpbGRyZW4ubGVuZ3RoID0gMDtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdmaW5kQ29tcG9uZW50Um9vdCguLi4sICVzKTogVW5hYmxlIHRvIGZpbmQgZWxlbWVudC4gVGhpcyBwcm9iYWJseSAnICsgJ21lYW5zIHRoZSBET00gd2FzIHVuZXhwZWN0ZWRseSBtdXRhdGVkIChlLmcuLCBieSB0aGUgYnJvd3NlciksICcgKyAndXN1YWxseSBkdWUgdG8gZm9yZ2V0dGluZyBhIDx0Ym9keT4gd2hlbiB1c2luZyB0YWJsZXMsIG5lc3RpbmcgdGFncyAnICsgJ2xpa2UgPGZvcm0+LCA8cD4sIG9yIDxhPiwgb3IgdXNpbmcgbm9uLVNWRyBlbGVtZW50cyBpbiBhbiA8c3ZnPiAnICsgJ3BhcmVudC4gJyArICdUcnkgaW5zcGVjdGluZyB0aGUgY2hpbGQgbm9kZXMgb2YgdGhlIGVsZW1lbnQgd2l0aCBSZWFjdCBJRCBgJXNgLicsIHRhcmdldElELCBSZWFjdE1vdW50LmdldElEKGFuY2VzdG9yTm9kZSkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSxcblxuICBfbW91bnRJbWFnZUludG9Ob2RlOiBmdW5jdGlvbiAobWFya3VwLCBjb250YWluZXIsIHNob3VsZFJldXNlTWFya3VwLCB0cmFuc2FjdGlvbikge1xuICAgICEoY29udGFpbmVyICYmIChjb250YWluZXIubm9kZVR5cGUgPT09IEVMRU1FTlRfTk9ERV9UWVBFIHx8IGNvbnRhaW5lci5ub2RlVHlwZSA9PT0gRE9DX05PREVfVFlQRSB8fCBjb250YWluZXIubm9kZVR5cGUgPT09IERPQ1VNRU5UX0ZSQUdNRU5UX05PREVfVFlQRSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ21vdW50Q29tcG9uZW50SW50b05vZGUoLi4uKTogVGFyZ2V0IGNvbnRhaW5lciBpcyBub3QgdmFsaWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgaWYgKHNob3VsZFJldXNlTWFya3VwKSB7XG4gICAgICB2YXIgcm9vdEVsZW1lbnQgPSBnZXRSZWFjdFJvb3RFbGVtZW50SW5Db250YWluZXIoY29udGFpbmVyKTtcbiAgICAgIGlmIChSZWFjdE1hcmt1cENoZWNrc3VtLmNhblJldXNlTWFya3VwKG1hcmt1cCwgcm9vdEVsZW1lbnQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBjaGVja3N1bSA9IHJvb3RFbGVtZW50LmdldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG4gICAgICAgIHJvb3RFbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSk7XG5cbiAgICAgICAgdmFyIHJvb3RNYXJrdXAgPSByb290RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgIHJvb3RFbGVtZW50LnNldEF0dHJpYnV0ZShSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSwgY2hlY2tzdW0pO1xuXG4gICAgICAgIHZhciBub3JtYWxpemVkTWFya3VwID0gbWFya3VwO1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIC8vIGJlY2F1c2Ugcm9vdE1hcmt1cCBpcyByZXRyaWV2ZWQgZnJvbSB0aGUgRE9NLCB2YXJpb3VzIG5vcm1hbGl6YXRpb25zXG4gICAgICAgICAgLy8gd2lsbCBoYXZlIG9jY3VycmVkIHdoaWNoIHdpbGwgbm90IGJlIHByZXNlbnQgaW4gYG1hcmt1cGAuIEhlcmUsXG4gICAgICAgICAgLy8gaW5zZXJ0IG1hcmt1cCBpbnRvIGEgPGRpdj4gb3IgPGlmcmFtZT4gZGVwZW5kaW5nIG9uIHRoZSBjb250YWluZXJcbiAgICAgICAgICAvLyB0eXBlIHRvIHBlcmZvcm0gdGhlIHNhbWUgbm9ybWFsaXphdGlvbnMgYmVmb3JlIGNvbXBhcmluZy5cbiAgICAgICAgICB2YXIgbm9ybWFsaXplcjtcbiAgICAgICAgICBpZiAoY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSkge1xuICAgICAgICAgICAgbm9ybWFsaXplciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgbm9ybWFsaXplci5pbm5lckhUTUwgPSBtYXJrdXA7XG4gICAgICAgICAgICBub3JtYWxpemVkTWFya3VwID0gbm9ybWFsaXplci5pbm5lckhUTUw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQobm9ybWFsaXplcik7XG4gICAgICAgICAgICBub3JtYWxpemVyLmNvbnRlbnREb2N1bWVudC53cml0ZShtYXJrdXApO1xuICAgICAgICAgICAgbm9ybWFsaXplZE1hcmt1cCA9IG5vcm1hbGl6ZXIuY29udGVudERvY3VtZW50LmRvY3VtZW50RWxlbWVudC5vdXRlckhUTUw7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKG5vcm1hbGl6ZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkaWZmSW5kZXggPSBmaXJzdERpZmZlcmVuY2VJbmRleChub3JtYWxpemVkTWFya3VwLCByb290TWFya3VwKTtcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSAnIChjbGllbnQpICcgKyBub3JtYWxpemVkTWFya3VwLnN1YnN0cmluZyhkaWZmSW5kZXggLSAyMCwgZGlmZkluZGV4ICsgMjApICsgJ1xcbiAoc2VydmVyKSAnICsgcm9vdE1hcmt1cC5zdWJzdHJpbmcoZGlmZkluZGV4IC0gMjAsIGRpZmZJbmRleCArIDIwKTtcblxuICAgICAgICAhKGNvbnRhaW5lci5ub2RlVHlwZSAhPT0gRE9DX05PREVfVFlQRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnWW91XFwncmUgdHJ5aW5nIHRvIHJlbmRlciBhIGNvbXBvbmVudCB0byB0aGUgZG9jdW1lbnQgdXNpbmcgJyArICdzZXJ2ZXIgcmVuZGVyaW5nIGJ1dCB0aGUgY2hlY2tzdW0gd2FzIGludmFsaWQuIFRoaXMgdXN1YWxseSAnICsgJ21lYW5zIHlvdSByZW5kZXJlZCBhIGRpZmZlcmVudCBjb21wb25lbnQgdHlwZSBvciBwcm9wcyBvbiAnICsgJ3RoZSBjbGllbnQgZnJvbSB0aGUgb25lIG9uIHRoZSBzZXJ2ZXIsIG9yIHlvdXIgcmVuZGVyKCkgJyArICdtZXRob2RzIGFyZSBpbXB1cmUuIFJlYWN0IGNhbm5vdCBoYW5kbGUgdGhpcyBjYXNlIGR1ZSB0byAnICsgJ2Nyb3NzLWJyb3dzZXIgcXVpcmtzIGJ5IHJlbmRlcmluZyBhdCB0aGUgZG9jdW1lbnQgcm9vdC4gWW91ICcgKyAnc2hvdWxkIGxvb2sgZm9yIGVudmlyb25tZW50IGRlcGVuZGVudCBjb2RlIGluIHlvdXIgY29tcG9uZW50cyAnICsgJ2FuZCBlbnN1cmUgdGhlIHByb3BzIGFyZSB0aGUgc2FtZSBjbGllbnQgYW5kIHNlcnZlciBzaWRlOlxcbiVzJywgZGlmZmVyZW5jZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdCBhdHRlbXB0ZWQgdG8gcmV1c2UgbWFya3VwIGluIGEgY29udGFpbmVyIGJ1dCB0aGUgJyArICdjaGVja3N1bSB3YXMgaW52YWxpZC4gVGhpcyBnZW5lcmFsbHkgbWVhbnMgdGhhdCB5b3UgYXJlICcgKyAndXNpbmcgc2VydmVyIHJlbmRlcmluZyBhbmQgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlICcgKyAnc2VydmVyIHdhcyBub3Qgd2hhdCB0aGUgY2xpZW50IHdhcyBleHBlY3RpbmcuIFJlYWN0IGluamVjdGVkICcgKyAnbmV3IG1hcmt1cCB0byBjb21wZW5zYXRlIHdoaWNoIHdvcmtzIGJ1dCB5b3UgaGF2ZSBsb3N0IG1hbnkgJyArICdvZiB0aGUgYmVuZWZpdHMgb2Ygc2VydmVyIHJlbmRlcmluZy4gSW5zdGVhZCwgZmlndXJlIG91dCAnICsgJ3doeSB0aGUgbWFya3VwIGJlaW5nIGdlbmVyYXRlZCBpcyBkaWZmZXJlbnQgb24gdGhlIGNsaWVudCAnICsgJ29yIHNlcnZlcjpcXG4lcycsIGRpZmZlcmVuY2UpIDogdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgIShjb250YWluZXIubm9kZVR5cGUgIT09IERPQ19OT0RFX1RZUEUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1lvdVxcJ3JlIHRyeWluZyB0byByZW5kZXIgYSBjb21wb25lbnQgdG8gdGhlIGRvY3VtZW50IGJ1dCAnICsgJ3lvdSBkaWRuXFwndCB1c2Ugc2VydmVyIHJlbmRlcmluZy4gV2UgY2FuXFwndCBkbyB0aGlzICcgKyAnd2l0aG91dCB1c2luZyBzZXJ2ZXIgcmVuZGVyaW5nIGR1ZSB0byBjcm9zcy1icm93c2VyIHF1aXJrcy4gJyArICdTZWUgUmVhY3RET01TZXJ2ZXIucmVuZGVyVG9TdHJpbmcoKSBmb3Igc2VydmVyIHJlbmRlcmluZy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAodHJhbnNhY3Rpb24udXNlQ3JlYXRlRWxlbWVudCkge1xuICAgICAgd2hpbGUgKGNvbnRhaW5lci5sYXN0Q2hpbGQpIHtcbiAgICAgICAgY29udGFpbmVyLnJlbW92ZUNoaWxkKGNvbnRhaW5lci5sYXN0Q2hpbGQpO1xuICAgICAgfVxuICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKG1hcmt1cCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNldElubmVySFRNTChjb250YWluZXIsIG1hcmt1cCk7XG4gICAgfVxuICB9LFxuXG4gIG93bmVyRG9jdW1lbnRDb250ZXh0S2V5OiBvd25lckRvY3VtZW50Q29udGV4dEtleSxcblxuICAvKipcbiAgICogUmVhY3QgSUQgdXRpbGl0aWVzLlxuICAgKi9cblxuICBnZXRSZWFjdFJvb3RJRDogZ2V0UmVhY3RSb290SUQsXG5cbiAgZ2V0SUQ6IGdldElELFxuXG4gIHNldElEOiBzZXRJRCxcblxuICBnZXROb2RlOiBnZXROb2RlLFxuXG4gIGdldE5vZGVGcm9tSW5zdGFuY2U6IGdldE5vZGVGcm9tSW5zdGFuY2UsXG5cbiAgaXNWYWxpZDogaXNWYWxpZCxcblxuICBwdXJnZUlEOiBwdXJnZUlEXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoUmVhY3RNb3VudCwgJ1JlYWN0TW91bnQnLCB7XG4gIF9yZW5kZXJOZXdSb290Q29tcG9uZW50OiAnX3JlbmRlck5ld1Jvb3RDb21wb25lbnQnLFxuICBfbW91bnRJbWFnZUludG9Ob2RlOiAnX21vdW50SW1hZ2VJbnRvTm9kZSdcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TW91bnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RNb3VudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRDb25zdGFudHMgPSByZXF1aXJlKCcuL0V2ZW50Q29uc3RhbnRzJyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW4gPSByZXF1aXJlKCcuL1JlYWN0RXZlbnRFbWl0dGVyTWl4aW4nKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFZpZXdwb3J0TWV0cmljcyA9IHJlcXVpcmUoJy4vVmlld3BvcnRNZXRyaWNzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG5cbi8qKlxuICogU3VtbWFyeSBvZiBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBldmVudCBoYW5kbGluZzpcbiAqXG4gKiAgLSBUb3AtbGV2ZWwgZGVsZWdhdGlvbiBpcyB1c2VkIHRvIHRyYXAgbW9zdCBuYXRpdmUgYnJvd3NlciBldmVudHMuIFRoaXNcbiAqICAgIG1heSBvbmx5IG9jY3VyIGluIHRoZSBtYWluIHRocmVhZCBhbmQgaXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mXG4gKiAgICBSZWFjdEV2ZW50TGlzdGVuZXIsIHdoaWNoIGlzIGluamVjdGVkIGFuZCBjYW4gdGhlcmVmb3JlIHN1cHBvcnQgcGx1Z2dhYmxlXG4gKiAgICBldmVudCBzb3VyY2VzLiBUaGlzIGlzIHRoZSBvbmx5IHdvcmsgdGhhdCBvY2N1cnMgaW4gdGhlIG1haW4gdGhyZWFkLlxuICpcbiAqICAtIFdlIG5vcm1hbGl6ZSBhbmQgZGUtZHVwbGljYXRlIGV2ZW50cyB0byBhY2NvdW50IGZvciBicm93c2VyIHF1aXJrcy4gVGhpc1xuICogICAgbWF5IGJlIGRvbmUgaW4gdGhlIHdvcmtlciB0aHJlYWQuXG4gKlxuICogIC0gRm9yd2FyZCB0aGVzZSBuYXRpdmUgZXZlbnRzICh3aXRoIHRoZSBhc3NvY2lhdGVkIHRvcC1sZXZlbCB0eXBlIHVzZWQgdG9cbiAqICAgIHRyYXAgaXQpIHRvIGBFdmVudFBsdWdpbkh1YmAsIHdoaWNoIGluIHR1cm4gd2lsbCBhc2sgcGx1Z2lucyBpZiB0aGV5IHdhbnRcbiAqICAgIHRvIGV4dHJhY3QgYW55IHN5bnRoZXRpYyBldmVudHMuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgd2lsbCB0aGVuIHByb2Nlc3MgZWFjaCBldmVudCBieSBhbm5vdGF0aW5nIHRoZW0gd2l0aFxuICogICAgXCJkaXNwYXRjaGVzXCIsIGEgc2VxdWVuY2Ugb2YgbGlzdGVuZXJzIGFuZCBJRHMgdGhhdCBjYXJlIGFib3V0IHRoYXQgZXZlbnQuXG4gKlxuICogIC0gVGhlIGBFdmVudFBsdWdpbkh1YmAgdGhlbiBkaXNwYXRjaGVzIHRoZSBldmVudHMuXG4gKlxuICogT3ZlcnZpZXcgb2YgUmVhY3QgYW5kIHRoZSBldmVudCBzeXN0ZW06XG4gKlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCAgICBET00gICAgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogICAgICAgfCAgICAgICAgICAgLlxuICogICAgICAgdiAgICAgICAgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLlxuICogfCBSZWFjdEV2ZW50IHwgICAgLlxuICogfCAgTGlzdGVuZXIgIHwgICAgLlxuICogKy0tLS0tLS0tLS0tLSsgICAgLiAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiAgICAgICB8ICAgICAgICAgICAuICAgICAgICAgICAgICAgKy0tLS0tLS0tK3xTaW1wbGVFdmVudHxcbiAqICAgICAgIHwgICAgICAgICAgIC4gICAgICAgICAgICAgICB8ICAgICAgICAgfFBsdWdpbiAgICAgfFxuICogKy0tLS0tfC0tLS0tLSsgICAgLiAgICAgICAgICAgICAgIHYgICAgICAgICArLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLSsgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnxFdmVudFBsdWdpbkh1YnwgICAgICAgICAgICAgICAgICAgIHwgICAgRXZlbnQgICB8XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgUHJvcGFnYXRvcnN8XG4gKiB8IFJlYWN0RXZlbnQgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgIHxUYXBFdmVudCAgIHwgIHwtLS0tLS0tLS0tLS18XG4gKiB8ICBFbWl0dGVyICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHw8LS0tK3xQbHVnaW4gICAgIHwgIHxvdGhlciBwbHVnaW58XG4gKiB8ICAgICAgICAgICAgfCAgICAuICAgIHwgICAgICAgICAgICAgIHwgICAgICstLS0tLS0tLS0tLSsgIHwgIHV0aWxpdGllcyB8XG4gKiB8ICAgICArLS0tLS0tLS0tLS0uLS0tPnwgICAgICAgICAgICAgIHwgICAgICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0rXG4gKiB8ICAgICB8ICAgICAgfCAgICAuICAgICstLS0tLS0tLS0tLS0tLStcbiAqICstLS0tLXwtLS0tLS0rICAgIC4gICAgICAgICAgICAgICAgXiAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogICAgICAgfCAgICAgICAgICAgLiAgICAgICAgICAgICAgICB8ICAgICAgICB8RW50ZXIvTGVhdmV8XG4gKiAgICAgICArICAgICAgICAgICAuICAgICAgICAgICAgICAgICstLS0tLS0tK3xQbHVnaW4gICAgIHxcbiAqICstLS0tLS0tLS0tLS0tKyAgIC4gICAgICAgICAgICAgICAgICAgICAgICAgKy0tLS0tLS0tLS0tK1xuICogfCBhcHBsaWNhdGlvbiB8ICAgLlxuICogfC0tLS0tLS0tLS0tLS18ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogfCAgICAgICAgICAgICB8ICAgLlxuICogKy0tLS0tLS0tLS0tLS0rICAgLlxuICogICAgICAgICAgICAgICAgICAgLlxuICogICAgUmVhY3QgQ29yZSAgICAgLiAgR2VuZXJhbCBQdXJwb3NlIEV2ZW50IFBsdWdpbiBTeXN0ZW1cbiAqL1xuXG52YXIgYWxyZWFkeUxpc3RlbmluZ1RvID0ge307XG52YXIgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSBmYWxzZTtcbnZhciByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIgPSAwO1xuXG4vLyBGb3IgZXZlbnRzIGxpa2UgJ3N1Ym1pdCcgd2hpY2ggZG9uJ3QgY29uc2lzdGVudGx5IGJ1YmJsZSAod2hpY2ggd2UgdHJhcCBhdCBhXG4vLyBsb3dlciBub2RlIHRoYW4gYGRvY3VtZW50YCksIGJpbmRpbmcgYXQgYGRvY3VtZW50YCB3b3VsZCBjYXVzZSBkdXBsaWNhdGVcbi8vIGV2ZW50cyBzbyB3ZSBkb24ndCBpbmNsdWRlIHRoZW0gaGVyZVxudmFyIHRvcEV2ZW50TWFwcGluZyA9IHtcbiAgdG9wQWJvcnQ6ICdhYm9ydCcsXG4gIHRvcEJsdXI6ICdibHVyJyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wQ2hhbmdlOiAnY2hhbmdlJyxcbiAgdG9wQ2xpY2s6ICdjbGljaycsXG4gIHRvcENvbXBvc2l0aW9uRW5kOiAnY29tcG9zaXRpb25lbmQnLFxuICB0b3BDb21wb3NpdGlvblN0YXJ0OiAnY29tcG9zaXRpb25zdGFydCcsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiAnY29tcG9zaXRpb251cGRhdGUnLFxuICB0b3BDb250ZXh0TWVudTogJ2NvbnRleHRtZW51JyxcbiAgdG9wQ29weTogJ2NvcHknLFxuICB0b3BDdXQ6ICdjdXQnLFxuICB0b3BEb3VibGVDbGljazogJ2RibGNsaWNrJyxcbiAgdG9wRHJhZzogJ2RyYWcnLFxuICB0b3BEcmFnRW5kOiAnZHJhZ2VuZCcsXG4gIHRvcERyYWdFbnRlcjogJ2RyYWdlbnRlcicsXG4gIHRvcERyYWdFeGl0OiAnZHJhZ2V4aXQnLFxuICB0b3BEcmFnTGVhdmU6ICdkcmFnbGVhdmUnLFxuICB0b3BEcmFnT3ZlcjogJ2RyYWdvdmVyJyxcbiAgdG9wRHJhZ1N0YXJ0OiAnZHJhZ3N0YXJ0JyxcbiAgdG9wRHJvcDogJ2Ryb3AnLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogJ2R1cmF0aW9uY2hhbmdlJyxcbiAgdG9wRW1wdGllZDogJ2VtcHRpZWQnLFxuICB0b3BFbmNyeXB0ZWQ6ICdlbmNyeXB0ZWQnLFxuICB0b3BFbmRlZDogJ2VuZGVkJyxcbiAgdG9wRXJyb3I6ICdlcnJvcicsXG4gIHRvcEZvY3VzOiAnZm9jdXMnLFxuICB0b3BJbnB1dDogJ2lucHV0JyxcbiAgdG9wS2V5RG93bjogJ2tleWRvd24nLFxuICB0b3BLZXlQcmVzczogJ2tleXByZXNzJyxcbiAgdG9wS2V5VXA6ICdrZXl1cCcsXG4gIHRvcExvYWRlZERhdGE6ICdsb2FkZWRkYXRhJyxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6ICdsb2FkZWRtZXRhZGF0YScsXG4gIHRvcExvYWRTdGFydDogJ2xvYWRzdGFydCcsXG4gIHRvcE1vdXNlRG93bjogJ21vdXNlZG93bicsXG4gIHRvcE1vdXNlTW92ZTogJ21vdXNlbW92ZScsXG4gIHRvcE1vdXNlT3V0OiAnbW91c2VvdXQnLFxuICB0b3BNb3VzZU92ZXI6ICdtb3VzZW92ZXInLFxuICB0b3BNb3VzZVVwOiAnbW91c2V1cCcsXG4gIHRvcFBhc3RlOiAncGFzdGUnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNjcm9sbDogJ3Njcm9sbCcsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU2VsZWN0aW9uQ2hhbmdlOiAnc2VsZWN0aW9uY2hhbmdlJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRleHRJbnB1dDogJ3RleHRJbnB1dCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVG91Y2hDYW5jZWw6ICd0b3VjaGNhbmNlbCcsXG4gIHRvcFRvdWNoRW5kOiAndG91Y2hlbmQnLFxuICB0b3BUb3VjaE1vdmU6ICd0b3VjaG1vdmUnLFxuICB0b3BUb3VjaFN0YXJ0OiAndG91Y2hzdGFydCcsXG4gIHRvcFZvbHVtZUNoYW5nZTogJ3ZvbHVtZWNoYW5nZScsXG4gIHRvcFdhaXRpbmc6ICd3YWl0aW5nJyxcbiAgdG9wV2hlZWw6ICd3aGVlbCdcbn07XG5cbi8qKlxuICogVG8gZW5zdXJlIG5vIGNvbmZsaWN0cyB3aXRoIG90aGVyIHBvdGVudGlhbCBSZWFjdCBpbnN0YW5jZXMgb24gdGhlIHBhZ2VcbiAqL1xudmFyIHRvcExpc3RlbmVyc0lES2V5ID0gJ19yZWFjdExpc3RlbmVyc0lEJyArIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zbGljZSgyKTtcblxuZnVuY3Rpb24gZ2V0TGlzdGVuaW5nRm9yRG9jdW1lbnQobW91bnRBdCkge1xuICAvLyBJbiBJRTgsIGBtb3VudEF0YCBpcyBhIGhvc3Qgb2JqZWN0IGFuZCBkb2Vzbid0IGhhdmUgYGhhc093blByb3BlcnR5YFxuICAvLyBkaXJlY3RseS5cbiAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW91bnRBdCwgdG9wTGlzdGVuZXJzSURLZXkpKSB7XG4gICAgbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV0gPSByZWFjdFRvcExpc3RlbmVyc0NvdW50ZXIrKztcbiAgICBhbHJlYWR5TGlzdGVuaW5nVG9bbW91bnRBdFt0b3BMaXN0ZW5lcnNJREtleV1dID0ge307XG4gIH1cbiAgcmV0dXJuIGFscmVhZHlMaXN0ZW5pbmdUb1ttb3VudEF0W3RvcExpc3RlbmVyc0lES2V5XV07XG59XG5cbi8qKlxuICogYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgaXMgdXNlZCB0byBhdHRhY2ggdG9wLWxldmVsIGV2ZW50IGxpc3RlbmVycy4gRm9yXG4gKiBleGFtcGxlOlxuICpcbiAqICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKCdteUlEJywgJ29uQ2xpY2snLCBteUZ1bmN0aW9uKTtcbiAqXG4gKiBUaGlzIHdvdWxkIGFsbG9jYXRlIGEgXCJyZWdpc3RyYXRpb25cIiBvZiBgKCdvbkNsaWNrJywgbXlGdW5jdGlvbilgIG9uICdteUlEJy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IGFzc2lnbih7fSwgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiwge1xuXG4gIC8qKlxuICAgKiBJbmplY3RhYmxlIGV2ZW50IGJhY2tlbmRcbiAgICovXG4gIFJlYWN0RXZlbnRMaXN0ZW5lcjogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gUmVhY3RFdmVudExpc3RlbmVyXG4gICAgICovXG4gICAgaW5qZWN0UmVhY3RFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAoUmVhY3RFdmVudExpc3RlbmVyKSB7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuc2V0SGFuZGxlVG9wTGV2ZWwoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmhhbmRsZVRvcExldmVsKTtcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTZXRzIHdoZXRoZXIgb3Igbm90IGFueSBjcmVhdGVkIGNhbGxiYWNrcyBzaG91bGQgYmUgZW5hYmxlZC5cbiAgICpcbiAgICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkIFRydWUgaWYgY2FsbGJhY2tzIHNob3VsZCBiZSBlbmFibGVkLlxuICAgKi9cbiAgc2V0RW5hYmxlZDogZnVuY3Rpb24gKGVuYWJsZWQpIHtcbiAgICBpZiAoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lcikge1xuICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci5zZXRFbmFibGVkKGVuYWJsZWQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBjYWxsYmFja3MgYXJlIGVuYWJsZWQuXG4gICAqL1xuICBpc0VuYWJsZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISEoUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lciAmJiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLmlzRW5hYmxlZCgpKTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgbGlzdGVuIGZvciBidWJibGVkIHRvdWNoIGV2ZW50cyBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LlxuICAgKlxuICAgKiBGaXJlZm94IHY4LjAxIChhbmQgcG9zc2libHkgb3RoZXJzKSBleGhpYml0ZWQgc3RyYW5nZSBiZWhhdmlvciB3aGVuXG4gICAqIG1vdW50aW5nIGBvbm1vdXNlbW92ZWAgZXZlbnRzIGF0IHNvbWUgbm9kZSB0aGF0IHdhcyBub3QgdGhlIGRvY3VtZW50XG4gICAqIGVsZW1lbnQuIFRoZSBzeW1wdG9tcyB3ZXJlIHRoYXQgaWYgeW91ciBtb3VzZSBpcyBub3QgbW92aW5nIG92ZXIgc29tZXRoaW5nXG4gICAqIGNvbnRhaW5lZCB3aXRoaW4gdGhhdCBtb3VudCBwb2ludCAoZm9yIGV4YW1wbGUgb24gdGhlIGJhY2tncm91bmQpIHRoZVxuICAgKiB0b3AtbGV2ZWwgbGlzdGVuZXJzIGZvciBgb25tb3VzZW1vdmVgIHdvbid0IGJlIGNhbGxlZC4gSG93ZXZlciwgaWYgeW91XG4gICAqIHJlZ2lzdGVyIHRoZSBgbW91c2Vtb3ZlYCBvbiB0aGUgZG9jdW1lbnQgb2JqZWN0LCB0aGVuIGl0IHdpbGwgb2YgY291cnNlXG4gICAqIGNhdGNoIGFsbCBgbW91c2Vtb3ZlYHMuIFRoaXMgYWxvbmcgd2l0aCBpT1MgcXVpcmtzLCBqdXN0aWZpZXMgcmVzdHJpY3RpbmdcbiAgICogdG9wLWxldmVsIGxpc3RlbmVycyB0byB0aGUgZG9jdW1lbnQgb2JqZWN0IG9ubHksIGF0IGxlYXN0IGZvciB0aGVzZVxuICAgKiBtb3ZlbWVudCB0eXBlcyBvZiBldmVudHMgYW5kIHBvc3NpYmx5IGFsbCBldmVudHMuXG4gICAqXG4gICAqIEBzZWUgaHR0cDovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTAvMDkvY2xpY2tfZXZlbnRfZGVsLmh0bWxcbiAgICpcbiAgICogQWxzbywgYGtleXVwYC9ga2V5cHJlc3NgL2BrZXlkb3duYCBkbyBub3QgYnViYmxlIHRvIHRoZSB3aW5kb3cgb24gSUUsIGJ1dFxuICAgKiB0aGV5IGJ1YmJsZSB0byBkb2N1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgTmFtZSBvZiBsaXN0ZW5lciAoZS5nLiBgb25DbGlja2ApLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGVudERvY3VtZW50SGFuZGxlIERvY3VtZW50IHdoaWNoIG93bnMgdGhlIGNvbnRhaW5lclxuICAgKi9cbiAgbGlzdGVuVG86IGZ1bmN0aW9uIChyZWdpc3RyYXRpb25OYW1lLCBjb250ZW50RG9jdW1lbnRIYW5kbGUpIHtcbiAgICB2YXIgbW91bnRBdCA9IGNvbnRlbnREb2N1bWVudEhhbmRsZTtcbiAgICB2YXIgaXNMaXN0ZW5pbmcgPSBnZXRMaXN0ZW5pbmdGb3JEb2N1bWVudChtb3VudEF0KTtcbiAgICB2YXIgZGVwZW5kZW5jaWVzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lRGVwZW5kZW5jaWVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuXG4gICAgdmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVwZW5kZW5jeSA9IGRlcGVuZGVuY2llc1tpXTtcbiAgICAgIGlmICghKGlzTGlzdGVuaW5nLmhhc093blByb3BlcnR5KGRlcGVuZGVuY3kpICYmIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldKSkge1xuICAgICAgICBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BXaGVlbCkge1xuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCd3aGVlbCcpKSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BXaGVlbCwgJ3doZWVsJywgbW91bnRBdCk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdtb3VzZXdoZWVsJykpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnbW91c2V3aGVlbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBGaXJlZm94IG5lZWRzIHRvIGNhcHR1cmUgYSBkaWZmZXJlbnQgbW91c2Ugc2Nyb2xsIGV2ZW50LlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2RvbS9ldmVudHMvdGVzdHMvc2Nyb2xsLmh0bWxcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFdoZWVsLCAnRE9NTW91c2VTY3JvbGwnLCBtb3VudEF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZGVwZW5kZW5jeSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwpIHtcblxuICAgICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKCdzY3JvbGwnLCB0cnVlKSkge1xuICAgICAgICAgICAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQ2FwdHVyZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcFNjcm9sbCwgJ3Njcm9sbCcsIG1vdW50QXQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BTY3JvbGwsICdzY3JvbGwnLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLldJTkRPV19IQU5ETEUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChkZXBlbmRlbmN5ID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzIHx8IGRlcGVuZGVuY3kgPT09IHRvcExldmVsVHlwZXMudG9wQmx1cikge1xuXG4gICAgICAgICAgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzJywgdHJ1ZSkpIHtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcENhcHR1cmVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzJywgbW91bnRBdCk7XG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZXMudG9wQmx1ciwgJ2JsdXInLCBtb3VudEF0KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGlzRXZlbnRTdXBwb3J0ZWQoJ2ZvY3VzaW4nKSkge1xuICAgICAgICAgICAgLy8gSUUgaGFzIGBmb2N1c2luYCBhbmQgYGZvY3Vzb3V0YCBldmVudHMgd2hpY2ggYnViYmxlLlxuICAgICAgICAgICAgLy8gQHNlZSBodHRwOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAwOC8wNC9kZWxlZ2F0aW5nX3RoZS5odG1sXG4gICAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQodG9wTGV2ZWxUeXBlcy50b3BGb2N1cywgJ2ZvY3VzaW4nLCBtb3VudEF0KTtcbiAgICAgICAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIudHJhcEJ1YmJsZWRFdmVudCh0b3BMZXZlbFR5cGVzLnRvcEJsdXIsICdmb2N1c291dCcsIG1vdW50QXQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIHRvIG1ha2Ugc3VyZSBibHVyIGFuZCBmb2N1cyBldmVudCBsaXN0ZW5lcnMgYXJlIG9ubHkgYXR0YWNoZWQgb25jZVxuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wQmx1cl0gPSB0cnVlO1xuICAgICAgICAgIGlzTGlzdGVuaW5nW3RvcExldmVsVHlwZXMudG9wRm9jdXNdID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmICh0b3BFdmVudE1hcHBpbmcuaGFzT3duUHJvcGVydHkoZGVwZW5kZW5jeSkpIHtcbiAgICAgICAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBCdWJibGVkRXZlbnQoZGVwZW5kZW5jeSwgdG9wRXZlbnRNYXBwaW5nW2RlcGVuZGVuY3ldLCBtb3VudEF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlzTGlzdGVuaW5nW2RlcGVuZGVuY3ldID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICByZXR1cm4gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLlJlYWN0RXZlbnRMaXN0ZW5lci50cmFwQnViYmxlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIHRyYXBDYXB0dXJlZEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBoYW5kbGVyQmFzZU5hbWUsIGhhbmRsZSkge1xuICAgIHJldHVybiBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuUmVhY3RFdmVudExpc3RlbmVyLnRyYXBDYXB0dXJlZEV2ZW50KHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBMaXN0ZW5zIHRvIHdpbmRvdyBzY3JvbGwgYW5kIHJlc2l6ZSBldmVudHMuIFdlIGNhY2hlIHNjcm9sbCB2YWx1ZXMgc28gdGhhdFxuICAgKiBhcHBsaWNhdGlvbiBjb2RlIGNhbiBhY2Nlc3MgdGhlbSB3aXRob3V0IHRyaWdnZXJpbmcgcmVmbG93cy5cbiAgICpcbiAgICogTk9URTogU2Nyb2xsIGV2ZW50cyBkbyBub3QgYnViYmxlLlxuICAgKlxuICAgKiBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvZG9tL2V2ZW50cy9zY3JvbGwuaHRtbFxuICAgKi9cbiAgZW5zdXJlU2Nyb2xsVmFsdWVNb25pdG9yaW5nOiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFpc01vbml0b3JpbmdTY3JvbGxWYWx1ZSkge1xuICAgICAgdmFyIHJlZnJlc2ggPSBWaWV3cG9ydE1ldHJpY3MucmVmcmVzaFNjcm9sbFZhbHVlcztcbiAgICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5SZWFjdEV2ZW50TGlzdGVuZXIubW9uaXRvclNjcm9sbFZhbHVlKHJlZnJlc2gpO1xuICAgICAgaXNNb25pdG9yaW5nU2Nyb2xsVmFsdWUgPSB0cnVlO1xuICAgIH1cbiAgfSxcblxuICBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M6IEV2ZW50UGx1Z2luSHViLmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5IdWIucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMsXG5cbiAgcHV0TGlzdGVuZXI6IEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyLFxuXG4gIGdldExpc3RlbmVyOiBFdmVudFBsdWdpbkh1Yi5nZXRMaXN0ZW5lcixcblxuICBkZWxldGVMaXN0ZW5lcjogRXZlbnRQbHVnaW5IdWIuZGVsZXRlTGlzdGVuZXIsXG5cbiAgZGVsZXRlQWxsTGlzdGVuZXJzOiBFdmVudFBsdWdpbkh1Yi5kZWxldGVBbGxMaXN0ZW5lcnNcblxufSk7XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIsICdSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInLCB7XG4gIHB1dExpc3RlbmVyOiAncHV0TGlzdGVuZXInLFxuICBkZWxldGVMaXN0ZW5lcjogJ2RlbGV0ZUxpc3RlbmVyJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudENvbnN0YW50c1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU1pcnJvciA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU1pcnJvcicpO1xuXG52YXIgUHJvcGFnYXRpb25QaGFzZXMgPSBrZXlNaXJyb3IoeyBidWJibGVkOiBudWxsLCBjYXB0dXJlZDogbnVsbCB9KTtcblxuLyoqXG4gKiBUeXBlcyBvZiByYXcgc2lnbmFscyBmcm9tIHRoZSBicm93c2VyIGNhdWdodCBhdCB0aGUgdG9wIGxldmVsLlxuICovXG52YXIgdG9wTGV2ZWxUeXBlcyA9IGtleU1pcnJvcih7XG4gIHRvcEFib3J0OiBudWxsLFxuICB0b3BCbHVyOiBudWxsLFxuICB0b3BDYW5QbGF5OiBudWxsLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogbnVsbCxcbiAgdG9wQ2hhbmdlOiBudWxsLFxuICB0b3BDbGljazogbnVsbCxcbiAgdG9wQ29tcG9zaXRpb25FbmQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uU3RhcnQ6IG51bGwsXG4gIHRvcENvbXBvc2l0aW9uVXBkYXRlOiBudWxsLFxuICB0b3BDb250ZXh0TWVudTogbnVsbCxcbiAgdG9wQ29weTogbnVsbCxcbiAgdG9wQ3V0OiBudWxsLFxuICB0b3BEb3VibGVDbGljazogbnVsbCxcbiAgdG9wRHJhZzogbnVsbCxcbiAgdG9wRHJhZ0VuZDogbnVsbCxcbiAgdG9wRHJhZ0VudGVyOiBudWxsLFxuICB0b3BEcmFnRXhpdDogbnVsbCxcbiAgdG9wRHJhZ0xlYXZlOiBudWxsLFxuICB0b3BEcmFnT3ZlcjogbnVsbCxcbiAgdG9wRHJhZ1N0YXJ0OiBudWxsLFxuICB0b3BEcm9wOiBudWxsLFxuICB0b3BEdXJhdGlvbkNoYW5nZTogbnVsbCxcbiAgdG9wRW1wdGllZDogbnVsbCxcbiAgdG9wRW5jcnlwdGVkOiBudWxsLFxuICB0b3BFbmRlZDogbnVsbCxcbiAgdG9wRXJyb3I6IG51bGwsXG4gIHRvcEZvY3VzOiBudWxsLFxuICB0b3BJbnB1dDogbnVsbCxcbiAgdG9wS2V5RG93bjogbnVsbCxcbiAgdG9wS2V5UHJlc3M6IG51bGwsXG4gIHRvcEtleVVwOiBudWxsLFxuICB0b3BMb2FkOiBudWxsLFxuICB0b3BMb2FkZWREYXRhOiBudWxsLFxuICB0b3BMb2FkZWRNZXRhZGF0YTogbnVsbCxcbiAgdG9wTG9hZFN0YXJ0OiBudWxsLFxuICB0b3BNb3VzZURvd246IG51bGwsXG4gIHRvcE1vdXNlTW92ZTogbnVsbCxcbiAgdG9wTW91c2VPdXQ6IG51bGwsXG4gIHRvcE1vdXNlT3ZlcjogbnVsbCxcbiAgdG9wTW91c2VVcDogbnVsbCxcbiAgdG9wUGFzdGU6IG51bGwsXG4gIHRvcFBhdXNlOiBudWxsLFxuICB0b3BQbGF5OiBudWxsLFxuICB0b3BQbGF5aW5nOiBudWxsLFxuICB0b3BQcm9ncmVzczogbnVsbCxcbiAgdG9wUmF0ZUNoYW5nZTogbnVsbCxcbiAgdG9wUmVzZXQ6IG51bGwsXG4gIHRvcFNjcm9sbDogbnVsbCxcbiAgdG9wU2Vla2VkOiBudWxsLFxuICB0b3BTZWVraW5nOiBudWxsLFxuICB0b3BTZWxlY3Rpb25DaGFuZ2U6IG51bGwsXG4gIHRvcFN0YWxsZWQ6IG51bGwsXG4gIHRvcFN1Ym1pdDogbnVsbCxcbiAgdG9wU3VzcGVuZDogbnVsbCxcbiAgdG9wVGV4dElucHV0OiBudWxsLFxuICB0b3BUaW1lVXBkYXRlOiBudWxsLFxuICB0b3BUb3VjaENhbmNlbDogbnVsbCxcbiAgdG9wVG91Y2hFbmQ6IG51bGwsXG4gIHRvcFRvdWNoTW92ZTogbnVsbCxcbiAgdG9wVG91Y2hTdGFydDogbnVsbCxcbiAgdG9wVm9sdW1lQ2hhbmdlOiBudWxsLFxuICB0b3BXYWl0aW5nOiBudWxsLFxuICB0b3BXaGVlbDogbnVsbFxufSk7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHtcbiAgdG9wTGV2ZWxUeXBlczogdG9wTGV2ZWxUeXBlcyxcbiAgUHJvcGFnYXRpb25QaGFzZXM6IFByb3BhZ2F0aW9uUGhhc2VzXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50Q29uc3RhbnRzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0V2ZW50Q29uc3RhbnRzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luSHViXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRQbHVnaW5SZWdpc3RyeSA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5SZWdpc3RyeScpO1xudmFyIEV2ZW50UGx1Z2luVXRpbHMgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luVXRpbHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgYWNjdW11bGF0ZUludG8gPSByZXF1aXJlKCcuL2FjY3VtdWxhdGVJbnRvJyk7XG52YXIgZm9yRWFjaEFjY3VtdWxhdGVkID0gcmVxdWlyZSgnLi9mb3JFYWNoQWNjdW11bGF0ZWQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEludGVybmFsIHN0b3JlIGZvciBldmVudCBsaXN0ZW5lcnNcbiAqL1xudmFyIGxpc3RlbmVyQmFuayA9IHt9O1xuXG4vKipcbiAqIEludGVybmFsIHF1ZXVlIG9mIGV2ZW50cyB0aGF0IGhhdmUgYWNjdW11bGF0ZWQgdGhlaXIgZGlzcGF0Y2hlcyBhbmQgYXJlXG4gKiB3YWl0aW5nIHRvIGhhdmUgdGhlaXIgZGlzcGF0Y2hlcyBleGVjdXRlZC5cbiAqL1xudmFyIGV2ZW50UXVldWUgPSBudWxsO1xuXG4vKipcbiAqIERpc3BhdGNoZXMgYW4gZXZlbnQgYW5kIHJlbGVhc2VzIGl0IGJhY2sgaW50byB0aGUgcG9vbCwgdW5sZXNzIHBlcnNpc3RlbnQuXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBldmVudCBTeW50aGV0aWMgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHByaXZhdGVcbiAqL1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZSA9IGZ1bmN0aW9uIChldmVudCwgc2ltdWxhdGVkKSB7XG4gIGlmIChldmVudCkge1xuICAgIEV2ZW50UGx1Z2luVXRpbHMuZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpO1xuXG4gICAgaWYgKCFldmVudC5pc1BlcnNpc3RlbnQoKSkge1xuICAgICAgZXZlbnQuY29uc3RydWN0b3IucmVsZWFzZShldmVudCk7XG4gICAgfVxuICB9XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCA9IGZ1bmN0aW9uIChlKSB7XG4gIHJldHVybiBleGVjdXRlRGlzcGF0Y2hlc0FuZFJlbGVhc2UoZSwgdHJ1ZSk7XG59O1xudmFyIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVRvcExldmVsID0gZnVuY3Rpb24gKGUpIHtcbiAgcmV0dXJuIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZShlLCBmYWxzZSk7XG59O1xuXG4vKipcbiAqIC0gYEluc3RhbmNlSGFuZGxlYDogW3JlcXVpcmVkXSBNb2R1bGUgdGhhdCBwZXJmb3JtcyBsb2dpY2FsIHRyYXZlcnNhbHMgb2YgRE9NXG4gKiAgIGhpZXJhcmNoeSBnaXZlbiBpZHMgb2YgdGhlIGxvZ2ljYWwgRE9NIGVsZW1lbnRzIGludm9sdmVkLlxuICovXG52YXIgSW5zdGFuY2VIYW5kbGUgPSBudWxsO1xuXG5mdW5jdGlvbiB2YWxpZGF0ZUluc3RhbmNlSGFuZGxlKCkge1xuICB2YXIgdmFsaWQgPSBJbnN0YW5jZUhhbmRsZSAmJiBJbnN0YW5jZUhhbmRsZS50cmF2ZXJzZVR3b1BoYXNlICYmIEluc3RhbmNlSGFuZGxlLnRyYXZlcnNlRW50ZXJMZWF2ZTtcbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodmFsaWQsICdJbnN0YW5jZUhhbmRsZSBub3QgaW5qZWN0ZWQgYmVmb3JlIHVzZSEnKSA6IHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBUaGlzIGlzIGEgdW5pZmllZCBpbnRlcmZhY2UgZm9yIGV2ZW50IHBsdWdpbnMgdG8gYmUgaW5zdGFsbGVkIGFuZCBjb25maWd1cmVkLlxuICpcbiAqIEV2ZW50IHBsdWdpbnMgY2FuIGltcGxlbWVudCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogICBgZXh0cmFjdEV2ZW50c2Age2Z1bmN0aW9uKHN0cmluZywgRE9NRXZlbnRUYXJnZXQsIHN0cmluZywgb2JqZWN0KTogKn1cbiAqICAgICBSZXF1aXJlZC4gV2hlbiBhIHRvcC1sZXZlbCBldmVudCBpcyBmaXJlZCwgdGhpcyBtZXRob2QgaXMgZXhwZWN0ZWQgdG9cbiAqICAgICBleHRyYWN0IHN5bnRoZXRpYyBldmVudHMgdGhhdCB3aWxsIGluIHR1cm4gYmUgcXVldWVkIGFuZCBkaXNwYXRjaGVkLlxuICpcbiAqICAgYGV2ZW50VHlwZXNgIHtvYmplY3R9XG4gKiAgICAgT3B0aW9uYWwsIHBsdWdpbnMgdGhhdCBmaXJlIGV2ZW50cyBtdXN0IHB1Ymxpc2ggYSBtYXBwaW5nIG9mIHJlZ2lzdHJhdGlvblxuICogICAgIG5hbWVzIHRoYXQgYXJlIHVzZWQgdG8gcmVnaXN0ZXIgbGlzdGVuZXJzLiBWYWx1ZXMgb2YgdGhpcyBtYXBwaW5nIG11c3RcbiAqICAgICBiZSBvYmplY3RzIHRoYXQgY29udGFpbiBgcmVnaXN0cmF0aW9uTmFtZWAgb3IgYHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzYC5cbiAqXG4gKiAgIGBleGVjdXRlRGlzcGF0Y2hgIHtmdW5jdGlvbihvYmplY3QsIGZ1bmN0aW9uLCBzdHJpbmcpfVxuICogICAgIE9wdGlvbmFsLCBhbGxvd3MgcGx1Z2lucyB0byBvdmVycmlkZSBob3cgYW4gZXZlbnQgZ2V0cyBkaXNwYXRjaGVkLiBCeVxuICogICAgIGRlZmF1bHQsIHRoZSBsaXN0ZW5lciBpcyBzaW1wbHkgaW52b2tlZC5cbiAqXG4gKiBFYWNoIHBsdWdpbiB0aGF0IGlzIGluamVjdGVkIGludG8gYEV2ZW50c1BsdWdpbkh1YmAgaXMgaW1tZWRpYXRlbHkgb3BlcmFibGUuXG4gKlxuICogQHB1YmxpY1xuICovXG52YXIgRXZlbnRQbHVnaW5IdWIgPSB7XG5cbiAgLyoqXG4gICAqIE1ldGhvZHMgZm9yIGluamVjdGluZyBkZXBlbmRlbmNpZXMuXG4gICAqL1xuICBpbmplY3Rpb246IHtcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZE1vdW50XG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdE1vdW50OiBFdmVudFBsdWdpblV0aWxzLmluamVjdGlvbi5pbmplY3RNb3VudCxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBJbmplY3RlZEluc3RhbmNlSGFuZGxlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluamVjdEluc3RhbmNlSGFuZGxlOiBmdW5jdGlvbiAoSW5qZWN0ZWRJbnN0YW5jZUhhbmRsZSkge1xuICAgICAgSW5zdGFuY2VIYW5kbGUgPSBJbmplY3RlZEluc3RhbmNlSGFuZGxlO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRJbnN0YW5jZUhhbmRsZTogZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFsaWRhdGVJbnN0YW5jZUhhbmRsZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEluc3RhbmNlSGFuZGxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge2FycmF5fSBJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcjogRXZlbnRQbHVnaW5SZWdpc3RyeS5pbmplY3RFdmVudFBsdWdpbk9yZGVyLFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGluamVjdGVkTmFtZXNUb1BsdWdpbnMgTWFwIGZyb20gbmFtZXMgdG8gcGx1Z2luIG1vZHVsZXMuXG4gICAgICovXG4gICAgaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmluamVjdEV2ZW50UGx1Z2luc0J5TmFtZVxuXG4gIH0sXG5cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlncyxcblxuICByZWdpc3RyYXRpb25OYW1lTW9kdWxlczogRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlcyxcblxuICAvKipcbiAgICogU3RvcmVzIGBsaXN0ZW5lcmAgYXQgYGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF1gLiBJcyBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgSUQgb2YgdGhlIERPTSBlbGVtZW50LlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVnaXN0cmF0aW9uTmFtZSBOYW1lIG9mIGxpc3RlbmVyIChlLmcuIGBvbkNsaWNrYCkuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBsaXN0ZW5lciBUaGUgY2FsbGJhY2sgdG8gc3RvcmUuXG4gICAqL1xuICBwdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgICEodHlwZW9mIGxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFeHBlY3RlZCAlcyBsaXN0ZW5lciB0byBiZSBhIGZ1bmN0aW9uLCBpbnN0ZWFkIGdvdCB0eXBlICVzJywgcmVnaXN0cmF0aW9uTmFtZSwgdHlwZW9mIGxpc3RlbmVyKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgPSBsaXN0ZW5lckJhbmtbcmVnaXN0cmF0aW9uTmFtZV0gfHwgKGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXSA9IHt9KTtcbiAgICBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZVtpZF0gPSBsaXN0ZW5lcjtcblxuICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgIGlmIChQbHVnaW5Nb2R1bGUgJiYgUGx1Z2luTW9kdWxlLmRpZFB1dExpc3RlbmVyKSB7XG4gICAgICBQbHVnaW5Nb2R1bGUuZGlkUHV0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICogQHJldHVybiB7P2Z1bmN0aW9ufSBUaGUgc3RvcmVkIGNhbGxiYWNrLlxuICAgKi9cbiAgZ2V0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICByZXR1cm4gYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWUgJiYgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZWxldGVzIGEgbGlzdGVuZXIgZnJvbSB0aGUgcmVnaXN0cmF0aW9uIGJhbmsuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWdpc3RyYXRpb25OYW1lIE5hbWUgb2YgbGlzdGVuZXIgKGUuZy4gYG9uQ2xpY2tgKS5cbiAgICovXG4gIGRlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICBpZiAoUGx1Z2luTW9kdWxlICYmIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIpIHtcbiAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIH1cblxuICAgIHZhciBiYW5rRm9yUmVnaXN0cmF0aW9uTmFtZSA9IGxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXTtcbiAgICAvLyBUT0RPOiBUaGlzIHNob3VsZCBuZXZlciBiZSBudWxsIC0tIHdoZW4gaXMgaXQ/XG4gICAgaWYgKGJhbmtGb3JSZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICBkZWxldGUgYmFua0ZvclJlZ2lzdHJhdGlvbk5hbWVbaWRdO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogRGVsZXRlcyBhbGwgbGlzdGVuZXJzIGZvciB0aGUgRE9NIGVsZW1lbnQgd2l0aCB0aGUgc3VwcGxpZWQgSUQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiB0aGUgRE9NIGVsZW1lbnQuXG4gICAqL1xuICBkZWxldGVBbGxMaXN0ZW5lcnM6IGZ1bmN0aW9uIChpZCkge1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gbGlzdGVuZXJCYW5rKSB7XG4gICAgICBpZiAoIWxpc3RlbmVyQmFua1tyZWdpc3RyYXRpb25OYW1lXVtpZF0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIHZhciBQbHVnaW5Nb2R1bGUgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSAmJiBQbHVnaW5Nb2R1bGUud2lsbERlbGV0ZUxpc3RlbmVyKSB7XG4gICAgICAgIFBsdWdpbk1vZHVsZS53aWxsRGVsZXRlTGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgICAgfVxuXG4gICAgICBkZWxldGUgbGlzdGVuZXJCYW5rW3JlZ2lzdHJhdGlvbk5hbWVdW2lkXTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFsbG93cyByZWdpc3RlcmVkIHBsdWdpbnMgYW4gb3Bwb3J0dW5pdHkgdG8gZXh0cmFjdCBldmVudHMgZnJvbSB0b3AtbGV2ZWxcbiAgICogbmF0aXZlIGJyb3dzZXIgZXZlbnRzLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gICAqIEBwYXJhbSB7RE9NRXZlbnRUYXJnZXR9IHRvcExldmVsVGFyZ2V0IFRoZSBsaXN0ZW5pbmcgY29tcG9uZW50IHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVGFyZ2V0SUQgSUQgb2YgYHRvcExldmVsVGFyZ2V0YC5cbiAgICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICAgKiBAcmV0dXJuIHsqfSBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgdmFyIGV2ZW50cztcbiAgICB2YXIgcGx1Z2lucyA9IEV2ZW50UGx1Z2luUmVnaXN0cnkucGx1Z2lucztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsdWdpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIE5vdCBldmVyeSBwbHVnaW4gaW4gdGhlIG9yZGVyaW5nIG1heSBiZSBsb2FkZWQgYXQgcnVudGltZS5cbiAgICAgIHZhciBwb3NzaWJsZVBsdWdpbiA9IHBsdWdpbnNbaV07XG4gICAgICBpZiAocG9zc2libGVQbHVnaW4pIHtcbiAgICAgICAgdmFyIGV4dHJhY3RlZEV2ZW50cyA9IHBvc3NpYmxlUGx1Z2luLmV4dHJhY3RFdmVudHModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICAgICAgaWYgKGV4dHJhY3RlZEV2ZW50cykge1xuICAgICAgICAgIGV2ZW50cyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50cywgZXh0cmFjdGVkRXZlbnRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXZlbnRzO1xuICB9LFxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHN5bnRoZXRpYyBldmVudCB0aGF0IHNob3VsZCBiZSBkaXNwYXRjaGVkIHdoZW5cbiAgICogYHByb2Nlc3NFdmVudFF1ZXVlYCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGV2ZW50cyBBbiBhY2N1bXVsYXRpb24gb2Ygc3ludGhldGljIGV2ZW50cy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlRXZlbnRzOiBmdW5jdGlvbiAoZXZlbnRzKSB7XG4gICAgaWYgKGV2ZW50cykge1xuICAgICAgZXZlbnRRdWV1ZSA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50UXVldWUsIGV2ZW50cyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEaXNwYXRjaGVzIGFsbCBzeW50aGV0aWMgZXZlbnRzIG9uIHRoZSBldmVudCBxdWV1ZS5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICBwcm9jZXNzRXZlbnRRdWV1ZTogZnVuY3Rpb24gKHNpbXVsYXRlZCkge1xuICAgIC8vIFNldCBgZXZlbnRRdWV1ZWAgdG8gbnVsbCBiZWZvcmUgcHJvY2Vzc2luZyBpdCBzbyB0aGF0IHdlIGNhbiB0ZWxsIGlmIG1vcmVcbiAgICAvLyBldmVudHMgZ2V0IGVucXVldWVkIHdoaWxlIHByb2Nlc3NpbmcuXG4gICAgdmFyIHByb2Nlc3NpbmdFdmVudFF1ZXVlID0gZXZlbnRRdWV1ZTtcbiAgICBldmVudFF1ZXVlID0gbnVsbDtcbiAgICBpZiAoc2ltdWxhdGVkKSB7XG4gICAgICBmb3JFYWNoQWNjdW11bGF0ZWQocHJvY2Vzc2luZ0V2ZW50UXVldWUsIGV4ZWN1dGVEaXNwYXRjaGVzQW5kUmVsZWFzZVNpbXVsYXRlZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2hBY2N1bXVsYXRlZChwcm9jZXNzaW5nRXZlbnRRdWV1ZSwgZXhlY3V0ZURpc3BhdGNoZXNBbmRSZWxlYXNlVG9wTGV2ZWwpO1xuICAgIH1cbiAgICAhIWV2ZW50UXVldWUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncHJvY2Vzc0V2ZW50UXVldWUoKTogQWRkaXRpb25hbCBldmVudHMgd2VyZSBlbnF1ZXVlZCB3aGlsZSBwcm9jZXNzaW5nICcgKyAnYW4gZXZlbnQgcXVldWUuIFN1cHBvcnQgZm9yIHRoaXMgaGFzIG5vdCB5ZXQgYmVlbiBpbXBsZW1lbnRlZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgLy8gVGhpcyB3b3VsZCBiZSBhIGdvb2QgdGltZSB0byByZXRocm93IGlmIGFueSBvZiB0aGUgZXZlbnQgaGFuZGxlcnMgdGhyZXcuXG4gICAgUmVhY3RFcnJvclV0aWxzLnJldGhyb3dDYXVnaHRFcnJvcigpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUaGVzZSBhcmUgbmVlZGVkIGZvciB0ZXN0cyBvbmx5LiBEbyBub3QgdXNlIVxuICAgKi9cbiAgX19wdXJnZTogZnVuY3Rpb24gKCkge1xuICAgIGxpc3RlbmVyQmFuayA9IHt9O1xuICB9LFxuXG4gIF9fZ2V0TGlzdGVuZXJCYW5rOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGxpc3RlbmVyQmFuaztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luSHViO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0V2ZW50UGx1Z2luSHViLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luUmVnaXN0cnlcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBvcmRlcmluZyBvZiBldmVudCBwbHVnaW5zLlxuICovXG52YXIgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG5cbi8qKlxuICogSW5qZWN0YWJsZSBtYXBwaW5nIGZyb20gbmFtZXMgdG8gZXZlbnQgcGx1Z2luIG1vZHVsZXMuXG4gKi9cbnZhciBuYW1lc1RvUGx1Z2lucyA9IHt9O1xuXG4vKipcbiAqIFJlY29tcHV0ZXMgdGhlIHBsdWdpbiBsaXN0IHVzaW5nIHRoZSBpbmplY3RlZCBwbHVnaW5zIGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKSB7XG4gIGlmICghRXZlbnRQbHVnaW5PcmRlcikge1xuICAgIC8vIFdhaXQgdW50aWwgYW4gYEV2ZW50UGx1Z2luT3JkZXJgIGlzIGluamVjdGVkLlxuICAgIHJldHVybjtcbiAgfVxuICBmb3IgKHZhciBwbHVnaW5OYW1lIGluIG5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIFBsdWdpbk1vZHVsZSA9IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdO1xuICAgIHZhciBwbHVnaW5JbmRleCA9IEV2ZW50UGx1Z2luT3JkZXIuaW5kZXhPZihwbHVnaW5OYW1lKTtcbiAgICAhKHBsdWdpbkluZGV4ID4gLTEpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IENhbm5vdCBpbmplY3QgZXZlbnQgcGx1Z2lucyB0aGF0IGRvIG5vdCBleGlzdCBpbiAnICsgJ3RoZSBwbHVnaW4gb3JkZXJpbmcsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGlmIChFdmVudFBsdWdpblJlZ2lzdHJ5LnBsdWdpbnNbcGx1Z2luSW5kZXhdKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgIVBsdWdpbk1vZHVsZS5leHRyYWN0RXZlbnRzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEV2ZW50IHBsdWdpbnMgbXVzdCBpbXBsZW1lbnQgYW4gYGV4dHJhY3RFdmVudHNgICcgKyAnbWV0aG9kLCBidXQgYCVzYCBkb2VzIG5vdC4nLCBwbHVnaW5OYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zW3BsdWdpbkluZGV4XSA9IFBsdWdpbk1vZHVsZTtcbiAgICB2YXIgcHVibGlzaGVkRXZlbnRzID0gUGx1Z2luTW9kdWxlLmV2ZW50VHlwZXM7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIHB1Ymxpc2hlZEV2ZW50cykge1xuICAgICAgIXB1Ymxpc2hFdmVudEZvclBsdWdpbihwdWJsaXNoZWRFdmVudHNbZXZlbnROYW1lXSwgUGx1Z2luTW9kdWxlLCBldmVudE5hbWUpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V2ZW50UGx1Z2luUmVnaXN0cnk6IEZhaWxlZCB0byBwdWJsaXNoIGV2ZW50IGAlc2AgZm9yIHBsdWdpbiBgJXNgLicsIGV2ZW50TmFtZSwgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhbiBldmVudCBzbyB0aGF0IGl0IGNhbiBiZSBkaXNwYXRjaGVkIGJ5IHRoZSBzdXBwbGllZCBwbHVnaW4uXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIERpc3BhdGNoIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBldmVudC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBQbHVnaW5Nb2R1bGUgUGx1Z2luIHB1Ymxpc2hpbmcgdGhlIGV2ZW50LlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXZlbnQgd2FzIHN1Y2Nlc3NmdWxseSBwdWJsaXNoZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoRXZlbnRGb3JQbHVnaW4oZGlzcGF0Y2hDb25maWcsIFBsdWdpbk1vZHVsZSwgZXZlbnROYW1lKSB7XG4gICEhRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3MuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpbkh1YjogTW9yZSB0aGFuIG9uZSBwbHVnaW4gYXR0ZW1wdGVkIHRvIHB1Ymxpc2ggdGhlIHNhbWUgJyArICdldmVudCBuYW1lLCBgJXNgLicsIGV2ZW50TmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LmV2ZW50TmFtZURpc3BhdGNoQ29uZmlnc1tldmVudE5hbWVdID0gZGlzcGF0Y2hDb25maWc7XG5cbiAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzID0gZGlzcGF0Y2hDb25maWcucGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM7XG4gIGlmIChwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIGZvciAodmFyIHBoYXNlTmFtZSBpbiBwaGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzLmhhc093blByb3BlcnR5KHBoYXNlTmFtZSkpIHtcbiAgICAgICAgdmFyIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWUgPSBwaGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZU5hbWVdO1xuICAgICAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShwaGFzZWRSZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9IGVsc2UgaWYgKGRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFB1Ymxpc2hlcyBhIHJlZ2lzdHJhdGlvbiBuYW1lIHRoYXQgaXMgdXNlZCB0byBpZGVudGlmeSBkaXNwYXRjaGVkIGV2ZW50cyBhbmRcbiAqIGNhbiBiZSB1c2VkIHdpdGggYEV2ZW50UGx1Z2luSHViLnB1dExpc3RlbmVyYCB0byByZWdpc3RlciBsaXN0ZW5lcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJlZ2lzdHJhdGlvbk5hbWUgUmVnaXN0cmF0aW9uIG5hbWUgdG8gYWRkLlxuICogQHBhcmFtIHtvYmplY3R9IFBsdWdpbk1vZHVsZSBQbHVnaW4gcHVibGlzaGluZyB0aGUgZXZlbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdWJsaXNoUmVnaXN0cmF0aW9uTmFtZShyZWdpc3RyYXRpb25OYW1lLCBQbHVnaW5Nb2R1bGUsIGV2ZW50TmFtZSkge1xuICAhIUV2ZW50UGx1Z2luUmVnaXN0cnkucmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV0gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5IdWI6IE1vcmUgdGhhbiBvbmUgcGx1Z2luIGF0dGVtcHRlZCB0byBwdWJsaXNoIHRoZSBzYW1lICcgKyAncmVnaXN0cmF0aW9uIG5hbWUsIGAlc2AuJywgcmVnaXN0cmF0aW9uTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzW3JlZ2lzdHJhdGlvbk5hbWVdID0gUGx1Z2luTW9kdWxlO1xuICBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXNbcmVnaXN0cmF0aW9uTmFtZV0gPSBQbHVnaW5Nb2R1bGUuZXZlbnRUeXBlc1tldmVudE5hbWVdLmRlcGVuZGVuY2llcztcbn1cblxuLyoqXG4gKiBSZWdpc3RlcnMgcGx1Z2lucyBzbyB0aGF0IHRoZXkgY2FuIGV4dHJhY3QgYW5kIGRpc3BhdGNoIGV2ZW50cy5cbiAqXG4gKiBAc2VlIHtFdmVudFBsdWdpbkh1Yn1cbiAqL1xudmFyIEV2ZW50UGx1Z2luUmVnaXN0cnkgPSB7XG5cbiAgLyoqXG4gICAqIE9yZGVyZWQgbGlzdCBvZiBpbmplY3RlZCBwbHVnaW5zLlxuICAgKi9cbiAgcGx1Z2luczogW10sXG5cbiAgLyoqXG4gICAqIE1hcHBpbmcgZnJvbSBldmVudCBuYW1lIHRvIGRpc3BhdGNoIGNvbmZpZ1xuICAgKi9cbiAgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIHBsdWdpbiBtb2R1bGVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzOiB7fSxcblxuICAvKipcbiAgICogTWFwcGluZyBmcm9tIHJlZ2lzdHJhdGlvbiBuYW1lIHRvIGV2ZW50IG5hbWVcbiAgICovXG4gIHJlZ2lzdHJhdGlvbk5hbWVEZXBlbmRlbmNpZXM6IHt9LFxuXG4gIC8qKlxuICAgKiBJbmplY3RzIGFuIG9yZGVyaW5nIG9mIHBsdWdpbnMgKGJ5IHBsdWdpbiBuYW1lKS4gVGhpcyBhbGxvd3MgdGhlIG9yZGVyaW5nXG4gICAqIHRvIGJlIGRlY291cGxlZCBmcm9tIGluamVjdGlvbiBvZiB0aGUgYWN0dWFsIHBsdWdpbnMgc28gdGhhdCBvcmRlcmluZyBpc1xuICAgKiBhbHdheXMgZGV0ZXJtaW5pc3RpYyByZWdhcmRsZXNzIG9mIHBhY2thZ2luZywgb24tdGhlLWZseSBpbmplY3Rpb24sIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIHthcnJheX0gSW5qZWN0ZWRFdmVudFBsdWdpbk9yZGVyXG4gICAqIEBpbnRlcm5hbFxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uaW5qZWN0RXZlbnRQbHVnaW5PcmRlcn1cbiAgICovXG4gIGluamVjdEV2ZW50UGx1Z2luT3JkZXI6IGZ1bmN0aW9uIChJbmplY3RlZEV2ZW50UGx1Z2luT3JkZXIpIHtcbiAgICAhIUV2ZW50UGx1Z2luT3JkZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnRXZlbnRQbHVnaW5SZWdpc3RyeTogQ2Fubm90IGluamVjdCBldmVudCBwbHVnaW4gb3JkZXJpbmcgbW9yZSB0aGFuICcgKyAnb25jZS4gWW91IGFyZSBsaWtlbHkgdHJ5aW5nIHRvIGxvYWQgbW9yZSB0aGFuIG9uZSBjb3B5IG9mIFJlYWN0LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAvLyBDbG9uZSB0aGUgb3JkZXJpbmcgc28gaXQgY2Fubm90IGJlIGR5bmFtaWNhbGx5IG11dGF0ZWQuXG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKEluamVjdGVkRXZlbnRQbHVnaW5PcmRlcik7XG4gICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgfSxcblxuICAvKipcbiAgICogSW5qZWN0cyBwbHVnaW5zIHRvIGJlIHVzZWQgYnkgYEV2ZW50UGx1Z2luSHViYC4gVGhlIHBsdWdpbiBuYW1lcyBtdXN0IGJlXG4gICAqIGluIHRoZSBvcmRlcmluZyBpbmplY3RlZCBieSBgaW5qZWN0RXZlbnRQbHVnaW5PcmRlcmAuXG4gICAqXG4gICAqIFBsdWdpbnMgY2FuIGJlIGluamVjdGVkIGFzIHBhcnQgb2YgcGFnZSBpbml0aWFsaXphdGlvbiBvciBvbi10aGUtZmx5LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucyBNYXAgZnJvbSBuYW1lcyB0byBwbHVnaW4gbW9kdWxlcy5cbiAgICogQGludGVybmFsXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmluamVjdGlvbi5pbmplY3RFdmVudFBsdWdpbnNCeU5hbWV9XG4gICAqL1xuICBpbmplY3RFdmVudFBsdWdpbnNCeU5hbWU6IGZ1bmN0aW9uIChpbmplY3RlZE5hbWVzVG9QbHVnaW5zKSB7XG4gICAgdmFyIGlzT3JkZXJpbmdEaXJ0eSA9IGZhbHNlO1xuICAgIGZvciAodmFyIHBsdWdpbk5hbWUgaW4gaW5qZWN0ZWROYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKCFpbmplY3RlZE5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIFBsdWdpbk1vZHVsZSA9IGluamVjdGVkTmFtZXNUb1BsdWdpbnNbcGx1Z2luTmFtZV07XG4gICAgICBpZiAoIW5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpIHx8IG5hbWVzVG9QbHVnaW5zW3BsdWdpbk5hbWVdICE9PSBQbHVnaW5Nb2R1bGUpIHtcbiAgICAgICAgISFuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFdmVudFBsdWdpblJlZ2lzdHJ5OiBDYW5ub3QgaW5qZWN0IHR3byBkaWZmZXJlbnQgZXZlbnQgcGx1Z2lucyAnICsgJ3VzaW5nIHRoZSBzYW1lIG5hbWUsIGAlc2AuJywgcGx1Z2luTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXSA9IFBsdWdpbk1vZHVsZTtcbiAgICAgICAgaXNPcmRlcmluZ0RpcnR5ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzT3JkZXJpbmdEaXJ0eSkge1xuICAgICAgcmVjb21wdXRlUGx1Z2luT3JkZXJpbmcoKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExvb2tzIHVwIHRoZSBwbHVnaW4gZm9yIHRoZSBzdXBwbGllZCBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IGV2ZW50IEEgc3ludGhldGljIGV2ZW50LlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBUaGUgcGx1Z2luIHRoYXQgY3JlYXRlZCB0aGUgc3VwcGxpZWQgZXZlbnQuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0UGx1Z2luTW9kdWxlRm9yRXZlbnQ6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnO1xuICAgIGlmIChkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lKSB7XG4gICAgICByZXR1cm4gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5yZWdpc3RyYXRpb25OYW1lXSB8fCBudWxsO1xuICAgIH1cbiAgICBmb3IgKHZhciBwaGFzZSBpbiBkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgICAgaWYgKCFkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcy5oYXNPd25Qcm9wZXJ0eShwaGFzZSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB2YXIgUGx1Z2luTW9kdWxlID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5yZWdpc3RyYXRpb25OYW1lTW9kdWxlc1tkaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lc1twaGFzZV1dO1xuICAgICAgaWYgKFBsdWdpbk1vZHVsZSkge1xuICAgICAgICByZXR1cm4gUGx1Z2luTW9kdWxlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgdW5pdCB0ZXN0aW5nLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Jlc2V0RXZlbnRQbHVnaW5zOiBmdW5jdGlvbiAoKSB7XG4gICAgRXZlbnRQbHVnaW5PcmRlciA9IG51bGw7XG4gICAgZm9yICh2YXIgcGx1Z2luTmFtZSBpbiBuYW1lc1RvUGx1Z2lucykge1xuICAgICAgaWYgKG5hbWVzVG9QbHVnaW5zLmhhc093blByb3BlcnR5KHBsdWdpbk5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBuYW1lc1RvUGx1Z2luc1twbHVnaW5OYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gICAgRXZlbnRQbHVnaW5SZWdpc3RyeS5wbHVnaW5zLmxlbmd0aCA9IDA7XG5cbiAgICB2YXIgZXZlbnROYW1lRGlzcGF0Y2hDb25maWdzID0gRXZlbnRQbHVnaW5SZWdpc3RyeS5ldmVudE5hbWVEaXNwYXRjaENvbmZpZ3M7XG4gICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncykge1xuICAgICAgaWYgKGV2ZW50TmFtZURpc3BhdGNoQ29uZmlncy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XG4gICAgICAgIGRlbGV0ZSBldmVudE5hbWVEaXNwYXRjaENvbmZpZ3NbZXZlbnROYW1lXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMgPSBFdmVudFBsdWdpblJlZ2lzdHJ5LnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuICAgIGZvciAodmFyIHJlZ2lzdHJhdGlvbk5hbWUgaW4gcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMpIHtcbiAgICAgIGlmIChyZWdpc3RyYXRpb25OYW1lTW9kdWxlcy5oYXNPd25Qcm9wZXJ0eShyZWdpc3RyYXRpb25OYW1lKSkge1xuICAgICAgICBkZWxldGUgcmVnaXN0cmF0aW9uTmFtZU1vZHVsZXNbcmVnaXN0cmF0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQbHVnaW5SZWdpc3RyeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9FdmVudFBsdWdpblJlZ2lzdHJ5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEV2ZW50UGx1Z2luVXRpbHNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBSZWFjdEVycm9yVXRpbHMgPSByZXF1aXJlKCcuL1JlYWN0RXJyb3JVdGlscycpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBJbmplY3RlZCBkZXBlbmRlbmNpZXM6XG4gKi9cblxuLyoqXG4gKiAtIGBNb3VudGA6IFtyZXF1aXJlZF0gTW9kdWxlIHRoYXQgY2FuIGNvbnZlcnQgYmV0d2VlbiBSZWFjdCBkb20gSURzIGFuZFxuICogICBhY3R1YWwgbm9kZSByZWZlcmVuY2VzLlxuICovXG52YXIgaW5qZWN0aW9uID0ge1xuICBNb3VudDogbnVsbCxcbiAgaW5qZWN0TW91bnQ6IGZ1bmN0aW9uIChJbmplY3RlZE1vdW50KSB7XG4gICAgaW5qZWN0aW9uLk1vdW50ID0gSW5qZWN0ZWRNb3VudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoSW5qZWN0ZWRNb3VudCAmJiBJbmplY3RlZE1vdW50LmdldE5vZGUgJiYgSW5qZWN0ZWRNb3VudC5nZXRJRCwgJ0V2ZW50UGx1Z2luVXRpbHMuaW5qZWN0aW9uLmluamVjdE1vdW50KC4uLik6IEluamVjdGVkIE1vdW50ICcgKyAnbW9kdWxlIGlzIG1pc3NpbmcgZ2V0Tm9kZSBvciBnZXRJRC4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxuZnVuY3Rpb24gaXNFbmRpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VVcCB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoQ2FuY2VsO1xufVxuXG5mdW5jdGlvbiBpc01vdmVpc2godG9wTGV2ZWxUeXBlKSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VNb3ZlIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BUb3VjaE1vdmU7XG59XG5mdW5jdGlvbiBpc1N0YXJ0aXNoKHRvcExldmVsVHlwZSkge1xuICByZXR1cm4gdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93biB8fCB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wVG91Y2hTdGFydDtcbn1cblxudmFyIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICB2YXIgZGlzcGF0Y2hMaXN0ZW5lcnMgPSBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnM7XG4gICAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuXG4gICAgdmFyIGxpc3RlbmVyc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycyk7XG4gICAgdmFyIGlkc0lzQXJyID0gQXJyYXkuaXNBcnJheShkaXNwYXRjaElEcyk7XG4gICAgdmFyIElEc0xlbiA9IGlkc0lzQXJyID8gZGlzcGF0Y2hJRHMubGVuZ3RoIDogZGlzcGF0Y2hJRHMgPyAxIDogMDtcbiAgICB2YXIgbGlzdGVuZXJzTGVuID0gbGlzdGVuZXJzSXNBcnIgPyBkaXNwYXRjaExpc3RlbmVycy5sZW5ndGggOiBkaXNwYXRjaExpc3RlbmVycyA/IDEgOiAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoaWRzSXNBcnIgPT09IGxpc3RlbmVyc0lzQXJyICYmIElEc0xlbiA9PT0gbGlzdGVuZXJzTGVuLCAnRXZlbnRQbHVnaW5VdGlsczogSW52YWxpZCBgZXZlbnRgLicpIDogdW5kZWZpbmVkO1xuICB9O1xufVxuXG4vKipcbiAqIERpc3BhdGNoIHRoZSBldmVudCB0byB0aGUgbGlzdGVuZXIuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBTeW50aGV0aWNFdmVudCB0byBoYW5kbGVcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gc2ltdWxhdGVkIElmIHRoZSBldmVudCBpcyBzaW11bGF0ZWQgKGNoYW5nZXMgZXhuIGJlaGF2aW9yKVxuICogQHBhcmFtIHtmdW5jdGlvbn0gbGlzdGVuZXIgQXBwbGljYXRpb24tbGV2ZWwgY2FsbGJhY2tcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb21JRCBET00gaWQgdG8gcGFzcyB0byB0aGUgY2FsbGJhY2suXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaChldmVudCwgc2ltdWxhdGVkLCBsaXN0ZW5lciwgZG9tSUQpIHtcbiAgdmFyIHR5cGUgPSBldmVudC50eXBlIHx8ICd1bmtub3duLWV2ZW50JztcbiAgZXZlbnQuY3VycmVudFRhcmdldCA9IGluamVjdGlvbi5Nb3VudC5nZXROb2RlKGRvbUlEKTtcbiAgaWYgKHNpbXVsYXRlZCkge1xuICAgIFJlYWN0RXJyb3JVdGlscy5pbnZva2VHdWFyZGVkQ2FsbGJhY2tXaXRoQ2F0Y2godHlwZSwgbGlzdGVuZXIsIGV2ZW50LCBkb21JRCk7XG4gIH0gZWxzZSB7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayh0eXBlLCBsaXN0ZW5lciwgZXZlbnQsIGRvbUlEKTtcbiAgfVxuICBldmVudC5jdXJyZW50VGFyZ2V0ID0gbnVsbDtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZC9zaW1wbGUgaXRlcmF0aW9uIHRocm91Z2ggYW4gZXZlbnQncyBjb2xsZWN0ZWQgZGlzcGF0Y2hlcy5cbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyKGV2ZW50LCBzaW11bGF0ZWQpIHtcbiAgdmFyIGRpc3BhdGNoTGlzdGVuZXJzID0gZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzO1xuICB2YXIgZGlzcGF0Y2hJRHMgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFsaWRhdGVFdmVudERpc3BhdGNoZXMoZXZlbnQpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KGRpc3BhdGNoTGlzdGVuZXJzKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlzcGF0Y2hMaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8gTGlzdGVuZXJzIGFuZCBJRHMgYXJlIHR3byBwYXJhbGxlbCBhcnJheXMgdGhhdCBhcmUgYWx3YXlzIGluIHN5bmMuXG4gICAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnNbaV0sIGRpc3BhdGNoSURzW2ldKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZGlzcGF0Y2hMaXN0ZW5lcnMpIHtcbiAgICBleGVjdXRlRGlzcGF0Y2goZXZlbnQsIHNpbXVsYXRlZCwgZGlzcGF0Y2hMaXN0ZW5lcnMsIGRpc3BhdGNoSURzKTtcbiAgfVxuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xufVxuXG4vKipcbiAqIFN0YW5kYXJkL3NpbXBsZSBpdGVyYXRpb24gdGhyb3VnaCBhbiBldmVudCdzIGNvbGxlY3RlZCBkaXNwYXRjaGVzLCBidXQgc3RvcHNcbiAqIGF0IHRoZSBmaXJzdCBkaXNwYXRjaCBleGVjdXRpb24gcmV0dXJuaW5nIHRydWUsIGFuZCByZXR1cm5zIHRoYXQgaWQuXG4gKlxuICogQHJldHVybiB7P3N0cmluZ30gaWQgb2YgdGhlIGZpcnN0IGRpc3BhdGNoIGV4ZWN1dGlvbiB3aG8ncyBsaXN0ZW5lciByZXR1cm5zXG4gKiB0cnVlLCBvciBudWxsIGlmIG5vIGxpc3RlbmVyIHJldHVybmVkIHRydWUuXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlclN0b3BBdFRydWVJbXBsKGV2ZW50KSB7XG4gIHZhciBkaXNwYXRjaExpc3RlbmVycyA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSURzID0gZXZlbnQuX2Rpc3BhdGNoSURzO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVycykpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRpc3BhdGNoTGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vIExpc3RlbmVycyBhbmQgSURzIGFyZSB0d28gcGFyYWxsZWwgYXJyYXlzIHRoYXQgYXJlIGFsd2F5cyBpbiBzeW5jLlxuICAgICAgaWYgKGRpc3BhdGNoTGlzdGVuZXJzW2ldKGV2ZW50LCBkaXNwYXRjaElEc1tpXSkpIHtcbiAgICAgICAgcmV0dXJuIGRpc3BhdGNoSURzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChkaXNwYXRjaExpc3RlbmVycykge1xuICAgIGlmIChkaXNwYXRjaExpc3RlbmVycyhldmVudCwgZGlzcGF0Y2hJRHMpKSB7XG4gICAgICByZXR1cm4gZGlzcGF0Y2hJRHM7XG4gICAgfVxuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBzZWUgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGxcbiAqL1xuZnVuY3Rpb24gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZShldmVudCkge1xuICB2YXIgcmV0ID0gZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZUltcGwoZXZlbnQpO1xuICBldmVudC5fZGlzcGF0Y2hJRHMgPSBudWxsO1xuICBldmVudC5fZGlzcGF0Y2hMaXN0ZW5lcnMgPSBudWxsO1xuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIEV4ZWN1dGlvbiBvZiBhIFwiZGlyZWN0XCIgZGlzcGF0Y2ggLSB0aGVyZSBtdXN0IGJlIGF0IG1vc3Qgb25lIGRpc3BhdGNoXG4gKiBhY2N1bXVsYXRlZCBvbiB0aGUgZXZlbnQgb3IgaXQgaXMgY29uc2lkZXJlZCBhbiBlcnJvci4gSXQgZG9lc24ndCByZWFsbHkgbWFrZVxuICogc2Vuc2UgZm9yIGFuIGV2ZW50IHdpdGggbXVsdGlwbGUgZGlzcGF0Y2hlcyAoYnViYmxlZCkgdG8ga2VlcCB0cmFjayBvZiB0aGVcbiAqIHJldHVybiB2YWx1ZXMgYXQgZWFjaCBkaXNwYXRjaCBleGVjdXRpb24sIGJ1dCBpdCBkb2VzIHRlbmQgdG8gbWFrZSBzZW5zZSB3aGVuXG4gKiBkZWFsaW5nIHdpdGggXCJkaXJlY3RcIiBkaXNwYXRjaGVzLlxuICpcbiAqIEByZXR1cm4geyp9IFRoZSByZXR1cm4gdmFsdWUgb2YgZXhlY3V0aW5nIHRoZSBzaW5nbGUgZGlzcGF0Y2guXG4gKi9cbmZ1bmN0aW9uIGV4ZWN1dGVEaXJlY3REaXNwYXRjaChldmVudCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhbGlkYXRlRXZlbnREaXNwYXRjaGVzKGV2ZW50KTtcbiAgfVxuICB2YXIgZGlzcGF0Y2hMaXN0ZW5lciA9IGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbiAgdmFyIGRpc3BhdGNoSUQgPSBldmVudC5fZGlzcGF0Y2hJRHM7XG4gICEhQXJyYXkuaXNBcnJheShkaXNwYXRjaExpc3RlbmVyKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdleGVjdXRlRGlyZWN0RGlzcGF0Y2goLi4uKTogSW52YWxpZCBgZXZlbnRgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgdmFyIHJlcyA9IGRpc3BhdGNoTGlzdGVuZXIgPyBkaXNwYXRjaExpc3RlbmVyKGV2ZW50LCBkaXNwYXRjaElEKSA6IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IG51bGw7XG4gIGV2ZW50Ll9kaXNwYXRjaElEcyA9IG51bGw7XG4gIHJldHVybiByZXM7XG59XG5cbi8qKlxuICogQHBhcmFtIHtTeW50aGV0aWNFdmVudH0gZXZlbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWZmIG51bWJlciBvZiBkaXNwYXRjaGVzIGFjY3VtdWxhdGVkIGlzIGdyZWF0ZXIgdGhhbiAwLlxuICovXG5mdW5jdGlvbiBoYXNEaXNwYXRjaGVzKGV2ZW50KSB7XG4gIHJldHVybiAhIWV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycztcbn1cblxuLyoqXG4gKiBHZW5lcmFsIHV0aWxpdGllcyB0aGF0IGFyZSB1c2VmdWwgaW4gY3JlYXRpbmcgY3VzdG9tIEV2ZW50IFBsdWdpbnMuXG4gKi9cbnZhciBFdmVudFBsdWdpblV0aWxzID0ge1xuICBpc0VuZGlzaDogaXNFbmRpc2gsXG4gIGlzTW92ZWlzaDogaXNNb3ZlaXNoLFxuICBpc1N0YXJ0aXNoOiBpc1N0YXJ0aXNoLFxuXG4gIGV4ZWN1dGVEaXJlY3REaXNwYXRjaDogZXhlY3V0ZURpcmVjdERpc3BhdGNoLFxuICBleGVjdXRlRGlzcGF0Y2hlc0luT3JkZXI6IGV4ZWN1dGVEaXNwYXRjaGVzSW5PcmRlcixcbiAgZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZTogZXhlY3V0ZURpc3BhdGNoZXNJbk9yZGVyU3RvcEF0VHJ1ZSxcbiAgaGFzRGlzcGF0Y2hlczogaGFzRGlzcGF0Y2hlcyxcblxuICBnZXROb2RlOiBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldE5vZGUoaWQpO1xuICB9LFxuICBnZXRJRDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICByZXR1cm4gaW5qZWN0aW9uLk1vdW50LmdldElEKG5vZGUpO1xuICB9LFxuXG4gIGluamVjdGlvbjogaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50UGx1Z2luVXRpbHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvRXZlbnRQbHVnaW5VdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVycm9yVXRpbHNcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2F1Z2h0RXJyb3IgPSBudWxsO1xuXG4vKipcbiAqIENhbGwgYSBmdW5jdGlvbiB3aGlsZSBndWFyZGluZyBhZ2FpbnN0IGVycm9ycyB0aGF0IGhhcHBlbnMgd2l0aGluIGl0LlxuICpcbiAqIEBwYXJhbSB7P1N0cmluZ30gbmFtZSBvZiB0aGUgZ3VhcmQgdG8gdXNlIGZvciBsb2dnaW5nIG9yIGRlYnVnZ2luZ1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaW52b2tlXG4gKiBAcGFyYW0geyp9IGEgRmlyc3QgYXJndW1lbnRcbiAqIEBwYXJhbSB7Kn0gYiBTZWNvbmQgYXJndW1lbnRcbiAqL1xuZnVuY3Rpb24gaW52b2tlR3VhcmRlZENhbGxiYWNrKG5hbWUsIGZ1bmMsIGEsIGIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYyhhLCBiKTtcbiAgfSBjYXRjaCAoeCkge1xuICAgIGlmIChjYXVnaHRFcnJvciA9PT0gbnVsbCkge1xuICAgICAgY2F1Z2h0RXJyb3IgPSB4O1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVycm9yVXRpbHMgPSB7XG4gIGludm9rZUd1YXJkZWRDYWxsYmFjazogaW52b2tlR3VhcmRlZENhbGxiYWNrLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIGJ5IFJlYWN0VGVzdFV0aWxzLlNpbXVsYXRlIHNvIHRoYXQgYW55IGVycm9ycyB0aHJvd24gYnkgdGhlIGV2ZW50XG4gICAqIGhhbmRsZXIgYXJlIHN1cmUgdG8gYmUgcmV0aHJvd24gYnkgcmV0aHJvd0NhdWdodEVycm9yLlxuICAgKi9cbiAgaW52b2tlR3VhcmRlZENhbGxiYWNrV2l0aENhdGNoOiBpbnZva2VHdWFyZGVkQ2FsbGJhY2ssXG5cbiAgLyoqXG4gICAqIER1cmluZyBleGVjdXRpb24gb2YgZ3VhcmRlZCBmdW5jdGlvbnMgd2Ugd2lsbCBjYXB0dXJlIHRoZSBmaXJzdCBlcnJvciB3aGljaFxuICAgKiB3ZSB3aWxsIHJldGhyb3cgdG8gYmUgaGFuZGxlZCBieSB0aGUgdG9wIGxldmVsIGVycm9yIGhhbmRsZXIuXG4gICAqL1xuICByZXRocm93Q2F1Z2h0RXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2F1Z2h0RXJyb3IpIHtcbiAgICAgIHZhciBlcnJvciA9IGNhdWdodEVycm9yO1xuICAgICAgY2F1Z2h0RXJyb3IgPSBudWxsO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICB9XG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvKipcbiAgICogVG8gaGVscCBkZXZlbG9wbWVudCB3ZSBjYW4gZ2V0IGJldHRlciBkZXZ0b29scyBpbnRlZ3JhdGlvbiBieSBzaW11bGF0aW5nIGFcbiAgICogcmVhbCBicm93c2VyIGV2ZW50LlxuICAgKi9cbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuZGlzcGF0Y2hFdmVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHZhciBmYWtlTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3JlYWN0Jyk7XG4gICAgUmVhY3RFcnJvclV0aWxzLmludm9rZUd1YXJkZWRDYWxsYmFjayA9IGZ1bmN0aW9uIChuYW1lLCBmdW5jLCBhLCBiKSB7XG4gICAgICB2YXIgYm91bmRGdW5jID0gZnVuYy5iaW5kKG51bGwsIGEsIGIpO1xuICAgICAgdmFyIGV2dFR5cGUgPSAncmVhY3QtJyArIG5hbWU7XG4gICAgICBmYWtlTm9kZS5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGJvdW5kRnVuYywgZmFsc2UpO1xuICAgICAgdmFyIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdFdmVudCcpO1xuICAgICAgZXZ0LmluaXRFdmVudChldnRUeXBlLCBmYWxzZSwgZmFsc2UpO1xuICAgICAgZmFrZU5vZGUuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgZmFrZU5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnRUeXBlLCBib3VuZEZ1bmMsIGZhbHNlKTtcbiAgICB9O1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFcnJvclV0aWxzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RXJyb3JVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhY2N1bXVsYXRlSW50b1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqXG4gKiBBY2N1bXVsYXRlcyBpdGVtcyB0aGF0IG11c3Qgbm90IGJlIG51bGwgb3IgdW5kZWZpbmVkIGludG8gdGhlIGZpcnN0IG9uZS4gVGhpc1xuICogaXMgdXNlZCB0byBjb25zZXJ2ZSBtZW1vcnkgYnkgYXZvaWRpbmcgYXJyYXkgYWxsb2NhdGlvbnMsIGFuZCB0aHVzIHNhY3JpZmljZXNcbiAqIEFQSSBjbGVhbm5lc3MuIFNpbmNlIGBjdXJyZW50YCBjYW4gYmUgbnVsbCBiZWZvcmUgYmVpbmcgcGFzc2VkIGluIGFuZCBub3RcbiAqIG51bGwgYWZ0ZXIgdGhpcyBmdW5jdGlvbiwgbWFrZSBzdXJlIHRvIGFzc2lnbiBpdCBiYWNrIHRvIGBjdXJyZW50YDpcbiAqXG4gKiBgYSA9IGFjY3VtdWxhdGVJbnRvKGEsIGIpO2BcbiAqXG4gKiBUaGlzIEFQSSBzaG91bGQgYmUgc3BhcmluZ2x5IHVzZWQuIFRyeSBgYWNjdW11bGF0ZWAgZm9yIHNvbWV0aGluZyBjbGVhbmVyLlxuICpcbiAqIEByZXR1cm4geyp8YXJyYXk8Kj59IEFuIGFjY3VtdWxhdGlvbiBvZiBpdGVtcy5cbiAqL1xuXG5mdW5jdGlvbiBhY2N1bXVsYXRlSW50byhjdXJyZW50LCBuZXh0KSB7XG4gICEobmV4dCAhPSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdhY2N1bXVsYXRlSW50byguLi4pOiBBY2N1bXVsYXRlZCBpdGVtcyBtdXN0IG5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8vIEJvdGggYXJlIG5vdCBlbXB0eS4gV2FybmluZzogTmV2ZXIgY2FsbCB4LmNvbmNhdCh5KSB3aGVuIHlvdSBhcmUgbm90XG4gIC8vIGNlcnRhaW4gdGhhdCB4IGlzIGFuIEFycmF5ICh4IGNvdWxkIGJlIGEgc3RyaW5nIHdpdGggY29uY2F0IG1ldGhvZCkuXG4gIHZhciBjdXJyZW50SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoY3VycmVudCk7XG4gIHZhciBuZXh0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkobmV4dCk7XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5ICYmIG5leHRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoLmFwcGx5KGN1cnJlbnQsIG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKGN1cnJlbnRJc0FycmF5KSB7XG4gICAgY3VycmVudC5wdXNoKG5leHQpO1xuICAgIHJldHVybiBjdXJyZW50O1xuICB9XG5cbiAgaWYgKG5leHRJc0FycmF5KSB7XG4gICAgLy8gQSBiaXQgdG9vIGRhbmdlcm91cyB0byBtdXRhdGUgYG5leHRgLlxuICAgIHJldHVybiBbY3VycmVudF0uY29uY2F0KG5leHQpO1xuICB9XG5cbiAgcmV0dXJuIFtjdXJyZW50LCBuZXh0XTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhY2N1bXVsYXRlSW50bztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9hY2N1bXVsYXRlSW50by5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb3JFYWNoQWNjdW11bGF0ZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHthcnJheX0gYXJyIGFuIFwiYWNjdW11bGF0aW9uXCIgb2YgaXRlbXMgd2hpY2ggaXMgZWl0aGVyIGFuIEFycmF5IG9yXG4gKiBhIHNpbmdsZSBpdGVtLiBVc2VmdWwgd2hlbiBwYWlyZWQgd2l0aCB0aGUgYGFjY3VtdWxhdGVgIG1vZHVsZS4gVGhpcyBpcyBhXG4gKiBzaW1wbGUgdXRpbGl0eSB0aGF0IGFsbG93cyB1cyB0byByZWFzb24gYWJvdXQgYSBjb2xsZWN0aW9uIG9mIGl0ZW1zLCBidXRcbiAqIGhhbmRsaW5nIHRoZSBjYXNlIHdoZW4gdGhlcmUgaXMgZXhhY3RseSBvbmUgaXRlbSAoYW5kIHdlIGRvIG5vdCBuZWVkIHRvXG4gKiBhbGxvY2F0ZSBhbiBhcnJheSkuXG4gKi9cbnZhciBmb3JFYWNoQWNjdW11bGF0ZWQgPSBmdW5jdGlvbiAoYXJyLCBjYiwgc2NvcGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgIGFyci5mb3JFYWNoKGNiLCBzY29wZSk7XG4gIH0gZWxzZSBpZiAoYXJyKSB7XG4gICAgY2IuY2FsbChzY29wZSwgYXJyKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmb3JFYWNoQWNjdW11bGF0ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvZm9yRWFjaEFjY3VtdWxhdGVkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RXZlbnRFbWl0dGVyTWl4aW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcblxuZnVuY3Rpb24gcnVuRXZlbnRRdWV1ZUluQmF0Y2goZXZlbnRzKSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnRzKTtcbiAgRXZlbnRQbHVnaW5IdWIucHJvY2Vzc0V2ZW50UXVldWUoZmFsc2UpO1xufVxuXG52YXIgUmVhY3RFdmVudEVtaXR0ZXJNaXhpbiA9IHtcblxuICAvKipcbiAgICogU3RyZWFtcyBhIGZpcmVkIHRvcC1sZXZlbCBldmVudCB0byBgRXZlbnRQbHVnaW5IdWJgIHdoZXJlIHBsdWdpbnMgaGF2ZSB0aGVcbiAgICogb3Bwb3J0dW5pdHkgdG8gY3JlYXRlIGBSZWFjdEV2ZW50YHMgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGVudmlyb25tZW50IGV2ZW50LlxuICAgKi9cbiAgaGFuZGxlVG9wTGV2ZWw6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgICB2YXIgZXZlbnRzID0gRXZlbnRQbHVnaW5IdWIuZXh0cmFjdEV2ZW50cyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIHJ1bkV2ZW50UXVldWVJbkJhdGNoKGV2ZW50cyk7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RFdmVudEVtaXR0ZXJNaXhpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEV2ZW50RW1pdHRlck1peGluLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFZpZXdwb3J0TWV0cmljc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFZpZXdwb3J0TWV0cmljcyA9IHtcblxuICBjdXJyZW50U2Nyb2xsTGVmdDogMCxcblxuICBjdXJyZW50U2Nyb2xsVG9wOiAwLFxuXG4gIHJlZnJlc2hTY3JvbGxWYWx1ZXM6IGZ1bmN0aW9uIChzY3JvbGxQb3NpdGlvbikge1xuICAgIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdCA9IHNjcm9sbFBvc2l0aW9uLng7XG4gICAgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3AgPSBzY3JvbGxQb3NpdGlvbi55O1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gVmlld3BvcnRNZXRyaWNzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1ZpZXdwb3J0TWV0cmljcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBPYmplY3QuYXNzaWduXG4gKi9cblxuLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLW9iamVjdC5hc3NpZ25cblxuJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0LCBzb3VyY2VzKSB7XG4gIGlmICh0YXJnZXQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ09iamVjdC5hc3NpZ24gdGFyZ2V0IGNhbm5vdCBiZSBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICB9XG5cbiAgdmFyIHRvID0gT2JqZWN0KHRhcmdldCk7XG4gIHZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbiAgZm9yICh2YXIgbmV4dEluZGV4ID0gMTsgbmV4dEluZGV4IDwgYXJndW1lbnRzLmxlbmd0aDsgbmV4dEluZGV4KyspIHtcbiAgICB2YXIgbmV4dFNvdXJjZSA9IGFyZ3VtZW50c1tuZXh0SW5kZXhdO1xuICAgIGlmIChuZXh0U291cmNlID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHZhciBmcm9tID0gT2JqZWN0KG5leHRTb3VyY2UpO1xuXG4gICAgLy8gV2UgZG9uJ3QgY3VycmVudGx5IHN1cHBvcnQgYWNjZXNzb3JzIG5vciBwcm94aWVzLiBUaGVyZWZvcmUgdGhpc1xuICAgIC8vIGNvcHkgY2Fubm90IHRocm93LiBJZiB3ZSBldmVyIHN1cHBvcnRlZCB0aGlzIHRoZW4gd2UgbXVzdCBoYW5kbGVcbiAgICAvLyBleGNlcHRpb25zIGFuZCBzaWRlLWVmZmVjdHMuIFdlIGRvbid0IHN1cHBvcnQgc3ltYm9scyBzbyB0aGV5IHdvbid0XG4gICAgLy8gYmUgdHJhbnNmZXJyZWQuXG5cbiAgICBmb3IgKHZhciBrZXkgaW4gZnJvbSkge1xuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoZnJvbSwga2V5KSkge1xuICAgICAgICB0b1trZXldID0gZnJvbVtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBhc3NpZ247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvT2JqZWN0LmFzc2lnbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBpc0V2ZW50U3VwcG9ydGVkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgdXNlSGFzRmVhdHVyZTtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgdXNlSGFzRmVhdHVyZSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uICYmIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUgJiZcbiAgLy8gYWx3YXlzIHJldHVybnMgdHJ1ZSBpbiBuZXdlciBicm93c2VycyBhcyBwZXIgdGhlIHN0YW5kYXJkLlxuICAvLyBAc2VlIGh0dHA6Ly9kb20uc3BlYy53aGF0d2cub3JnLyNkb20tZG9taW1wbGVtZW50YXRpb24taGFzZmVhdHVyZVxuICBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlKCcnLCAnJykgIT09IHRydWU7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGFuIGV2ZW50IGlzIHN1cHBvcnRlZCBpbiB0aGUgY3VycmVudCBleGVjdXRpb24gZW52aXJvbm1lbnQuXG4gKlxuICogTk9URTogVGhpcyB3aWxsIG5vdCB3b3JrIGNvcnJlY3RseSBmb3Igbm9uLWdlbmVyaWMgZXZlbnRzIHN1Y2ggYXMgYGNoYW5nZWAsXG4gKiBgcmVzZXRgLCBgbG9hZGAsIGBlcnJvcmAsIGFuZCBgc2VsZWN0YC5cbiAqXG4gKiBCb3Jyb3dzIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudE5hbWVTdWZmaXggRXZlbnQgbmFtZSwgZS5nLiBcImNsaWNrXCIuXG4gKiBAcGFyYW0gez9ib29sZWFufSBjYXB0dXJlIENoZWNrIGlmIHRoZSBjYXB0dXJlIHBoYXNlIGlzIHN1cHBvcnRlZC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV2ZW50IGlzIHN1cHBvcnRlZC5cbiAqIEBpbnRlcm5hbFxuICogQGxpY2Vuc2UgTW9kZXJuaXpyIDMuMC4wcHJlIChDdXN0b20gQnVpbGQpIHwgTUlUXG4gKi9cbmZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lU3VmZml4LCBjYXB0dXJlKSB7XG4gIGlmICghRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NIHx8IGNhcHR1cmUgJiYgISgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gZG9jdW1lbnQpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgdmFyIGV2ZW50TmFtZSA9ICdvbicgKyBldmVudE5hbWVTdWZmaXg7XG4gIHZhciBpc1N1cHBvcnRlZCA9IChldmVudE5hbWUgaW4gZG9jdW1lbnQpO1xuXG4gIGlmICghaXNTdXBwb3J0ZWQpIHtcbiAgICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGV2ZW50TmFtZSwgJ3JldHVybjsnKTtcbiAgICBpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbGVtZW50W2V2ZW50TmFtZV0gPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBpZiAoIWlzU3VwcG9ydGVkICYmIHVzZUhhc0ZlYXR1cmUgJiYgZXZlbnROYW1lU3VmZml4ID09PSAnd2hlZWwnKSB7XG4gICAgLy8gVGhpcyBpcyB0aGUgb25seSB3YXkgdG8gdGVzdCBzdXBwb3J0IGZvciB0aGUgYHdoZWVsYCBldmVudCBpbiBJRTkrLlxuICAgIGlzU3VwcG9ydGVkID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uaGFzRmVhdHVyZSgnRXZlbnRzLndoZWVsJywgJzMuMCcpO1xuICB9XG5cbiAgcmV0dXJuIGlzU3VwcG9ydGVkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzRXZlbnRTdXBwb3J0ZWQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvaXNFdmVudFN1cHBvcnRlZC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZlYXR1cmVGbGFnc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0ge1xuICB1c2VDcmVhdGVFbGVtZW50OiBmYWxzZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUZlYXR1cmVGbGFncztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdERPTUZlYXR1cmVGbGFncy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEVsZW1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xuXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQgdHlwZS4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sWydmb3InXSAmJiBTeW1ib2xbJ2ZvciddKCdyZWFjdC5lbGVtZW50JykgfHwgMHhlYWM3O1xuXG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xuXG4vKipcbiAqIEJhc2UgY29uc3RydWN0b3IgZm9yIGFsbCBSZWFjdCBlbGVtZW50cy4gVGhpcyBpcyBvbmx5IHVzZWQgdG8gbWFrZSB0aGlzXG4gKiB3b3JrIHdpdGggYSBkeW5hbWljIGluc3RhbmNlb2YgY2hlY2suIE5vdGhpbmcgc2hvdWxkIGxpdmUgb24gdGhpcyBwcm90b3R5cGUuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBpbnRlcm5hbFxuICovXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvdyB1cyB0byB1bmlxdWVseSBpZGVudGlmeSB0aGlzIGFzIGEgUmVhY3QgRWxlbWVudFxuICAgICQkdHlwZW9mOiBSRUFDVF9FTEVNRU5UX1RZUEUsXG5cbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG5cbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9O1xuXG4gICAgLy8gVG8gbWFrZSBjb21wYXJpbmcgUmVhY3RFbGVtZW50cyBlYXNpZXIgZm9yIHRlc3RpbmcgcHVycG9zZXMsIHdlIG1ha2VcbiAgICAvLyB0aGUgdmFsaWRhdGlvbiBmbGFnIG5vbi1lbnVtZXJhYmxlICh3aGVyZSBwb3NzaWJsZSwgd2hpY2ggc2hvdWxkXG4gICAgLy8gaW5jbHVkZSBldmVyeSBlbnZpcm9ubWVudCB3ZSBydW4gdGVzdHMgaW4pLCBzbyB0aGUgdGVzdCBmcmFtZXdvcmtcbiAgICAvLyBpZ25vcmVzIGl0LlxuICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQuX3N0b3JlLCAndmFsaWRhdGVkJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgICB2YWx1ZTogc2VsZlxuICAgICAgfSk7XG4gICAgICAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgICAgLy8gZXF1YWwgZm9yIHRlc3RpbmcgcHVycG9zZXMgYW5kIHRoZXJlZm9yZSB3ZSBoaWRlIGl0IGZyb20gZW51bWVyYXRpb24uXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zb3VyY2UnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgPSBmYWxzZTtcbiAgICAgIGVsZW1lbnQuX3NlbGYgPSBzZWxmO1xuICAgICAgZWxlbWVudC5fc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgIE9iamVjdC5mcmVlemUoZWxlbWVudCk7XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcbiAgdmFyIHByb3BzID0ge307XG5cbiAgdmFyIGtleSA9IG51bGw7XG4gIHZhciByZWYgPSBudWxsO1xuICB2YXIgc2VsZiA9IG51bGw7XG4gIHZhciBzb3VyY2UgPSBudWxsO1xuXG4gIGlmIChjb25maWcgIT0gbnVsbCkge1xuICAgIHJlZiA9IGNvbmZpZy5yZWYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcucmVmO1xuICAgIGtleSA9IGNvbmZpZy5rZXkgPT09IHVuZGVmaW5lZCA/IG51bGwgOiAnJyArIGNvbmZpZy5rZXk7XG4gICAgc2VsZiA9IGNvbmZpZy5fX3NlbGYgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBjb25maWcuX19zZWxmO1xuICAgIHNvdXJjZSA9IGNvbmZpZy5fX3NvdXJjZSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGNvbmZpZy5fX3NvdXJjZTtcbiAgICAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcbiAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICB2YXIgZGVmYXVsdFByb3BzID0gdHlwZS5kZWZhdWx0UHJvcHM7XG4gICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgIGlmICh0eXBlb2YgcHJvcHNbcHJvcE5hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCwgcHJvcHMpO1xufTtcblxuUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3RvcnkgPSBmdW5jdGlvbiAodHlwZSkge1xuICB2YXIgZmFjdG9yeSA9IFJlYWN0RWxlbWVudC5jcmVhdGVFbGVtZW50LmJpbmQobnVsbCwgdHlwZSk7XG4gIC8vIEV4cG9zZSB0aGUgdHlwZSBvbiB0aGUgZmFjdG9yeSBhbmQgdGhlIHByb3RvdHlwZSBzbyB0aGF0IGl0IGNhbiBiZVxuICAvLyBlYXNpbHkgYWNjZXNzZWQgb24gZWxlbWVudHMuIEUuZy4gYDxGb28gLz4udHlwZSA9PT0gRm9vYC5cbiAgLy8gVGhpcyBzaG91bGQgbm90IGJlIG5hbWVkIGBjb25zdHJ1Y3RvcmAgc2luY2UgdGhpcyBtYXkgbm90IGJlIHRoZSBmdW5jdGlvblxuICAvLyB0aGF0IGNyZWF0ZWQgdGhlIGVsZW1lbnQsIGFuZCBpdCBtYXkgbm90IGV2ZW4gYmUgYSBjb25zdHJ1Y3Rvci5cbiAgLy8gTGVnYWN5IGhvb2sgVE9ETzogV2FybiBpZiB0aGlzIGlzIGFjY2Vzc2VkXG4gIGZhY3RvcnkudHlwZSA9IHR5cGU7XG4gIHJldHVybiBmYWN0b3J5O1xufTtcblxuUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZUtleSA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdLZXkpIHtcbiAgdmFyIG5ld0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQob2xkRWxlbWVudC50eXBlLCBuZXdLZXksIG9sZEVsZW1lbnQucmVmLCBvbGRFbGVtZW50Ll9zZWxmLCBvbGRFbGVtZW50Ll9zb3VyY2UsIG9sZEVsZW1lbnQuX293bmVyLCBvbGRFbGVtZW50LnByb3BzKTtcblxuICByZXR1cm4gbmV3RWxlbWVudDtcbn07XG5cblJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyA9IGZ1bmN0aW9uIChvbGRFbGVtZW50LCBuZXdQcm9wcykge1xuICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudChvbGRFbGVtZW50LnR5cGUsIG9sZEVsZW1lbnQua2V5LCBvbGRFbGVtZW50LnJlZiwgb2xkRWxlbWVudC5fc2VsZiwgb2xkRWxlbWVudC5fc291cmNlLCBvbGRFbGVtZW50Ll9vd25lciwgbmV3UHJvcHMpO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gSWYgdGhlIGtleSBvbiB0aGUgb3JpZ2luYWwgaXMgdmFsaWQsIHRoZW4gdGhlIGNsb25lIGlzIHZhbGlkXG4gICAgbmV3RWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gb2xkRWxlbWVudC5fc3RvcmUudmFsaWRhdGVkO1xuICB9XG5cbiAgcmV0dXJuIG5ld0VsZW1lbnQ7XG59O1xuXG5SZWFjdEVsZW1lbnQuY2xvbmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGNvbmZpZywgY2hpbGRyZW4pIHtcbiAgdmFyIHByb3BOYW1lO1xuXG4gIC8vIE9yaWdpbmFsIHByb3BzIGFyZSBjb3BpZWRcbiAgdmFyIHByb3BzID0gYXNzaWduKHt9LCBlbGVtZW50LnByb3BzKTtcblxuICAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG4gIHZhciBrZXkgPSBlbGVtZW50LmtleTtcbiAgdmFyIHJlZiA9IGVsZW1lbnQucmVmO1xuICAvLyBTZWxmIGlzIHByZXNlcnZlZCBzaW5jZSB0aGUgb3duZXIgaXMgcHJlc2VydmVkLlxuICB2YXIgc2VsZiA9IGVsZW1lbnQuX3NlbGY7XG4gIC8vIFNvdXJjZSBpcyBwcmVzZXJ2ZWQgc2luY2UgY2xvbmVFbGVtZW50IGlzIHVubGlrZWx5IHRvIGJlIHRhcmdldGVkIGJ5IGFcbiAgLy8gdHJhbnNwaWxlciwgYW5kIHRoZSBvcmlnaW5hbCBzb3VyY2UgaXMgcHJvYmFibHkgYSBiZXR0ZXIgaW5kaWNhdG9yIG9mIHRoZVxuICAvLyB0cnVlIG93bmVyLlxuICB2YXIgc291cmNlID0gZWxlbWVudC5fc291cmNlO1xuXG4gIC8vIE93bmVyIHdpbGwgYmUgcHJlc2VydmVkLCB1bmxlc3MgcmVmIGlzIG92ZXJyaWRkZW5cbiAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG5cbiAgaWYgKGNvbmZpZyAhPSBudWxsKSB7XG4gICAgaWYgKGNvbmZpZy5yZWYgIT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gU2lsZW50bHkgc3RlYWwgdGhlIHJlZiBmcm9tIHRoZSBwYXJlbnQuXG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgIH1cbiAgICBpZiAoY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuICAgIC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIG92ZXJyaWRlIGV4aXN0aW5nIHByb3BzXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChjb25maWcuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBDaGlsZHJlbiBjYW4gYmUgbW9yZSB0aGFuIG9uZSBhcmd1bWVudCwgYW5kIHRob3NlIGFyZSB0cmFuc2ZlcnJlZCBvbnRvXG4gIC8vIHRoZSBuZXdseSBhbGxvY2F0ZWQgcHJvcHMgb2JqZWN0LlxuICB2YXIgY2hpbGRyZW5MZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoIC0gMjtcbiAgaWYgKGNoaWxkcmVuTGVuZ3RoID09PSAxKSB7XG4gICAgcHJvcHMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgfSBlbHNlIGlmIChjaGlsZHJlbkxlbmd0aCA+IDEpIHtcbiAgICB2YXIgY2hpbGRBcnJheSA9IEFycmF5KGNoaWxkcmVuTGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuTGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkQXJyYXlbaV0gPSBhcmd1bWVudHNbaSArIDJdO1xuICAgIH1cbiAgICBwcm9wcy5jaGlsZHJlbiA9IGNoaWxkQXJyYXk7XG4gIH1cblxuICByZXR1cm4gUmVhY3RFbGVtZW50KGVsZW1lbnQudHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgb3duZXIsIHByb3BzKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSB2YWxpZCBjb21wb25lbnQuXG4gKiBAZmluYWxcbiAqL1xuUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50ID0gZnVuY3Rpb24gKG9iamVjdCkge1xuICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RFbGVtZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGNhbkRlZmluZVByb3BlcnR5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FuRGVmaW5lUHJvcGVydHkgPSBmYWxzZTtcbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHt9LCAneCcsIHsgZ2V0OiBmdW5jdGlvbiAoKSB7fSB9KTtcbiAgICBjYW5EZWZpbmVQcm9wZXJ0eSA9IHRydWU7XG4gIH0gY2F0Y2ggKHgpIHtcbiAgICAvLyBJRSB3aWxsIGZhaWwgb24gZGVmaW5lUHJvcGVydHlcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbkRlZmluZVByb3BlcnR5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2NhbkRlZmluZVByb3BlcnR5LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB0aGUgUmVhY3QgSURzIG9mIHRoZSBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgdG9cbi8vIGBudWxsYCAoaW4gcmVhbGl0eSBhIHBsYWNlaG9sZGVyIHN1Y2ggYXMgYG5vc2NyaXB0YClcbnZhciBudWxsQ29tcG9uZW50SURzUmVnaXN0cnkgPSB7fTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gaWQgQ29tcG9uZW50J3MgYF9yb290Tm9kZUlEYC5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBpcyByZW5kZXJlZCB0byBudWxsLlxuICovXG5mdW5jdGlvbiBpc051bGxDb21wb25lbnRJRChpZCkge1xuICByZXR1cm4gISFudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdO1xufVxuXG4vKipcbiAqIE1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBDb21wb25lbnQncyBgX3Jvb3ROb2RlSURgLlxuICovXG5mdW5jdGlvbiByZWdpc3Rlck51bGxDb21wb25lbnRJRChpZCkge1xuICBudWxsQ29tcG9uZW50SURzUmVnaXN0cnlbaWRdID0gdHJ1ZTtcbn1cblxuLyoqXG4gKiBVbm1hcmsgdGhlIGNvbXBvbmVudCBhcyBoYXZpbmcgcmVuZGVyZWQgdG8gbnVsbDogaXQgcmVuZGVycyB0byBzb21ldGhpbmcgbm93LlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIENvbXBvbmVudCdzIGBfcm9vdE5vZGVJRGAuXG4gKi9cbmZ1bmN0aW9uIGRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQoaWQpIHtcbiAgZGVsZXRlIG51bGxDb21wb25lbnRJRHNSZWdpc3RyeVtpZF07XG59XG5cbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkgPSB7XG4gIGlzTnVsbENvbXBvbmVudElEOiBpc051bGxDb21wb25lbnRJRCxcbiAgcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQ6IHJlZ2lzdGVyTnVsbENvbXBvbmVudElELFxuICBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEOiBkZXJlZ2lzdGVyTnVsbENvbXBvbmVudElEXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEVtcHR5Q29tcG9uZW50UmVnaXN0cnkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnN0YW5jZUhhbmRsZXNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RSb290SW5kZXggPSByZXF1aXJlKCcuL1JlYWN0Um9vdEluZGV4Jyk7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIFNFUEFSQVRPUiA9ICcuJztcbnZhciBTRVBBUkFUT1JfTEVOR1RIID0gU0VQQVJBVE9SLmxlbmd0aDtcblxuLyoqXG4gKiBNYXhpbXVtIGRlcHRoIG9mIHRyYXZlcnNhbHMgYmVmb3JlIHdlIGNvbnNpZGVyIHRoZSBwb3NzaWJpbGl0eSBvZiBhIGJhZCBJRC5cbiAqL1xudmFyIE1BWF9UUkVFX0RFUFRIID0gMTAwMDA7XG5cbi8qKlxuICogQ3JlYXRlcyBhIERPTSBJRCBwcmVmaXggdG8gdXNlIHdoZW4gbW91bnRpbmcgUmVhY3QgY29tcG9uZW50cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggQSB1bmlxdWUgaW50ZWdlclxuICogQHJldHVybiB7c3RyaW5nfSBSZWFjdCByb290IElELlxuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIGdldFJlYWN0Um9vdElEU3RyaW5nKGluZGV4KSB7XG4gIHJldHVybiBTRVBBUkFUT1IgKyBpbmRleC50b1N0cmluZygzNik7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIGEgY2hhcmFjdGVyIGluIHRoZSBzdXBwbGllZCBJRCBpcyBhIHNlcGFyYXRvciBvciB0aGUgZW5kLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBBIFJlYWN0IERPTSBJRC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCBJbmRleCBvZiB0aGUgY2hhcmFjdGVyIHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgY2hhcmFjdGVyIGlzIGEgc2VwYXJhdG9yIG9yIGVuZCBvZiB0aGUgSUQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpc0JvdW5kYXJ5KGlkLCBpbmRleCkge1xuICByZXR1cm4gaWQuY2hhckF0KGluZGV4KSA9PT0gU0VQQVJBVE9SIHx8IGluZGV4ID09PSBpZC5sZW5ndGg7XG59XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBzdXBwbGllZCBzdHJpbmcgaXMgYSB2YWxpZCBSZWFjdCBET00gSUQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGlkIEEgUmVhY3QgRE9NIElELCBtYXliZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIHN0cmluZyBpcyBhIHZhbGlkIFJlYWN0IERPTSBJRC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRJRChpZCkge1xuICByZXR1cm4gaWQgPT09ICcnIHx8IGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmNoYXJBdChpZC5sZW5ndGggLSAxKSAhPT0gU0VQQVJBVE9SO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZmlyc3QgSUQgaXMgYW4gYW5jZXN0b3Igb2Ygb3IgZXF1YWwgdG8gdGhlIHNlY29uZCBJRC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYW5jZXN0b3JJRFxuICogQHBhcmFtIHtzdHJpbmd9IGRlc2NlbmRhbnRJRFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgYW5jZXN0b3JJRGAgaXMgYW4gYW5jZXN0b3Igb2YgYGRlc2NlbmRhbnRJRGAuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gaXNBbmNlc3RvcklET2YoYW5jZXN0b3JJRCwgZGVzY2VuZGFudElEKSB7XG4gIHJldHVybiBkZXNjZW5kYW50SUQuaW5kZXhPZihhbmNlc3RvcklEKSA9PT0gMCAmJiBpc0JvdW5kYXJ5KGRlc2NlbmRhbnRJRCwgYW5jZXN0b3JJRC5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEdldHMgdGhlIHBhcmVudCBJRCBvZiB0aGUgc3VwcGxpZWQgUmVhY3QgRE9NIElELCBgaWRgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBpZCBJRCBvZiBhIGNvbXBvbmVudC5cbiAqIEByZXR1cm4ge3N0cmluZ30gSUQgb2YgdGhlIHBhcmVudCwgb3IgYW4gZW1wdHkgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0UGFyZW50SUQoaWQpIHtcbiAgcmV0dXJuIGlkID8gaWQuc3Vic3RyKDAsIGlkLmxhc3RJbmRleE9mKFNFUEFSQVRPUikpIDogJyc7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmV4dCBET00gSUQgb24gdGhlIHRyZWUgcGF0aCBmcm9tIHRoZSBzdXBwbGllZCBgYW5jZXN0b3JJRGAgdG8gdGhlXG4gKiBzdXBwbGllZCBgZGVzdGluYXRpb25JRGAuIElmIHRoZXkgYXJlIGVxdWFsLCB0aGUgSUQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGFuY2VzdG9ySUQgSUQgb2YgYW4gYW5jZXN0b3Igbm9kZSBvZiBgZGVzdGluYXRpb25JRGAuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGVzdGluYXRpb25JRCBJRCBvZiB0aGUgZGVzdGluYXRpb24gbm9kZS5cbiAqIEByZXR1cm4ge3N0cmluZ30gTmV4dCBJRCBvbiB0aGUgcGF0aCBmcm9tIGBhbmNlc3RvcklEYCB0byBgZGVzdGluYXRpb25JRGAuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBnZXROZXh0RGVzY2VuZGFudElEKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIHtcbiAgIShpc1ZhbGlkSUQoYW5jZXN0b3JJRCkgJiYgaXNWYWxpZElEKGRlc3RpbmF0aW9uSUQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXROZXh0RGVzY2VuZGFudElEKCVzLCAlcyk6IFJlY2VpdmVkIGFuIGludmFsaWQgUmVhY3QgRE9NIElELicsIGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWlzQW5jZXN0b3JJRE9mKGFuY2VzdG9ySUQsIGRlc3RpbmF0aW9uSUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2dldE5leHREZXNjZW5kYW50SUQoLi4uKTogUmVhY3QgaGFzIG1hZGUgYW4gaW52YWxpZCBhc3N1bXB0aW9uIGFib3V0ICcgKyAndGhlIERPTSBoaWVyYXJjaHkuIEV4cGVjdGVkIGAlc2AgdG8gYmUgYW4gYW5jZXN0b3Igb2YgYCVzYC4nLCBhbmNlc3RvcklELCBkZXN0aW5hdGlvbklEKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIGlmIChhbmNlc3RvcklEID09PSBkZXN0aW5hdGlvbklEKSB7XG4gICAgcmV0dXJuIGFuY2VzdG9ySUQ7XG4gIH1cbiAgLy8gU2tpcCBvdmVyIHRoZSBhbmNlc3RvciBhbmQgdGhlIGltbWVkaWF0ZSBzZXBhcmF0b3IuIFRyYXZlcnNlIHVudGlsIHdlIGhpdFxuICAvLyBhbm90aGVyIHNlcGFyYXRvciBvciB3ZSByZWFjaCB0aGUgZW5kIG9mIGBkZXN0aW5hdGlvbklEYC5cbiAgdmFyIHN0YXJ0ID0gYW5jZXN0b3JJRC5sZW5ndGggKyBTRVBBUkFUT1JfTEVOR1RIO1xuICB2YXIgaTtcbiAgZm9yIChpID0gc3RhcnQ7IGkgPCBkZXN0aW5hdGlvbklELmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkoZGVzdGluYXRpb25JRCwgaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdGluYXRpb25JRC5zdWJzdHIoMCwgaSk7XG59XG5cbi8qKlxuICogR2V0cyB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgSUQgb2YgdHdvIElEcy5cbiAqXG4gKiBVc2luZyB0aGlzIElEIHNjaGVtZSwgdGhlIG5lYXJlc3QgY29tbW9uIGFuY2VzdG9yIElEIGlzIHRoZSBsb25nZXN0IGNvbW1vblxuICogcHJlZml4IG9mIHRoZSB0d28gSURzIHRoYXQgaW1tZWRpYXRlbHkgcHJlY2VkZWQgYSBcIm1hcmtlclwiIGluIGJvdGggc3RyaW5ncy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gb25lSURcbiAqIEBwYXJhbSB7c3RyaW5nfSB0d29JRFxuICogQHJldHVybiB7c3RyaW5nfSBOZWFyZXN0IGNvbW1vbiBhbmNlc3RvciBJRCwgb3IgdGhlIGVtcHR5IHN0cmluZyBpZiBub25lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEKG9uZUlELCB0d29JRCkge1xuICB2YXIgbWluTGVuZ3RoID0gTWF0aC5taW4ob25lSUQubGVuZ3RoLCB0d29JRC5sZW5ndGgpO1xuICBpZiAobWluTGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG4gIHZhciBsYXN0Q29tbW9uTWFya2VySW5kZXggPSAwO1xuICAvLyBVc2UgYDw9YCB0byB0cmF2ZXJzZSB1bnRpbCB0aGUgXCJFT0xcIiBvZiB0aGUgc2hvcnRlciBzdHJpbmcuXG4gIGZvciAodmFyIGkgPSAwOyBpIDw9IG1pbkxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGlzQm91bmRhcnkob25lSUQsIGkpICYmIGlzQm91bmRhcnkodHdvSUQsIGkpKSB7XG4gICAgICBsYXN0Q29tbW9uTWFya2VySW5kZXggPSBpO1xuICAgIH0gZWxzZSBpZiAob25lSUQuY2hhckF0KGkpICE9PSB0d29JRC5jaGFyQXQoaSkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICB2YXIgbG9uZ2VzdENvbW1vbklEID0gb25lSUQuc3Vic3RyKDAsIGxhc3RDb21tb25NYXJrZXJJbmRleCk7XG4gICFpc1ZhbGlkSUQobG9uZ2VzdENvbW1vbklEKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQoJXMsICVzKTogRXhwZWN0ZWQgYSB2YWxpZCBSZWFjdCBET00gSUQ6ICVzJywgb25lSUQsIHR3b0lELCBsb25nZXN0Q29tbW9uSUQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGxvbmdlc3RDb21tb25JRDtcbn1cblxuLyoqXG4gKiBUcmF2ZXJzZXMgdGhlIHBhcmVudCBwYXRoIGJldHdlZW4gdHdvIElEcyAoZWl0aGVyIHVwIG9yIGRvd24pLiBUaGUgSURzIG11c3RcbiAqIG5vdCBiZSB0aGUgc2FtZSwgYW5kIHRoZXJlIG11c3QgZXhpc3QgYSBwYXJlbnQgcGF0aCBiZXR3ZWVuIHRoZW0uIElmIHRoZVxuICogY2FsbGJhY2sgcmV0dXJucyBgZmFsc2VgLCB0cmF2ZXJzYWwgaXMgc3RvcHBlZC5cbiAqXG4gKiBAcGFyYW0gez9zdHJpbmd9IHN0YXJ0IElEIGF0IHdoaWNoIHRvIHN0YXJ0IHRyYXZlcnNhbC5cbiAqIEBwYXJhbSB7P3N0cmluZ30gc3RvcCBJRCBhdCB3aGljaCB0byBlbmQgdHJhdmVyc2FsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIGVhY2ggSUQgd2l0aC5cbiAqIEBwYXJhbSB7Kn0gYXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aC5cbiAqIEBwYXJhbSB7P2Jvb2xlYW59IHNraXBGaXJzdCBXaGV0aGVyIG9yIG5vdCB0byBza2lwIHRoZSBmaXJzdCBub2RlLlxuICogQHBhcmFtIHs/Ym9vbGVhbn0gc2tpcExhc3QgV2hldGhlciBvciBub3QgdG8gc2tpcCB0aGUgbGFzdCBub2RlLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdHJhdmVyc2VQYXJlbnRQYXRoKHN0YXJ0LCBzdG9wLCBjYiwgYXJnLCBza2lwRmlyc3QsIHNraXBMYXN0KSB7XG4gIHN0YXJ0ID0gc3RhcnQgfHwgJyc7XG4gIHN0b3AgPSBzdG9wIHx8ICcnO1xuICAhKHN0YXJ0ICE9PSBzdG9wKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoLi4uKTogQ2Fubm90IHRyYXZlcnNlIGZyb20gYW5kIHRvIHRoZSBzYW1lIElELCBgJXNgLicsIHN0YXJ0KSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHZhciB0cmF2ZXJzZVVwID0gaXNBbmNlc3RvcklET2Yoc3RvcCwgc3RhcnQpO1xuICAhKHRyYXZlcnNlVXAgfHwgaXNBbmNlc3RvcklET2Yoc3RhcnQsIHN0b3ApKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICd0cmF2ZXJzZVBhcmVudFBhdGgoJXMsICVzLCAuLi4pOiBDYW5ub3QgdHJhdmVyc2UgZnJvbSB0d28gSURzIHRoYXQgZG8gJyArICdub3QgaGF2ZSBhIHBhcmVudCBwYXRoLicsIHN0YXJ0LCBzdG9wKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIC8vIFRyYXZlcnNlIGZyb20gYHN0YXJ0YCB0byBgc3RvcGAgb25lIGRlcHRoIGF0IGEgdGltZS5cbiAgdmFyIGRlcHRoID0gMDtcbiAgdmFyIHRyYXZlcnNlID0gdHJhdmVyc2VVcCA/IGdldFBhcmVudElEIDogZ2V0TmV4dERlc2NlbmRhbnRJRDtcbiAgZm9yICh2YXIgaWQgPSBzdGFydDs7IC8qIHVudGlsIGJyZWFrICovaWQgPSB0cmF2ZXJzZShpZCwgc3RvcCkpIHtcbiAgICB2YXIgcmV0O1xuICAgIGlmICgoIXNraXBGaXJzdCB8fCBpZCAhPT0gc3RhcnQpICYmICghc2tpcExhc3QgfHwgaWQgIT09IHN0b3ApKSB7XG4gICAgICByZXQgPSBjYihpZCwgdHJhdmVyc2VVcCwgYXJnKTtcbiAgICB9XG4gICAgaWYgKHJldCA9PT0gZmFsc2UgfHwgaWQgPT09IHN0b3ApIHtcbiAgICAgIC8vIE9ubHkgYnJlYWsgLy9hZnRlci8vIHZpc2l0aW5nIGBzdG9wYC5cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhKGRlcHRoKysgPCBNQVhfVFJFRV9ERVBUSCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhdmVyc2VQYXJlbnRQYXRoKCVzLCAlcywgLi4uKTogRGV0ZWN0ZWQgYW4gaW5maW5pdGUgbG9vcCB3aGlsZSAnICsgJ3RyYXZlcnNpbmcgdGhlIFJlYWN0IERPTSBJRCB0cmVlLiBUaGlzIG1heSBiZSBkdWUgdG8gbWFsZm9ybWVkIElEczogJXMnLCBzdGFydCwgc3RvcCwgaWQpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1hbmFnZXMgdGhlIElEcyBhc3NpZ25lZCB0byBET00gcmVwcmVzZW50YXRpb25zIG9mIFJlYWN0IGNvbXBvbmVudHMuIFRoaXNcbiAqIHVzZXMgYSBzcGVjaWZpYyBzY2hlbWUgaW4gb3JkZXIgdG8gdHJhdmVyc2UgdGhlIERPTSBlZmZpY2llbnRseSAoZS5nLiBpblxuICogb3JkZXIgdG8gc2ltdWxhdGUgZXZlbnRzKS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0ge1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3Qgcm9vdCBJRFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IEEgUmVhY3Qgcm9vdCBJRC5cbiAgICovXG4gIGNyZWF0ZVJlYWN0Um9vdElEOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGdldFJlYWN0Um9vdElEU3RyaW5nKFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4KCkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgUmVhY3QgSUQgYnkgam9pbmluZyBhIHJvb3QgSUQgd2l0aCBhIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgUm9vdCBJRCBvZiBhIHBhcmVudCBjb21wb25lbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIEEgY29tcG9uZW50J3MgbmFtZSAoYXMgZmxhdHRlbmVkIGNoaWxkcmVuKS5cbiAgICogQHJldHVybiB7c3RyaW5nfSBBIFJlYWN0IElELlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGNyZWF0ZVJlYWN0SUQ6IGZ1bmN0aW9uIChyb290SUQsIG5hbWUpIHtcbiAgICByZXR1cm4gcm9vdElEICsgbmFtZTtcbiAgfSxcblxuICAvKipcbiAgICogR2V0cyB0aGUgRE9NIElEIG9mIHRoZSBSZWFjdCBjb21wb25lbnQgdGhhdCBpcyB0aGUgcm9vdCBvZiB0aGUgdHJlZSB0aGF0XG4gICAqIGNvbnRhaW5zIHRoZSBSZWFjdCBjb21wb25lbnQgd2l0aCB0aGUgc3VwcGxpZWQgRE9NIElELlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaWQgRE9NIElEIG9mIGEgUmVhY3QgY29tcG9uZW50LlxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBET00gSUQgb2YgdGhlIFJlYWN0IGNvbXBvbmVudCB0aGF0IGlzIHRoZSByb290LlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFJlYWN0Um9vdElERnJvbU5vZGVJRDogZnVuY3Rpb24gKGlkKSB7XG4gICAgaWYgKGlkICYmIGlkLmNoYXJBdCgwKSA9PT0gU0VQQVJBVE9SICYmIGlkLmxlbmd0aCA+IDEpIHtcbiAgICAgIHZhciBpbmRleCA9IGlkLmluZGV4T2YoU0VQQVJBVE9SLCAxKTtcbiAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaWQuc3Vic3RyKDAsIGluZGV4KSA6IGlkO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2VzIHRoZSBJRCBoaWVyYXJjaHkgYW5kIGludm9rZXMgdGhlIHN1cHBsaWVkIGBjYmAgb24gYW55IElEcyB0aGF0XG4gICAqIHNob3VsZCB3b3VsZCByZWNlaXZlIGEgYG1vdXNlRW50ZXJgIG9yIGBtb3VzZUxlYXZlYCBldmVudC5cbiAgICpcbiAgICogTk9URTogRG9lcyBub3QgaW52b2tlIHRoZSBjYWxsYmFjayBvbiB0aGUgbmVhcmVzdCBjb21tb24gYW5jZXN0b3IgYmVjYXVzZVxuICAgKiBub3RoaW5nIFwiZW50ZXJlZFwiIG9yIFwibGVmdFwiIHRoYXQgZWxlbWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxlYXZlSUQgSUQgYmVpbmcgbGVmdC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGVudGVySUQgSUQgYmVpbmcgZW50ZXJlZC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlIG9uIGVhY2ggZW50ZXJlZC9sZWZ0IElELlxuICAgKiBAcGFyYW0geyp9IHVwQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBsZWZ0IElEcy5cbiAgICogQHBhcmFtIHsqfSBkb3duQXJnIEFyZ3VtZW50IHRvIGludm9rZSB0aGUgY2FsbGJhY2sgd2l0aCBvbiBlbnRlcmVkIElEcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB0cmF2ZXJzZUVudGVyTGVhdmU6IGZ1bmN0aW9uIChsZWF2ZUlELCBlbnRlcklELCBjYiwgdXBBcmcsIGRvd25BcmcpIHtcbiAgICB2YXIgYW5jZXN0b3JJRCA9IGdldEZpcnN0Q29tbW9uQW5jZXN0b3JJRChsZWF2ZUlELCBlbnRlcklEKTtcbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gbGVhdmVJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGxlYXZlSUQsIGFuY2VzdG9ySUQsIGNiLCB1cEFyZywgZmFsc2UsIHRydWUpO1xuICAgIH1cbiAgICBpZiAoYW5jZXN0b3JJRCAhPT0gZW50ZXJJRCkge1xuICAgICAgdHJhdmVyc2VQYXJlbnRQYXRoKGFuY2VzdG9ySUQsIGVudGVySUQsIGNiLCBkb3duQXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTaW11bGF0ZXMgdGhlIHRyYXZlcnNhbCBvZiBhIHR3by1waGFzZSwgY2FwdHVyZS9idWJibGUgZXZlbnQgZGlzcGF0Y2guXG4gICAqXG4gICAqIE5PVEU6IFRoaXMgdHJhdmVyc2FsIGhhcHBlbnMgb24gSURzIHdpdGhvdXQgdG91Y2hpbmcgdGhlIERPTS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRhcmdldElEIElEIG9mIHRoZSB0YXJnZXQgbm9kZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgQ2FsbGJhY2sgdG8gaW52b2tlLlxuICAgKiBAcGFyYW0geyp9IGFyZyBBcmd1bWVudCB0byBpbnZva2UgdGhlIGNhbGxiYWNrIHdpdGguXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhdmVyc2VUd29QaGFzZTogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgodGFyZ2V0SUQsICcnLCBjYiwgYXJnLCBmYWxzZSwgdHJ1ZSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBTYW1lIGFzIGB0cmF2ZXJzZVR3b1BoYXNlYCBidXQgc2tpcHMgdGhlIGB0YXJnZXRJRGAuXG4gICAqL1xuICB0cmF2ZXJzZVR3b1BoYXNlU2tpcFRhcmdldDogZnVuY3Rpb24gKHRhcmdldElELCBjYiwgYXJnKSB7XG4gICAgaWYgKHRhcmdldElEKSB7XG4gICAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCB0cnVlKTtcbiAgICAgIHRyYXZlcnNlUGFyZW50UGF0aCh0YXJnZXRJRCwgJycsIGNiLCBhcmcsIHRydWUsIHRydWUpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogVHJhdmVyc2UgYSBub2RlIElELCBjYWxsaW5nIHRoZSBzdXBwbGllZCBgY2JgIGZvciBlYWNoIGFuY2VzdG9yIElELiBGb3JcbiAgICogZXhhbXBsZSwgcGFzc2luZyBgLjAuJHJvdy0wLjFgIHdvdWxkIHJlc3VsdCBpbiBgY2JgIGdldHRpbmcgY2FsbGVkXG4gICAqIHdpdGggYC4wYCwgYC4wLiRyb3ctMGAsIGFuZCBgLjAuJHJvdy0wLjFgLlxuICAgKlxuICAgKiBOT1RFOiBUaGlzIHRyYXZlcnNhbCBoYXBwZW5zIG9uIElEcyB3aXRob3V0IHRvdWNoaW5nIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXRJRCBJRCBvZiB0aGUgdGFyZ2V0IG5vZGUuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIENhbGxiYWNrIHRvIGludm9rZS5cbiAgICogQHBhcmFtIHsqfSBhcmcgQXJndW1lbnQgdG8gaW52b2tlIHRoZSBjYWxsYmFjayB3aXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHRyYXZlcnNlQW5jZXN0b3JzOiBmdW5jdGlvbiAodGFyZ2V0SUQsIGNiLCBhcmcpIHtcbiAgICB0cmF2ZXJzZVBhcmVudFBhdGgoJycsIHRhcmdldElELCBjYiwgYXJnLCB0cnVlLCBmYWxzZSk7XG4gIH0sXG5cbiAgZ2V0Rmlyc3RDb21tb25BbmNlc3RvcklEOiBnZXRGaXJzdENvbW1vbkFuY2VzdG9ySUQsXG5cbiAgLyoqXG4gICAqIEV4cG9zZWQgZm9yIHVuaXQgdGVzdGluZy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9nZXROZXh0RGVzY2VuZGFudElEOiBnZXROZXh0RGVzY2VuZGFudElELFxuXG4gIGlzQW5jZXN0b3JJRE9mOiBpc0FuY2VzdG9ySURPZixcblxuICBTRVBBUkFUT1I6IFNFUEFSQVRPUlxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0SW5zdGFuY2VIYW5kbGVzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4XG4gICAqL1xuICBpbmplY3RDcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKF9jcmVhdGVSZWFjdFJvb3RJbmRleCkge1xuICAgIFJlYWN0Um9vdEluZGV4LmNyZWF0ZVJlYWN0Um9vdEluZGV4ID0gX2NyZWF0ZVJlYWN0Um9vdEluZGV4O1xuICB9XG59O1xuXG52YXIgUmVhY3RSb290SW5kZXggPSB7XG4gIGNyZWF0ZVJlYWN0Um9vdEluZGV4OiBudWxsLFxuICBpbmplY3Rpb246IFJlYWN0Um9vdEluZGV4SW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Um9vdEluZGV4O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Um9vdEluZGV4LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5zdGFuY2VNYXBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogYFJlYWN0SW5zdGFuY2VNYXBgIG1haW50YWlucyBhIG1hcHBpbmcgZnJvbSBhIHB1YmxpYyBmYWNpbmcgc3RhdGVmdWxcbiAqIGluc3RhbmNlIChrZXkpIGFuZCB0aGUgaW50ZXJuYWwgcmVwcmVzZW50YXRpb24gKHZhbHVlKS4gVGhpcyBhbGxvd3MgcHVibGljXG4gKiBtZXRob2RzIHRvIGFjY2VwdCB0aGUgdXNlciBmYWNpbmcgaW5zdGFuY2UgYXMgYW4gYXJndW1lbnQgYW5kIG1hcCB0aGVtIGJhY2tcbiAqIHRvIGludGVybmFsIG1ldGhvZHMuXG4gKi9cblxuLy8gVE9ETzogUmVwbGFjZSB0aGlzIHdpdGggRVM2OiB2YXIgUmVhY3RJbnN0YW5jZU1hcCA9IG5ldyBNYXAoKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0ge1xuXG4gIC8qKlxuICAgKiBUaGlzIEFQSSBzaG91bGQgYmUgY2FsbGVkIGBkZWxldGVgIGJ1dCB3ZSdkIGhhdmUgdG8gbWFrZSBzdXJlIHRvIGFsd2F5c1xuICAgKiB0cmFuc2Zvcm0gdGhlc2UgdG8gc3RyaW5ncyBmb3IgSUUgc3VwcG9ydC4gV2hlbiB0aGlzIHRyYW5zZm9ybSBpcyBmdWxseVxuICAgKiBzdXBwb3J0ZWQgd2UgY2FuIHJlbmFtZSBpdC5cbiAgICovXG4gIHJlbW92ZTogZnVuY3Rpb24gKGtleSkge1xuICAgIGtleS5fcmVhY3RJbnRlcm5hbEluc3RhbmNlID0gdW5kZWZpbmVkO1xuICB9LFxuXG4gIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBrZXkuX3JlYWN0SW50ZXJuYWxJbnN0YW5jZTtcbiAgfSxcblxuICBoYXM6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4ga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAga2V5Ll9yZWFjdEludGVybmFsSW5zdGFuY2UgPSB2YWx1ZTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5zdGFuY2VNYXA7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RJbnN0YW5jZU1hcC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE1hcmt1cENoZWNrc3VtXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgYWRsZXIzMiA9IHJlcXVpcmUoJy4vYWRsZXIzMicpO1xuXG52YXIgVEFHX0VORCA9IC9cXC8/Pi87XG5cbnZhciBSZWFjdE1hcmt1cENoZWNrc3VtID0ge1xuICBDSEVDS1NVTV9BVFRSX05BTUU6ICdkYXRhLXJlYWN0LWNoZWNrc3VtJyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1hcmt1cCBNYXJrdXAgc3RyaW5nXG4gICAqIEByZXR1cm4ge3N0cmluZ30gTWFya3VwIHN0cmluZyB3aXRoIGNoZWNrc3VtIGF0dHJpYnV0ZSBhdHRhY2hlZFxuICAgKi9cbiAgYWRkQ2hlY2tzdW1Ub01hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCkge1xuICAgIHZhciBjaGVja3N1bSA9IGFkbGVyMzIobWFya3VwKTtcblxuICAgIC8vIEFkZCBjaGVja3N1bSAoaGFuZGxlIGJvdGggcGFyZW50IHRhZ3MgYW5kIHNlbGYtY2xvc2luZyB0YWdzKVxuICAgIHJldHVybiBtYXJrdXAucmVwbGFjZShUQUdfRU5ELCAnICcgKyBSZWFjdE1hcmt1cENoZWNrc3VtLkNIRUNLU1VNX0FUVFJfTkFNRSArICc9XCInICsgY2hlY2tzdW0gKyAnXCIkJicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWFya3VwIHRvIHVzZVxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR9IGVsZW1lbnQgcm9vdCBSZWFjdCBlbGVtZW50XG4gICAqIEByZXR1cm5zIHtib29sZWFufSB3aGV0aGVyIG9yIG5vdCB0aGUgbWFya3VwIGlzIHRoZSBzYW1lXG4gICAqL1xuICBjYW5SZXVzZU1hcmt1cDogZnVuY3Rpb24gKG1hcmt1cCwgZWxlbWVudCkge1xuICAgIHZhciBleGlzdGluZ0NoZWNrc3VtID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoUmVhY3RNYXJrdXBDaGVja3N1bS5DSEVDS1NVTV9BVFRSX05BTUUpO1xuICAgIGV4aXN0aW5nQ2hlY2tzdW0gPSBleGlzdGluZ0NoZWNrc3VtICYmIHBhcnNlSW50KGV4aXN0aW5nQ2hlY2tzdW0sIDEwKTtcbiAgICB2YXIgbWFya3VwQ2hlY2tzdW0gPSBhZGxlcjMyKG1hcmt1cCk7XG4gICAgcmV0dXJuIG1hcmt1cENoZWNrc3VtID09PSBleGlzdGluZ0NoZWNrc3VtO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0TWFya3VwQ2hlY2tzdW07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RNYXJrdXBDaGVja3N1bS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBhZGxlcjMyXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgTU9EID0gNjU1MjE7XG5cbi8vIGFkbGVyMzIgaXMgbm90IGNyeXB0b2dyYXBoaWNhbGx5IHN0cm9uZywgYW5kIGlzIG9ubHkgdXNlZCB0byBzYW5pdHkgY2hlY2sgdGhhdFxuLy8gbWFya3VwIGdlbmVyYXRlZCBvbiB0aGUgc2VydmVyIG1hdGNoZXMgdGhlIG1hcmt1cCBnZW5lcmF0ZWQgb24gdGhlIGNsaWVudC5cbi8vIFRoaXMgaW1wbGVtZW50YXRpb24gKGEgbW9kaWZpZWQgdmVyc2lvbiBvZiB0aGUgU2hlZXRKUyB2ZXJzaW9uKSBoYXMgYmVlbiBvcHRpbWl6ZWRcbi8vIGZvciBvdXIgdXNlIGNhc2UsIGF0IHRoZSBleHBlbnNlIG9mIGNvbmZvcm1pbmcgdG8gdGhlIGFkbGVyMzIgc3BlY2lmaWNhdGlvblxuLy8gZm9yIG5vbi1hc2NpaSBpbnB1dHMuXG5mdW5jdGlvbiBhZGxlcjMyKGRhdGEpIHtcbiAgdmFyIGEgPSAxO1xuICB2YXIgYiA9IDA7XG4gIHZhciBpID0gMDtcbiAgdmFyIGwgPSBkYXRhLmxlbmd0aDtcbiAgdmFyIG0gPSBsICYgfjB4MztcbiAgd2hpbGUgKGkgPCBtKSB7XG4gICAgZm9yICg7IGkgPCBNYXRoLm1pbihpICsgNDA5NiwgbSk7IGkgKz0gNCkge1xuICAgICAgYiArPSAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSkpICsgKGEgKz0gZGF0YS5jaGFyQ29kZUF0KGkgKyAxKSkgKyAoYSArPSBkYXRhLmNoYXJDb2RlQXQoaSArIDIpKSArIChhICs9IGRhdGEuY2hhckNvZGVBdChpICsgMykpO1xuICAgIH1cbiAgICBhICU9IE1PRDtcbiAgICBiICU9IE1PRDtcbiAgfVxuICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgIGIgKz0gYSArPSBkYXRhLmNoYXJDb2RlQXQoaSk7XG4gIH1cbiAgYSAlPSBNT0Q7XG4gIGIgJT0gTU9EO1xuICByZXR1cm4gYSB8IGIgPDwgMTY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRsZXIzMjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9hZGxlcjMyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UmVjb25jaWxlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVmID0gcmVxdWlyZSgnLi9SZWFjdFJlZicpO1xuXG4vKipcbiAqIEhlbHBlciB0byBjYWxsIFJlYWN0UmVmLmF0dGFjaFJlZnMgd2l0aCB0aGlzIGNvbXBvc2l0ZSBjb21wb25lbnQsIHNwbGl0IG91dFxuICogdG8gYXZvaWQgYWxsb2NhdGlvbnMgaW4gdGhlIHRyYW5zYWN0aW9uIG1vdW50LXJlYWR5IHF1ZXVlLlxuICovXG5mdW5jdGlvbiBhdHRhY2hSZWZzKCkge1xuICBSZWFjdFJlZi5hdHRhY2hSZWZzKHRoaXMsIHRoaXMuX2N1cnJlbnRFbGVtZW50KTtcbn1cblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhlIGNvbXBvbmVudCwgcmVuZGVycyBtYXJrdXAsIGFuZCByZWdpc3RlcnMgZXZlbnQgbGlzdGVuZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByb290SUQgRE9NIElEIG9mIHRoZSByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfSBSZW5kZXJlZCBtYXJrdXAgdG8gYmUgaW5zZXJ0ZWQgaW50byB0aGUgRE9NLlxuICAgKiBAZmluYWxcbiAgICogQGludGVybmFsXG4gICAqL1xuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgbWFya3VwID0gaW50ZXJuYWxJbnN0YW5jZS5tb3VudENvbXBvbmVudChyb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQgJiYgaW50ZXJuYWxJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQucmVmICE9IG51bGwpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoYXR0YWNoUmVmcywgaW50ZXJuYWxJbnN0YW5jZSk7XG4gICAgfVxuICAgIHJldHVybiBtYXJrdXA7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFueSByZXNvdXJjZXMgYWxsb2NhdGVkIGJ5IGBtb3VudENvbXBvbmVudGAuXG4gICAqXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDb21wb25lbnQ6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgUmVhY3RSZWYuZGV0YWNoUmVmcyhpbnRlcm5hbEluc3RhbmNlLCBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCk7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS51bm1vdW50Q29tcG9uZW50KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBhIGNvbXBvbmVudCB1c2luZyBhIG5ldyBlbGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKGludGVybmFsSW5zdGFuY2UsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHZhciBwcmV2RWxlbWVudCA9IGludGVybmFsSW5zdGFuY2UuX2N1cnJlbnRFbGVtZW50O1xuXG4gICAgaWYgKG5leHRFbGVtZW50ID09PSBwcmV2RWxlbWVudCAmJiBjb250ZXh0ID09PSBpbnRlcm5hbEluc3RhbmNlLl9jb250ZXh0KSB7XG4gICAgICAvLyBTaW5jZSBlbGVtZW50cyBhcmUgaW1tdXRhYmxlIGFmdGVyIHRoZSBvd25lciBpcyByZW5kZXJlZCxcbiAgICAgIC8vIHdlIGNhbiBkbyBhIGNoZWFwIGlkZW50aXR5IGNvbXBhcmUgaGVyZSB0byBkZXRlcm1pbmUgaWYgdGhpcyBpcyBhXG4gICAgICAvLyBzdXBlcmZsdW91cyByZWNvbmNpbGUuIEl0J3MgcG9zc2libGUgZm9yIHN0YXRlIHRvIGJlIG11dGFibGUgYnV0IHN1Y2hcbiAgICAgIC8vIGNoYW5nZSBzaG91bGQgdHJpZ2dlciBhbiB1cGRhdGUgb2YgdGhlIG93bmVyIHdoaWNoIHdvdWxkIHJlY3JlYXRlXG4gICAgICAvLyB0aGUgZWxlbWVudC4gV2UgZXhwbGljaXRseSBjaGVjayBmb3IgdGhlIGV4aXN0ZW5jZSBvZiBhbiBvd25lciBzaW5jZVxuICAgICAgLy8gaXQncyBwb3NzaWJsZSBmb3IgYW4gZWxlbWVudCBjcmVhdGVkIG91dHNpZGUgYSBjb21wb3NpdGUgdG8gYmVcbiAgICAgIC8vIGRlZXBseSBtdXRhdGVkIGFuZCByZXVzZWQuXG5cbiAgICAgIC8vIFRPRE86IEJhaWxpbmcgb3V0IGVhcmx5IGlzIGp1c3QgYSBwZXJmIG9wdGltaXphdGlvbiByaWdodD9cbiAgICAgIC8vIFRPRE86IFJlbW92aW5nIHRoZSByZXR1cm4gc3RhdGVtZW50IHNob3VsZCBhZmZlY3QgY29ycmVjdG5lc3M/XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlZnNDaGFuZ2VkID0gUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyhwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpO1xuXG4gICAgaWYgKHJlZnNDaGFuZ2VkKSB7XG4gICAgICBSZWFjdFJlZi5kZXRhY2hSZWZzKGludGVybmFsSW5zdGFuY2UsIHByZXZFbGVtZW50KTtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLnJlY2VpdmVDb21wb25lbnQobmV4dEVsZW1lbnQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcblxuICAgIGlmIChyZWZzQ2hhbmdlZCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudCAmJiBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5yZWYgIT0gbnVsbCkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShhdHRhY2hSZWZzLCBpbnRlcm5hbEluc3RhbmNlKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZsdXNoIGFueSBkaXJ0eSBjaGFuZ2VzIGluIGEgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBpbnRlcm5hbEluc3RhbmNlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCB0cmFuc2FjdGlvbikge1xuICAgIGludGVybmFsSW5zdGFuY2UucGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5KHRyYW5zYWN0aW9uKTtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UmVjb25jaWxlcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFJlY29uY2lsZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RSZWZcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdE93bmVyJyk7XG5cbnZhciBSZWFjdFJlZiA9IHt9O1xuXG5mdW5jdGlvbiBhdHRhY2hSZWYocmVmLCBjb21wb25lbnQsIG93bmVyKSB7XG4gIGlmICh0eXBlb2YgcmVmID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmVmKGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5hZGRDb21wb25lbnRBc1JlZlRvKGNvbXBvbmVudCwgcmVmLCBvd25lcik7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0YWNoUmVmKHJlZiwgY29tcG9uZW50LCBvd25lcikge1xuICBpZiAodHlwZW9mIHJlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJlZihudWxsKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBMZWdhY3kgcmVmXG4gICAgUmVhY3RPd25lci5yZW1vdmVDb21wb25lbnRBc1JlZkZyb20oY29tcG9uZW50LCByZWYsIG93bmVyKTtcbiAgfVxufVxuXG5SZWFjdFJlZi5hdHRhY2hSZWZzID0gZnVuY3Rpb24gKGluc3RhbmNlLCBlbGVtZW50KSB7XG4gIGlmIChlbGVtZW50ID09PSBudWxsIHx8IGVsZW1lbnQgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByZWYgPSBlbGVtZW50LnJlZjtcbiAgaWYgKHJlZiAhPSBudWxsKSB7XG4gICAgYXR0YWNoUmVmKHJlZiwgaW5zdGFuY2UsIGVsZW1lbnQuX293bmVyKTtcbiAgfVxufTtcblxuUmVhY3RSZWYuc2hvdWxkVXBkYXRlUmVmcyA9IGZ1bmN0aW9uIChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgLy8gSWYgZWl0aGVyIHRoZSBvd25lciBvciBhIGByZWZgIGhhcyBjaGFuZ2VkLCBtYWtlIHN1cmUgdGhlIG5ld2VzdCBvd25lclxuICAvLyBoYXMgc3RvcmVkIGEgcmVmZXJlbmNlIHRvIGB0aGlzYCwgYW5kIHRoZSBwcmV2aW91cyBvd25lciAoaWYgZGlmZmVyZW50KVxuICAvLyBoYXMgZm9yZ290dGVuIHRoZSByZWZlcmVuY2UgdG8gYHRoaXNgLiBXZSB1c2UgdGhlIGVsZW1lbnQgaW5zdGVhZFxuICAvLyBvZiB0aGUgcHVibGljIHRoaXMucHJvcHMgYmVjYXVzZSB0aGUgcG9zdCBwcm9jZXNzaW5nIGNhbm5vdCBkZXRlcm1pbmVcbiAgLy8gYSByZWYuIFRoZSByZWYgY29uY2VwdHVhbGx5IGxpdmVzIG9uIHRoZSBlbGVtZW50LlxuXG4gIC8vIFRPRE86IFNob3VsZCB0aGlzIGV2ZW4gYmUgcG9zc2libGU/IFRoZSBvd25lciBjYW5ub3QgY2hhbmdlIGJlY2F1c2VcbiAgLy8gaXQncyBmb3JiaWRkZW4gYnkgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQuIFRoZSByZWYgY2FuIGNoYW5nZVxuICAvLyBpZiB5b3Ugc3dhcCB0aGUga2V5cyBvZiBidXQgbm90IHRoZSByZWZzLiBSZWNvbnNpZGVyIHdoZXJlIHRoaXMgY2hlY2tcbiAgLy8gaXMgbWFkZS4gSXQgcHJvYmFibHkgYmVsb25ncyB3aGVyZSB0aGUga2V5IGNoZWNraW5nIGFuZFxuICAvLyBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50IGlzIGRvbmUuXG5cbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcblxuICByZXR1cm4oXG4gICAgLy8gVGhpcyBoYXMgYSBmZXcgZmFsc2UgcG9zaXRpdmVzIHcvci90IGVtcHR5IGNvbXBvbmVudHMuXG4gICAgcHJldkVtcHR5IHx8IG5leHRFbXB0eSB8fCBuZXh0RWxlbWVudC5fb3duZXIgIT09IHByZXZFbGVtZW50Ll9vd25lciB8fCBuZXh0RWxlbWVudC5yZWYgIT09IHByZXZFbGVtZW50LnJlZlxuICApO1xufTtcblxuUmVhY3RSZWYuZGV0YWNoUmVmcyA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgZWxlbWVudCkge1xuICBpZiAoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmVmID0gZWxlbWVudC5yZWY7XG4gIGlmIChyZWYgIT0gbnVsbCkge1xuICAgIGRldGFjaFJlZihyZWYsIGluc3RhbmNlLCBlbGVtZW50Ll9vd25lcik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RSZWY7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RSZWYuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RPd25lclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJlYWN0T3duZXJzIGFyZSBjYXBhYmxlIG9mIHN0b3JpbmcgcmVmZXJlbmNlcyB0byBvd25lZCBjb21wb25lbnRzLlxuICpcbiAqIEFsbCBjb21wb25lbnRzIGFyZSBjYXBhYmxlIG9mIC8vYmVpbmcvLyByZWZlcmVuY2VkIGJ5IG93bmVyIGNvbXBvbmVudHMsIGJ1dFxuICogb25seSBSZWFjdE93bmVyIGNvbXBvbmVudHMgYXJlIGNhcGFibGUgb2YgLy9yZWZlcmVuY2luZy8vIG93bmVkIGNvbXBvbmVudHMuXG4gKiBUaGUgbmFtZWQgcmVmZXJlbmNlIGlzIGtub3duIGFzIGEgXCJyZWZcIi5cbiAqXG4gKiBSZWZzIGFyZSBhdmFpbGFibGUgd2hlbiBtb3VudGVkIGFuZCB1cGRhdGVkIGR1cmluZyByZWNvbmNpbGlhdGlvbi5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIChcbiAqICAgICAgICAgPGRpdiBvbkNsaWNrPXt0aGlzLmhhbmRsZUNsaWNrfT5cbiAqICAgICAgICAgICA8Q3VzdG9tQ29tcG9uZW50IHJlZj1cImN1c3RvbVwiIC8+XG4gKiAgICAgICAgIDwvZGl2PlxuICogICAgICAgKTtcbiAqICAgICB9LFxuICogICAgIGhhbmRsZUNsaWNrOiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaGFuZGxlQ2xpY2soKTtcbiAqICAgICB9LFxuICogICAgIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbigpIHtcbiAqICAgICAgIHRoaXMucmVmcy5jdXN0b20uaW5pdGlhbGl6ZSgpO1xuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogUmVmcyBzaG91bGQgcmFyZWx5IGJlIHVzZWQuIFdoZW4gcmVmcyBhcmUgdXNlZCwgdGhleSBzaG91bGQgb25seSBiZSBkb25lIHRvXG4gKiBjb250cm9sIGRhdGEgdGhhdCBpcyBub3QgaGFuZGxlZCBieSBSZWFjdCdzIGRhdGEgZmxvdy5cbiAqXG4gKiBAY2xhc3MgUmVhY3RPd25lclxuICovXG52YXIgUmVhY3RPd25lciA9IHtcblxuICAvKipcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIHZhbGlkIG93bmVyLlxuICAgKiBAZmluYWxcbiAgICovXG4gIGlzVmFsaWRPd25lcjogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiAhIShvYmplY3QgJiYgdHlwZW9mIG9iamVjdC5hdHRhY2hSZWYgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iamVjdC5kZXRhY2hSZWYgPT09ICdmdW5jdGlvbicpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBBZGRzIGEgY29tcG9uZW50IGJ5IHJlZiB0byBhbiBvd25lciBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgYnkgd2hpY2ggdG8gcmVmZXIgdG8gdGhlIGNvbXBvbmVudC5cbiAgICogQHBhcmFtIHtSZWFjdE93bmVyfSBvd25lciBDb21wb25lbnQgb24gd2hpY2ggdG8gcmVjb3JkIHRoZSByZWYuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGFkZENvbXBvbmVudEFzUmVmVG86IGZ1bmN0aW9uIChjb21wb25lbnQsIHJlZiwgb3duZXIpIHtcbiAgICAhUmVhY3RPd25lci5pc1ZhbGlkT3duZXIob3duZXIpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2FkZENvbXBvbmVudEFzUmVmVG8oLi4uKTogT25seSBhIFJlYWN0T3duZXIgY2FuIGhhdmUgcmVmcy4gWW91IG1pZ2h0ICcgKyAnYmUgYWRkaW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIG93bmVyLmF0dGFjaFJlZihyZWYsIGNvbXBvbmVudCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjb21wb25lbnQgYnkgcmVmIGZyb20gYW4gb3duZXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnQgQ29tcG9uZW50IHRvIGRlcmVmZXJlbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcmVmIE5hbWUgb2YgdGhlIHJlZiB0byByZW1vdmUuXG4gICAqIEBwYXJhbSB7UmVhY3RPd25lcn0gb3duZXIgQ29tcG9uZW50IG9uIHdoaWNoIHRoZSByZWYgaXMgcmVjb3JkZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlbW92ZUNvbXBvbmVudEFzUmVmRnJvbTogZnVuY3Rpb24gKGNvbXBvbmVudCwgcmVmLCBvd25lcikge1xuICAgICFSZWFjdE93bmVyLmlzVmFsaWRPd25lcihvd25lcikgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVtb3ZlQ29tcG9uZW50QXNSZWZGcm9tKC4uLik6IE9ubHkgYSBSZWFjdE93bmVyIGNhbiBoYXZlIHJlZnMuIFlvdSBtaWdodCAnICsgJ2JlIHJlbW92aW5nIGEgcmVmIHRvIGEgY29tcG9uZW50IHRoYXQgd2FzIG5vdCBjcmVhdGVkIGluc2lkZSBhIGNvbXBvbmVudFxcJ3MgJyArICdgcmVuZGVyYCBtZXRob2QsIG9yIHlvdSBoYXZlIG11bHRpcGxlIGNvcGllcyBvZiBSZWFjdCBsb2FkZWQgJyArICcoZGV0YWlsczogaHR0cHM6Ly9mYi5tZS9yZWFjdC1yZWZzLW11c3QtaGF2ZS1vd25lcikuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIC8vIENoZWNrIHRoYXQgYGNvbXBvbmVudGAgaXMgc3RpbGwgdGhlIGN1cnJlbnQgcmVmIGJlY2F1c2Ugd2UgZG8gbm90IHdhbnQgdG9cbiAgICAvLyBkZXRhY2ggdGhlIHJlZiBpZiBhbm90aGVyIGNvbXBvbmVudCBzdG9sZSBpdC5cbiAgICBpZiAob3duZXIuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzW3JlZl0gPT09IGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKSB7XG4gICAgICBvd25lci5kZXRhY2hSZWYocmVmKTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE93bmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0T3duZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0VXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VNYXAgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VNYXAnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKSB7XG4gIFJlYWN0VXBkYXRlcy5lbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xufVxuXG5mdW5jdGlvbiBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsIGNhbGxlck5hbWUpIHtcbiAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gIGlmICghaW50ZXJuYWxJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBPbmx5IHdhcm4gd2hlbiB3ZSBoYXZlIGEgY2FsbGVyTmFtZS4gT3RoZXJ3aXNlIHdlIHNob3VsZCBiZSBzaWxlbnQuXG4gICAgICAvLyBXZSdyZSBwcm9iYWJseSBjYWxsaW5nIGZyb20gZW5xdWV1ZUNhbGxiYWNrLiBXZSBkb24ndCB3YW50IHRvIHdhcm5cbiAgICAgIC8vIHRoZXJlIGJlY2F1c2Ugd2UgYWxyZWFkeSB3YXJuZWQgZm9yIHRoZSBjb3JyZXNwb25kaW5nIGxpZmVjeWNsZSBtZXRob2QuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghY2FsbGVyTmFtZSwgJyVzKC4uLik6IENhbiBvbmx5IHVwZGF0ZSBhIG1vdW50ZWQgb3IgbW91bnRpbmcgY29tcG9uZW50LiAnICsgJ1RoaXMgdXN1YWxseSBtZWFucyB5b3UgY2FsbGVkICVzKCkgb24gYW4gdW5tb3VudGVkIGNvbXBvbmVudC4gJyArICdUaGlzIGlzIGEgbm8tb3AuIFBsZWFzZSBjaGVjayB0aGUgY29kZSBmb3IgdGhlICVzIGNvbXBvbmVudC4nLCBjYWxsZXJOYW1lLCBjYWxsZXJOYW1lLCBwdWJsaWNJbnN0YW5jZS5jb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID09IG51bGwsICclcyguLi4pOiBDYW5ub3QgdXBkYXRlIGR1cmluZyBhbiBleGlzdGluZyBzdGF0ZSB0cmFuc2l0aW9uICcgKyAnKHN1Y2ggYXMgd2l0aGluIGByZW5kZXJgKS4gUmVuZGVyIG1ldGhvZHMgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiAnICsgJ29mIHByb3BzIGFuZCBzdGF0ZS4nLCBjYWxsZXJOYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiBpbnRlcm5hbEluc3RhbmNlO1xufVxuXG4vKipcbiAqIFJlYWN0VXBkYXRlUXVldWUgYWxsb3dzIGZvciBzdGF0ZSB1cGRhdGVzIHRvIGJlIHNjaGVkdWxlZCBpbnRvIGEgbGF0ZXJcbiAqIHJlY29uY2lsaWF0aW9uIHN0ZXAuXG4gKi9cbnZhciBSZWFjdFVwZGF0ZVF1ZXVlID0ge1xuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHdlIHdhbnQgdG8gdGVzdC5cbiAgICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBtb3VudGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqIEBwcm90ZWN0ZWRcbiAgICogQGZpbmFsXG4gICAqL1xuICBpc01vdW50ZWQ6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgb3duZXIgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50O1xuICAgICAgaWYgKG93bmVyICE9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBpc01vdW50ZWQgaW5zaWRlIGl0cyByZW5kZXIoKSBmdW5jdGlvbi4gJyArICdyZW5kZXIoKSBzaG91bGQgYmUgYSBwdXJlIGZ1bmN0aW9uIG9mIHByb3BzIGFuZCBzdGF0ZS4gSXQgc2hvdWxkICcgKyAnbmV2ZXIgYWNjZXNzIHNvbWV0aGluZyB0aGF0IHJlcXVpcmVzIHN0YWxlIGRhdGEgZnJvbSB0aGUgcHJldmlvdXMgJyArICdyZW5kZXIsIHN1Y2ggYXMgcmVmcy4gTW92ZSB0aGlzIGxvZ2ljIHRvIGNvbXBvbmVudERpZE1vdW50IGFuZCAnICsgJ2NvbXBvbmVudERpZFVwZGF0ZSBpbnN0ZWFkLicsIG93bmVyLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgb3duZXIuX3dhcm5lZEFib3V0UmVmc0luUmVuZGVyID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBSZWFjdEluc3RhbmNlTWFwLmdldChwdWJsaWNJbnN0YW5jZSk7XG4gICAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIC8vIER1cmluZyBjb21wb25lbnRXaWxsTW91bnQgYW5kIHJlbmRlciB0aGlzIHdpbGwgc3RpbGwgYmUgbnVsbCBidXQgYWZ0ZXJcbiAgICAgIC8vIHRoYXQgd2lsbCBhbHdheXMgcmVuZGVyIHRvIHNvbWV0aGluZy4gQXQgbGVhc3QgZm9yIG5vdy4gU28gd2UgY2FuIHVzZVxuICAgICAgLy8gdGhpcyBoYWNrLlxuICAgICAgcmV0dXJuICEhaW50ZXJuYWxJbnN0YW5jZS5fcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge1xuICAgICEodHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdlbnF1ZXVlQ2FsbGJhY2soLi4uKTogWW91IGNhbGxlZCBgc2V0UHJvcHNgLCBgcmVwbGFjZVByb3BzYCwgJyArICdgc2V0U3RhdGVgLCBgcmVwbGFjZVN0YXRlYCwgb3IgYGZvcmNlVXBkYXRlYCB3aXRoIGEgY2FsbGJhY2sgdGhhdCAnICsgJ2lzblxcJ3QgY2FsbGFibGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlKTtcblxuICAgIC8vIFByZXZpb3VzbHkgd2Ugd291bGQgdGhyb3cgYW4gZXJyb3IgaWYgd2UgZGlkbid0IGhhdmUgYW4gaW50ZXJuYWxcbiAgICAvLyBpbnN0YW5jZS4gU2luY2Ugd2Ugd2FudCB0byBtYWtlIGl0IGEgbm8tb3AgaW5zdGVhZCwgd2UgbWlycm9yIHRoZSBzYW1lXG4gICAgLy8gYmVoYXZpb3Igd2UgaGF2ZSBpbiBvdGhlciBlbnF1ZXVlKiBtZXRob2RzLlxuICAgIC8vIFdlIGFsc28gbmVlZCB0byBpZ25vcmUgY2FsbGJhY2tzIGluIGNvbXBvbmVudFdpbGxNb3VudC4gU2VlXG4gICAgLy8gZW5xdWV1ZVVwZGF0ZXMuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIC8vIFRPRE86IFRoZSBjYWxsYmFjayBoZXJlIGlzIGlnbm9yZWQgd2hlbiBzZXRTdGF0ZSBpcyBjYWxsZWQgZnJvbVxuICAgIC8vIGNvbXBvbmVudFdpbGxNb3VudC4gRWl0aGVyIGZpeCBpdCBvciBkaXNhbGxvdyBkb2luZyBzbyBjb21wbGV0ZWx5IGluXG4gICAgLy8gZmF2b3Igb2YgZ2V0SW5pdGlhbFN0YXRlLiBBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gZGlzYWxsb3dcbiAgICAvLyBjb21wb25lbnRXaWxsTW91bnQgZHVyaW5nIHNlcnZlci1zaWRlIHJlbmRlcmluZy5cbiAgICBlbnF1ZXVlVXBkYXRlKGludGVybmFsSW5zdGFuY2UpO1xuICB9LFxuXG4gIGVucXVldWVDYWxsYmFja0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgY2FsbGJhY2spIHtcbiAgICAhKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZW5xdWV1ZUNhbGxiYWNrKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCwgYHJlcGxhY2VQcm9wc2AsICcgKyAnYHNldFN0YXRlYCwgYHJlcGxhY2VTdGF0ZWAsIG9yIGBmb3JjZVVwZGF0ZWAgd2l0aCBhIGNhbGxiYWNrIHRoYXQgJyArICdpc25cXCd0IGNhbGxhYmxlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICBpZiAoaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcykge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0NhbGxiYWNrcyA9IFtjYWxsYmFja107XG4gICAgfVxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB2YXIgaW50ZXJuYWxJbnN0YW5jZSA9IGdldEludGVybmFsSW5zdGFuY2VSZWFkeUZvclVwZGF0ZShwdWJsaWNJbnN0YW5jZSwgJ2ZvcmNlVXBkYXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSB0cnVlO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZShpbnRlcm5hbEluc3RhbmNlKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVN0YXRlJyk7XG5cbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IFtjb21wbGV0ZVN0YXRlXTtcbiAgICBpbnRlcm5hbEluc3RhbmNlLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gdHJ1ZTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHN0YXRlLiBUaGlzIG9ubHkgZXhpc3RzIGJlY2F1c2UgX3BlbmRpbmdTdGF0ZSBpc1xuICAgKiBpbnRlcm5hbC4gVGhpcyBwcm92aWRlcyBhIG1lcmdpbmcgc3RyYXRlZ3kgdGhhdCBpcyBub3QgYXZhaWxhYmxlIHRvIGRlZXBcbiAgICogcHJvcGVydGllcyB3aGljaCBpcyBjb25mdXNpbmcuIFRPRE86IEV4cG9zZSBwZW5kaW5nU3RhdGUgb3IgZG9uJ3QgdXNlIGl0XG4gICAqIGR1cmluZyB0aGUgbWVyZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFN0YXRlIE5leHQgcGFydGlhbCBzdGF0ZSB0byBiZSBtZXJnZWQgd2l0aCBzdGF0ZS5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0U3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFN0YXRlKSB7XG4gICAgdmFyIGludGVybmFsSW5zdGFuY2UgPSBnZXRJbnRlcm5hbEluc3RhbmNlUmVhZHlGb3JVcGRhdGUocHVibGljSW5zdGFuY2UsICdzZXRTdGF0ZScpO1xuXG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHF1ZXVlID0gaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ1N0YXRlUXVldWUgfHwgKGludGVybmFsSW5zdGFuY2UuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gW10pO1xuICAgIHF1ZXVlLnB1c2gocGFydGlhbFN0YXRlKTtcblxuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB0aGF0IHNob3VsZCByZXJlbmRlci5cbiAgICogQHBhcmFtIHtvYmplY3R9IHBhcnRpYWxQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVNldFByb3BzOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UsIHBhcnRpYWxQcm9wcykge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAnc2V0UHJvcHMnKTtcbiAgICBpZiAoIWludGVybmFsSW5zdGFuY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgUmVhY3RVcGRhdGVRdWV1ZS5lbnF1ZXVlU2V0UHJvcHNJbnRlcm5hbChpbnRlcm5hbEluc3RhbmNlLCBwYXJ0aWFsUHJvcHMpO1xuICB9LFxuXG4gIGVucXVldWVTZXRQcm9wc0ludGVybmFsOiBmdW5jdGlvbiAoaW50ZXJuYWxJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgdmFyIHRvcExldmVsV3JhcHBlciA9IGludGVybmFsSW5zdGFuY2UuX3RvcExldmVsV3JhcHBlcjtcbiAgICAhdG9wTGV2ZWxXcmFwcGVyID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFByb3BzKC4uLik6IFlvdSBjYWxsZWQgYHNldFByb3BzYCBvbiBhICcgKyAnY29tcG9uZW50IHdpdGggYSBwYXJlbnQuIFRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuIHNpbmNlIHByb3BzIHdpbGwgJyArICdnZXQgcmVhY3RpdmVseSB1cGRhdGVkIHdoZW4gcmVuZGVyZWQuIEluc3RlYWQsIGNoYW5nZSB0aGUgb3duZXJcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kIHRvIHBhc3MgdGhlIGNvcnJlY3QgdmFsdWUgYXMgcHJvcHMgdG8gdGhlIGNvbXBvbmVudCAnICsgJ3doZXJlIGl0IGlzIGNyZWF0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gTWVyZ2Ugd2l0aCB0aGUgcGVuZGluZyBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdpdGggZXhpc3RpbmdcbiAgICAvLyBlbGVtZW50IHByb3BzLlxuICAgIHZhciB3cmFwRWxlbWVudCA9IHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgfHwgdG9wTGV2ZWxXcmFwcGVyLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgZWxlbWVudCA9IHdyYXBFbGVtZW50LnByb3BzO1xuICAgIHZhciBwcm9wcyA9IGFzc2lnbih7fSwgZWxlbWVudC5wcm9wcywgcGFydGlhbFByb3BzKTtcbiAgICB0b3BMZXZlbFdyYXBwZXIuX3BlbmRpbmdFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lQW5kUmVwbGFjZVByb3BzKHdyYXBFbGVtZW50LCBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMoZWxlbWVudCwgcHJvcHMpKTtcblxuICAgIGVucXVldWVVcGRhdGUodG9wTGV2ZWxXcmFwcGVyKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBwcm9wcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wcyBOZXcgcHJvcHMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZVJlcGxhY2VQcm9wczogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwcm9wcykge1xuICAgIHZhciBpbnRlcm5hbEluc3RhbmNlID0gZ2V0SW50ZXJuYWxJbnN0YW5jZVJlYWR5Rm9yVXBkYXRlKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVByb3BzJyk7XG4gICAgaWYgKCFpbnRlcm5hbEluc3RhbmNlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVJlcGxhY2VQcm9wc0ludGVybmFsKGludGVybmFsSW5zdGFuY2UsIHByb3BzKTtcbiAgfSxcblxuICBlbnF1ZXVlUmVwbGFjZVByb3BzSW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBwcm9wcykge1xuICAgIHZhciB0b3BMZXZlbFdyYXBwZXIgPSBpbnRlcm5hbEluc3RhbmNlLl90b3BMZXZlbFdyYXBwZXI7XG4gICAgIXRvcExldmVsV3JhcHBlciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdyZXBsYWNlUHJvcHMoLi4uKTogWW91IGNhbGxlZCBgcmVwbGFjZVByb3BzYCBvbiBhICcgKyAnY29tcG9uZW50IHdpdGggYSBwYXJlbnQuIFRoaXMgaXMgYW4gYW50aS1wYXR0ZXJuIHNpbmNlIHByb3BzIHdpbGwgJyArICdnZXQgcmVhY3RpdmVseSB1cGRhdGVkIHdoZW4gcmVuZGVyZWQuIEluc3RlYWQsIGNoYW5nZSB0aGUgb3duZXJcXCdzICcgKyAnYHJlbmRlcmAgbWV0aG9kIHRvIHBhc3MgdGhlIGNvcnJlY3QgdmFsdWUgYXMgcHJvcHMgdG8gdGhlIGNvbXBvbmVudCAnICsgJ3doZXJlIGl0IGlzIGNyZWF0ZWQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gTWVyZ2Ugd2l0aCB0aGUgcGVuZGluZyBlbGVtZW50IGlmIGl0IGV4aXN0cywgb3RoZXJ3aXNlIHdpdGggZXhpc3RpbmdcbiAgICAvLyBlbGVtZW50IHByb3BzLlxuICAgIHZhciB3cmFwRWxlbWVudCA9IHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgfHwgdG9wTGV2ZWxXcmFwcGVyLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgZWxlbWVudCA9IHdyYXBFbGVtZW50LnByb3BzO1xuICAgIHRvcExldmVsV3JhcHBlci5fcGVuZGluZ0VsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY2xvbmVBbmRSZXBsYWNlUHJvcHMod3JhcEVsZW1lbnQsIFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VQcm9wcyhlbGVtZW50LCBwcm9wcykpO1xuXG4gICAgZW5xdWV1ZVVwZGF0ZSh0b3BMZXZlbFdyYXBwZXIpO1xuICB9LFxuXG4gIGVucXVldWVFbGVtZW50SW50ZXJuYWw6IGZ1bmN0aW9uIChpbnRlcm5hbEluc3RhbmNlLCBuZXdFbGVtZW50KSB7XG4gICAgaW50ZXJuYWxJbnN0YW5jZS5fcGVuZGluZ0VsZW1lbnQgPSBuZXdFbGVtZW50O1xuICAgIGVucXVldWVVcGRhdGUoaW50ZXJuYWxJbnN0YW5jZSk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFVwZGF0ZVF1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0VXBkYXRlUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RVcGRhdGVzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ2FsbGJhY2tRdWV1ZSA9IHJlcXVpcmUoJy4vQ2FsbGJhY2tRdWV1ZScpO1xudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgZGlydHlDb21wb25lbnRzID0gW107XG52YXIgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xudmFyIGFzYXBFbnF1ZXVlZCA9IGZhbHNlO1xuXG52YXIgYmF0Y2hpbmdTdHJhdGVneSA9IG51bGw7XG5cbmZ1bmN0aW9uIGVuc3VyZUluamVjdGVkKCkge1xuICAhKFJlYWN0VXBkYXRlcy5SZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uICYmIGJhdGNoaW5nU3RyYXRlZ3kpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBpbmplY3QgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MgYW5kIGJhdGNoaW5nICcgKyAnc3RyYXRlZ3knKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbnZhciBORVNURURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGlydHlDb21wb25lbnRzTGVuZ3RoID0gZGlydHlDb21wb25lbnRzLmxlbmd0aDtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGggIT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgIC8vIEFkZGl0aW9uYWwgdXBkYXRlcyB3ZXJlIGVucXVldWVkIGJ5IGNvbXBvbmVudERpZFVwZGF0ZSBoYW5kbGVycyBvclxuICAgICAgLy8gc2ltaWxhcjsgYmVmb3JlIG91ciBvd24gVVBEQVRFX1FVRVVFSU5HIHdyYXBwZXIgY2xvc2VzLCB3ZSB3YW50IHRvIHJ1blxuICAgICAgLy8gdGhlc2UgbmV3IHVwZGF0ZXMgc28gdGhhdCBpZiBBJ3MgY29tcG9uZW50RGlkVXBkYXRlIGNhbGxzIHNldFN0YXRlIG9uXG4gICAgICAvLyBCLCBCIHdpbGwgdXBkYXRlIGJlZm9yZSB0aGUgY2FsbGJhY2sgQSdzIHVwZGF0ZXIgcHJvdmlkZWQgd2hlbiBjYWxsaW5nXG4gICAgICAvLyBzZXRTdGF0ZS5cbiAgICAgIGRpcnR5Q29tcG9uZW50cy5zcGxpY2UoMCwgdGhpcy5kaXJ0eUNvbXBvbmVudHNMZW5ndGgpO1xuICAgICAgZmx1c2hCYXRjaGVkVXBkYXRlcygpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBVUERBVEVfUVVFVUVJTkcgPSB7XG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUucmVzZXQoKTtcbiAgfSxcbiAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbGxiYWNrUXVldWUubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtORVNURURfVVBEQVRFUywgVVBEQVRFX1FVRVVFSU5HXTtcblxuZnVuY3Rpb24gUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbigpIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gIHRoaXMuY2FsbGJhY2tRdWV1ZSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKCk7XG4gIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5nZXRQb29sZWQoIC8qIGZvcmNlSFRNTCAqL2ZhbHNlKTtcbn1cblxuYXNzaWduKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRpcnR5Q29tcG9uZW50c0xlbmd0aCA9IG51bGw7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMuY2FsbGJhY2tRdWV1ZSk7XG4gICAgdGhpcy5jYWxsYmFja1F1ZXVlID0gbnVsbDtcbiAgICBSZWFjdFVwZGF0ZXMuUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5yZWxlYXNlKHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24pO1xuICAgIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24gPSBudWxsO1xuICB9LFxuXG4gIHBlcmZvcm06IGZ1bmN0aW9uIChtZXRob2QsIHNjb3BlLCBhKSB7XG4gICAgLy8gRXNzZW50aWFsbHkgY2FsbHMgYHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24ucGVyZm9ybShtZXRob2QsIHNjb3BlLCBhKWBcbiAgICAvLyB3aXRoIHRoaXMgdHJhbnNhY3Rpb24ncyB3cmFwcGVycyBhcm91bmQgaXQuXG4gICAgcmV0dXJuIFRyYW5zYWN0aW9uLk1peGluLnBlcmZvcm0uY2FsbCh0aGlzLCB0aGlzLnJlY29uY2lsZVRyYW5zYWN0aW9uLnBlcmZvcm0sIHRoaXMucmVjb25jaWxlVHJhbnNhY3Rpb24sIG1ldGhvZCwgc2NvcGUsIGEpO1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24pO1xuXG5mdW5jdGlvbiBiYXRjaGVkVXBkYXRlcyhjYWxsYmFjaywgYSwgYiwgYywgZCwgZSkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuICBiYXRjaGluZ1N0cmF0ZWd5LmJhdGNoZWRVcGRhdGVzKGNhbGxiYWNrLCBhLCBiLCBjLCBkLCBlKTtcbn1cblxuLyoqXG4gKiBBcnJheSBjb21wYXJhdG9yIGZvciBSZWFjdENvbXBvbmVudHMgYnkgbW91bnQgb3JkZXJpbmcuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudH0gYzEgZmlyc3QgY29tcG9uZW50IHlvdSdyZSBjb21wYXJpbmdcbiAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGMyIHNlY29uZCBjb21wb25lbnQgeW91J3JlIGNvbXBhcmluZ1xuICogQHJldHVybiB7bnVtYmVyfSBSZXR1cm4gdmFsdWUgdXNhYmxlIGJ5IEFycmF5LnByb3RvdHlwZS5zb3J0KCkuXG4gKi9cbmZ1bmN0aW9uIG1vdW50T3JkZXJDb21wYXJhdG9yKGMxLCBjMikge1xuICByZXR1cm4gYzEuX21vdW50T3JkZXIgLSBjMi5fbW91bnRPcmRlcjtcbn1cblxuZnVuY3Rpb24gcnVuQmF0Y2hlZFVwZGF0ZXModHJhbnNhY3Rpb24pIHtcbiAgdmFyIGxlbiA9IHRyYW5zYWN0aW9uLmRpcnR5Q29tcG9uZW50c0xlbmd0aDtcbiAgIShsZW4gPT09IGRpcnR5Q29tcG9uZW50cy5sZW5ndGgpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0V4cGVjdGVkIGZsdXNoIHRyYW5zYWN0aW9uXFwncyBzdG9yZWQgZGlydHktY29tcG9uZW50cyBsZW5ndGggKCVzKSB0byAnICsgJ21hdGNoIGRpcnR5LWNvbXBvbmVudHMgYXJyYXkgbGVuZ3RoICglcykuJywgbGVuLCBkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgLy8gU2luY2UgcmVjb25jaWxpbmcgYSBjb21wb25lbnQgaGlnaGVyIGluIHRoZSBvd25lciBoaWVyYXJjaHkgdXN1YWxseSAobm90XG4gIC8vIGFsd2F5cyAtLSBzZWUgc2hvdWxkQ29tcG9uZW50VXBkYXRlKCkpIHdpbGwgcmVjb25jaWxlIGNoaWxkcmVuLCByZWNvbmNpbGVcbiAgLy8gdGhlbSBiZWZvcmUgdGhlaXIgY2hpbGRyZW4gYnkgc29ydGluZyB0aGUgYXJyYXkuXG4gIGRpcnR5Q29tcG9uZW50cy5zb3J0KG1vdW50T3JkZXJDb21wYXJhdG9yKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgLy8gSWYgYSBjb21wb25lbnQgaXMgdW5tb3VudGVkIGJlZm9yZSBwZW5kaW5nIGNoYW5nZXMgYXBwbHksIGl0IHdpbGwgc3RpbGxcbiAgICAvLyBiZSBoZXJlLCBidXQgd2UgYXNzdW1lIHRoYXQgaXQgaGFzIGNsZWFyZWQgaXRzIF9wZW5kaW5nQ2FsbGJhY2tzIGFuZFxuICAgIC8vIHRoYXQgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGlzIGEgbm9vcC5cbiAgICB2YXIgY29tcG9uZW50ID0gZGlydHlDb21wb25lbnRzW2ldO1xuXG4gICAgLy8gSWYgcGVyZm9ybVVwZGF0ZUlmTmVjZXNzYXJ5IGhhcHBlbnMgdG8gZW5xdWV1ZSBhbnkgbmV3IHVwZGF0ZXMsIHdlXG4gICAgLy8gc2hvdWxkbid0IGV4ZWN1dGUgdGhlIGNhbGxiYWNrcyB1bnRpbCB0aGUgbmV4dCByZW5kZXIgaGFwcGVucywgc29cbiAgICAvLyBzdGFzaCB0aGUgY2FsbGJhY2tzIGZpcnN0XG4gICAgdmFyIGNhbGxiYWNrcyA9IGNvbXBvbmVudC5fcGVuZGluZ0NhbGxiYWNrcztcbiAgICBjb21wb25lbnQuX3BlbmRpbmdDYWxsYmFja3MgPSBudWxsO1xuXG4gICAgUmVhY3RSZWNvbmNpbGVyLnBlcmZvcm1VcGRhdGVJZk5lY2Vzc2FyeShjb21wb25lbnQsIHRyYW5zYWN0aW9uLnJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxuICAgIGlmIChjYWxsYmFja3MpIHtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgY2FsbGJhY2tzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHRyYW5zYWN0aW9uLmNhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFja3Nbal0sIGNvbXBvbmVudC5nZXRQdWJsaWNJbnN0YW5jZSgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxudmFyIGZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIFJlYWN0VXBkYXRlc0ZsdXNoVHJhbnNhY3Rpb24ncyB3cmFwcGVycyB3aWxsIGNsZWFyIHRoZSBkaXJ0eUNvbXBvbmVudHNcbiAgLy8gYXJyYXkgYW5kIHBlcmZvcm0gYW55IHVwZGF0ZXMgZW5xdWV1ZWQgYnkgbW91bnQtcmVhZHkgaGFuZGxlcnMgKGkuZS4sXG4gIC8vIGNvbXBvbmVudERpZFVwZGF0ZSkgYnV0IHdlIG5lZWQgdG8gY2hlY2sgaGVyZSB0b28gaW4gb3JkZXIgdG8gY2F0Y2hcbiAgLy8gdXBkYXRlcyBlbnF1ZXVlZCBieSBzZXRTdGF0ZSBjYWxsYmFja3MgYW5kIGFzYXAgY2FsbHMuXG4gIHdoaWxlIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoIHx8IGFzYXBFbnF1ZXVlZCkge1xuICAgIGlmIChkaXJ0eUNvbXBvbmVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgdHJhbnNhY3Rpb24gPSBSZWFjdFVwZGF0ZXNGbHVzaFRyYW5zYWN0aW9uLmdldFBvb2xlZCgpO1xuICAgICAgdHJhbnNhY3Rpb24ucGVyZm9ybShydW5CYXRjaGVkVXBkYXRlcywgbnVsbCwgdHJhbnNhY3Rpb24pO1xuICAgICAgUmVhY3RVcGRhdGVzRmx1c2hUcmFuc2FjdGlvbi5yZWxlYXNlKHRyYW5zYWN0aW9uKTtcbiAgICB9XG5cbiAgICBpZiAoYXNhcEVucXVldWVkKSB7XG4gICAgICBhc2FwRW5xdWV1ZWQgPSBmYWxzZTtcbiAgICAgIHZhciBxdWV1ZSA9IGFzYXBDYWxsYmFja1F1ZXVlO1xuICAgICAgYXNhcENhbGxiYWNrUXVldWUgPSBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpO1xuICAgICAgcXVldWUubm90aWZ5QWxsKCk7XG4gICAgICBDYWxsYmFja1F1ZXVlLnJlbGVhc2UocXVldWUpO1xuICAgIH1cbiAgfVxufTtcbmZsdXNoQmF0Y2hlZFVwZGF0ZXMgPSBSZWFjdFBlcmYubWVhc3VyZSgnUmVhY3RVcGRhdGVzJywgJ2ZsdXNoQmF0Y2hlZFVwZGF0ZXMnLCBmbHVzaEJhdGNoZWRVcGRhdGVzKTtcblxuLyoqXG4gKiBNYXJrIGEgY29tcG9uZW50IGFzIG5lZWRpbmcgYSByZXJlbmRlciwgYWRkaW5nIGFuIG9wdGlvbmFsIGNhbGxiYWNrIHRvIGFcbiAqIGxpc3Qgb2YgZnVuY3Rpb25zIHdoaWNoIHdpbGwgYmUgZXhlY3V0ZWQgb25jZSB0aGUgcmVyZW5kZXIgb2NjdXJzLlxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVXBkYXRlKGNvbXBvbmVudCkge1xuICBlbnN1cmVJbmplY3RlZCgpO1xuXG4gIC8vIFZhcmlvdXMgcGFydHMgb2Ygb3VyIGNvZGUgKHN1Y2ggYXMgUmVhY3RDb21wb3NpdGVDb21wb25lbnQnc1xuICAvLyBfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50KSBhc3N1bWUgdGhhdCBjYWxscyB0byByZW5kZXIgYXJlbid0IG5lc3RlZDtcbiAgLy8gdmVyaWZ5IHRoYXQgdGhhdCdzIHRoZSBjYXNlLiAoVGhpcyBpcyBjYWxsZWQgYnkgZWFjaCB0b3AtbGV2ZWwgdXBkYXRlXG4gIC8vIGZ1bmN0aW9uLCBsaWtlIHNldFByb3BzLCBzZXRTdGF0ZSwgZm9yY2VVcGRhdGUsIGV0Yy47IGNyZWF0aW9uIGFuZFxuICAvLyBkZXN0cnVjdGlvbiBvZiB0b3AtbGV2ZWwgY29tcG9uZW50cyBpcyBndWFyZGVkIGluIFJlYWN0TW91bnQuKVxuXG4gIGlmICghYmF0Y2hpbmdTdHJhdGVneS5pc0JhdGNoaW5nVXBkYXRlcykge1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kuYmF0Y2hlZFVwZGF0ZXMoZW5xdWV1ZVVwZGF0ZSwgY29tcG9uZW50KTtcbiAgICByZXR1cm47XG4gIH1cblxuICBkaXJ0eUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xufVxuXG4vKipcbiAqIEVucXVldWUgYSBjYWxsYmFjayB0byBiZSBydW4gYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBiYXRjaGluZyBjeWNsZS4gVGhyb3dzXG4gKiBpZiBubyB1cGRhdGVzIGFyZSBjdXJyZW50bHkgYmVpbmcgcGVyZm9ybWVkLlxuICovXG5mdW5jdGlvbiBhc2FwKGNhbGxiYWNrLCBjb250ZXh0KSB7XG4gICFiYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlcy5hc2FwOiBDYW5cXCd0IGVucXVldWUgYW4gYXNhcCBjYWxsYmFjayBpbiBhIGNvbnRleHQgd2hlcmUnICsgJ3VwZGF0ZXMgYXJlIG5vdCBiZWluZyBiYXRjaGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgYXNhcENhbGxiYWNrUXVldWUuZW5xdWV1ZShjYWxsYmFjaywgY29udGV4dCk7XG4gIGFzYXBFbnF1ZXVlZCA9IHRydWU7XG59XG5cbnZhciBSZWFjdFVwZGF0ZXNJbmplY3Rpb24gPSB7XG4gIGluamVjdFJlY29uY2lsZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoUmVjb25jaWxlVHJhbnNhY3Rpb24pIHtcbiAgICAhUmVjb25jaWxlVHJhbnNhY3Rpb24gPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSByZWNvbmNpbGUgdHJhbnNhY3Rpb24gY2xhc3MnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgUmVhY3RVcGRhdGVzLlJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSBSZWNvbmNpbGVUcmFuc2FjdGlvbjtcbiAgfSxcblxuICBpbmplY3RCYXRjaGluZ1N0cmF0ZWd5OiBmdW5jdGlvbiAoX2JhdGNoaW5nU3RyYXRlZ3kpIHtcbiAgICAhX2JhdGNoaW5nU3RyYXRlZ3kgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGluZyBzdHJhdGVneScpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBfYmF0Y2hpbmdTdHJhdGVneS5iYXRjaGVkVXBkYXRlcyA9PT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RVcGRhdGVzOiBtdXN0IHByb3ZpZGUgYSBiYXRjaGVkVXBkYXRlcygpIGZ1bmN0aW9uJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICEodHlwZW9mIF9iYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID09PSAnYm9vbGVhbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0VXBkYXRlczogbXVzdCBwcm92aWRlIGFuIGlzQmF0Y2hpbmdVcGRhdGVzIGJvb2xlYW4gYXR0cmlidXRlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIGJhdGNoaW5nU3RyYXRlZ3kgPSBfYmF0Y2hpbmdTdHJhdGVneTtcbiAgfVxufTtcblxudmFyIFJlYWN0VXBkYXRlcyA9IHtcbiAgLyoqXG4gICAqIFJlYWN0IHJlZmVyZW5jZXMgYFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb25gIHVzaW5nIHRoaXMgcHJvcGVydHkgaW4gb3JkZXJcbiAgICogdG8gYWxsb3cgZGVwZW5kZW5jeSBpbmplY3Rpb24uXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbjogbnVsbCxcblxuICBiYXRjaGVkVXBkYXRlczogYmF0Y2hlZFVwZGF0ZXMsXG4gIGVucXVldWVVcGRhdGU6IGVucXVldWVVcGRhdGUsXG4gIGZsdXNoQmF0Y2hlZFVwZGF0ZXM6IGZsdXNoQmF0Y2hlZFVwZGF0ZXMsXG4gIGluamVjdGlvbjogUmVhY3RVcGRhdGVzSW5qZWN0aW9uLFxuICBhc2FwOiBhc2FwXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0VXBkYXRlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFVwZGF0ZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2FsbGJhY2tRdWV1ZVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbi8qKlxuICogQSBzcGVjaWFsaXplZCBwc2V1ZG8tZXZlbnQgbW9kdWxlIHRvIGhlbHAga2VlcCB0cmFjayBvZiBjb21wb25lbnRzIHdhaXRpbmcgdG9cbiAqIGJlIG5vdGlmaWVkIHdoZW4gdGhlaXIgRE9NIHJlcHJlc2VudGF0aW9ucyBhcmUgYXZhaWxhYmxlIGZvciB1c2UuXG4gKlxuICogVGhpcyBpbXBsZW1lbnRzIGBQb29sZWRDbGFzc2AsIHNvIHlvdSBzaG91bGQgbmV2ZXIgbmVlZCB0byBpbnN0YW50aWF0ZSB0aGlzLlxuICogSW5zdGVhZCwgdXNlIGBDYWxsYmFja1F1ZXVlLmdldFBvb2xlZCgpYC5cbiAqXG4gKiBAY2xhc3MgUmVhY3RNb3VudFJlYWR5XG4gKiBAaW1wbGVtZW50cyBQb29sZWRDbGFzc1xuICogQGludGVybmFsXG4gKi9cbmZ1bmN0aW9uIENhbGxiYWNrUXVldWUoKSB7XG4gIHRoaXMuX2NhbGxiYWNrcyA9IG51bGw7XG4gIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbn1cblxuYXNzaWduKENhbGxiYWNrUXVldWUucHJvdG90eXBlLCB7XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgY2FsbGJhY2sgdG8gYmUgaW52b2tlZCB3aGVuIGBub3RpZnlBbGxgIGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIEludm9rZWQgd2hlbiBgbm90aWZ5QWxsYCBpcyBpbnZva2VkLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IGNvbnRleHQgQ29udGV4dCB0byBjYWxsIGBjYWxsYmFja2Agd2l0aC5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwgW107XG4gICAgdGhpcy5fY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cyB8fCBbXTtcbiAgICB0aGlzLl9jYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgdGhpcy5fY29udGV4dHMucHVzaChjb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSW52b2tlcyBhbGwgZW5xdWV1ZWQgY2FsbGJhY2tzIGFuZCBjbGVhcnMgdGhlIHF1ZXVlLiBUaGlzIGlzIGludm9rZWQgYWZ0ZXJcbiAgICogdGhlIERPTSByZXByZXNlbnRhdGlvbiBvZiBhIGNvbXBvbmVudCBoYXMgYmVlbiBjcmVhdGVkIG9yIHVwZGF0ZWQuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgbm90aWZ5QWxsOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcztcbiAgICB2YXIgY29udGV4dHMgPSB0aGlzLl9jb250ZXh0cztcbiAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAhKGNhbGxiYWNrcy5sZW5ndGggPT09IGNvbnRleHRzLmxlbmd0aCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTWlzbWF0Y2hlZCBsaXN0IG9mIGNvbnRleHRzIGluIGNhbGxiYWNrIHF1ZXVlJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgdGhpcy5fY2FsbGJhY2tzID0gbnVsbDtcbiAgICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNhbGxiYWNrc1tpXS5jYWxsKGNvbnRleHRzW2ldKTtcbiAgICAgIH1cbiAgICAgIGNhbGxiYWNrcy5sZW5ndGggPSAwO1xuICAgICAgY29udGV4dHMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlc2V0cyB0aGUgaW50ZXJuYWwgcXVldWUuXG4gICAqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jYWxsYmFja3MgPSBudWxsO1xuICAgIHRoaXMuX2NvbnRleHRzID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcy5cbiAgICovXG4gIGRlc3RydWN0b3I6IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2V0KCk7XG4gIH1cblxufSk7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDYWxsYmFja1F1ZXVlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYWxsYmFja1F1ZXVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0NhbGxiYWNrUXVldWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUG9vbGVkQ2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBTdGF0aWMgcG9vbGVycy4gU2V2ZXJhbCBjdXN0b20gdmVyc2lvbnMgZm9yIGVhY2ggcG90ZW50aWFsIG51bWJlciBvZlxuICogYXJndW1lbnRzLiBBIGNvbXBsZXRlbHkgZ2VuZXJpYyBwb29sZXIgaXMgZWFzeSB0byBpbXBsZW1lbnQsIGJ1dCB3b3VsZFxuICogcmVxdWlyZSBhY2Nlc3NpbmcgdGhlIGBhcmd1bWVudHNgIG9iamVjdC4gSW4gZWFjaCBvZiB0aGVzZSwgYHRoaXNgIHJlZmVycyB0b1xuICogdGhlIENsYXNzIGl0c2VsZiwgbm90IGFuIGluc3RhbmNlLiBJZiBhbnkgb3RoZXJzIGFyZSBuZWVkZWQsIHNpbXBseSBhZGQgdGhlbVxuICogaGVyZSwgb3IgaW4gdGhlaXIgb3duIGZpbGVzLlxuICovXG52YXIgb25lQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoY29weUZpZWxkc0Zyb20pIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgY29weUZpZWxkc0Zyb20pO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGNvcHlGaWVsZHNGcm9tKTtcbiAgfVxufTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMikge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICBpZiAoS2xhc3MuaW5zdGFuY2VQb29sLmxlbmd0aCkge1xuICAgIHZhciBpbnN0YW5jZSA9IEtsYXNzLmluc3RhbmNlUG9vbC5wb3AoKTtcbiAgICBLbGFzcy5jYWxsKGluc3RhbmNlLCBhMSwgYTIpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMik7XG4gIH1cbn07XG5cbnZhciB0aHJlZUFyZ3VtZW50UG9vbGVyID0gZnVuY3Rpb24gKGExLCBhMiwgYTMpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgS2xhc3MoYTEsIGEyLCBhMyk7XG4gIH1cbn07XG5cbnZhciBmb3VyQXJndW1lbnRQb29sZXIgPSBmdW5jdGlvbiAoYTEsIGEyLCBhMywgYTQpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEtsYXNzKGExLCBhMiwgYTMsIGE0KTtcbiAgfVxufTtcblxudmFyIGZpdmVBcmd1bWVudFBvb2xlciA9IGZ1bmN0aW9uIChhMSwgYTIsIGEzLCBhNCwgYTUpIHtcbiAgdmFyIEtsYXNzID0gdGhpcztcbiAgaWYgKEtsYXNzLmluc3RhbmNlUG9vbC5sZW5ndGgpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSBLbGFzcy5pbnN0YW5jZVBvb2wucG9wKCk7XG4gICAgS2xhc3MuY2FsbChpbnN0YW5jZSwgYTEsIGEyLCBhMywgYTQsIGE1KTtcbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBLbGFzcyhhMSwgYTIsIGEzLCBhNCwgYTUpO1xuICB9XG59O1xuXG52YXIgc3RhbmRhcmRSZWxlYXNlciA9IGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuICB2YXIgS2xhc3MgPSB0aGlzO1xuICAhKGluc3RhbmNlIGluc3RhbmNlb2YgS2xhc3MpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RyeWluZyB0byByZWxlYXNlIGFuIGluc3RhbmNlIGludG8gYSBwb29sIG9mIGEgZGlmZmVyZW50IHR5cGUuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpbnN0YW5jZS5kZXN0cnVjdG9yKCk7XG4gIGlmIChLbGFzcy5pbnN0YW5jZVBvb2wubGVuZ3RoIDwgS2xhc3MucG9vbFNpemUpIHtcbiAgICBLbGFzcy5pbnN0YW5jZVBvb2wucHVzaChpbnN0YW5jZSk7XG4gIH1cbn07XG5cbnZhciBERUZBVUxUX1BPT0xfU0laRSA9IDEwO1xudmFyIERFRkFVTFRfUE9PTEVSID0gb25lQXJndW1lbnRQb29sZXI7XG5cbi8qKlxuICogQXVnbWVudHMgYENvcHlDb25zdHJ1Y3RvcmAgdG8gYmUgYSBwb29sYWJsZSBjbGFzcywgYXVnbWVudGluZyBvbmx5IHRoZSBjbGFzc1xuICogaXRzZWxmIChzdGF0aWNhbGx5KSBub3QgYWRkaW5nIGFueSBwcm90b3R5cGljYWwgZmllbGRzLiBBbnkgQ29weUNvbnN0cnVjdG9yXG4gKiB5b3UgZ2l2ZSB0aGlzIG1heSBoYXZlIGEgYHBvb2xTaXplYCBwcm9wZXJ0eSwgYW5kIHdpbGwgbG9vayBmb3IgYVxuICogcHJvdG90eXBpY2FsIGBkZXN0cnVjdG9yYCBvbiBpbnN0YW5jZXMgKG9wdGlvbmFsKS5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBDb3B5Q29uc3RydWN0b3IgQ29uc3RydWN0b3IgdGhhdCBjYW4gYmUgdXNlZCB0byByZXNldC5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IHBvb2xlciBDdXN0b21pemFibGUgcG9vbGVyLlxuICovXG52YXIgYWRkUG9vbGluZ1RvID0gZnVuY3Rpb24gKENvcHlDb25zdHJ1Y3RvciwgcG9vbGVyKSB7XG4gIHZhciBOZXdLbGFzcyA9IENvcHlDb25zdHJ1Y3RvcjtcbiAgTmV3S2xhc3MuaW5zdGFuY2VQb29sID0gW107XG4gIE5ld0tsYXNzLmdldFBvb2xlZCA9IHBvb2xlciB8fCBERUZBVUxUX1BPT0xFUjtcbiAgaWYgKCFOZXdLbGFzcy5wb29sU2l6ZSkge1xuICAgIE5ld0tsYXNzLnBvb2xTaXplID0gREVGQVVMVF9QT09MX1NJWkU7XG4gIH1cbiAgTmV3S2xhc3MucmVsZWFzZSA9IHN0YW5kYXJkUmVsZWFzZXI7XG4gIHJldHVybiBOZXdLbGFzcztcbn07XG5cbnZhciBQb29sZWRDbGFzcyA9IHtcbiAgYWRkUG9vbGluZ1RvOiBhZGRQb29saW5nVG8sXG4gIG9uZUFyZ3VtZW50UG9vbGVyOiBvbmVBcmd1bWVudFBvb2xlcixcbiAgdHdvQXJndW1lbnRQb29sZXI6IHR3b0FyZ3VtZW50UG9vbGVyLFxuICB0aHJlZUFyZ3VtZW50UG9vbGVyOiB0aHJlZUFyZ3VtZW50UG9vbGVyLFxuICBmb3VyQXJndW1lbnRQb29sZXI6IGZvdXJBcmd1bWVudFBvb2xlcixcbiAgZml2ZUFyZ3VtZW50UG9vbGVyOiBmaXZlQXJndW1lbnRQb29sZXJcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUG9vbGVkQ2xhc3M7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUG9vbGVkQ2xhc3MuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgVHJhbnNhY3Rpb25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBgVHJhbnNhY3Rpb25gIGNyZWF0ZXMgYSBibGFjayBib3ggdGhhdCBpcyBhYmxlIHRvIHdyYXAgYW55IG1ldGhvZCBzdWNoIHRoYXRcbiAqIGNlcnRhaW4gaW52YXJpYW50cyBhcmUgbWFpbnRhaW5lZCBiZWZvcmUgYW5kIGFmdGVyIHRoZSBtZXRob2QgaXMgaW52b2tlZFxuICogKEV2ZW4gaWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biB3aGlsZSBpbnZva2luZyB0aGUgd3JhcHBlZCBtZXRob2QpLiBXaG9ldmVyXG4gKiBpbnN0YW50aWF0ZXMgYSB0cmFuc2FjdGlvbiBjYW4gcHJvdmlkZSBlbmZvcmNlcnMgb2YgdGhlIGludmFyaWFudHMgYXRcbiAqIGNyZWF0aW9uIHRpbWUuIFRoZSBgVHJhbnNhY3Rpb25gIGNsYXNzIGl0c2VsZiB3aWxsIHN1cHBseSBvbmUgYWRkaXRpb25hbFxuICogYXV0b21hdGljIGludmFyaWFudCBmb3IgeW91IC0gdGhlIGludmFyaWFudCB0aGF0IGFueSB0cmFuc2FjdGlvbiBpbnN0YW5jZVxuICogc2hvdWxkIG5vdCBiZSBydW4gd2hpbGUgaXQgaXMgYWxyZWFkeSBiZWluZyBydW4uIFlvdSB3b3VsZCB0eXBpY2FsbHkgY3JlYXRlIGFcbiAqIHNpbmdsZSBpbnN0YW5jZSBvZiBhIGBUcmFuc2FjdGlvbmAgZm9yIHJldXNlIG11bHRpcGxlIHRpbWVzLCB0aGF0IHBvdGVudGlhbGx5XG4gKiBpcyB1c2VkIHRvIHdyYXAgc2V2ZXJhbCBkaWZmZXJlbnQgbWV0aG9kcy4gV3JhcHBlcnMgYXJlIGV4dHJlbWVseSBzaW1wbGUgLVxuICogdGhleSBvbmx5IHJlcXVpcmUgaW1wbGVtZW50aW5nIHR3byBtZXRob2RzLlxuICpcbiAqIDxwcmU+XG4gKiAgICAgICAgICAgICAgICAgICAgICAgd3JhcHBlcnMgKGluamVjdGVkIGF0IGNyZWF0aW9uIHRpbWUpXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyAgICAgICAgK1xuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS18LS0tLS0tLS18LS0tLS0tLS0tLS0tLS0rXG4gKiAgICAgICAgICAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgdiAgICAgICAgfCAgICAgICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICAgICArLS0tLS0tLS0tLS0tLS0tKyAgIHwgICAgICAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgKy0tfCAgICB3cmFwcGVyMSAgIHwtLS18LS0tLSsgICAgICAgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICstLS0tLS0tLS0tLS0tLS0rICAgdiAgICB8ICAgICAgICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICAgICAgICstLS0tLS0tLS0tLS0tKyAgfCAgICAgICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgfCAgICAgKy0tLS18ICAgd3JhcHBlcjIgIHwtLS0tLS0tLSsgICB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCAgIHwgICAgIHwgICAgKy0tLS0tLS0tLS0tLS0rICB8ICAgICB8ICAgfFxuICogICAgICAgICAgICAgICAgICAgIHwgICB8ICAgICB8ICAgICAgICAgICAgICAgICAgICAgfCAgICAgfCAgIHxcbiAqICAgICAgICAgICAgICAgICAgICB8ICAgdiAgICAgdiAgICAgICAgICAgICAgICAgICAgIHYgICAgIHYgICB8IHdyYXBwZXJcbiAqICAgICAgICAgICAgICAgICAgICB8ICstLS0rICstLS0rICAgKy0tLS0tLS0tLSsgICArLS0tKyArLS0tKyB8IGludmFyaWFudHNcbiAqIHBlcmZvcm0oYW55TWV0aG9kKSB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8IG1haW50YWluZWRcbiAqICstLS0tLS0tLS0tLS0tLS0tLT58LXwtLS18LXwtLS18LS0+fGFueU1ldGhvZHwtLS18LS0tfC18LS0tfC18LS0tLS0tLS0+XG4gKiAgICAgICAgICAgICAgICAgICAgfCB8ICAgfCB8ICAgfCAgIHwgICAgICAgICB8ICAgfCAgIHwgfCAgIHwgfFxuICogICAgICAgICAgICAgICAgICAgIHwgfCAgIHwgfCAgIHwgICB8ICAgICAgICAgfCAgIHwgICB8IHwgICB8IHxcbiAqICAgICAgICAgICAgICAgICAgICB8IHwgICB8IHwgICB8ICAgfCAgICAgICAgIHwgICB8ICAgfCB8ICAgfCB8XG4gKiAgICAgICAgICAgICAgICAgICAgfCArLS0tKyArLS0tKyAgICstLS0tLS0tLS0rICAgKy0tLSsgKy0tLSsgfFxuICogICAgICAgICAgICAgICAgICAgIHwgIGluaXRpYWxpemUgICAgICAgICAgICAgICAgICAgIGNsb3NlICAgIHxcbiAqICAgICAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gKiA8L3ByZT5cbiAqXG4gKiBVc2UgY2FzZXM6XG4gKiAtIFByZXNlcnZpbmcgdGhlIGlucHV0IHNlbGVjdGlvbiByYW5nZXMgYmVmb3JlL2FmdGVyIHJlY29uY2lsaWF0aW9uLlxuICogICBSZXN0b3Jpbmcgc2VsZWN0aW9uIGV2ZW4gaW4gdGhlIGV2ZW50IG9mIGFuIHVuZXhwZWN0ZWQgZXJyb3IuXG4gKiAtIERlYWN0aXZhdGluZyBldmVudHMgd2hpbGUgcmVhcnJhbmdpbmcgdGhlIERPTSwgcHJldmVudGluZyBibHVycy9mb2N1c2VzLFxuICogICB3aGlsZSBndWFyYW50ZWVpbmcgdGhhdCBhZnRlcndhcmRzLCB0aGUgZXZlbnQgc3lzdGVtIGlzIHJlYWN0aXZhdGVkLlxuICogLSBGbHVzaGluZyBhIHF1ZXVlIG9mIGNvbGxlY3RlZCBET00gbXV0YXRpb25zIHRvIHRoZSBtYWluIFVJIHRocmVhZCBhZnRlciBhXG4gKiAgIHJlY29uY2lsaWF0aW9uIHRha2VzIHBsYWNlIGluIGEgd29ya2VyIHRocmVhZC5cbiAqIC0gSW52b2tpbmcgYW55IGNvbGxlY3RlZCBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgYWZ0ZXIgcmVuZGVyaW5nIG5ld1xuICogICBjb250ZW50LlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogV3JhcHBpbmcgcGFydGljdWxhciBmbHVzaGVzIG9mIHRoZSBgUmVhY3RXb3JrZXJgIHF1ZXVlXG4gKiAgIHRvIHByZXNlcnZlIHRoZSBgc2Nyb2xsVG9wYCAoYW4gYXV0b21hdGljIHNjcm9sbCBhd2FyZSBET00pLlxuICogLSAoRnV0dXJlIHVzZSBjYXNlKTogTGF5b3V0IGNhbGN1bGF0aW9ucyBiZWZvcmUgYW5kIGFmdGVyIERPTSB1cGRhdGVzLlxuICpcbiAqIFRyYW5zYWN0aW9uYWwgcGx1Z2luIEFQSTpcbiAqIC0gQSBtb2R1bGUgdGhhdCBoYXMgYW4gYGluaXRpYWxpemVgIG1ldGhvZCB0aGF0IHJldHVybnMgYW55IHByZWNvbXB1dGF0aW9uLlxuICogLSBhbmQgYSBgY2xvc2VgIG1ldGhvZCB0aGF0IGFjY2VwdHMgdGhlIHByZWNvbXB1dGF0aW9uLiBgY2xvc2VgIGlzIGludm9rZWRcbiAqICAgd2hlbiB0aGUgd3JhcHBlZCBwcm9jZXNzIGlzIGNvbXBsZXRlZCwgb3IgaGFzIGZhaWxlZC5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PFRyYW5zYWN0aW9uYWxXcmFwcGVyPn0gdHJhbnNhY3Rpb25XcmFwcGVyIFdyYXBwZXIgbW9kdWxlc1xuICogdGhhdCBpbXBsZW1lbnQgYGluaXRpYWxpemVgIGFuZCBgY2xvc2VgLlxuICogQHJldHVybiB7VHJhbnNhY3Rpb259IFNpbmdsZSB0cmFuc2FjdGlvbiBmb3IgcmV1c2UgaW4gdGhyZWFkLlxuICpcbiAqIEBjbGFzcyBUcmFuc2FjdGlvblxuICovXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBTZXRzIHVwIHRoaXMgaW5zdGFuY2Ugc28gdGhhdCBpdCBpcyBwcmVwYXJlZCBmb3IgY29sbGVjdGluZyBtZXRyaWNzLiBEb2VzXG4gICAqIHNvIHN1Y2ggdGhhdCB0aGlzIHNldHVwIG1ldGhvZCBtYXkgYmUgdXNlZCBvbiBhbiBpbnN0YW5jZSB0aGF0IGlzIGFscmVhZHlcbiAgICogaW5pdGlhbGl6ZWQsIGluIGEgd2F5IHRoYXQgZG9lcyBub3QgY29uc3VtZSBhZGRpdGlvbmFsIG1lbW9yeSB1cG9uIHJldXNlLlxuICAgKiBUaGF0IGNhbiBiZSB1c2VmdWwgaWYgeW91IGRlY2lkZSB0byBtYWtlIHlvdXIgc3ViY2xhc3Mgb2YgdGhpcyBtaXhpbiBhXG4gICAqIFwiUG9vbGVkQ2xhc3NcIi5cbiAgICovXG4gIHJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmFuc2FjdGlvbldyYXBwZXJzID0gdGhpcy5nZXRUcmFuc2FjdGlvbldyYXBwZXJzKCk7XG4gICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhKSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndyYXBwZXJJbml0RGF0YSA9IFtdO1xuICAgIH1cbiAgICB0aGlzLl9pc0luVHJhbnNhY3Rpb24gPSBmYWxzZTtcbiAgfSxcblxuICBfaXNJblRyYW5zYWN0aW9uOiBmYWxzZSxcblxuICAvKipcbiAgICogQGFic3RyYWN0XG4gICAqIEByZXR1cm4ge0FycmF5PFRyYW5zYWN0aW9uV3JhcHBlcj59IEFycmF5IG9mIHRyYW5zYWN0aW9uIHdyYXBwZXJzLlxuICAgKi9cbiAgZ2V0VHJhbnNhY3Rpb25XcmFwcGVyczogbnVsbCxcblxuICBpc0luVHJhbnNhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gISF0aGlzLl9pc0luVHJhbnNhY3Rpb247XG4gIH0sXG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBmdW5jdGlvbiB3aXRoaW4gYSBzYWZldHkgd2luZG93LiBVc2UgdGhpcyBmb3IgdGhlIHRvcCBsZXZlbFxuICAgKiBtZXRob2RzIHRoYXQgcmVzdWx0IGluIGxhcmdlIGFtb3VudHMgb2YgY29tcHV0YXRpb24vbXV0YXRpb25zIHRoYXQgd291bGRcbiAgICogbmVlZCB0byBiZSBzYWZldHkgY2hlY2tlZC4gVGhlIG9wdGlvbmFsIGFyZ3VtZW50cyBoZWxwcyBwcmV2ZW50IHRoZSBuZWVkXG4gICAqIHRvIGJpbmQgaW4gbWFueSBjYXNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1lbWJlciBvZiBzY29wZSB0byBjYWxsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gc2NvcGUgU2NvcGUgdG8gaW52b2tlIGZyb20uXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGEgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBiIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gYyBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqIEBwYXJhbSB7T2JqZWN0Pz19IGQgQXJndW1lbnQgdG8gcGFzcyB0byB0aGUgbWV0aG9kLlxuICAgKiBAcGFyYW0ge09iamVjdD89fSBlIEFyZ3VtZW50IHRvIHBhc3MgdG8gdGhlIG1ldGhvZC5cbiAgICogQHBhcmFtIHtPYmplY3Q/PX0gZiBBcmd1bWVudCB0byBwYXNzIHRvIHRoZSBtZXRob2QuXG4gICAqXG4gICAqIEByZXR1cm4geyp9IFJldHVybiB2YWx1ZSBmcm9tIGBtZXRob2RgLlxuICAgKi9cbiAgcGVyZm9ybTogZnVuY3Rpb24gKG1ldGhvZCwgc2NvcGUsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICAhIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24ucGVyZm9ybSguLi4pOiBDYW5ub3QgaW5pdGlhbGl6ZSBhIHRyYW5zYWN0aW9uIHdoZW4gdGhlcmUgJyArICdpcyBhbHJlYWR5IGFuIG91dHN0YW5kaW5nIHRyYW5zYWN0aW9uLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YXIgZXJyb3JUaHJvd247XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgIC8vIGVycm9yVGhyb3duIHNldCB0byB0cnVlIGJlZm9yZSBzZXR0aW5nIGl0IHRvIGZhbHNlIGFmdGVyIGNhbGxpbmdcbiAgICAgIC8vIGNsb3NlIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIHRydWUgaW4gdGhlIGZpbmFsbHkgYmxvY2ssIGl0IG1lYW5zXG4gICAgICAvLyBvbmUgb2YgdGhlc2UgY2FsbHMgdGhyZXcuXG4gICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0aGlzLmluaXRpYWxpemVBbGwoMCk7XG4gICAgICByZXQgPSBtZXRob2QuY2FsbChzY29wZSwgYSwgYiwgYywgZCwgZSwgZik7XG4gICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgIH0gZmluYWxseSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAvLyBJZiBgbWV0aG9kYCB0aHJvd3MsIHByZWZlciB0byBzaG93IHRoYXQgc3RhY2sgdHJhY2Ugb3ZlciBhbnkgdGhyb3duXG4gICAgICAgICAgLy8gYnkgaW52b2tpbmcgYGNsb3NlQWxsYC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gU2luY2UgYG1ldGhvZGAgZGlkbid0IHRocm93LCB3ZSBkb24ndCB3YW50IHRvIHNpbGVuY2UgdGhlIGV4Y2VwdGlvblxuICAgICAgICAgIC8vIGhlcmUuXG4gICAgICAgICAgdGhpcy5jbG9zZUFsbCgwKTtcbiAgICAgICAgfVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdGhpcy5faXNJblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG4gIH0sXG5cbiAgaW5pdGlhbGl6ZUFsbDogZnVuY3Rpb24gKHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgdHJhbnNhY3Rpb25XcmFwcGVycyA9IHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycztcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleDsgaSA8IHRyYW5zYWN0aW9uV3JhcHBlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3cmFwcGVyID0gdHJhbnNhY3Rpb25XcmFwcGVyc1tpXTtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGggdGhlXG4gICAgICAgIC8vIE9CU0VSVkVEX0VSUk9SIHN0YXRlIGJlZm9yZSBvdmVyd3JpdGluZyBpdCB3aXRoIHRoZSByZWFsIHJldHVybiB2YWx1ZVxuICAgICAgICAvLyBvZiBpbml0aWFsaXplIC0tIGlmIGl0J3Mgc3RpbGwgc2V0IHRvIE9CU0VSVkVEX0VSUk9SIGluIHRoZSBmaW5hbGx5XG4gICAgICAgIC8vIGJsb2NrLCBpdCBtZWFucyB3cmFwcGVyLmluaXRpYWxpemUgdGhyZXcuXG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1I7XG4gICAgICAgIHRoaXMud3JhcHBlckluaXREYXRhW2ldID0gd3JhcHBlci5pbml0aWFsaXplID8gd3JhcHBlci5pbml0aWFsaXplLmNhbGwodGhpcykgOiBudWxsO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgaWYgKHRoaXMud3JhcHBlckluaXREYXRhW2ldID09PSBUcmFuc2FjdGlvbi5PQlNFUlZFRF9FUlJPUikge1xuICAgICAgICAgIC8vIFRoZSBpbml0aWFsaXplciBmb3Igd3JhcHBlciBpIHRocmV3IGFuIGVycm9yOyBpbml0aWFsaXplIHRoZVxuICAgICAgICAgIC8vIHJlbWFpbmluZyB3cmFwcGVycyBidXQgc2lsZW5jZSBhbnkgZXhjZXB0aW9ucyBmcm9tIHRoZW0gdG8gZW5zdXJlXG4gICAgICAgICAgLy8gdGhhdCB0aGUgZmlyc3QgZXJyb3IgaXMgdGhlIG9uZSB0byBidWJibGUgdXAuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuaW5pdGlhbGl6ZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBJbnZva2VzIGVhY2ggb2YgYHRoaXMudHJhbnNhY3Rpb25XcmFwcGVycy5jbG9zZVtpXWAgZnVuY3Rpb25zLCBwYXNzaW5nIGludG9cbiAgICogdGhlbSB0aGUgcmVzcGVjdGl2ZSByZXR1cm4gdmFsdWVzIG9mIGB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnMuaW5pdFtpXWBcbiAgICogKGBjbG9zZWBycyB0aGF0IGNvcnJlc3BvbmQgdG8gaW5pdGlhbGl6ZXJzIHRoYXQgZmFpbGVkIHdpbGwgbm90IGJlXG4gICAqIGludm9rZWQpLlxuICAgKi9cbiAgY2xvc2VBbGw6IGZ1bmN0aW9uIChzdGFydEluZGV4KSB7XG4gICAgIXRoaXMuaXNJblRyYW5zYWN0aW9uKCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnVHJhbnNhY3Rpb24uY2xvc2VBbGwoKTogQ2Fubm90IGNsb3NlIHRyYW5zYWN0aW9uIHdoZW4gbm9uZSBhcmUgb3Blbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHRyYW5zYWN0aW9uV3JhcHBlcnMgPSB0aGlzLnRyYW5zYWN0aW9uV3JhcHBlcnM7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXg7IGkgPCB0cmFuc2FjdGlvbldyYXBwZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgd3JhcHBlciA9IHRyYW5zYWN0aW9uV3JhcHBlcnNbaV07XG4gICAgICB2YXIgaW5pdERhdGEgPSB0aGlzLndyYXBwZXJJbml0RGF0YVtpXTtcbiAgICAgIHZhciBlcnJvclRocm93bjtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIENhdGNoaW5nIGVycm9ycyBtYWtlcyBkZWJ1Z2dpbmcgbW9yZSBkaWZmaWN1bHQsIHNvIHdlIHN0YXJ0IHdpdGhcbiAgICAgICAgLy8gZXJyb3JUaHJvd24gc2V0IHRvIHRydWUgYmVmb3JlIHNldHRpbmcgaXQgdG8gZmFsc2UgYWZ0ZXIgY2FsbGluZ1xuICAgICAgICAvLyBjbG9zZSAtLSBpZiBpdCdzIHN0aWxsIHNldCB0byB0cnVlIGluIHRoZSBmaW5hbGx5IGJsb2NrLCBpdCBtZWFuc1xuICAgICAgICAvLyB3cmFwcGVyLmNsb3NlIHRocmV3LlxuICAgICAgICBlcnJvclRocm93biA9IHRydWU7XG4gICAgICAgIGlmIChpbml0RGF0YSAhPT0gVHJhbnNhY3Rpb24uT0JTRVJWRURfRVJST1IgJiYgd3JhcHBlci5jbG9zZSkge1xuICAgICAgICAgIHdyYXBwZXIuY2xvc2UuY2FsbCh0aGlzLCBpbml0RGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgIC8vIFRoZSBjbG9zZXIgZm9yIHdyYXBwZXIgaSB0aHJldyBhbiBlcnJvcjsgY2xvc2UgdGhlIHJlbWFpbmluZ1xuICAgICAgICAgIC8vIHdyYXBwZXJzIGJ1dCBzaWxlbmNlIGFueSBleGNlcHRpb25zIGZyb20gdGhlbSB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICAvLyBmaXJzdCBlcnJvciBpcyB0aGUgb25lIHRvIGJ1YmJsZSB1cC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUFsbChpICsgMSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLndyYXBwZXJJbml0RGF0YS5sZW5ndGggPSAwO1xuICB9XG59O1xuXG52YXIgVHJhbnNhY3Rpb24gPSB7XG5cbiAgTWl4aW46IE1peGluLFxuXG4gIC8qKlxuICAgKiBUb2tlbiB0byBsb29rIGZvciB0byBkZXRlcm1pbmUgaWYgYW4gZXJyb3Igb2NjdXJyZWQuXG4gICAqL1xuICBPQlNFUlZFRF9FUlJPUjoge31cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2FjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9UcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBlbXB0eU9iamVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5T2JqZWN0ID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIE9iamVjdC5mcmVlemUoZW1wdHlPYmplY3QpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5T2JqZWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9lbXB0eU9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjb250YWluc05vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNUZXh0Tm9kZSA9IHJlcXVpcmUoJy4vaXNUZXh0Tm9kZScpO1xuXG4vKmVzbGludC1kaXNhYmxlIG5vLWJpdHdpc2UgKi9cblxuLyoqXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBET00gbm9kZSBjb250YWlucyBvciBpcyBhbm90aGVyIERPTSBub2RlLlxuICpcbiAqIEBwYXJhbSB7P0RPTU5vZGV9IG91dGVyTm9kZSBPdXRlciBET00gbm9kZS5cbiAqIEBwYXJhbSB7P0RPTU5vZGV9IGlubmVyTm9kZSBJbm5lciBET00gbm9kZS5cbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG91dGVyTm9kZWAgY29udGFpbnMgb3IgaXMgYGlubmVyTm9kZWAuXG4gKi9cbmZ1bmN0aW9uIGNvbnRhaW5zTm9kZShfeCwgX3gyKSB7XG4gIHZhciBfYWdhaW4gPSB0cnVlO1xuXG4gIF9mdW5jdGlvbjogd2hpbGUgKF9hZ2Fpbikge1xuICAgIHZhciBvdXRlck5vZGUgPSBfeCxcbiAgICAgICAgaW5uZXJOb2RlID0gX3gyO1xuICAgIF9hZ2FpbiA9IGZhbHNlO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgIWlubmVyTm9kZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlID09PSBpbm5lck5vZGUpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gZWxzZSBpZiAoaXNUZXh0Tm9kZShvdXRlck5vZGUpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1RleHROb2RlKGlubmVyTm9kZSkpIHtcbiAgICAgIF94ID0gb3V0ZXJOb2RlO1xuICAgICAgX3gyID0gaW5uZXJOb2RlLnBhcmVudE5vZGU7XG4gICAgICBfYWdhaW4gPSB0cnVlO1xuICAgICAgY29udGludWUgX2Z1bmN0aW9uO1xuICAgIH0gZWxzZSBpZiAob3V0ZXJOb2RlLmNvbnRhaW5zKSB7XG4gICAgICByZXR1cm4gb3V0ZXJOb2RlLmNvbnRhaW5zKGlubmVyTm9kZSk7XG4gICAgfSBlbHNlIGlmIChvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24pIHtcbiAgICAgIHJldHVybiAhIShvdXRlck5vZGUuY29tcGFyZURvY3VtZW50UG9zaXRpb24oaW5uZXJOb2RlKSAmIDE2KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnRhaW5zTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIvY29udGFpbnNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzVGV4dE5vZGVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaXNOb2RlID0gcmVxdWlyZSgnLi9pc05vZGUnKTtcblxuLyoqXG4gKiBAcGFyYW0geyp9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICogQHJldHVybiB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgdGhlIG9iamVjdCBpcyBhIERPTSB0ZXh0IG5vZGUuXG4gKi9cbmZ1bmN0aW9uIGlzVGV4dE5vZGUob2JqZWN0KSB7XG4gIHJldHVybiBpc05vZGUob2JqZWN0KSAmJiBvYmplY3Qubm9kZVR5cGUgPT0gMztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBpc1RleHROb2RlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9pc1RleHROb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGlzTm9kZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKipcbiAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2hlY2suXG4gKiBAcmV0dXJuIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCB0aGUgb2JqZWN0IGlzIGEgRE9NIG5vZGUuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaXNOb2RlKG9iamVjdCkge1xuICByZXR1cm4gISEob2JqZWN0ICYmICh0eXBlb2YgTm9kZSA9PT0gJ2Z1bmN0aW9uJyA/IG9iamVjdCBpbnN0YW5jZW9mIE5vZGUgOiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlID09PSAnbnVtYmVyJyAmJiB0eXBlb2Ygb2JqZWN0Lm5vZGVOYW1lID09PSAnc3RyaW5nJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzTm9kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIvaXNOb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb3NpdGVDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50Jyk7XG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudCcpO1xudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdE5hdGl2ZUNvbXBvbmVudCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLy8gVG8gYXZvaWQgYSBjeWNsaWMgZGVwZW5kZW5jeSwgd2UgY3JlYXRlIHRoZSBmaW5hbCBjbGFzcyBpbiB0aGlzIG1vZHVsZVxudmFyIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlciA9IGZ1bmN0aW9uICgpIHt9O1xuYXNzaWduKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50V3JhcHBlci5wcm90b3R5cGUsIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50Lk1peGluLCB7XG4gIF9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50OiBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50XG59KTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSB7XG4gIGlmIChvd25lcikge1xuICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgIGlmIChuYW1lKSB7XG4gICAgICByZXR1cm4gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgIH1cbiAgfVxuICByZXR1cm4gJyc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIHR5cGUgcmVmZXJlbmNlIGlzIGEga25vd24gaW50ZXJuYWwgdHlwZS4gSS5lLiBub3QgYSB1c2VyXG4gKiBwcm92aWRlZCBjb21wb3NpdGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHZhbGlkIGludGVybmFsIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGlzSW50ZXJuYWxDb21wb25lbnRUeXBlKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHR5cGUucHJvdG90eXBlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB0eXBlLnByb3RvdHlwZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgUmVhY3ROb2RlLCBjcmVhdGUgYW4gaW5zdGFuY2UgdGhhdCB3aWxsIGFjdHVhbGx5IGJlIG1vdW50ZWQuXG4gKlxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGVcbiAqIEByZXR1cm4ge29iamVjdH0gQSBuZXcgaW5zdGFuY2Ugb2YgdGhlIGVsZW1lbnQncyBjb25zdHJ1Y3Rvci5cbiAqIEBwcm90ZWN0ZWRcbiAqL1xuZnVuY3Rpb24gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChub2RlKSB7XG4gIHZhciBpbnN0YW5jZTtcblxuICBpZiAobm9kZSA9PT0gbnVsbCB8fCBub2RlID09PSBmYWxzZSkge1xuICAgIGluc3RhbmNlID0gbmV3IFJlYWN0RW1wdHlDb21wb25lbnQoaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdvYmplY3QnKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuICAgICEoZWxlbWVudCAmJiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgZWxlbWVudC50eXBlID09PSAnc3RyaW5nJykpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgdHlwZSBpcyBpbnZhbGlkOiBleHBlY3RlZCBhIHN0cmluZyAoZm9yIGJ1aWx0LWluIGNvbXBvbmVudHMpICcgKyAnb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSBjb21wb25lbnRzKSBidXQgZ290OiAlcy4lcycsIGVsZW1lbnQudHlwZSA9PSBudWxsID8gZWxlbWVudC50eXBlIDogdHlwZW9mIGVsZW1lbnQudHlwZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGVsZW1lbnQuX293bmVyKSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgLy8gU3BlY2lhbCBjYXNlIHN0cmluZyB2YWx1ZXNcbiAgICBpZiAodHlwZW9mIGVsZW1lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCk7XG4gICAgfSBlbHNlIGlmIChpc0ludGVybmFsQ29tcG9uZW50VHlwZShlbGVtZW50LnR5cGUpKSB7XG4gICAgICAvLyBUaGlzIGlzIHRlbXBvcmFyaWx5IGF2YWlsYWJsZSBmb3IgY3VzdG9tIGNvbXBvbmVudHMgdGhhdCBhcmUgbm90IHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb25zLiBJLmUuIEFSVC4gT25jZSB0aG9zZSBhcmUgdXBkYXRlZCB0byB1c2UgdGhlIHN0cmluZ1xuICAgICAgLy8gcmVwcmVzZW50YXRpb24sIHdlIGNhbiBkcm9wIHRoaXMgY29kZSBwYXRoLlxuICAgICAgaW5zdGFuY2UgPSBuZXcgZWxlbWVudC50eXBlKGVsZW1lbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnN0YW5jZSA9IG5ldyBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudFdyYXBwZXIoKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBub2RlID09PSAnbnVtYmVyJykge1xuICAgIGluc3RhbmNlID0gUmVhY3ROYXRpdmVDb21wb25lbnQuY3JlYXRlSW5zdGFuY2VGb3JUZXh0KG5vZGUpO1xuICB9IGVsc2Uge1xuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdFbmNvdW50ZXJlZCBpbnZhbGlkIFJlYWN0IG5vZGUgb2YgdHlwZSAlcycsIHR5cGVvZiBub2RlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0YW5jZS5jb25zdHJ1Y3QgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGluc3RhbmNlLm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS5yZWNlaXZlQ29tcG9uZW50ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBpbnN0YW5jZS51bm1vdW50Q29tcG9uZW50ID09PSAnZnVuY3Rpb24nLCAnT25seSBSZWFjdCBDb21wb25lbnRzIGNhbiBiZSBtb3VudGVkLicpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gU2V0cyB1cCB0aGUgaW5zdGFuY2UuIFRoaXMgY2FuIHByb2JhYmx5IGp1c3QgbW92ZSBpbnRvIHRoZSBjb25zdHJ1Y3RvciBub3cuXG4gIGluc3RhbmNlLmNvbnN0cnVjdChub2RlKTtcblxuICAvLyBUaGVzZSB0d28gZmllbGRzIGFyZSB1c2VkIGJ5IHRoZSBET00gYW5kIEFSVCBkaWZmaW5nIGFsZ29yaXRobXNcbiAgLy8gcmVzcGVjdGl2ZWx5LiBJbnN0ZWFkIG9mIHVzaW5nIGV4cGFuZG9zIG9uIGNvbXBvbmVudHMsIHdlIHNob3VsZCBiZVxuICAvLyBzdG9yaW5nIHRoZSBzdGF0ZSBuZWVkZWQgYnkgdGhlIGRpZmZpbmcgYWxnb3JpdGhtcyBlbHNld2hlcmUuXG4gIGluc3RhbmNlLl9tb3VudEluZGV4ID0gMDtcbiAgaW5zdGFuY2UuX21vdW50SW1hZ2UgPSBudWxsO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaW5zdGFuY2UuX2lzT3duZXJOZWNlc3NhcnkgPSBmYWxzZTtcbiAgICBpbnN0YW5jZS5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSBmYWxzZTtcbiAgfVxuXG4gIC8vIEludGVybmFsIGluc3RhbmNlcyBzaG91bGQgZnVsbHkgY29uc3RydWN0ZWQgYXQgdGhpcyBwb2ludCwgc28gdGhleSBzaG91bGRcbiAgLy8gbm90IGdldCBhbnkgbmV3IGZpZWxkcyBhZGRlZCB0byB0aGVtIGF0IHRoaXMgcG9pbnQuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaWYgKE9iamVjdC5wcmV2ZW50RXh0ZW5zaW9ucykge1xuICAgICAgT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zKGluc3RhbmNlKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q3VycmVudE93bmVyID0gcmVxdWlyZSgnLi9SZWFjdEN1cnJlbnRPd25lcicpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9ucycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcycpO1xudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG52YXIgUmVhY3RVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVRdWV1ZScpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9zaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpIHtcbiAgdmFyIG93bmVyID0gY29tcG9uZW50Ll9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgaWYgKG93bmVyKSB7XG4gICAgdmFyIG5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuZnVuY3Rpb24gU3RhdGVsZXNzQ29tcG9uZW50KENvbXBvbmVudCkge31cblN0YXRlbGVzc0NvbXBvbmVudC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICB2YXIgQ29tcG9uZW50ID0gUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gIHJldHVybiBDb21wb25lbnQodGhpcy5wcm9wcywgdGhpcy5jb250ZXh0LCB0aGlzLnVwZGF0ZXIpO1xufTtcblxuLyoqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0gVGhlIExpZmUtQ3ljbGUgb2YgYSBDb21wb3NpdGUgQ29tcG9uZW50IC0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIC0gY29uc3RydWN0b3I6IEluaXRpYWxpemF0aW9uIG9mIHN0YXRlLiBUaGUgaW5zdGFuY2UgaXMgbm93IHJldGFpbmVkLlxuICogICAtIGNvbXBvbmVudFdpbGxNb3VudFxuICogICAtIHJlbmRlclxuICogICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9yc11cbiAqICAgICAtIFtjaGlsZHJlbidzIGNvbXBvbmVudFdpbGxNb3VudCBhbmQgcmVuZGVyXVxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50RGlkTW91bnRdXG4gKiAgICAgLSBjb21wb25lbnREaWRNb3VudFxuICpcbiAqICAgICAgIFVwZGF0ZSBQaGFzZXM6XG4gKiAgICAgICAtIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKG9ubHkgY2FsbGVkIGlmIHBhcmVudCB1cGRhdGVkKVxuICogICAgICAgLSBzaG91bGRDb21wb25lbnRVcGRhdGVcbiAqICAgICAgICAgLSBjb21wb25lbnRXaWxsVXBkYXRlXG4gKiAgICAgICAgICAgLSByZW5kZXJcbiAqICAgICAgICAgICAtIFtjaGlsZHJlbidzIGNvbnN0cnVjdG9ycyBvciByZWNlaXZlIHByb3BzIHBoYXNlc11cbiAqICAgICAgICAgLSBjb21wb25lbnREaWRVcGRhdGVcbiAqXG4gKiAgICAgLSBjb21wb25lbnRXaWxsVW5tb3VudFxuICogICAgIC0gW2NoaWxkcmVuJ3MgY29tcG9uZW50V2lsbFVubW91bnRdXG4gKiAgIC0gW2NoaWxkcmVuIGRlc3Ryb3llZF1cbiAqIC0gKGRlc3Ryb3llZCk6IFRoZSBpbnN0YW5jZSBpcyBub3cgYmxhbmssIHJlbGVhc2VkIGJ5IFJlYWN0IGFuZCByZWFkeSBmb3IgR0MuXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAqL1xuXG4vKipcbiAqIEFuIGluY3JlbWVudGluZyBJRCBhc3NpZ25lZCB0byBlYWNoIGNvbXBvbmVudCB3aGVuIGl0IGlzIG1vdW50ZWQuIFRoaXMgaXNcbiAqIHVzZWQgdG8gZW5mb3JjZSB0aGUgb3JkZXIgaW4gd2hpY2ggYFJlYWN0VXBkYXRlc2AgdXBkYXRlcyBkaXJ0eSBjb21wb25lbnRzLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbnZhciBuZXh0TW91bnRJRCA9IDE7XG5cbi8qKlxuICogQGxlbmRzIHtSZWFjdENvbXBvc2l0ZUNvbXBvbmVudC5wcm90b3R5cGV9XG4gKi9cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudE1peGluID0ge1xuXG4gIC8qKlxuICAgKiBCYXNlIGNvbnN0cnVjdG9yIGZvciBhbGwgY29tcG9zaXRlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgY29uc3RydWN0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gZWxlbWVudDtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl9pbnN0YW5jZSA9IG51bGw7XG5cbiAgICAvLyBTZWUgUmVhY3RVcGRhdGVRdWV1ZVxuICAgIHRoaXMuX3BlbmRpbmdFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZSA9IGZhbHNlO1xuICAgIHRoaXMuX3BlbmRpbmdGb3JjZVVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuXG4gICAgdGhpcy5fY29udGV4dCA9IG51bGw7XG4gICAgdGhpcy5fbW91bnRPcmRlciA9IDA7XG4gICAgdGhpcy5fdG9wTGV2ZWxXcmFwcGVyID0gbnVsbDtcblxuICAgIC8vIFNlZSBSZWFjdFVwZGF0ZXMgYW5kIFJlYWN0VXBkYXRlUXVldWUuXG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIHRoZSBjb21wb25lbnQsIHJlbmRlcnMgbWFya3VwLCBhbmQgcmVnaXN0ZXJzIGV2ZW50IGxpc3RlbmVycy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBET00gSUQgb2YgdGhlIHJvb3Qgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEByZXR1cm4gez9zdHJpbmd9IFJlbmRlcmVkIG1hcmt1cCB0byBiZSBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAqIEBmaW5hbFxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuICAgIHRoaXMuX21vdW50T3JkZXIgPSBuZXh0TW91bnRJRCsrO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHVibGljUHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHModGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHMpO1xuICAgIHZhciBwdWJsaWNDb250ZXh0ID0gdGhpcy5fcHJvY2Vzc0NvbnRleHQoY29udGV4dCk7XG5cbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcblxuICAgIC8vIEluaXRpYWxpemUgdGhlIHB1YmxpYyBjbGFzc1xuICAgIHZhciBpbnN0O1xuICAgIHZhciByZW5kZXJlZEVsZW1lbnQ7XG5cbiAgICAvLyBUaGlzIGlzIGEgd2F5IHRvIGRldGVjdCBpZiBDb21wb25lbnQgaXMgYSBzdGF0ZWxlc3MgYXJyb3cgZnVuY3Rpb25cbiAgICAvLyBjb21wb25lbnQsIHdoaWNoIGlzIG5vdCBuZXdhYmxlLiBJdCBtaWdodCBub3QgYmUgMTAwJSByZWxpYWJsZSBidXQgaXNcbiAgICAvLyBzb21ldGhpbmcgd2UgY2FuIGRvIHVudGlsIHdlIHN0YXJ0IGRldGVjdGluZyB0aGF0IENvbXBvbmVudCBleHRlbmRzXG4gICAgLy8gUmVhY3QuQ29tcG9uZW50LiBXZSBhbHJlYWR5IGFzc3VtZSB0aGF0IHR5cGVvZiBDb21wb25lbnQgPT09ICdmdW5jdGlvbicuXG4gICAgdmFyIGNhbkluc3RhbnRpYXRlID0gKCdwcm90b3R5cGUnIGluIENvbXBvbmVudCk7XG5cbiAgICBpZiAoY2FuSW5zdGFudGlhdGUpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSB0aGlzO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGluc3QgPSBuZXcgQ29tcG9uZW50KHB1YmxpY1Byb3BzLCBwdWJsaWNDb250ZXh0LCBSZWFjdFVwZGF0ZVF1ZXVlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5zdCA9IG5ldyBDb21wb25lbnQocHVibGljUHJvcHMsIHB1YmxpY0NvbnRleHQsIFJlYWN0VXBkYXRlUXVldWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghY2FuSW5zdGFudGlhdGUgfHwgaW5zdCA9PT0gbnVsbCB8fCBpbnN0ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoaW5zdCkpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IGluc3Q7XG4gICAgICBpbnN0ID0gbmV3IFN0YXRlbGVzc0NvbXBvbmVudChDb21wb25lbnQpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgbGF0ZXIgaW4gX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCwgYnV0IGFkZCBhbiBlYXJseVxuICAgICAgLy8gd2FybmluZyBub3cgdG8gaGVscCBkZWJ1Z2dpbmdcbiAgICAgIGlmIChpbnN0LnJlbmRlciA9PSBudWxsKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKTogTm8gYHJlbmRlcmAgbWV0aG9kIGZvdW5kIG9uIHRoZSByZXR1cm5lZCBjb21wb25lbnQgJyArICdpbnN0YW5jZTogeW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBkZWZpbmUgYHJlbmRlcmAsIHJldHVybmVkICcgKyAnbnVsbC9mYWxzZSBmcm9tIGEgc3RhdGVsZXNzIGNvbXBvbmVudCwgb3IgdHJpZWQgdG8gcmVuZGVyIGFuICcgKyAnZWxlbWVudCB3aG9zZSB0eXBlIGlzIGEgZnVuY3Rpb24gdGhhdCBpc25cXCd0IGEgUmVhY3QgY29tcG9uZW50LicsIENvbXBvbmVudC5kaXNwbGF5TmFtZSB8fCBDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBXZSBzdXBwb3J0IEVTNiBpbmhlcml0aW5nIGZyb20gUmVhY3QuQ29tcG9uZW50LCB0aGUgbW9kdWxlIHBhdHRlcm4sXG4gICAgICAgIC8vIGFuZCBzdGF0ZWxlc3MgY29tcG9uZW50cywgYnV0IG5vdCBFUzYgY2xhc3NlcyB0aGF0IGRvbid0IGV4dGVuZFxuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhDb21wb25lbnQucHJvdG90eXBlICYmIENvbXBvbmVudC5wcm90b3R5cGUuaXNSZWFjdENvbXBvbmVudCB8fCAhY2FuSW5zdGFudGlhdGUgfHwgIShpbnN0IGluc3RhbmNlb2YgQ29tcG9uZW50KSwgJyVzKC4uLik6IFJlYWN0IGNvbXBvbmVudCBjbGFzc2VzIG11c3QgZXh0ZW5kIFJlYWN0LkNvbXBvbmVudC4nLCBDb21wb25lbnQuZGlzcGxheU5hbWUgfHwgQ29tcG9uZW50Lm5hbWUgfHwgJ0NvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFRoZXNlIHNob3VsZCBiZSBzZXQgdXAgaW4gdGhlIGNvbnN0cnVjdG9yLCBidXQgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBzaW1wbGVyIGNsYXNzIGFic3RyYWN0aW9ucywgd2Ugc2V0IHRoZW0gdXAgYWZ0ZXIgdGhlIGZhY3QuXG4gICAgaW5zdC5wcm9wcyA9IHB1YmxpY1Byb3BzO1xuICAgIGluc3QuY29udGV4dCA9IHB1YmxpY0NvbnRleHQ7XG4gICAgaW5zdC5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgaW5zdC51cGRhdGVyID0gUmVhY3RVcGRhdGVRdWV1ZTtcblxuICAgIHRoaXMuX2luc3RhbmNlID0gaW5zdDtcblxuICAgIC8vIFN0b3JlIGEgcmVmZXJlbmNlIGZyb20gdGhlIGluc3RhbmNlIGJhY2sgdG8gdGhlIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgUmVhY3RJbnN0YW5jZU1hcC5zZXQoaW5zdCwgdGhpcyk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gU2luY2UgcGxhaW4gSlMgY2xhc3NlcyBhcmUgZGVmaW5lZCB3aXRob3V0IGFueSBzcGVjaWFsIGluaXRpYWxpemF0aW9uXG4gICAgICAvLyBsb2dpYywgd2UgY2FuIG5vdCBjYXRjaCBjb21tb24gZXJyb3JzIGVhcmx5LiBUaGVyZWZvcmUsIHdlIGhhdmUgdG9cbiAgICAgIC8vIGNhdGNoIHRoZW0gaGVyZSwgYXQgaW5pdGlhbGl6YXRpb24gdGltZSwgaW5zdGVhZC5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldEluaXRpYWxTdGF0ZSB8fCBpbnN0LmdldEluaXRpYWxTdGF0ZS5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldEluaXRpYWxTdGF0ZSB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdEaWQgeW91IG1lYW4gdG8gZGVmaW5lIGEgc3RhdGUgcHJvcGVydHkgaW5zdGVhZD8nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKCFpbnN0LmdldERlZmF1bHRQcm9wcyB8fCBpbnN0LmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCwgJ2dldERlZmF1bHRQcm9wcyB3YXMgZGVmaW5lZCBvbiAlcywgYSBwbGFpbiBKYXZhU2NyaXB0IGNsYXNzLiAnICsgJ1RoaXMgaXMgb25seSBzdXBwb3J0ZWQgZm9yIGNsYXNzZXMgY3JlYXRlZCB1c2luZyBSZWFjdC5jcmVhdGVDbGFzcy4gJyArICdVc2UgYSBzdGF0aWMgcHJvcGVydHkgdG8gZGVmaW5lIGRlZmF1bHRQcm9wcyBpbnN0ZWFkLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdhIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIWluc3QucHJvcFR5cGVzLCAncHJvcFR5cGVzIHdhcyBkZWZpbmVkIGFzIGFuIGluc3RhbmNlIHByb3BlcnR5IG9uICVzLiBVc2UgYSBzdGF0aWMgJyArICdwcm9wZXJ0eSB0byBkZWZpbmUgcHJvcFR5cGVzIGluc3RlYWQuJywgdGhpcy5nZXROYW1lKCkgfHwgJ2EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghaW5zdC5jb250ZXh0VHlwZXMsICdjb250ZXh0VHlwZXMgd2FzIGRlZmluZWQgYXMgYW4gaW5zdGFuY2UgcHJvcGVydHkgb24gJXMuIFVzZSBhICcgKyAnc3RhdGljIHByb3BlcnR5IHRvIGRlZmluZSBjb250ZXh0VHlwZXMgaW5zdGVhZC4nLCB0aGlzLmdldE5hbWUoKSB8fCAnYSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHR5cGVvZiBpbnN0LmNvbXBvbmVudFNob3VsZFVwZGF0ZSAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnRTaG91bGRVcGRhdGUoKS4gRGlkIHlvdSBtZWFuIHNob3VsZENvbXBvbmVudFVwZGF0ZSgpPyAnICsgJ1RoZSBuYW1lIGlzIHBocmFzZWQgYXMgYSBxdWVzdGlvbiBiZWNhdXNlIHRoZSBmdW5jdGlvbiBpcyAnICsgJ2V4cGVjdGVkIHRvIHJldHVybiBhIHZhbHVlLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIGluc3QuY29tcG9uZW50RGlkVW5tb3VudCAhPT0gJ2Z1bmN0aW9uJywgJyVzIGhhcyBhIG1ldGhvZCBjYWxsZWQgJyArICdjb21wb25lbnREaWRVbm1vdW50KCkuIEJ1dCB0aGVyZSBpcyBubyBzdWNoIGxpZmVjeWNsZSBtZXRob2QuICcgKyAnRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxVbm1vdW50KCk/JywgdGhpcy5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyh0eXBlb2YgaW5zdC5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzICE9PSAnZnVuY3Rpb24nLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCB0aGlzLmdldE5hbWUoKSB8fCAnQSBjb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICB2YXIgaW5pdGlhbFN0YXRlID0gaW5zdC5zdGF0ZTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGluc3Quc3RhdGUgPSBpbml0aWFsU3RhdGUgPSBudWxsO1xuICAgIH1cbiAgICAhKHR5cGVvZiBpbml0aWFsU3RhdGUgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KGluaXRpYWxTdGF0ZSkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzLnN0YXRlOiBtdXN0IGJlIHNldCB0byBhbiBvYmplY3Qgb3IgbnVsbCcsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsTW91bnQpIHtcbiAgICAgIGluc3QuY29tcG9uZW50V2lsbE1vdW50KCk7XG4gICAgICAvLyBXaGVuIG1vdW50aW5nLCBjYWxscyB0byBgc2V0U3RhdGVgIGJ5IGBjb21wb25lbnRXaWxsTW91bnRgIHdpbGwgc2V0XG4gICAgICAvLyBgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWVgIHdpdGhvdXQgdHJpZ2dlcmluZyBhIHJlLXJlbmRlci5cbiAgICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSkge1xuICAgICAgICBpbnN0LnN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShpbnN0LnByb3BzLCBpbnN0LmNvbnRleHQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIG5vdCBhIHN0YXRlbGVzcyBjb21wb25lbnQsIHdlIG5vdyByZW5kZXJcbiAgICBpZiAocmVuZGVyZWRFbGVtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIH1cblxuICAgIHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5faW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChyZW5kZXJlZEVsZW1lbnQpO1xuXG4gICAgdmFyIG1hcmt1cCA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCwgcm9vdElELCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgaWYgKGluc3QuY29tcG9uZW50RGlkTW91bnQpIHtcbiAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUoaW5zdC5jb21wb25lbnREaWRNb3VudCwgaW5zdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcmt1cDtcbiAgfSxcblxuICAvKipcbiAgICogUmVsZWFzZXMgYW55IHJlc291cmNlcyBhbGxvY2F0ZWQgYnkgYG1vdW50Q29tcG9uZW50YC5cbiAgICpcbiAgICogQGZpbmFsXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG5cbiAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVW5tb3VudCgpO1xuICAgIH1cblxuICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50KTtcbiAgICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IG51bGw7XG4gICAgdGhpcy5faW5zdGFuY2UgPSBudWxsO1xuXG4gICAgLy8gUmVzZXQgcGVuZGluZyBmaWVsZHNcbiAgICAvLyBFdmVuIGlmIHRoaXMgY29tcG9uZW50IGlzIHNjaGVkdWxlZCBmb3IgYW5vdGhlciB1cGRhdGUgaW4gUmVhY3RVcGRhdGVzLFxuICAgIC8vIGl0IHdvdWxkIHN0aWxsIGJlIGlnbm9yZWQgYmVjYXVzZSB0aGVzZSBmaWVsZHMgYXJlIHJlc2V0LlxuICAgIHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlID0gbnVsbDtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0ZvcmNlVXBkYXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ0NhbGxiYWNrcyA9IG51bGw7XG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgLy8gVGhlc2UgZmllbGRzIGRvIG5vdCByZWFsbHkgbmVlZCB0byBiZSByZXNldCBzaW5jZSB0aGlzIG9iamVjdCBpcyBub1xuICAgIC8vIGxvbmdlciBhY2Nlc3NpYmxlLlxuICAgIHRoaXMuX2NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICAgIHRoaXMuX3RvcExldmVsV3JhcHBlciA9IG51bGw7XG5cbiAgICAvLyBEZWxldGUgdGhlIHJlZmVyZW5jZSBmcm9tIHRoZSBpbnN0YW5jZSB0byB0aGlzIGludGVybmFsIHJlcHJlc2VudGF0aW9uXG4gICAgLy8gd2hpY2ggYWxsb3cgdGhlIGludGVybmFscyB0byBiZSBwcm9wZXJseSBjbGVhbmVkIHVwIGV2ZW4gaWYgdGhlIHVzZXJcbiAgICAvLyBsZWFrcyBhIHJlZmVyZW5jZSB0byB0aGUgcHVibGljIGluc3RhbmNlLlxuICAgIFJlYWN0SW5zdGFuY2VNYXAucmVtb3ZlKGluc3QpO1xuXG4gICAgLy8gU29tZSBleGlzdGluZyBjb21wb25lbnRzIHJlbHkgb24gaW5zdC5wcm9wcyBldmVuIGFmdGVyIHRoZXkndmUgYmVlblxuICAgIC8vIGRlc3Ryb3llZCAoaW4gZXZlbnQgaGFuZGxlcnMpLlxuICAgIC8vIFRPRE86IGluc3QucHJvcHMgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3Quc3RhdGUgPSBudWxsO1xuICAgIC8vIFRPRE86IGluc3QuY29udGV4dCA9IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEZpbHRlcnMgdGhlIGNvbnRleHQgb2JqZWN0IHRvIG9ubHkgY29udGFpbiBrZXlzIHNwZWNpZmllZCBpblxuICAgKiBgY29udGV4dFR5cGVzYFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX21hc2tDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gbnVsbDtcbiAgICB2YXIgQ29tcG9uZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29udGV4dFR5cGVzID0gQ29tcG9uZW50LmNvbnRleHRUeXBlcztcbiAgICBpZiAoIWNvbnRleHRUeXBlcykge1xuICAgICAgcmV0dXJuIGVtcHR5T2JqZWN0O1xuICAgIH1cbiAgICBtYXNrZWRDb250ZXh0ID0ge307XG4gICAgZm9yICh2YXIgY29udGV4dE5hbWUgaW4gY29udGV4dFR5cGVzKSB7XG4gICAgICBtYXNrZWRDb250ZXh0W2NvbnRleHROYW1lXSA9IGNvbnRleHRbY29udGV4dE5hbWVdO1xuICAgIH1cbiAgICByZXR1cm4gbWFza2VkQ29udGV4dDtcbiAgfSxcblxuICAvKipcbiAgICogRmlsdGVycyB0aGUgY29udGV4dCBvYmplY3QgdG8gb25seSBjb250YWluIGtleXMgc3BlY2lmaWVkIGluXG4gICAqIGBjb250ZXh0VHlwZXNgLCBhbmQgYXNzZXJ0cyB0aGF0IHRoZXkgYXJlIHZhbGlkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NDb250ZXh0OiBmdW5jdGlvbiAoY29udGV4dCkge1xuICAgIHZhciBtYXNrZWRDb250ZXh0ID0gdGhpcy5fbWFza0NvbnRleHQoY29udGV4dCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5jb250ZXh0VHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LmNvbnRleHRUeXBlcywgbWFza2VkQ29udGV4dCwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5jb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hc2tlZENvbnRleHQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjdXJyZW50Q29udGV4dFxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcHJvY2Vzc0NoaWxkQ29udGV4dDogZnVuY3Rpb24gKGN1cnJlbnRDb250ZXh0KSB7XG4gICAgdmFyIENvbXBvbmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICB2YXIgY2hpbGRDb250ZXh0ID0gaW5zdC5nZXRDaGlsZENvbnRleHQgJiYgaW5zdC5nZXRDaGlsZENvbnRleHQoKTtcbiAgICBpZiAoY2hpbGRDb250ZXh0KSB7XG4gICAgICAhKHR5cGVvZiBDb21wb25lbnQuY2hpbGRDb250ZXh0VHlwZXMgPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKTogY2hpbGRDb250ZXh0VHlwZXMgbXVzdCBiZSBkZWZpbmVkIGluIG9yZGVyIHRvICcgKyAndXNlIGdldENoaWxkQ29udGV4dCgpLicsIHRoaXMuZ2V0TmFtZSgpIHx8ICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrUHJvcFR5cGVzKENvbXBvbmVudC5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0LCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBuYW1lIGluIGNoaWxkQ29udGV4dCkge1xuICAgICAgICAhKG5hbWUgaW4gQ29tcG9uZW50LmNoaWxkQ29udGV4dFR5cGVzKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRDaGlsZENvbnRleHQoKToga2V5IFwiJXNcIiBpcyBub3QgZGVmaW5lZCBpbiBjaGlsZENvbnRleHRUeXBlcy4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXNzaWduKHt9LCBjdXJyZW50Q29udGV4dCwgY2hpbGRDb250ZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnRDb250ZXh0O1xuICB9LFxuXG4gIC8qKlxuICAgKiBQcm9jZXNzZXMgcHJvcHMgYnkgc2V0dGluZyBkZWZhdWx0IHZhbHVlcyBmb3IgdW5zcGVjaWZpZWQgcHJvcHMgYW5kXG4gICAqIGFzc2VydGluZyB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWQuIERvZXMgbm90IG11dGF0ZSBpdHMgYXJndW1lbnQ7IHJldHVybnNcbiAgICogYSBuZXcgcHJvcHMgb2JqZWN0IHdpdGggZGVmYXVsdHMgbWVyZ2VkIGluLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV3UHJvcHNcbiAgICogQHJldHVybiB7b2JqZWN0fVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3Byb2Nlc3NQcm9wczogZnVuY3Rpb24gKG5ld1Byb3BzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBDb21wb25lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudC50eXBlO1xuICAgICAgaWYgKENvbXBvbmVudC5wcm9wVHlwZXMpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tQcm9wVHlwZXMoQ29tcG9uZW50LnByb3BUeXBlcywgbmV3UHJvcHMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXdQcm9wcztcbiAgfSxcblxuICAvKipcbiAgICogQXNzZXJ0IHRoYXQgdGhlIHByb3BzIGFyZSB2YWxpZFxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcFR5cGVzIE1hcCBvZiBwcm9wIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tQcm9wVHlwZXM6IGZ1bmN0aW9uIChwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICAgIC8vIFRPRE86IFN0b3AgdmFsaWRhdGluZyBwcm9wIHR5cGVzIGhlcmUgYW5kIG9ubHkgdXNlIHRoZSBlbGVtZW50XG4gICAgLy8gdmFsaWRhdGlvbi5cbiAgICB2YXIgY29tcG9uZW50TmFtZSA9IHRoaXMuZ2V0TmFtZSgpO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BUeXBlcykge1xuICAgICAgaWYgKHByb3BUeXBlcy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICAhKHR5cGVvZiBwcm9wVHlwZXNbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclczogJXMgdHlwZSBgJXNgIGlzIGludmFsaWQ7IGl0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSAnICsgJ2Zyb20gUmVhY3QuUHJvcFR5cGVzLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciA9IGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgLy8gV2UgbWF5IHdhbnQgdG8gZXh0ZW5kIHRoaXMgbG9naWMgZm9yIHNpbWlsYXIgZXJyb3JzIGluXG4gICAgICAgICAgLy8gdG9wLWxldmVsIHJlbmRlciBjYWxscywgc28gSSdtIGFic3RyYWN0aW5nIGl0IGF3YXkgaW50b1xuICAgICAgICAgIC8vIGEgZnVuY3Rpb24gdG8gbWluaW1pemUgcmVmYWN0b3JpbmcgaW4gdGhlIGZ1dHVyZVxuICAgICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSh0aGlzKTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbiA9PT0gUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKSB7XG4gICAgICAgICAgICAvLyBQcmVmYWNlIGdpdmVzIHVzIHNvbWV0aGluZyB0byBibGFja2xpc3QgaW4gd2FybmluZyBtb2R1bGVcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIENvbXBvc2l0ZSBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdGYWlsZWQgQ29udGV4dCBUeXBlczogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcmVjZWl2ZUNvbXBvbmVudDogZnVuY3Rpb24gKG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgbmV4dENvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgcHJldkNvbnRleHQgPSB0aGlzLl9jb250ZXh0O1xuXG4gICAgdGhpcy5fcGVuZGluZ0VsZW1lbnQgPSBudWxsO1xuXG4gICAgdGhpcy51cGRhdGVDb21wb25lbnQodHJhbnNhY3Rpb24sIHByZXZFbGVtZW50LCBuZXh0RWxlbWVudCwgcHJldkNvbnRleHQsIG5leHRDb250ZXh0KTtcbiAgfSxcblxuICAvKipcbiAgICogSWYgYW55IG9mIGBfcGVuZGluZ0VsZW1lbnRgLCBgX3BlbmRpbmdTdGF0ZVF1ZXVlYCwgb3IgYF9wZW5kaW5nRm9yY2VVcGRhdGVgXG4gICAqIGlzIHNldCwgdXBkYXRlIHRoZSBjb21wb25lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQGludGVybmFsXG4gICAqL1xuICBwZXJmb3JtVXBkYXRlSWZOZWNlc3Nhcnk6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbikge1xuICAgIGlmICh0aGlzLl9wZW5kaW5nRWxlbWVudCAhPSBudWxsKSB7XG4gICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudCh0aGlzLCB0aGlzLl9wZW5kaW5nRWxlbWVudCB8fCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdHJhbnNhY3Rpb24sIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wZW5kaW5nU3RhdGVRdWV1ZSAhPT0gbnVsbCB8fCB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB0aGlzLl9jdXJyZW50RWxlbWVudCwgdGhpcy5fY3VycmVudEVsZW1lbnQsIHRoaXMuX2NvbnRleHQsIHRoaXMuX2NvbnRleHQpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUGVyZm9ybSBhbiB1cGRhdGUgdG8gYSBtb3VudGVkIGNvbXBvbmVudC4gVGhlIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgYW5kXG4gICAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSBtZXRob2RzIGFyZSBjYWxsZWQsIHRoZW4gKGFzc3VtaW5nIHRoZSB1cGRhdGUgaXNuJ3RcbiAgICogc2tpcHBlZCkgdGhlIHJlbWFpbmluZyB1cGRhdGUgbGlmZWN5Y2xlIG1ldGhvZHMgYXJlIGNhbGxlZCBhbmQgdGhlIERPTVxuICAgKiByZXByZXNlbnRhdGlvbiBpcyB1cGRhdGVkLlxuICAgKlxuICAgKiBCeSBkZWZhdWx0LCB0aGlzIGltcGxlbWVudHMgUmVhY3QncyByZW5kZXJpbmcgYW5kIHJlY29uY2lsaWF0aW9uIGFsZ29yaXRobS5cbiAgICogU29waGlzdGljYXRlZCBjbGllbnRzIG1heSB3aXNoIHRvIG92ZXJyaWRlIHRoaXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZQYXJlbnRFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0UGFyZW50RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldlBhcmVudEVsZW1lbnQsIG5leHRQYXJlbnRFbGVtZW50LCBwcmV2VW5tYXNrZWRDb250ZXh0LCBuZXh0VW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBuZXh0Q29udGV4dCA9IHRoaXMuX2NvbnRleHQgPT09IG5leHRVbm1hc2tlZENvbnRleHQgPyBpbnN0LmNvbnRleHQgOiB0aGlzLl9wcm9jZXNzQ29udGV4dChuZXh0VW5tYXNrZWRDb250ZXh0KTtcbiAgICB2YXIgbmV4dFByb3BzO1xuXG4gICAgLy8gRGlzdGluZ3Vpc2ggYmV0d2VlbiBhIHByb3BzIHVwZGF0ZSB2ZXJzdXMgYSBzaW1wbGUgc3RhdGUgdXBkYXRlXG4gICAgaWYgKHByZXZQYXJlbnRFbGVtZW50ID09PSBuZXh0UGFyZW50RWxlbWVudCkge1xuICAgICAgLy8gU2tpcCBjaGVja2luZyBwcm9wIHR5cGVzIGFnYWluIC0tIHdlIGRvbid0IHJlYWQgaW5zdC5wcm9wcyB0byBhdm9pZFxuICAgICAgLy8gd2FybmluZyBmb3IgRE9NIGNvbXBvbmVudCBwcm9wcyBpbiB0aGlzIHVwZ3JhZGVcbiAgICAgIG5leHRQcm9wcyA9IG5leHRQYXJlbnRFbGVtZW50LnByb3BzO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXh0UHJvcHMgPSB0aGlzLl9wcm9jZXNzUHJvcHMobmV4dFBhcmVudEVsZW1lbnQucHJvcHMpO1xuICAgICAgLy8gQW4gdXBkYXRlIGhlcmUgd2lsbCBzY2hlZHVsZSBhbiB1cGRhdGUgYnV0IGltbWVkaWF0ZWx5IHNldFxuICAgICAgLy8gX3BlbmRpbmdTdGF0ZVF1ZXVlIHdoaWNoIHdpbGwgZW5zdXJlIHRoYXQgYW55IHN0YXRlIHVwZGF0ZXMgZ2V0c1xuICAgICAgLy8gaW1tZWRpYXRlbHkgcmVjb25jaWxlZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIHRoZSBuZXh0IGJhdGNoLlxuXG4gICAgICBpZiAoaW5zdC5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzKSB7XG4gICAgICAgIGluc3QuY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgbmV4dFN0YXRlID0gdGhpcy5fcHJvY2Vzc1BlbmRpbmdTdGF0ZShuZXh0UHJvcHMsIG5leHRDb250ZXh0KTtcblxuICAgIHZhciBzaG91bGRVcGRhdGUgPSB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgfHwgIWluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlIHx8IGluc3Quc2hvdWxkQ29tcG9uZW50VXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHNob3VsZFVwZGF0ZSAhPT0gJ3VuZGVmaW5lZCcsICclcy5zaG91bGRDb21wb25lbnRVcGRhdGUoKTogUmV0dXJuZWQgdW5kZWZpbmVkIGluc3RlYWQgb2YgYSAnICsgJ2Jvb2xlYW4gdmFsdWUuIE1ha2Ugc3VyZSB0byByZXR1cm4gdHJ1ZSBvciBmYWxzZS4nLCB0aGlzLmdldE5hbWUoKSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAoc2hvdWxkVXBkYXRlKSB7XG4gICAgICB0aGlzLl9wZW5kaW5nRm9yY2VVcGRhdGUgPSBmYWxzZTtcbiAgICAgIC8vIFdpbGwgc2V0IGB0aGlzLnByb3BzYCwgYHRoaXMuc3RhdGVgIGFuZCBgdGhpcy5jb250ZXh0YC5cbiAgICAgIHRoaXMuX3BlcmZvcm1Db21wb25lbnRVcGRhdGUobmV4dFBhcmVudEVsZW1lbnQsIG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCwgdHJhbnNhY3Rpb24sIG5leHRVbm1hc2tlZENvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBpdCdzIGRldGVybWluZWQgdGhhdCBhIGNvbXBvbmVudCBzaG91bGQgbm90IHVwZGF0ZSwgd2Ugc3RpbGwgd2FudFxuICAgICAgLy8gdG8gc2V0IHByb3BzIGFuZCBzdGF0ZSBidXQgd2Ugc2hvcnRjdXQgdGhlIHJlc3Qgb2YgdGhlIHVwZGF0ZS5cbiAgICAgIHRoaXMuX2N1cnJlbnRFbGVtZW50ID0gbmV4dFBhcmVudEVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb250ZXh0ID0gbmV4dFVubWFza2VkQ29udGV4dDtcbiAgICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgICBpbnN0LnN0YXRlID0gbmV4dFN0YXRlO1xuICAgICAgaW5zdC5jb250ZXh0ID0gbmV4dENvbnRleHQ7XG4gICAgfVxuICB9LFxuXG4gIF9wcm9jZXNzUGVuZGluZ1N0YXRlOiBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuX2luc3RhbmNlO1xuICAgIHZhciBxdWV1ZSA9IHRoaXMuX3BlbmRpbmdTdGF0ZVF1ZXVlO1xuICAgIHZhciByZXBsYWNlID0gdGhpcy5fcGVuZGluZ1JlcGxhY2VTdGF0ZTtcbiAgICB0aGlzLl9wZW5kaW5nUmVwbGFjZVN0YXRlID0gZmFsc2U7XG4gICAgdGhpcy5fcGVuZGluZ1N0YXRlUXVldWUgPSBudWxsO1xuXG4gICAgaWYgKCFxdWV1ZSkge1xuICAgICAgcmV0dXJuIGluc3Quc3RhdGU7XG4gICAgfVxuXG4gICAgaWYgKHJlcGxhY2UgJiYgcXVldWUubGVuZ3RoID09PSAxKSB7XG4gICAgICByZXR1cm4gcXVldWVbMF07XG4gICAgfVxuXG4gICAgdmFyIG5leHRTdGF0ZSA9IGFzc2lnbih7fSwgcmVwbGFjZSA/IHF1ZXVlWzBdIDogaW5zdC5zdGF0ZSk7XG4gICAgZm9yICh2YXIgaSA9IHJlcGxhY2UgPyAxIDogMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcGFydGlhbCA9IHF1ZXVlW2ldO1xuICAgICAgYXNzaWduKG5leHRTdGF0ZSwgdHlwZW9mIHBhcnRpYWwgPT09ICdmdW5jdGlvbicgPyBwYXJ0aWFsLmNhbGwoaW5zdCwgbmV4dFN0YXRlLCBwcm9wcywgY29udGV4dCkgOiBwYXJ0aWFsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV4dFN0YXRlO1xuICB9LFxuXG4gIC8qKlxuICAgKiBNZXJnZXMgbmV3IHByb3BzIGFuZCBzdGF0ZSwgbm90aWZpZXMgZGVsZWdhdGUgbWV0aG9kcyBvZiB1cGRhdGUgYW5kXG4gICAqIHBlcmZvcm1zIHVwZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IG5leHRFbGVtZW50IE5leHQgZWxlbWVudFxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzIE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgcHJvcGVydGllcy5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGUgTmV4dCBvYmplY3QgdG8gc2V0IGFzIHN0YXRlLlxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0IE5leHQgcHVibGljIG9iamVjdCB0byBzZXQgYXMgY29udGV4dC5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9vYmplY3R9IHVubWFza2VkQ29udGV4dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3BlcmZvcm1Db21wb25lbnRVcGRhdGU6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgbmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0LCB0cmFuc2FjdGlvbiwgdW5tYXNrZWRDb250ZXh0KSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcblxuICAgIHZhciBoYXNDb21wb25lbnREaWRVcGRhdGUgPSBCb29sZWFuKGluc3QuY29tcG9uZW50RGlkVXBkYXRlKTtcbiAgICB2YXIgcHJldlByb3BzO1xuICAgIHZhciBwcmV2U3RhdGU7XG4gICAgdmFyIHByZXZDb250ZXh0O1xuICAgIGlmIChoYXNDb21wb25lbnREaWRVcGRhdGUpIHtcbiAgICAgIHByZXZQcm9wcyA9IGluc3QucHJvcHM7XG4gICAgICBwcmV2U3RhdGUgPSBpbnN0LnN0YXRlO1xuICAgICAgcHJldkNvbnRleHQgPSBpbnN0LmNvbnRleHQ7XG4gICAgfVxuXG4gICAgaWYgKGluc3QuY29tcG9uZW50V2lsbFVwZGF0ZSkge1xuICAgICAgaW5zdC5jb21wb25lbnRXaWxsVXBkYXRlKG5leHRQcm9wcywgbmV4dFN0YXRlLCBuZXh0Q29udGV4dCk7XG4gICAgfVxuXG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBuZXh0RWxlbWVudDtcbiAgICB0aGlzLl9jb250ZXh0ID0gdW5tYXNrZWRDb250ZXh0O1xuICAgIGluc3QucHJvcHMgPSBuZXh0UHJvcHM7XG4gICAgaW5zdC5zdGF0ZSA9IG5leHRTdGF0ZTtcbiAgICBpbnN0LmNvbnRleHQgPSBuZXh0Q29udGV4dDtcblxuICAgIHRoaXMuX3VwZGF0ZVJlbmRlcmVkQ29tcG9uZW50KHRyYW5zYWN0aW9uLCB1bm1hc2tlZENvbnRleHQpO1xuXG4gICAgaWYgKGhhc0NvbXBvbmVudERpZFVwZGF0ZSkge1xuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShpbnN0LmNvbXBvbmVudERpZFVwZGF0ZS5iaW5kKGluc3QsIHByZXZQcm9wcywgcHJldlN0YXRlLCBwcmV2Q29udGV4dCksIGluc3QpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQ2FsbCB0aGUgY29tcG9uZW50J3MgYHJlbmRlcmAgbWV0aG9kIGFuZCB1cGRhdGUgdGhlIERPTSBhY2NvcmRpbmdseS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIF91cGRhdGVSZW5kZXJlZENvbXBvbmVudDogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIHByZXZDb21wb25lbnRJbnN0YW5jZSA9IHRoaXMuX3JlbmRlcmVkQ29tcG9uZW50O1xuICAgIHZhciBwcmV2UmVuZGVyZWRFbGVtZW50ID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9jdXJyZW50RWxlbWVudDtcbiAgICB2YXIgbmV4dFJlbmRlcmVkRWxlbWVudCA9IHRoaXMuX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudCgpO1xuICAgIGlmIChzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2UmVuZGVyZWRFbGVtZW50LCBuZXh0UmVuZGVyZWRFbGVtZW50KSkge1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnJlY2VpdmVDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlLCBuZXh0UmVuZGVyZWRFbGVtZW50LCB0cmFuc2FjdGlvbiwgdGhpcy5fcHJvY2Vzc0NoaWxkQ29udGV4dChjb250ZXh0KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZXNlIHR3byBJRHMgYXJlIGFjdHVhbGx5IHRoZSBzYW1lISBCdXQgbm90aGluZyBzaG91bGQgcmVseSBvbiB0aGF0LlxuICAgICAgdmFyIHRoaXNJRCA9IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICB2YXIgcHJldkNvbXBvbmVudElEID0gcHJldkNvbXBvbmVudEluc3RhbmNlLl9yb290Tm9kZUlEO1xuICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocHJldkNvbXBvbmVudEluc3RhbmNlKTtcblxuICAgICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSB0aGlzLl9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRSZW5kZXJlZEVsZW1lbnQpO1xuICAgICAgdmFyIG5leHRNYXJrdXAgPSBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHRoaXNJRCwgdHJhbnNhY3Rpb24sIHRoaXMuX3Byb2Nlc3NDaGlsZENvbnRleHQoY29udGV4dCkpO1xuICAgICAgdGhpcy5fcmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQ6IGZ1bmN0aW9uIChwcmV2Q29tcG9uZW50SUQsIG5leHRNYXJrdXApIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnJlcGxhY2VOb2RlV2l0aE1hcmt1cEJ5SUQocHJldkNvbXBvbmVudElELCBuZXh0TWFya3VwKTtcbiAgfSxcblxuICAvKipcbiAgICogQHByb3RlY3RlZFxuICAgKi9cbiAgX3JlbmRlclZhbGlkYXRlZENvbXBvbmVudFdpdGhvdXRPd25lck9yQ29udGV4dDogZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbnN0ID0gdGhpcy5faW5zdGFuY2U7XG4gICAgdmFyIHJlbmRlcmVkQ29tcG9uZW50ID0gaW5zdC5yZW5kZXIoKTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICBpZiAodHlwZW9mIHJlbmRlcmVkQ29tcG9uZW50ID09PSAndW5kZWZpbmVkJyAmJiBpbnN0LnJlbmRlci5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgLy8gVGhpcyBpcyBwcm9iYWJseSBiYWQgcHJhY3RpY2UuIENvbnNpZGVyIHdhcm5pbmcgaGVyZSBhbmRcbiAgICAgICAgLy8gZGVwcmVjYXRpbmcgdGhpcyBjb252ZW5pZW5jZS5cbiAgICAgICAgcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVuZGVyZWRDb21wb25lbnQ7XG4gICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXM7XG4gICAgdHJ5IHtcbiAgICAgIHJlbmRlcmVkQ29tcG9uZW50ID0gdGhpcy5fcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50V2l0aG91dE93bmVyT3JDb250ZXh0KCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICAhKFxuICAgIC8vIFRPRE86IEFuIGBpc1ZhbGlkTm9kZWAgZnVuY3Rpb24gd291bGQgcHJvYmFibHkgYmUgbW9yZSBhcHByb3ByaWF0ZVxuICAgIHJlbmRlcmVkQ29tcG9uZW50ID09PSBudWxsIHx8IHJlbmRlcmVkQ29tcG9uZW50ID09PSBmYWxzZSB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQocmVuZGVyZWRDb21wb25lbnQpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5yZW5kZXIoKTogQSB2YWxpZCBSZWFjdENvbXBvbmVudCBtdXN0IGJlIHJldHVybmVkLiBZb3UgbWF5IGhhdmUgJyArICdyZXR1cm5lZCB1bmRlZmluZWQsIGFuIGFycmF5IG9yIHNvbWUgb3RoZXIgaW52YWxpZCBvYmplY3QuJywgdGhpcy5nZXROYW1lKCkgfHwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50JykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgIHJldHVybiByZW5kZXJlZENvbXBvbmVudDtcbiAgfSxcblxuICAvKipcbiAgICogTGF6aWx5IGFsbG9jYXRlcyB0aGUgcmVmcyBvYmplY3QgYW5kIHN0b3JlcyBgY29tcG9uZW50YCBhcyBgcmVmYC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJlZiBSZWZlcmVuY2UgbmFtZS5cbiAgICogQHBhcmFtIHtjb21wb25lbnR9IGNvbXBvbmVudCBDb21wb25lbnQgdG8gc3RvcmUgYXMgYHJlZmAuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXR0YWNoUmVmOiBmdW5jdGlvbiAocmVmLCBjb21wb25lbnQpIHtcbiAgICB2YXIgaW5zdCA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKTtcbiAgICAhKGluc3QgIT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGhhdmUgcmVmcy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIHB1YmxpY0NvbXBvbmVudEluc3RhbmNlID0gY29tcG9uZW50LmdldFB1YmxpY0luc3RhbmNlKCk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50ICYmIGNvbXBvbmVudC5nZXROYW1lID8gY29tcG9uZW50LmdldE5hbWUoKSA6ICdhIGNvbXBvbmVudCc7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwdWJsaWNDb21wb25lbnRJbnN0YW5jZSAhPSBudWxsLCAnU3RhdGVsZXNzIGZ1bmN0aW9uIGNvbXBvbmVudHMgY2Fubm90IGJlIGdpdmVuIHJlZnMgJyArICcoU2VlIHJlZiBcIiVzXCIgaW4gJXMgY3JlYXRlZCBieSAlcykuICcgKyAnQXR0ZW1wdHMgdG8gYWNjZXNzIHRoaXMgcmVmIHdpbGwgZmFpbC4nLCByZWYsIGNvbXBvbmVudE5hbWUsIHRoaXMuZ2V0TmFtZSgpKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgdmFyIHJlZnMgPSBpbnN0LnJlZnMgPT09IGVtcHR5T2JqZWN0ID8gaW5zdC5yZWZzID0ge30gOiBpbnN0LnJlZnM7XG4gICAgcmVmc1tyZWZdID0gcHVibGljQ29tcG9uZW50SW5zdGFuY2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIERldGFjaGVzIGEgcmVmZXJlbmNlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSByZWYgTmFtZSB0byBkZXJlZmVyZW5jZS5cbiAgICogQGZpbmFsXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXRhY2hSZWY6IGZ1bmN0aW9uIChyZWYpIHtcbiAgICB2YXIgcmVmcyA9IHRoaXMuZ2V0UHVibGljSW5zdGFuY2UoKS5yZWZzO1xuICAgIGRlbGV0ZSByZWZzW3JlZl07XG4gIH0sXG5cbiAgLyoqXG4gICAqIEdldCBhIHRleHQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbXBvbmVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIGlkZW50aWZ5IGl0XG4gICAqIGluIGVycm9yIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBuYW1lIG9yIG51bGwuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZ2V0TmFtZTogZnVuY3Rpb24gKCkge1xuICAgIHZhciB0eXBlID0gdGhpcy5fY3VycmVudEVsZW1lbnQudHlwZTtcbiAgICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLl9pbnN0YW5jZSAmJiB0aGlzLl9pbnN0YW5jZS5jb25zdHJ1Y3RvcjtcbiAgICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCBjb25zdHJ1Y3RvciAmJiBjb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgY29uc3RydWN0b3IgJiYgY29uc3RydWN0b3IubmFtZSB8fCBudWxsO1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIHB1YmxpY2x5IGFjY2Vzc2libGUgcmVwcmVzZW50YXRpb24gb2YgdGhpcyBjb21wb25lbnQgLSBpLmUuIHdoYXRcbiAgICogaXMgZXhwb3NlZCBieSByZWZzIGFuZCByZXR1cm5lZCBieSByZW5kZXIuIENhbiBiZSBudWxsIGZvciBzdGF0ZWxlc3NcbiAgICogY29tcG9uZW50cy5cbiAgICpcbiAgICogQHJldHVybiB7UmVhY3RDb21wb25lbnR9IHRoZSBwdWJsaWMgY29tcG9uZW50IGluc3RhbmNlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGdldFB1YmxpY0luc3RhbmNlOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGluc3QgPSB0aGlzLl9pbnN0YW5jZTtcbiAgICBpZiAoaW5zdCBpbnN0YW5jZW9mIFN0YXRlbGVzc0NvbXBvbmVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBpbnN0O1xuICB9LFxuXG4gIC8vIFN0dWJcbiAgX2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQ6IG51bGxcblxufTtcblxuUmVhY3RQZXJmLm1lYXN1cmVNZXRob2RzKFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50TWl4aW4sICdSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCcsIHtcbiAgbW91bnRDb21wb25lbnQ6ICdtb3VudENvbXBvbmVudCcsXG4gIHVwZGF0ZUNvbXBvbmVudDogJ3VwZGF0ZUNvbXBvbmVudCcsXG4gIF9yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQ6ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50J1xufSk7XG5cbnZhciBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCA9IHtcblxuICBNaXhpbjogUmVhY3RDb21wb3NpdGVDb21wb25lbnRNaXhpblxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0Q29tcG9zaXRlQ29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxudmFyIGluamVjdGVkID0gZmFsc2U7XG5cbnZhciBSZWFjdENvbXBvbmVudEVudmlyb25tZW50ID0ge1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgZW52aXJvbm1lbnQgZGVwZW5kZW50IGNsZWFudXAgaG9vay4gKHNlcnZlciB2cy5cbiAgICogYnJvd3NlciBldGMpLiBFeGFtcGxlOiBBIGJyb3dzZXIgc3lzdGVtIGNhY2hlcyBET00gbm9kZXMgYmFzZWQgb24gY29tcG9uZW50XG4gICAqIElEIGFuZCBtdXN0IHJlbW92ZSB0aGF0IGNhY2hlIGVudHJ5IHdoZW4gdGhpcyBpbnN0YW5jZSBpcyB1bm1vdW50ZWQuXG4gICAqL1xuICB1bm1vdW50SURGcm9tRW52aXJvbm1lbnQ6IG51bGwsXG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsbHkgaW5qZWN0YWJsZSBob29rIGZvciBzd2FwcGluZyBvdXQgbW91bnQgaW1hZ2VzIGluIHRoZSBtaWRkbGUgb2ZcbiAgICogdGhlIHRyZWUuXG4gICAqL1xuICByZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEOiBudWxsLFxuXG4gIC8qKlxuICAgKiBPcHRpb25hbGx5IGluamVjdGFibGUgaG9vayBmb3IgcHJvY2Vzc2luZyBhIHF1ZXVlIG9mIGNoaWxkIHVwZGF0ZXMuIFdpbGxcbiAgICogbGF0ZXIgbW92ZSBpbnRvIE11bHRpQ2hpbGRDb21wb25lbnRzLlxuICAgKi9cbiAgcHJvY2Vzc0NoaWxkcmVuVXBkYXRlczogbnVsbCxcblxuICBpbmplY3Rpb246IHtcbiAgICBpbmplY3RFbnZpcm9ubWVudDogZnVuY3Rpb24gKGVudmlyb25tZW50KSB7XG4gICAgICAhIWluamVjdGVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q29tcG9zaXRlQ29tcG9uZW50OiBpbmplY3RFbnZpcm9ubWVudCgpIGNhbiBvbmx5IGJlIGNhbGxlZCBvbmNlLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50ID0gZW52aXJvbm1lbnQudW5tb3VudElERnJvbUVudmlyb25tZW50O1xuICAgICAgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudC5yZXBsYWNlTm9kZVdpdGhNYXJrdXBCeUlEID0gZW52aXJvbm1lbnQucmVwbGFjZU5vZGVXaXRoTWFya3VwQnlJRDtcbiAgICAgIFJlYWN0Q29tcG9uZW50RW52aXJvbm1lbnQucHJvY2Vzc0NoaWxkcmVuVXBkYXRlcyA9IGVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXM7XG4gICAgICBpbmplY3RlZCA9IHRydWU7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudEVudmlyb25tZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSBrZXlNaXJyb3Ioe1xuICBwcm9wOiBudWxsLFxuICBjb250ZXh0OiBudWxsLFxuICBjaGlsZENvbnRleHQ6IG51bGxcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbnM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzID0ge1xuICAgIHByb3A6ICdwcm9wJyxcbiAgICBjb250ZXh0OiAnY29udGV4dCcsXG4gICAgY2hpbGRDb250ZXh0OiAnY2hpbGQgY29udGV4dCdcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogR2l2ZW4gYSBgcHJldkVsZW1lbnRgIGFuZCBgbmV4dEVsZW1lbnRgLCBkZXRlcm1pbmVzIGlmIHRoZSBleGlzdGluZ1xuICogaW5zdGFuY2Ugc2hvdWxkIGJlIHVwZGF0ZWQgYXMgb3Bwb3NlZCB0byBiZWluZyBkZXN0cm95ZWQgb3IgcmVwbGFjZWQgYnkgYSBuZXdcbiAqIGluc3RhbmNlLiBCb3RoIGFyZ3VtZW50cyBhcmUgZWxlbWVudHMuIFRoaXMgZW5zdXJlcyB0aGF0IHRoaXMgbG9naWMgY2FuXG4gKiBvcGVyYXRlIG9uIHN0YXRlbGVzcyB0cmVlcyB3aXRob3V0IGFueSBiYWNraW5nIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJldkVsZW1lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gbmV4dEVsZW1lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGV4aXN0aW5nIGluc3RhbmNlIHNob3VsZCBiZSB1cGRhdGVkLlxuICogQHByb3RlY3RlZFxuICovXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVSZWFjdENvbXBvbmVudChwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQpIHtcbiAgdmFyIHByZXZFbXB0eSA9IHByZXZFbGVtZW50ID09PSBudWxsIHx8IHByZXZFbGVtZW50ID09PSBmYWxzZTtcbiAgdmFyIG5leHRFbXB0eSA9IG5leHRFbGVtZW50ID09PSBudWxsIHx8IG5leHRFbGVtZW50ID09PSBmYWxzZTtcbiAgaWYgKHByZXZFbXB0eSB8fCBuZXh0RW1wdHkpIHtcbiAgICByZXR1cm4gcHJldkVtcHR5ID09PSBuZXh0RW1wdHk7XG4gIH1cblxuICB2YXIgcHJldlR5cGUgPSB0eXBlb2YgcHJldkVsZW1lbnQ7XG4gIHZhciBuZXh0VHlwZSA9IHR5cGVvZiBuZXh0RWxlbWVudDtcbiAgaWYgKHByZXZUeXBlID09PSAnc3RyaW5nJyB8fCBwcmV2VHlwZSA9PT0gJ251bWJlcicpIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdzdHJpbmcnIHx8IG5leHRUeXBlID09PSAnbnVtYmVyJztcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV4dFR5cGUgPT09ICdvYmplY3QnICYmIHByZXZFbGVtZW50LnR5cGUgPT09IG5leHRFbGVtZW50LnR5cGUgJiYgcHJldkVsZW1lbnQua2V5ID09PSBuZXh0RWxlbWVudC5rZXk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RW1wdHlDb21wb25lbnRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RW1wdHlDb21wb25lbnRSZWdpc3RyeSA9IHJlcXVpcmUoJy4vUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5Jyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG52YXIgcGxhY2Vob2xkZXJFbGVtZW50O1xuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudEluamVjdGlvbiA9IHtcbiAgaW5qZWN0RW1wdHlDb21wb25lbnQ6IGZ1bmN0aW9uIChjb21wb25lbnQpIHtcbiAgICBwbGFjZWhvbGRlckVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudChjb21wb25lbnQpO1xuICB9XG59O1xuXG5mdW5jdGlvbiByZWdpc3Rlck51bGxDb21wb25lbnRJRCgpIHtcbiAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LnJlZ2lzdGVyTnVsbENvbXBvbmVudElEKHRoaXMuX3Jvb3ROb2RlSUQpO1xufVxuXG52YXIgUmVhY3RFbXB0eUNvbXBvbmVudCA9IGZ1bmN0aW9uIChpbnN0YW50aWF0ZSkge1xuICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl9yZW5kZXJlZENvbXBvbmVudCA9IGluc3RhbnRpYXRlKHBsYWNlaG9sZGVyRWxlbWVudCk7XG59O1xuYXNzaWduKFJlYWN0RW1wdHlDb21wb25lbnQucHJvdG90eXBlLCB7XG4gIGNvbnN0cnVjdDogZnVuY3Rpb24gKGVsZW1lbnQpIHt9LFxuICBtb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB0cmFuc2FjdGlvbi5nZXRSZWFjdE1vdW50UmVhZHkoKS5lbnF1ZXVlKHJlZ2lzdGVyTnVsbENvbXBvbmVudElELCB0aGlzKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gcm9vdElEO1xuICAgIHJldHVybiBSZWFjdFJlY29uY2lsZXIubW91bnRDb21wb25lbnQodGhpcy5fcmVuZGVyZWRDb21wb25lbnQsIHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICB9LFxuICByZWNlaXZlQ29tcG9uZW50OiBmdW5jdGlvbiAoKSB7fSxcbiAgdW5tb3VudENvbXBvbmVudDogZnVuY3Rpb24gKHJvb3RJRCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudCh0aGlzLl9yZW5kZXJlZENvbXBvbmVudCk7XG4gICAgUmVhY3RFbXB0eUNvbXBvbmVudFJlZ2lzdHJ5LmRlcmVnaXN0ZXJOdWxsQ29tcG9uZW50SUQodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgdGhpcy5fcm9vdE5vZGVJRCA9IG51bGw7XG4gICAgdGhpcy5fcmVuZGVyZWRDb21wb25lbnQgPSBudWxsO1xuICB9XG59KTtcblxuUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24gPSBSZWFjdEVtcHR5Q29tcG9uZW50SW5qZWN0aW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RW1wdHlDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RFbXB0eUNvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE5hdGl2ZUNvbXBvbmVudFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG52YXIgYXV0b0dlbmVyYXRlV3JhcHBlckNsYXNzID0gbnVsbDtcbnZhciBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBudWxsO1xuLy8gVGhpcyByZWdpc3RyeSBrZWVwcyB0cmFjayBvZiB3cmFwcGVyIGNsYXNzZXMgYXJvdW5kIG5hdGl2ZSB0YWdzLlxudmFyIHRhZ1RvQ29tcG9uZW50Q2xhc3MgPSB7fTtcbnZhciB0ZXh0Q29tcG9uZW50Q2xhc3MgPSBudWxsO1xuXG52YXIgUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb24gPSB7XG4gIC8vIFRoaXMgYWNjZXB0cyBhIGNsYXNzIHRoYXQgcmVjZWl2ZXMgdGhlIHRhZyBzdHJpbmcuIFRoaXMgaXMgYSBjYXRjaCBhbGxcbiAgLy8gdGhhdCBjYW4gcmVuZGVyIGFueSBraW5kIG9mIHRhZy5cbiAgaW5qZWN0R2VuZXJpY0NvbXBvbmVudENsYXNzOiBmdW5jdGlvbiAoY29tcG9uZW50Q2xhc3MpIHtcbiAgICBnZW5lcmljQ29tcG9uZW50Q2xhc3MgPSBjb21wb25lbnRDbGFzcztcbiAgfSxcbiAgLy8gVGhpcyBhY2NlcHRzIGEgdGV4dCBjb21wb25lbnQgY2xhc3MgdGhhdCB0YWtlcyB0aGUgdGV4dCBzdHJpbmcgdG8gYmVcbiAgLy8gcmVuZGVyZWQgYXMgcHJvcHMuXG4gIGluamVjdFRleHRDb21wb25lbnRDbGFzczogZnVuY3Rpb24gKGNvbXBvbmVudENsYXNzKSB7XG4gICAgdGV4dENvbXBvbmVudENsYXNzID0gY29tcG9uZW50Q2xhc3M7XG4gIH0sXG4gIC8vIFRoaXMgYWNjZXB0cyBhIGtleWVkIG9iamVjdCB3aXRoIGNsYXNzZXMgYXMgdmFsdWVzLiBFYWNoIGtleSByZXByZXNlbnRzIGFcbiAgLy8gdGFnLiBUaGF0IHBhcnRpY3VsYXIgdGFnIHdpbGwgdXNlIHRoaXMgY2xhc3MgaW5zdGVhZCBvZiB0aGUgZ2VuZXJpYyBvbmUuXG4gIGluamVjdENvbXBvbmVudENsYXNzZXM6IGZ1bmN0aW9uIChjb21wb25lbnRDbGFzc2VzKSB7XG4gICAgYXNzaWduKHRhZ1RvQ29tcG9uZW50Q2xhc3MsIGNvbXBvbmVudENsYXNzZXMpO1xuICB9XG59O1xuXG4vKipcbiAqIEdldCBhIGNvbXBvc2l0ZSBjb21wb25lbnQgd3JhcHBlciBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIHRhZyBmb3Igd2hpY2ggdG8gZ2V0IHRoZSBjbGFzcy5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgUmVhY3QgY2xhc3MgY29uc3RydWN0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudChlbGVtZW50KSB7XG4gIGlmICh0eXBlb2YgZWxlbWVudC50eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQudHlwZTtcbiAgfVxuICB2YXIgdGFnID0gZWxlbWVudC50eXBlO1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSB0YWdUb0NvbXBvbmVudENsYXNzW3RhZ107XG4gIGlmIChjb21wb25lbnRDbGFzcyA9PSBudWxsKSB7XG4gICAgdGFnVG9Db21wb25lbnRDbGFzc1t0YWddID0gY29tcG9uZW50Q2xhc3MgPSBhdXRvR2VuZXJhdGVXcmFwcGVyQ2xhc3ModGFnKTtcbiAgfVxuICByZXR1cm4gY29tcG9uZW50Q2xhc3M7XG59XG5cbi8qKlxuICogR2V0IGEgbmF0aXZlIGludGVybmFsIGNvbXBvbmVudCBjbGFzcyBmb3IgYSBzcGVjaWZpYyB0YWcuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgVGhlIGVsZW1lbnQgdG8gY3JlYXRlLlxuICogQHJldHVybiB7ZnVuY3Rpb259IFRoZSBpbnRlcm5hbCBjbGFzcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW50ZXJuYWxDb21wb25lbnQoZWxlbWVudCkge1xuICAhZ2VuZXJpY0NvbXBvbmVudENsYXNzID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZXJlIGlzIG5vIHJlZ2lzdGVyZWQgY29tcG9uZW50IGZvciB0aGUgdGFnICVzJywgZWxlbWVudC50eXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIHJldHVybiBuZXcgZ2VuZXJpY0NvbXBvbmVudENsYXNzKGVsZW1lbnQudHlwZSwgZWxlbWVudC5wcm9wcyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdFRleHR9IHRleHRcbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZUZvclRleHQodGV4dCkge1xuICByZXR1cm4gbmV3IHRleHRDb21wb25lbnRDbGFzcyh0ZXh0KTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjb21wb25lbnRcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVGV4dENvbXBvbmVudChjb21wb25lbnQpIHtcbiAgcmV0dXJuIGNvbXBvbmVudCBpbnN0YW5jZW9mIHRleHRDb21wb25lbnRDbGFzcztcbn1cblxudmFyIFJlYWN0TmF0aXZlQ29tcG9uZW50ID0ge1xuICBnZXRDb21wb25lbnRDbGFzc0ZvckVsZW1lbnQ6IGdldENvbXBvbmVudENsYXNzRm9yRWxlbWVudCxcbiAgY3JlYXRlSW50ZXJuYWxDb21wb25lbnQ6IGNyZWF0ZUludGVybmFsQ29tcG9uZW50LFxuICBjcmVhdGVJbnN0YW5jZUZvclRleHQ6IGNyZWF0ZUluc3RhbmNlRm9yVGV4dCxcbiAgaXNUZXh0Q29tcG9uZW50OiBpc1RleHRDb21wb25lbnQsXG4gIGluamVjdGlvbjogUmVhY3ROYXRpdmVDb21wb25lbnRJbmplY3Rpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3ROYXRpdmVDb21wb25lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3ROYXRpdmVDb21wb25lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHZhbGlkYXRlRE9NTmVzdGluZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IGVtcHR5RnVuY3Rpb247XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIC8vIFRoaXMgdmFsaWRhdGlvbiBjb2RlIHdhcyB3cml0dGVuIGJhc2VkIG9uIHRoZSBIVE1MNSBwYXJzaW5nIHNwZWM6XG4gIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2hhcy1hbi1lbGVtZW50LWluLXNjb3BlXG4gIC8vXG4gIC8vIE5vdGU6IHRoaXMgZG9lcyBub3QgY2F0Y2ggYWxsIGludmFsaWQgbmVzdGluZywgbm9yIGRvZXMgaXQgdHJ5IHRvIChhcyBpdCdzXG4gIC8vIG5vdCBjbGVhciB3aGF0IHByYWN0aWNhbCBiZW5lZml0IGRvaW5nIHNvIHByb3ZpZGVzKTsgaW5zdGVhZCwgd2Ugd2FybiBvbmx5XG4gIC8vIGZvciBjYXNlcyB3aGVyZSB0aGUgcGFyc2VyIHdpbGwgZ2l2ZSBhIHBhcnNlIHRyZWUgZGlmZmVyaW5nIGZyb20gd2hhdCBSZWFjdFxuICAvLyBpbnRlbmRlZC4gRm9yIGV4YW1wbGUsIDxiPjxkaXY+PC9kaXY+PC9iPiBpcyBpbnZhbGlkIGJ1dCB3ZSBkb24ndCB3YXJuXG4gIC8vIGJlY2F1c2UgaXQgc3RpbGwgcGFyc2VzIGNvcnJlY3RseTsgd2UgZG8gd2FybiBmb3Igb3RoZXIgY2FzZXMgbGlrZSBuZXN0ZWRcbiAgLy8gPHA+IHRhZ3Mgd2hlcmUgdGhlIGJlZ2lubmluZyBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgaW1wbGljaXRseSBjbG9zZXMgdGhlXG4gIC8vIGZpcnN0LCBjYXVzaW5nIGEgY29uZnVzaW5nIG1lc3MuXG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjc3BlY2lhbFxuICB2YXIgc3BlY2lhbFRhZ3MgPSBbJ2FkZHJlc3MnLCAnYXBwbGV0JywgJ2FyZWEnLCAnYXJ0aWNsZScsICdhc2lkZScsICdiYXNlJywgJ2Jhc2Vmb250JywgJ2Jnc291bmQnLCAnYmxvY2txdW90ZScsICdib2R5JywgJ2JyJywgJ2J1dHRvbicsICdjYXB0aW9uJywgJ2NlbnRlcicsICdjb2wnLCAnY29sZ3JvdXAnLCAnZGQnLCAnZGV0YWlscycsICdkaXInLCAnZGl2JywgJ2RsJywgJ2R0JywgJ2VtYmVkJywgJ2ZpZWxkc2V0JywgJ2ZpZ2NhcHRpb24nLCAnZmlndXJlJywgJ2Zvb3RlcicsICdmb3JtJywgJ2ZyYW1lJywgJ2ZyYW1lc2V0JywgJ2gxJywgJ2gyJywgJ2gzJywgJ2g0JywgJ2g1JywgJ2g2JywgJ2hlYWQnLCAnaGVhZGVyJywgJ2hncm91cCcsICdocicsICdodG1sJywgJ2lmcmFtZScsICdpbWcnLCAnaW5wdXQnLCAnaXNpbmRleCcsICdsaScsICdsaW5rJywgJ2xpc3RpbmcnLCAnbWFpbicsICdtYXJxdWVlJywgJ21lbnUnLCAnbWVudWl0ZW0nLCAnbWV0YScsICduYXYnLCAnbm9lbWJlZCcsICdub2ZyYW1lcycsICdub3NjcmlwdCcsICdvYmplY3QnLCAnb2wnLCAncCcsICdwYXJhbScsICdwbGFpbnRleHQnLCAncHJlJywgJ3NjcmlwdCcsICdzZWN0aW9uJywgJ3NlbGVjdCcsICdzb3VyY2UnLCAnc3R5bGUnLCAnc3VtbWFyeScsICd0YWJsZScsICd0Ym9keScsICd0ZCcsICd0ZW1wbGF0ZScsICd0ZXh0YXJlYScsICd0Zm9vdCcsICd0aCcsICd0aGVhZCcsICd0aXRsZScsICd0cicsICd0cmFjaycsICd1bCcsICd3YnInLCAneG1wJ107XG5cbiAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjaGFzLWFuLWVsZW1lbnQtaW4tc2NvcGVcbiAgdmFyIGluU2NvcGVUYWdzID0gWydhcHBsZXQnLCAnY2FwdGlvbicsICdodG1sJywgJ3RhYmxlJywgJ3RkJywgJ3RoJywgJ21hcnF1ZWUnLCAnb2JqZWN0JywgJ3RlbXBsYXRlJyxcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNodG1sLWludGVncmF0aW9uLXBvaW50XG4gIC8vIFRPRE86IERpc3Rpbmd1aXNoIGJ5IG5hbWVzcGFjZSBoZXJlIC0tIGZvciA8dGl0bGU+LCBpbmNsdWRpbmcgaXQgaGVyZVxuICAvLyBlcnJzIG9uIHRoZSBzaWRlIG9mIGZld2VyIHdhcm5pbmdzXG4gICdmb3JlaWduT2JqZWN0JywgJ2Rlc2MnLCAndGl0bGUnXTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNoYXMtYW4tZWxlbWVudC1pbi1idXR0b24tc2NvcGVcbiAgdmFyIGJ1dHRvblNjb3BlVGFncyA9IGluU2NvcGVUYWdzLmNvbmNhdChbJ2J1dHRvbiddKTtcblxuICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNnZW5lcmF0ZS1pbXBsaWVkLWVuZC10YWdzXG4gIHZhciBpbXBsaWVkRW5kVGFncyA9IFsnZGQnLCAnZHQnLCAnbGknLCAnb3B0aW9uJywgJ29wdGdyb3VwJywgJ3AnLCAncnAnLCAncnQnXTtcblxuICB2YXIgZW1wdHlBbmNlc3RvckluZm8gPSB7XG4gICAgcGFyZW50VGFnOiBudWxsLFxuXG4gICAgZm9ybVRhZzogbnVsbCxcbiAgICBhVGFnSW5TY29wZTogbnVsbCxcbiAgICBidXR0b25UYWdJblNjb3BlOiBudWxsLFxuICAgIG5vYnJUYWdJblNjb3BlOiBudWxsLFxuICAgIHBUYWdJbkJ1dHRvblNjb3BlOiBudWxsLFxuXG4gICAgbGlzdEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbCxcbiAgICBkbEl0ZW1UYWdBdXRvY2xvc2luZzogbnVsbFxuICB9O1xuXG4gIHZhciB1cGRhdGVkQW5jZXN0b3JJbmZvID0gZnVuY3Rpb24gKG9sZEluZm8sIHRhZywgaW5zdGFuY2UpIHtcbiAgICB2YXIgYW5jZXN0b3JJbmZvID0gYXNzaWduKHt9LCBvbGRJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvKTtcbiAgICB2YXIgaW5mbyA9IHsgdGFnOiB0YWcsIGluc3RhbmNlOiBpbnN0YW5jZSB9O1xuXG4gICAgaWYgKGluU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IG51bGw7XG4gICAgICBhbmNlc3RvckluZm8ubm9iclRhZ0luU2NvcGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYnV0dG9uU2NvcGVUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5wVGFnSW5CdXR0b25TY29wZSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VlIHJ1bGVzIGZvciAnbGknLCAnZGQnLCAnZHQnIHN0YXJ0IHRhZ3MgaW5cbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW5ib2R5XG4gICAgaWYgKHNwZWNpYWxUYWdzLmluZGV4T2YodGFnKSAhPT0gLTEgJiYgdGFnICE9PSAnYWRkcmVzcycgJiYgdGFnICE9PSAnZGl2JyAmJiB0YWcgIT09ICdwJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmxpc3RJdGVtVGFnQXV0b2Nsb3NpbmcgPSBudWxsO1xuICAgICAgYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nID0gbnVsbDtcbiAgICB9XG5cbiAgICBhbmNlc3RvckluZm8ucGFyZW50VGFnID0gaW5mbztcblxuICAgIGlmICh0YWcgPT09ICdmb3JtJykge1xuICAgICAgYW5jZXN0b3JJbmZvLmZvcm1UYWcgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnYScpIHtcbiAgICAgIGFuY2VzdG9ySW5mby5hVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdidXR0b24nKSB7XG4gICAgICBhbmNlc3RvckluZm8uYnV0dG9uVGFnSW5TY29wZSA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdub2JyJykge1xuICAgICAgYW5jZXN0b3JJbmZvLm5vYnJUYWdJblNjb3BlID0gaW5mbztcbiAgICB9XG4gICAgaWYgKHRhZyA9PT0gJ3AnKSB7XG4gICAgICBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGUgPSBpbmZvO1xuICAgIH1cbiAgICBpZiAodGFnID09PSAnbGknKSB7XG4gICAgICBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZyA9IGluZm87XG4gICAgfVxuICAgIGlmICh0YWcgPT09ICdkZCcgfHwgdGFnID09PSAnZHQnKSB7XG4gICAgICBhbmNlc3RvckluZm8uZGxJdGVtVGFnQXV0b2Nsb3NpbmcgPSBpbmZvO1xuICAgIH1cblxuICAgIHJldHVybiBhbmNlc3RvckluZm87XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgd2hldGhlclxuICAgKi9cbiAgdmFyIGlzVGFnVmFsaWRXaXRoUGFyZW50ID0gZnVuY3Rpb24gKHRhZywgcGFyZW50VGFnKSB7XG4gICAgLy8gRmlyc3QsIGxldCdzIGNoZWNrIGlmIHdlJ3JlIGluIGFuIHVudXN1YWwgcGFyc2luZyBtb2RlLi4uXG4gICAgc3dpdGNoIChwYXJlbnRUYWcpIHtcbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnNlbGVjdFxuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnb3B0Z3JvdXAnIHx8IHRhZyA9PT0gJyN0ZXh0JztcbiAgICAgIGNhc2UgJ29wdGdyb3VwJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ29wdGlvbicgfHwgdGFnID09PSAnI3RleHQnO1xuICAgICAgLy8gU3RyaWN0bHkgc3BlYWtpbmcsIHNlZWluZyBhbiA8b3B0aW9uPiBkb2Vzbid0IG1lYW4gd2UncmUgaW4gYSA8c2VsZWN0PlxuICAgICAgLy8gYnV0XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnI3RleHQnO1xuXG4gICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCNwYXJzaW5nLW1haW4taW50ZFxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluY2FwdGlvblxuICAgICAgLy8gTm8gc3BlY2lhbCBiZWhhdmlvciBzaW5jZSB0aGVzZSBydWxlcyBmYWxsIGJhY2sgdG8gXCJpbiBib2R5XCIgbW9kZSBmb3JcbiAgICAgIC8vIGFsbCBleGNlcHQgc3BlY2lhbCB0YWJsZSBub2RlcyB3aGljaCBjYXVzZSBiYWQgcGFyc2luZyBiZWhhdmlvciBhbnl3YXkuXG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbnRyXG4gICAgICBjYXNlICd0cic6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICd0aCcgfHwgdGFnID09PSAndGQnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGJvZHlcbiAgICAgIGNhc2UgJ3Rib2R5JzpcbiAgICAgIGNhc2UgJ3RoZWFkJzpcbiAgICAgIGNhc2UgJ3Rmb290JzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ3RyJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmNvbGdyb3VwXG4gICAgICBjYXNlICdjb2xncm91cCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdjb2wnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWludGFibGVcbiAgICAgIGNhc2UgJ3RhYmxlJzpcbiAgICAgICAgcmV0dXJuIHRhZyA9PT0gJ2NhcHRpb24nIHx8IHRhZyA9PT0gJ2NvbGdyb3VwJyB8fCB0YWcgPT09ICd0Ym9keScgfHwgdGFnID09PSAndGZvb3QnIHx8IHRhZyA9PT0gJ3RoZWFkJyB8fCB0YWcgPT09ICdzdHlsZScgfHwgdGFnID09PSAnc2NyaXB0JyB8fCB0YWcgPT09ICd0ZW1wbGF0ZSc7XG5cbiAgICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmhlYWRcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgICByZXR1cm4gdGFnID09PSAnYmFzZScgfHwgdGFnID09PSAnYmFzZWZvbnQnIHx8IHRhZyA9PT0gJ2Jnc291bmQnIHx8IHRhZyA9PT0gJ2xpbmsnIHx8IHRhZyA9PT0gJ21ldGEnIHx8IHRhZyA9PT0gJ3RpdGxlJyB8fCB0YWcgPT09ICdub3NjcmlwdCcgfHwgdGFnID09PSAnbm9mcmFtZXMnIHx8IHRhZyA9PT0gJ3N0eWxlJyB8fCB0YWcgPT09ICdzY3JpcHQnIHx8IHRhZyA9PT0gJ3RlbXBsYXRlJztcblxuICAgICAgLy8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2VtYW50aWNzLmh0bWwjdGhlLWh0bWwtZWxlbWVudFxuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdoZWFkJyB8fCB0YWcgPT09ICdib2R5JztcbiAgICB9XG5cbiAgICAvLyBQcm9iYWJseSBpbiB0aGUgXCJpbiBib2R5XCIgcGFyc2luZyBtb2RlLCBzbyB3ZSBvdXRsYXcgb25seSB0YWcgY29tYm9zXG4gICAgLy8gd2hlcmUgdGhlIHBhcnNpbmcgcnVsZXMgY2F1c2UgaW1wbGljaXQgb3BlbnMgb3IgY2xvc2VzIHRvIGJlIGFkZGVkLlxuICAgIC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI3BhcnNpbmctbWFpbi1pbmJvZHlcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgY2FzZSAnaDEnOlxuICAgICAgY2FzZSAnaDInOlxuICAgICAgY2FzZSAnaDMnOlxuICAgICAgY2FzZSAnaDQnOlxuICAgICAgY2FzZSAnaDUnOlxuICAgICAgY2FzZSAnaDYnOlxuICAgICAgICByZXR1cm4gcGFyZW50VGFnICE9PSAnaDEnICYmIHBhcmVudFRhZyAhPT0gJ2gyJyAmJiBwYXJlbnRUYWcgIT09ICdoMycgJiYgcGFyZW50VGFnICE9PSAnaDQnICYmIHBhcmVudFRhZyAhPT0gJ2g1JyAmJiBwYXJlbnRUYWcgIT09ICdoNic7XG5cbiAgICAgIGNhc2UgJ3JwJzpcbiAgICAgIGNhc2UgJ3J0JzpcbiAgICAgICAgcmV0dXJuIGltcGxpZWRFbmRUYWdzLmluZGV4T2YocGFyZW50VGFnKSA9PT0gLTE7XG5cbiAgICAgIGNhc2UgJ2NhcHRpb24nOlxuICAgICAgY2FzZSAnY29sJzpcbiAgICAgIGNhc2UgJ2NvbGdyb3VwJzpcbiAgICAgIGNhc2UgJ2ZyYW1lJzpcbiAgICAgIGNhc2UgJ2hlYWQnOlxuICAgICAgY2FzZSAndGJvZHknOlxuICAgICAgY2FzZSAndGQnOlxuICAgICAgY2FzZSAndGZvb3QnOlxuICAgICAgY2FzZSAndGgnOlxuICAgICAgY2FzZSAndGhlYWQnOlxuICAgICAgY2FzZSAndHInOlxuICAgICAgICAvLyBUaGVzZSB0YWdzIGFyZSBvbmx5IHZhbGlkIHdpdGggYSBmZXcgcGFyZW50cyB0aGF0IGhhdmUgc3BlY2lhbCBjaGlsZFxuICAgICAgICAvLyBwYXJzaW5nIHJ1bGVzIC0tIGlmIHdlJ3JlIGRvd24gaGVyZSwgdGhlbiBub25lIG9mIHRob3NlIG1hdGNoZWQgYW5kXG4gICAgICAgIC8vIHNvIHdlIGFsbG93IGl0IG9ubHkgaWYgd2UgZG9uJ3Qga25vdyB3aGF0IHRoZSBwYXJlbnQgaXMsIGFzIGFsbCBvdGhlclxuICAgICAgICAvLyBjYXNlcyBhcmUgaW52YWxpZC5cbiAgICAgICAgcmV0dXJuIHBhcmVudFRhZyA9PSBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXJcbiAgICovXG4gIHZhciBmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgc3dpdGNoICh0YWcpIHtcbiAgICAgIGNhc2UgJ2FkZHJlc3MnOlxuICAgICAgY2FzZSAnYXJ0aWNsZSc6XG4gICAgICBjYXNlICdhc2lkZSc6XG4gICAgICBjYXNlICdibG9ja3F1b3RlJzpcbiAgICAgIGNhc2UgJ2NlbnRlcic6XG4gICAgICBjYXNlICdkZXRhaWxzJzpcbiAgICAgIGNhc2UgJ2RpYWxvZyc6XG4gICAgICBjYXNlICdkaXInOlxuICAgICAgY2FzZSAnZGl2JzpcbiAgICAgIGNhc2UgJ2RsJzpcbiAgICAgIGNhc2UgJ2ZpZWxkc2V0JzpcbiAgICAgIGNhc2UgJ2ZpZ2NhcHRpb24nOlxuICAgICAgY2FzZSAnZmlndXJlJzpcbiAgICAgIGNhc2UgJ2Zvb3Rlcic6XG4gICAgICBjYXNlICdoZWFkZXInOlxuICAgICAgY2FzZSAnaGdyb3VwJzpcbiAgICAgIGNhc2UgJ21haW4nOlxuICAgICAgY2FzZSAnbWVudSc6XG4gICAgICBjYXNlICduYXYnOlxuICAgICAgY2FzZSAnb2wnOlxuICAgICAgY2FzZSAncCc6XG4gICAgICBjYXNlICdzZWN0aW9uJzpcbiAgICAgIGNhc2UgJ3N1bW1hcnknOlxuICAgICAgY2FzZSAndWwnOlxuXG4gICAgICBjYXNlICdwcmUnOlxuICAgICAgY2FzZSAnbGlzdGluZyc6XG5cbiAgICAgIGNhc2UgJ3RhYmxlJzpcblxuICAgICAgY2FzZSAnaHInOlxuXG4gICAgICBjYXNlICd4bXAnOlxuXG4gICAgICBjYXNlICdoMSc6XG4gICAgICBjYXNlICdoMic6XG4gICAgICBjYXNlICdoMyc6XG4gICAgICBjYXNlICdoNCc6XG4gICAgICBjYXNlICdoNSc6XG4gICAgICBjYXNlICdoNic6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ucFRhZ0luQnV0dG9uU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmZvcm1UYWcgfHwgYW5jZXN0b3JJbmZvLnBUYWdJbkJ1dHRvblNjb3BlO1xuXG4gICAgICBjYXNlICdsaSc6XG4gICAgICAgIHJldHVybiBhbmNlc3RvckluZm8ubGlzdEl0ZW1UYWdBdXRvY2xvc2luZztcblxuICAgICAgY2FzZSAnZGQnOlxuICAgICAgY2FzZSAnZHQnOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmRsSXRlbVRhZ0F1dG9jbG9zaW5nO1xuXG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmJ1dHRvblRhZ0luU2NvcGU7XG5cbiAgICAgIGNhc2UgJ2EnOlxuICAgICAgICAvLyBTcGVjIHNheXMgc29tZXRoaW5nIGFib3V0IHN0b3JpbmcgYSBsaXN0IG9mIG1hcmtlcnMsIGJ1dCBpdCBzb3VuZHNcbiAgICAgICAgLy8gZXF1aXZhbGVudCB0byB0aGlzIGNoZWNrLlxuICAgICAgICByZXR1cm4gYW5jZXN0b3JJbmZvLmFUYWdJblNjb3BlO1xuXG4gICAgICBjYXNlICdub2JyJzpcbiAgICAgICAgcmV0dXJuIGFuY2VzdG9ySW5mby5ub2JyVGFnSW5TY29wZTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICAvKipcbiAgICogR2l2ZW4gYSBSZWFjdENvbXBvc2l0ZUNvbXBvbmVudCBpbnN0YW5jZSwgcmV0dXJuIGEgbGlzdCBvZiBpdHMgcmVjdXJzaXZlXG4gICAqIG93bmVycywgc3RhcnRpbmcgYXQgdGhlIHJvb3QgYW5kIGVuZGluZyB3aXRoIHRoZSBpbnN0YW5jZSBpdHNlbGYuXG4gICAqL1xuICB2YXIgZmluZE93bmVyU3RhY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UpIHtcbiAgICBpZiAoIWluc3RhbmNlKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIHN0YWNrID0gW107XG4gICAgLyplc2xpbnQtZGlzYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgIGRvIHtcbiAgICAgIC8qZXNsaW50LWVuYWJsZSBzcGFjZS1hZnRlci1rZXl3b3JkcyAqL1xuICAgICAgc3RhY2sucHVzaChpbnN0YW5jZSk7XG4gICAgfSB3aGlsZSAoaW5zdGFuY2UgPSBpbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyKTtcbiAgICBzdGFjay5yZXZlcnNlKCk7XG4gICAgcmV0dXJuIHN0YWNrO1xuICB9O1xuXG4gIHZhciBkaWRXYXJuID0ge307XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nID0gZnVuY3Rpb24gKGNoaWxkVGFnLCBjaGlsZEluc3RhbmNlLCBhbmNlc3RvckluZm8pIHtcbiAgICBhbmNlc3RvckluZm8gPSBhbmNlc3RvckluZm8gfHwgZW1wdHlBbmNlc3RvckluZm87XG4gICAgdmFyIHBhcmVudEluZm8gPSBhbmNlc3RvckluZm8ucGFyZW50VGFnO1xuICAgIHZhciBwYXJlbnRUYWcgPSBwYXJlbnRJbmZvICYmIHBhcmVudEluZm8udGFnO1xuXG4gICAgdmFyIGludmFsaWRQYXJlbnQgPSBpc1RhZ1ZhbGlkV2l0aFBhcmVudChjaGlsZFRhZywgcGFyZW50VGFnKSA/IG51bGwgOiBwYXJlbnRJbmZvO1xuICAgIHZhciBpbnZhbGlkQW5jZXN0b3IgPSBpbnZhbGlkUGFyZW50ID8gbnVsbCA6IGZpbmRJbnZhbGlkQW5jZXN0b3JGb3JUYWcoY2hpbGRUYWcsIGFuY2VzdG9ySW5mbyk7XG4gICAgdmFyIHByb2JsZW1hdGljID0gaW52YWxpZFBhcmVudCB8fCBpbnZhbGlkQW5jZXN0b3I7XG5cbiAgICBpZiAocHJvYmxlbWF0aWMpIHtcbiAgICAgIHZhciBhbmNlc3RvclRhZyA9IHByb2JsZW1hdGljLnRhZztcbiAgICAgIHZhciBhbmNlc3Rvckluc3RhbmNlID0gcHJvYmxlbWF0aWMuaW5zdGFuY2U7XG5cbiAgICAgIHZhciBjaGlsZE93bmVyID0gY2hpbGRJbnN0YW5jZSAmJiBjaGlsZEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgYW5jZXN0b3JPd25lciA9IGFuY2VzdG9ySW5zdGFuY2UgJiYgYW5jZXN0b3JJbnN0YW5jZS5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuXG4gICAgICB2YXIgY2hpbGRPd25lcnMgPSBmaW5kT3duZXJTdGFjayhjaGlsZE93bmVyKTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVycyA9IGZpbmRPd25lclN0YWNrKGFuY2VzdG9yT3duZXIpO1xuXG4gICAgICB2YXIgbWluU3RhY2tMZW4gPSBNYXRoLm1pbihjaGlsZE93bmVycy5sZW5ndGgsIGFuY2VzdG9yT3duZXJzLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcblxuICAgICAgdmFyIGRlZXBlc3RDb21tb24gPSAtMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtaW5TdGFja0xlbjsgaSsrKSB7XG4gICAgICAgIGlmIChjaGlsZE93bmVyc1tpXSA9PT0gYW5jZXN0b3JPd25lcnNbaV0pIHtcbiAgICAgICAgICBkZWVwZXN0Q29tbW9uID0gaTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgVU5LTk9XTiA9ICcodW5rbm93biknO1xuICAgICAgdmFyIGNoaWxkT3duZXJOYW1lcyA9IGNoaWxkT3duZXJzLnNsaWNlKGRlZXBlc3RDb21tb24gKyAxKS5tYXAoZnVuY3Rpb24gKGluc3QpIHtcbiAgICAgICAgcmV0dXJuIGluc3QuZ2V0TmFtZSgpIHx8IFVOS05PV047XG4gICAgICB9KTtcbiAgICAgIHZhciBhbmNlc3Rvck93bmVyTmFtZXMgPSBhbmNlc3Rvck93bmVycy5zbGljZShkZWVwZXN0Q29tbW9uICsgMSkubWFwKGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgICAgIHJldHVybiBpbnN0LmdldE5hbWUoKSB8fCBVTktOT1dOO1xuICAgICAgfSk7XG4gICAgICB2YXIgb3duZXJJbmZvID0gW10uY29uY2F0KFxuICAgICAgLy8gSWYgdGhlIHBhcmVudCBhbmQgY2hpbGQgaW5zdGFuY2VzIGhhdmUgYSBjb21tb24gb3duZXIgYW5jZXN0b3IsIHN0YXJ0XG4gICAgICAvLyB3aXRoIHRoYXQgLS0gb3RoZXJ3aXNlIHdlIGp1c3Qgc3RhcnQgd2l0aCB0aGUgcGFyZW50J3Mgb3duZXJzLlxuICAgICAgZGVlcGVzdENvbW1vbiAhPT0gLTEgPyBjaGlsZE93bmVyc1tkZWVwZXN0Q29tbW9uXS5nZXROYW1lKCkgfHwgVU5LTk9XTiA6IFtdLCBhbmNlc3Rvck93bmVyTmFtZXMsIGFuY2VzdG9yVGFnLFxuICAgICAgLy8gSWYgd2UncmUgd2FybmluZyBhYm91dCBhbiBpbnZhbGlkIChub24tcGFyZW50KSBhbmNlc3RyeSwgYWRkICcuLi4nXG4gICAgICBpbnZhbGlkQW5jZXN0b3IgPyBbJy4uLiddIDogW10sIGNoaWxkT3duZXJOYW1lcywgY2hpbGRUYWcpLmpvaW4oJyA+ICcpO1xuXG4gICAgICB2YXIgd2FybktleSA9ICEhaW52YWxpZFBhcmVudCArICd8JyArIGNoaWxkVGFnICsgJ3wnICsgYW5jZXN0b3JUYWcgKyAnfCcgKyBvd25lckluZm87XG4gICAgICBpZiAoZGlkV2Fyblt3YXJuS2V5XSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBkaWRXYXJuW3dhcm5LZXldID0gdHJ1ZTtcblxuICAgICAgaWYgKGludmFsaWRQYXJlbnQpIHtcbiAgICAgICAgdmFyIGluZm8gPSAnJztcbiAgICAgICAgaWYgKGFuY2VzdG9yVGFnID09PSAndGFibGUnICYmIGNoaWxkVGFnID09PSAndHInKSB7XG4gICAgICAgICAgaW5mbyArPSAnIEFkZCBhIDx0Ym9keT4gdG8geW91ciBjb2RlIHRvIG1hdGNoIHRoZSBET00gdHJlZSBnZW5lcmF0ZWQgYnkgJyArICd0aGUgYnJvd3Nlci4nO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAndmFsaWRhdGVET01OZXN0aW5nKC4uLik6IDwlcz4gY2Fubm90IGFwcGVhciBhcyBhIGNoaWxkIG9mIDwlcz4uICcgKyAnU2VlICVzLiVzJywgY2hpbGRUYWcsIGFuY2VzdG9yVGFnLCBvd25lckluZm8sIGluZm8pIDogdW5kZWZpbmVkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICd2YWxpZGF0ZURPTU5lc3RpbmcoLi4uKTogPCVzPiBjYW5ub3QgYXBwZWFyIGFzIGEgZGVzY2VuZGFudCBvZiAnICsgJzwlcz4uIFNlZSAlcy4nLCBjaGlsZFRhZywgYW5jZXN0b3JUYWcsIG93bmVySW5mbykgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5ID0gJ19fdmFsaWRhdGVET01OZXN0aW5nX2FuY2VzdG9ySW5mbyQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbiAgdmFsaWRhdGVET01OZXN0aW5nLnVwZGF0ZWRBbmNlc3RvckluZm8gPSB1cGRhdGVkQW5jZXN0b3JJbmZvO1xuXG4gIC8vIEZvciB0ZXN0aW5nXG4gIHZhbGlkYXRlRE9NTmVzdGluZy5pc1RhZ1ZhbGlkSW5Db250ZXh0ID0gZnVuY3Rpb24gKHRhZywgYW5jZXN0b3JJbmZvKSB7XG4gICAgYW5jZXN0b3JJbmZvID0gYW5jZXN0b3JJbmZvIHx8IGVtcHR5QW5jZXN0b3JJbmZvO1xuICAgIHZhciBwYXJlbnRJbmZvID0gYW5jZXN0b3JJbmZvLnBhcmVudFRhZztcbiAgICB2YXIgcGFyZW50VGFnID0gcGFyZW50SW5mbyAmJiBwYXJlbnRJbmZvLnRhZztcbiAgICByZXR1cm4gaXNUYWdWYWxpZFdpdGhQYXJlbnQodGFnLCBwYXJlbnRUYWcpICYmICFmaW5kSW52YWxpZEFuY2VzdG9yRm9yVGFnKHRhZywgYW5jZXN0b3JJbmZvKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2YWxpZGF0ZURPTU5lc3Rpbmc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvdmFsaWRhdGVET01OZXN0aW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdEluamVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4nKTtcbnZhciBDaGFuZ2VFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vQ2hhbmdlRXZlbnRQbHVnaW4nKTtcbnZhciBDbGllbnRSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vQ2xpZW50UmVhY3RSb290SW5kZXgnKTtcbnZhciBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlciA9IHJlcXVpcmUoJy4vRGVmYXVsdEV2ZW50UGx1Z2luT3JkZXInKTtcbnZhciBFbnRlckxlYXZlRXZlbnRQbHVnaW4gPSByZXF1aXJlKCcuL0VudGVyTGVhdmVFdmVudFBsdWdpbicpO1xudmFyIEV4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnZmJqcy9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSByZXF1aXJlKCcuL0hUTUxET01Qcm9wZXJ0eUNvbmZpZycpO1xudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbicpO1xudmFyIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9SZWFjdENvbXBvbmVudEJyb3dzZXJFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdERPTUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RET01Db21wb25lbnQnKTtcbnZhciBSZWFjdERPTVRleHRDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dENvbXBvbmVudCcpO1xudmFyIFJlYWN0RXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJy4vUmVhY3RFdmVudExpc3RlbmVyJyk7XG52YXIgUmVhY3RJbmplY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24nKTtcbnZhciBTZWxlY3RFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2VsZWN0RXZlbnRQbHVnaW4nKTtcbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHJlcXVpcmUoJy4vU2VydmVyUmVhY3RSb290SW5kZXgnKTtcbnZhciBTaW1wbGVFdmVudFBsdWdpbiA9IHJlcXVpcmUoJy4vU2ltcGxlRXZlbnRQbHVnaW4nKTtcbnZhciBTVkdET01Qcm9wZXJ0eUNvbmZpZyA9IHJlcXVpcmUoJy4vU1ZHRE9NUHJvcGVydHlDb25maWcnKTtcblxudmFyIGFscmVhZHlJbmplY3RlZCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbmplY3QoKSB7XG4gIGlmIChhbHJlYWR5SW5qZWN0ZWQpIHtcbiAgICAvLyBUT0RPOiBUaGlzIGlzIGN1cnJlbnRseSB0cnVlIGJlY2F1c2UgdGhlc2UgaW5qZWN0aW9ucyBhcmUgc2hhcmVkIGJldHdlZW5cbiAgICAvLyB0aGUgY2xpZW50IGFuZCB0aGUgc2VydmVyIHBhY2thZ2UuIFRoZXkgc2hvdWxkIGJlIGJ1aWx0IGluZGVwZW5kZW50bHlcbiAgICAvLyBhbmQgbm90IHNoYXJlIGFueSBpbmplY3Rpb24gc3RhdGUuIFRoZW4gdGhpcyBwcm9ibGVtIHdpbGwgYmUgc29sdmVkLlxuICAgIHJldHVybjtcbiAgfVxuICBhbHJlYWR5SW5qZWN0ZWQgPSB0cnVlO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkV2ZW50RW1pdHRlci5pbmplY3RSZWFjdEV2ZW50TGlzdGVuZXIoUmVhY3RFdmVudExpc3RlbmVyKTtcblxuICAvKipcbiAgICogSW5qZWN0IG1vZHVsZXMgZm9yIHJlc29sdmluZyBET00gaGllcmFyY2h5IGFuZCBwbHVnaW4gb3JkZXJpbmcuXG4gICAqL1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RFdmVudFBsdWdpbk9yZGVyKERlZmF1bHRFdmVudFBsdWdpbk9yZGVyKTtcbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0SW5zdGFuY2VIYW5kbGUoUmVhY3RJbnN0YW5jZUhhbmRsZXMpO1xuICBSZWFjdEluamVjdGlvbi5FdmVudFBsdWdpbkh1Yi5pbmplY3RNb3VudChSZWFjdE1vdW50KTtcblxuICAvKipcbiAgICogU29tZSBpbXBvcnRhbnQgZXZlbnQgcGx1Z2lucyBpbmNsdWRlZCBieSBkZWZhdWx0ICh3aXRob3V0IGhhdmluZyB0byByZXF1aXJlXG4gICAqIHRoZW0pLlxuICAgKi9cbiAgUmVhY3RJbmplY3Rpb24uRXZlbnRQbHVnaW5IdWIuaW5qZWN0RXZlbnRQbHVnaW5zQnlOYW1lKHtcbiAgICBTaW1wbGVFdmVudFBsdWdpbjogU2ltcGxlRXZlbnRQbHVnaW4sXG4gICAgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBFbnRlckxlYXZlRXZlbnRQbHVnaW4sXG4gICAgQ2hhbmdlRXZlbnRQbHVnaW46IENoYW5nZUV2ZW50UGx1Z2luLFxuICAgIFNlbGVjdEV2ZW50UGx1Z2luOiBTZWxlY3RFdmVudFBsdWdpbixcbiAgICBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luOiBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luXG4gIH0pO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RHZW5lcmljQ29tcG9uZW50Q2xhc3MoUmVhY3RET01Db21wb25lbnQpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLk5hdGl2ZUNvbXBvbmVudC5pbmplY3RUZXh0Q29tcG9uZW50Q2xhc3MoUmVhY3RET01UZXh0Q29tcG9uZW50KTtcblxuICBSZWFjdEluamVjdGlvbi5DbGFzcy5pbmplY3RNaXhpbihSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbik7XG5cbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoSFRNTERPTVByb3BlcnR5Q29uZmlnKTtcbiAgUmVhY3RJbmplY3Rpb24uRE9NUHJvcGVydHkuaW5qZWN0RE9NUHJvcGVydHlDb25maWcoU1ZHRE9NUHJvcGVydHlDb25maWcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLkVtcHR5Q29tcG9uZW50LmluamVjdEVtcHR5Q29tcG9uZW50KCdub3NjcmlwdCcpO1xuXG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbik7XG4gIFJlYWN0SW5qZWN0aW9uLlVwZGF0ZXMuaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICBSZWFjdEluamVjdGlvbi5Sb290SW5kZXguaW5qZWN0Q3JlYXRlUmVhY3RSb290SW5kZXgoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gQ2xpZW50UmVhY3RSb290SW5kZXguY3JlYXRlUmVhY3RSb290SW5kZXggOiBTZXJ2ZXJSZWFjdFJvb3RJbmRleC5jcmVhdGVSZWFjdFJvb3RJbmRleCk7XG5cbiAgUmVhY3RJbmplY3Rpb24uQ29tcG9uZW50LmluamVjdEVudmlyb25tZW50KFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50KTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciB1cmwgPSBFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgd2luZG93LmxvY2F0aW9uLmhyZWYgfHwgJyc7XG4gICAgaWYgKC9bPyZdcmVhY3RfcGVyZlxcYi8udGVzdCh1cmwpKSB7XG4gICAgICB2YXIgUmVhY3REZWZhdWx0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZicpO1xuICAgICAgUmVhY3REZWZhdWx0UGVyZi5zdGFydCgpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaW5qZWN0OiBpbmplY3Rcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1IEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQmVmb3JlSW5wdXRFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSA9IHJlcXVpcmUoJy4vRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlJyk7XG52YXIgU3ludGhldGljQ29tcG9zaXRpb25FdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ29tcG9zaXRpb25FdmVudCcpO1xudmFyIFN5bnRoZXRpY0lucHV0RXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0lucHV0RXZlbnQnKTtcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIEVORF9LRVlDT0RFUyA9IFs5LCAxMywgMjcsIDMyXTsgLy8gVGFiLCBSZXR1cm4sIEVzYywgU3BhY2VcbnZhciBTVEFSVF9LRVlDT0RFID0gMjI5O1xuXG52YXIgY2FuVXNlQ29tcG9zaXRpb25FdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnQ29tcG9zaXRpb25FdmVudCcgaW4gd2luZG93O1xuXG52YXIgZG9jdW1lbnRNb2RlID0gbnVsbDtcbmlmIChFeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00gJiYgJ2RvY3VtZW50TW9kZScgaW4gZG9jdW1lbnQpIHtcbiAgZG9jdW1lbnRNb2RlID0gZG9jdW1lbnQuZG9jdW1lbnRNb2RlO1xufVxuXG4vLyBXZWJraXQgb2ZmZXJzIGEgdmVyeSB1c2VmdWwgYHRleHRJbnB1dGAgZXZlbnQgdGhhdCBjYW4gYmUgdXNlZCB0b1xuLy8gZGlyZWN0bHkgcmVwcmVzZW50IGBiZWZvcmVJbnB1dGAuIFRoZSBJRSBgdGV4dGlucHV0YCBldmVudCBpcyBub3QgYXNcbi8vIHVzZWZ1bCwgc28gd2UgZG9uJ3QgdXNlIGl0LlxudmFyIGNhblVzZVRleHRJbnB1dEV2ZW50ID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdUZXh0RXZlbnQnIGluIHdpbmRvdyAmJiAhZG9jdW1lbnRNb2RlICYmICFpc1ByZXN0bygpO1xuXG4vLyBJbiBJRTkrLCB3ZSBoYXZlIGFjY2VzcyB0byBjb21wb3NpdGlvbiBldmVudHMsIGJ1dCB0aGUgZGF0YSBzdXBwbGllZFxuLy8gYnkgdGhlIG5hdGl2ZSBjb21wb3NpdGlvbmVuZCBldmVudCBtYXkgYmUgaW5jb3JyZWN0LiBKYXBhbmVzZSBpZGVvZ3JhcGhpY1xuLy8gc3BhY2VzLCBmb3IgaW5zdGFuY2UgKFxcdTMwMDApIGFyZSBub3QgcmVjb3JkZWQgY29ycmVjdGx5LlxudmFyIHVzZUZhbGxiYWNrQ29tcG9zaXRpb25EYXRhID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICghY2FuVXNlQ29tcG9zaXRpb25FdmVudCB8fCBkb2N1bWVudE1vZGUgJiYgZG9jdW1lbnRNb2RlID4gOCAmJiBkb2N1bWVudE1vZGUgPD0gMTEpO1xuXG4vKipcbiAqIE9wZXJhIDw9IDEyIGluY2x1ZGVzIFRleHRFdmVudCBpbiB3aW5kb3csIGJ1dCBkb2VzIG5vdCBmaXJlXG4gKiB0ZXh0IGlucHV0IGV2ZW50cy4gUmVseSBvbiBrZXlwcmVzcyBpbnN0ZWFkLlxuICovXG5mdW5jdGlvbiBpc1ByZXN0bygpIHtcbiAgdmFyIG9wZXJhID0gd2luZG93Lm9wZXJhO1xuICByZXR1cm4gdHlwZW9mIG9wZXJhID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb3BlcmEudmVyc2lvbiA9PT0gJ2Z1bmN0aW9uJyAmJiBwYXJzZUludChvcGVyYS52ZXJzaW9uKCksIDEwKSA8PSAxMjtcbn1cblxudmFyIFNQQUNFQkFSX0NPREUgPSAzMjtcbnZhciBTUEFDRUJBUl9DSEFSID0gU3RyaW5nLmZyb21DaGFyQ29kZShTUEFDRUJBUl9DT0RFKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xuXG4vLyBFdmVudHMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgbmFtZXMuXG52YXIgZXZlbnRUeXBlcyA9IHtcbiAgYmVmb3JlSW5wdXQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkJlZm9yZUlucHV0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25CZWZvcmVJbnB1dENhcHR1cmU6IG51bGwgfSlcbiAgICB9LFxuICAgIGRlcGVuZGVuY2llczogW3RvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25FbmQsIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wVGV4dElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlXVxuICB9LFxuICBjb21wb3NpdGlvbkVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25FbmQ6IG51bGwgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNvbXBvc2l0aW9uRW5kQ2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5UHJlc3MsIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duXVxuICB9LFxuICBjb21wb3NpdGlvblN0YXJ0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0OiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblN0YXJ0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH0sXG4gIGNvbXBvc2l0aW9uVXBkYXRlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db21wb3NpdGlvblVwZGF0ZTogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29tcG9zaXRpb25VcGRhdGVDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ29tcG9zaXRpb25VcGRhdGUsIHRvcExldmVsVHlwZXMudG9wS2V5RG93biwgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzcywgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd25dXG4gIH1cbn07XG5cbi8vIFRyYWNrIHdoZXRoZXIgd2UndmUgZXZlciBoYW5kbGVkIGEga2V5cHJlc3Mgb24gdGhlIHNwYWNlIGtleS5cbnZhciBoYXNTcGFjZUtleXByZXNzID0gZmFsc2U7XG5cbi8qKlxuICogUmV0dXJuIHdoZXRoZXIgYSBuYXRpdmUga2V5cHJlc3MgZXZlbnQgaXMgYXNzdW1lZCB0byBiZSBhIGNvbW1hbmQuXG4gKiBUaGlzIGlzIHJlcXVpcmVkIGJlY2F1c2UgRmlyZWZveCBmaXJlcyBga2V5cHJlc3NgIGV2ZW50cyBmb3Iga2V5IGNvbW1hbmRzXG4gKiAoY3V0LCBjb3B5LCBzZWxlY3QtYWxsLCBldGMuKSBldmVuIHRob3VnaCBubyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQuXG4gKi9cbmZ1bmN0aW9uIGlzS2V5cHJlc3NDb21tYW5kKG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiAobmF0aXZlRXZlbnQuY3RybEtleSB8fCBuYXRpdmVFdmVudC5hbHRLZXkgfHwgbmF0aXZlRXZlbnQubWV0YUtleSkgJiZcbiAgLy8gY3RybEtleSAmJiBhbHRLZXkgaXMgZXF1aXZhbGVudCB0byBBbHRHciwgYW5kIGlzIG5vdCBhIGNvbW1hbmQuXG4gICEobmF0aXZlRXZlbnQuY3RybEtleSAmJiBuYXRpdmVFdmVudC5hbHRLZXkpO1xufVxuXG4vKipcbiAqIFRyYW5zbGF0ZSBuYXRpdmUgdG9wIGxldmVsIGV2ZW50cyBpbnRvIGV2ZW50IHR5cGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGVcbiAqIEByZXR1cm4ge29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Q29tcG9zaXRpb25FdmVudFR5cGUodG9wTGV2ZWxUeXBlKSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uU3RhcnQ6XG4gICAgICByZXR1cm4gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvblVwZGF0ZTpcbiAgICAgIHJldHVybiBldmVudFR5cGVzLmNvbXBvc2l0aW9uVXBkYXRlO1xuICB9XG59XG5cbi8qKlxuICogRG9lcyBvdXIgZmFsbGJhY2sgYmVzdC1ndWVzcyBtb2RlbCB0aGluayB0aGlzIGV2ZW50IHNpZ25pZmllcyB0aGF0XG4gKiBjb21wb3NpdGlvbiBoYXMgYmVndW4/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHJldHVybiB0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wS2V5RG93biAmJiBuYXRpdmVFdmVudC5rZXlDb2RlID09PSBTVEFSVF9LRVlDT0RFO1xufVxuXG4vKipcbiAqIERvZXMgb3VyIGZhbGxiYWNrIG1vZGUgdGhpbmsgdGhhdCB0aGlzIGV2ZW50IGlzIHRoZSBlbmQgb2YgY29tcG9zaXRpb24/XG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5mdW5jdGlvbiBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlVcDpcbiAgICAgIC8vIENvbW1hbmQga2V5cyBpbnNlcnQgb3IgY2xlYXIgSU1FIGlucHV0LlxuICAgICAgcmV0dXJuIEVORF9LRVlDT0RFUy5pbmRleE9mKG5hdGl2ZUV2ZW50LmtleUNvZGUpICE9PSAtMTtcbiAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5RG93bjpcbiAgICAgIC8vIEV4cGVjdCBJTUUga2V5Q29kZSBvbiBlYWNoIGtleWRvd24uIElmIHdlIGdldCBhbnkgb3RoZXJcbiAgICAgIC8vIGNvZGUgd2UgbXVzdCBoYXZlIGV4aXRlZCBlYXJsaWVyLlxuICAgICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmtleUNvZGUgIT09IFNUQVJUX0tFWUNPREU7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZURvd246XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEJsdXI6XG4gICAgICAvLyBFdmVudHMgYXJlIG5vdCBwb3NzaWJsZSB3aXRob3V0IGNhbmNlbGxpbmcgSU1FLlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG4vKipcbiAqIEdvb2dsZSBJbnB1dCBUb29scyBwcm92aWRlcyBjb21wb3NpdGlvbiBkYXRhIHZpYSBhIEN1c3RvbUV2ZW50LFxuICogd2l0aCB0aGUgYGRhdGFgIHByb3BlcnR5IHBvcHVsYXRlZCBpbiB0aGUgYGRldGFpbGAgb2JqZWN0LiBJZiB0aGlzXG4gKiBpcyBhdmFpbGFibGUgb24gdGhlIGV2ZW50IG9iamVjdCwgdXNlIGl0LiBJZiBub3QsIHRoaXMgaXMgYSBwbGFpblxuICogY29tcG9zaXRpb24gZXZlbnQgYW5kIHdlIGhhdmUgbm90aGluZyBzcGVjaWFsIHRvIGV4dHJhY3QuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50XG4gKiBAcmV0dXJuIHs/c3RyaW5nfVxuICovXG5mdW5jdGlvbiBnZXREYXRhRnJvbUN1c3RvbUV2ZW50KG5hdGl2ZUV2ZW50KSB7XG4gIHZhciBkZXRhaWwgPSBuYXRpdmVFdmVudC5kZXRhaWw7XG4gIGlmICh0eXBlb2YgZGV0YWlsID09PSAnb2JqZWN0JyAmJiAnZGF0YScgaW4gZGV0YWlsKSB7XG4gICAgcmV0dXJuIGRldGFpbC5kYXRhO1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG4vLyBUcmFjayB0aGUgY3VycmVudCBJTUUgY29tcG9zaXRpb24gZmFsbGJhY2sgb2JqZWN0LCBpZiBhbnkuXG52YXIgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGV2ZW50VHlwZTtcbiAgdmFyIGZhbGxiYWNrRGF0YTtcblxuICBpZiAoY2FuVXNlQ29tcG9zaXRpb25FdmVudCkge1xuICAgIGV2ZW50VHlwZSA9IGdldENvbXBvc2l0aW9uRXZlbnRUeXBlKHRvcExldmVsVHlwZSk7XG4gIH0gZWxzZSBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbikge1xuICAgIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25TdGFydCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSkge1xuICAgICAgZXZlbnRUeXBlID0gZXZlbnRUeXBlcy5jb21wb3NpdGlvblN0YXJ0O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICBldmVudFR5cGUgPSBldmVudFR5cGVzLmNvbXBvc2l0aW9uRW5kO1xuICB9XG5cbiAgaWYgKCFldmVudFR5cGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmICh1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSkge1xuICAgIC8vIFRoZSBjdXJyZW50IGNvbXBvc2l0aW9uIGlzIHN0b3JlZCBzdGF0aWNhbGx5IGFuZCBtdXN0IG5vdCBiZVxuICAgIC8vIG92ZXJ3cml0dGVuIHdoaWxlIGNvbXBvc2l0aW9uIGNvbnRpbnVlcy5cbiAgICBpZiAoIWN1cnJlbnRDb21wb3NpdGlvbiAmJiBldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25TdGFydCkge1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlLmdldFBvb2xlZCh0b3BMZXZlbFRhcmdldCk7XG4gICAgfSBlbHNlIGlmIChldmVudFR5cGUgPT09IGV2ZW50VHlwZXMuY29tcG9zaXRpb25FbmQpIHtcbiAgICAgIGlmIChjdXJyZW50Q29tcG9zaXRpb24pIHtcbiAgICAgICAgZmFsbGJhY2tEYXRhID0gY3VycmVudENvbXBvc2l0aW9uLmdldERhdGEoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmdldFBvb2xlZChldmVudFR5cGUsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgaWYgKGZhbGxiYWNrRGF0YSkge1xuICAgIC8vIEluamVjdCBkYXRhIGdlbmVyYXRlZCBmcm9tIGZhbGxiYWNrIHBhdGggaW50byB0aGUgc3ludGhldGljIGV2ZW50LlxuICAgIC8vIFRoaXMgbWF0Y2hlcyB0aGUgcHJvcGVydHkgb2YgbmF0aXZlIENvbXBvc2l0aW9uRXZlbnRJbnRlcmZhY2UuXG4gICAgZXZlbnQuZGF0YSA9IGZhbGxiYWNrRGF0YTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgY3VzdG9tRGF0YSA9IGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGlmIChjdXN0b21EYXRhICE9PSBudWxsKSB7XG4gICAgICBldmVudC5kYXRhID0gY3VzdG9tRGF0YTtcbiAgICB9XG4gIH1cblxuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIHN0cmluZyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgYGJlZm9yZUlucHV0YCBldmVudC5cbiAqL1xuZnVuY3Rpb24gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KSB7XG4gIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbXBvc2l0aW9uRW5kOlxuICAgICAgcmV0dXJuIGdldERhdGFGcm9tQ3VzdG9tRXZlbnQobmF0aXZlRXZlbnQpO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogSWYgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50cyBhcmUgYXZhaWxhYmxlLCBvdXIgZ29hbCBpcyB0byBtYWtlXG4gICAgICAgKiB1c2Ugb2YgdGhlbS4gSG93ZXZlciwgdGhlcmUgaXMgYSBzcGVjaWFsIGNhc2U6IHRoZSBzcGFjZWJhciBrZXkuXG4gICAgICAgKiBJbiBXZWJraXQsIHByZXZlbnRpbmcgZGVmYXVsdCBvbiBhIHNwYWNlYmFyIGB0ZXh0SW5wdXRgIGV2ZW50XG4gICAgICAgKiBjYW5jZWxzIGNoYXJhY3RlciBpbnNlcnRpb24sIGJ1dCBpdCAqYWxzbyogY2F1c2VzIHRoZSBicm93c2VyXG4gICAgICAgKiB0byBmYWxsIGJhY2sgdG8gaXRzIGRlZmF1bHQgc3BhY2ViYXIgYmVoYXZpb3Igb2Ygc2Nyb2xsaW5nIHRoZVxuICAgICAgICogcGFnZS5cbiAgICAgICAqXG4gICAgICAgKiBUcmFja2luZyBhdDpcbiAgICAgICAqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0zNTUxMDNcbiAgICAgICAqXG4gICAgICAgKiBUbyBhdm9pZCB0aGlzIGlzc3VlLCB1c2UgdGhlIGtleXByZXNzIGV2ZW50IGFzIGlmIG5vIGB0ZXh0SW5wdXRgXG4gICAgICAgKiBldmVudCBpcyBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIHZhciB3aGljaCA9IG5hdGl2ZUV2ZW50LndoaWNoO1xuICAgICAgaWYgKHdoaWNoICE9PSBTUEFDRUJBUl9DT0RFKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICBoYXNTcGFjZUtleXByZXNzID0gdHJ1ZTtcbiAgICAgIHJldHVybiBTUEFDRUJBUl9DSEFSO1xuXG4gICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRleHRJbnB1dDpcbiAgICAgIC8vIFJlY29yZCB0aGUgY2hhcmFjdGVycyB0byBiZSBhZGRlZCB0byB0aGUgRE9NLlxuICAgICAgdmFyIGNoYXJzID0gbmF0aXZlRXZlbnQuZGF0YTtcblxuICAgICAgLy8gSWYgaXQncyBhIHNwYWNlYmFyIGNoYXJhY3RlciwgYXNzdW1lIHRoYXQgd2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWRcbiAgICAgIC8vIGl0IGF0IHRoZSBrZXlwcmVzcyBsZXZlbCBhbmQgYmFpbCBpbW1lZGlhdGVseS4gQW5kcm9pZCBDaHJvbWVcbiAgICAgIC8vIGRvZXNuJ3QgZ2l2ZSB1cyBrZXljb2Rlcywgc28gd2UgbmVlZCB0byBibGFja2xpc3QgaXQuXG4gICAgICBpZiAoY2hhcnMgPT09IFNQQUNFQkFSX0NIQVIgJiYgaGFzU3BhY2VLZXlwcmVzcykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGNoYXJzO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIEZvciBvdGhlciBuYXRpdmUgZXZlbnQgdHlwZXMsIGRvIG5vdGhpbmcuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEZvciBicm93c2VycyB0aGF0IGRvIG5vdCBwcm92aWRlIHRoZSBgdGV4dElucHV0YCBldmVudCwgZXh0cmFjdCB0aGVcbiAqIGFwcHJvcHJpYXRlIHN0cmluZyB0byB1c2UgZm9yIFN5bnRoZXRpY0lucHV0RXZlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P3N0cmluZ30gVGhlIGZhbGxiYWNrIHN0cmluZyBmb3IgdGhpcyBgYmVmb3JlSW5wdXRgIGV2ZW50LlxuICovXG5mdW5jdGlvbiBnZXRGYWxsYmFja0JlZm9yZUlucHV0Q2hhcnModG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAvLyBJZiB3ZSBhcmUgY3VycmVudGx5IGNvbXBvc2luZyAoSU1FKSBhbmQgdXNpbmcgYSBmYWxsYmFjayB0byBkbyBzbyxcbiAgLy8gdHJ5IHRvIGV4dHJhY3QgdGhlIGNvbXBvc2VkIGNoYXJhY3RlcnMgZnJvbSB0aGUgZmFsbGJhY2sgb2JqZWN0LlxuICBpZiAoY3VycmVudENvbXBvc2l0aW9uKSB7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZCB8fCBpc0ZhbGxiYWNrQ29tcG9zaXRpb25FbmQodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkpIHtcbiAgICAgIHZhciBjaGFycyA9IGN1cnJlbnRDb21wb3NpdGlvbi5nZXREYXRhKCk7XG4gICAgICBGYWxsYmFja0NvbXBvc2l0aW9uU3RhdGUucmVsZWFzZShjdXJyZW50Q29tcG9zaXRpb24pO1xuICAgICAgY3VycmVudENvbXBvc2l0aW9uID0gbnVsbDtcbiAgICAgIHJldHVybiBjaGFycztcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXN0ZTpcbiAgICAgIC8vIElmIGEgcGFzdGUgZXZlbnQgb2NjdXJzIGFmdGVyIGEga2V5cHJlc3MsIHRocm93IG91dCB0aGUgaW5wdXRcbiAgICAgIC8vIGNoYXJzLiBQYXN0ZSBldmVudHMgc2hvdWxkIG5vdCBsZWFkIHRvIEJlZm9yZUlucHV0IGV2ZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlQcmVzczpcbiAgICAgIC8qKlxuICAgICAgICogQXMgb2YgdjI3LCBGaXJlZm94IG1heSBmaXJlIGtleXByZXNzIGV2ZW50cyBldmVuIHdoZW4gbm8gY2hhcmFjdGVyXG4gICAgICAgKiB3aWxsIGJlIGluc2VydGVkLiBBIGZldyBwb3NzaWJpbGl0aWVzOlxuICAgICAgICpcbiAgICAgICAqIC0gYHdoaWNoYCBpcyBgMGAuIEFycm93IGtleXMsIEVzYyBrZXksIGV0Yy5cbiAgICAgICAqXG4gICAgICAgKiAtIGB3aGljaGAgaXMgdGhlIHByZXNzZWQga2V5IGNvZGUsIGJ1dCBubyBjaGFyIGlzIGF2YWlsYWJsZS5cbiAgICAgICAqICAgRXg6ICdBbHRHciArIGRgIGluIFBvbGlzaC4gVGhlcmUgaXMgbm8gbW9kaWZpZWQgY2hhcmFjdGVyIGZvclxuICAgICAgICogICB0aGlzIGtleSBjb21iaW5hdGlvbiBhbmQgbm8gY2hhcmFjdGVyIGlzIGluc2VydGVkIGludG8gdGhlXG4gICAgICAgKiAgIGRvY3VtZW50LCBidXQgRkYgZmlyZXMgdGhlIGtleXByZXNzIGZvciBjaGFyIGNvZGUgYDEwMGAgYW55d2F5LlxuICAgICAgICogICBObyBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKlxuICAgICAgICogLSBgd2hpY2hgIGlzIHRoZSBwcmVzc2VkIGtleSBjb2RlLCBidXQgYSBjb21tYW5kIGNvbWJpbmF0aW9uIGlzXG4gICAgICAgKiAgIGJlaW5nIHVzZWQuIEV4OiBgQ21kK0NgLiBObyBjaGFyYWN0ZXIgaXMgaW5zZXJ0ZWQsIGFuZCBub1xuICAgICAgICogICBgaW5wdXRgIGV2ZW50IHdpbGwgb2NjdXIuXG4gICAgICAgKi9cbiAgICAgIGlmIChuYXRpdmVFdmVudC53aGljaCAmJiAhaXNLZXlwcmVzc0NvbW1hbmQobmF0aXZlRXZlbnQpKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKG5hdGl2ZUV2ZW50LndoaWNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BDb21wb3NpdGlvbkVuZDpcbiAgICAgIHJldHVybiB1c2VGYWxsYmFja0NvbXBvc2l0aW9uRGF0YSA/IG51bGwgOiBuYXRpdmVFdmVudC5kYXRhO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEV4dHJhY3QgYSBTeW50aGV0aWNJbnB1dEV2ZW50IGZvciBgYmVmb3JlSW5wdXRgLCBiYXNlZCBvbiBlaXRoZXIgbmF0aXZlXG4gKiBgdGV4dElucHV0YCBvciBmYWxsYmFjayBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUeXBlIFJlY29yZCBmcm9tIGBFdmVudENvbnN0YW50c2AuXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7P29iamVjdH0gQSBTeW50aGV0aWNJbnB1dEV2ZW50LlxuICovXG5mdW5jdGlvbiBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgdmFyIGNoYXJzO1xuXG4gIGlmIChjYW5Vc2VUZXh0SW5wdXRFdmVudCkge1xuICAgIGNoYXJzID0gZ2V0TmF0aXZlQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBjaGFycyA9IGdldEZhbGxiYWNrQmVmb3JlSW5wdXRDaGFycyh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgfVxuXG4gIC8vIElmIG5vIGNoYXJhY3RlcnMgYXJlIGJlaW5nIGluc2VydGVkLCBubyBCZWZvcmVJbnB1dCBldmVudCBzaG91bGRcbiAgLy8gYmUgZmlyZWQuXG4gIGlmICghY2hhcnMpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBldmVudCA9IFN5bnRoZXRpY0lucHV0RXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMuYmVmb3JlSW5wdXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG5cbiAgZXZlbnQuZGF0YSA9IGNoYXJzO1xuICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoZXZlbnQpO1xuICByZXR1cm4gZXZlbnQ7XG59XG5cbi8qKlxuICogQ3JlYXRlIGFuIGBvbkJlZm9yZUlucHV0YCBldmVudCB0byBtYXRjaFxuICogaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDUvI2V2ZW50cy1pbnB1dGV2ZW50cy5cbiAqXG4gKiBUaGlzIGV2ZW50IHBsdWdpbiBpcyBiYXNlZCBvbiB0aGUgbmF0aXZlIGB0ZXh0SW5wdXRgIGV2ZW50XG4gKiBhdmFpbGFibGUgaW4gQ2hyb21lLCBTYWZhcmksIE9wZXJhLCBhbmQgSUUuIFRoaXMgZXZlbnQgZmlyZXMgYWZ0ZXJcbiAqIGBvbktleVByZXNzYCBhbmQgYG9uQ29tcG9zaXRpb25FbmRgLCBidXQgYmVmb3JlIGBvbklucHV0YC5cbiAqXG4gKiBgYmVmb3JlSW5wdXRgIGlzIHNwZWMnZCBidXQgbm90IGltcGxlbWVudGVkIGluIGFueSBicm93c2VycywgYW5kXG4gKiB0aGUgYGlucHV0YCBldmVudCBkb2VzIG5vdCBwcm92aWRlIGFueSB1c2VmdWwgaW5mb3JtYXRpb24gYWJvdXQgd2hhdCBoYXNcbiAqIGFjdHVhbGx5IGJlZW4gYWRkZWQsIGNvbnRyYXJ5IHRvIHRoZSBzcGVjLiBUaHVzLCBgdGV4dElucHV0YCBpcyB0aGUgYmVzdFxuICogYXZhaWxhYmxlIGV2ZW50IHRvIGlkZW50aWZ5IHRoZSBjaGFyYWN0ZXJzIHRoYXQgaGF2ZSBhY3R1YWxseSBiZWVuIGluc2VydGVkXG4gKiBpbnRvIHRoZSB0YXJnZXQgbm9kZS5cbiAqXG4gKiBUaGlzIHBsdWdpbiBpcyBhbHNvIHJlc3BvbnNpYmxlIGZvciBlbWl0dGluZyBgY29tcG9zaXRpb25gIGV2ZW50cywgdGh1c1xuICogYWxsb3dpbmcgdXMgdG8gc2hhcmUgY29tcG9zaXRpb24gZmFsbGJhY2sgY29kZSBmb3IgYm90aCBgYmVmb3JlSW5wdXRgIGFuZFxuICogYGNvbXBvc2l0aW9uYCBldmVudCB0eXBlcy5cbiAqL1xudmFyIEJlZm9yZUlucHV0RXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gICAgcmV0dXJuIFtleHRyYWN0Q29tcG9zaXRpb25FdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpLCBleHRyYWN0QmVmb3JlSW5wdXRFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpXTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBCZWZvcmVJbnB1dEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0JlZm9yZUlucHV0RXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgRXZlbnRQcm9wYWdhdG9yc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50UGx1Z2luSHViID0gcmVxdWlyZSgnLi9FdmVudFBsdWdpbkh1YicpO1xuXG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGFjY3VtdWxhdGVJbnRvID0gcmVxdWlyZSgnLi9hY2N1bXVsYXRlSW50bycpO1xudmFyIGZvckVhY2hBY2N1bXVsYXRlZCA9IHJlcXVpcmUoJy4vZm9yRWFjaEFjY3VtdWxhdGVkJyk7XG5cbnZhciBQcm9wYWdhdGlvblBoYXNlcyA9IEV2ZW50Q29uc3RhbnRzLlByb3BhZ2F0aW9uUGhhc2VzO1xudmFyIGdldExpc3RlbmVyID0gRXZlbnRQbHVnaW5IdWIuZ2V0TGlzdGVuZXI7XG5cbi8qKlxuICogU29tZSBldmVudCB0eXBlcyBoYXZlIGEgbm90aW9uIG9mIGRpZmZlcmVudCByZWdpc3RyYXRpb24gbmFtZXMgZm9yIGRpZmZlcmVudFxuICogXCJwaGFzZXNcIiBvZiBwcm9wYWdhdGlvbi4gVGhpcyBmaW5kcyBsaXN0ZW5lcnMgYnkgYSBnaXZlbiBwaGFzZS5cbiAqL1xuZnVuY3Rpb24gbGlzdGVuZXJBdFBoYXNlKGlkLCBldmVudCwgcHJvcGFnYXRpb25QaGFzZSkge1xuICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzW3Byb3BhZ2F0aW9uUGhhc2VdO1xuICByZXR1cm4gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xufVxuXG4vKipcbiAqIFRhZ3MgYSBgU3ludGhldGljRXZlbnRgIHdpdGggZGlzcGF0Y2hlZCBsaXN0ZW5lcnMuIENyZWF0aW5nIHRoaXMgZnVuY3Rpb25cbiAqIGhlcmUsIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBiaW5kIG9yIGNyZWF0ZSBmdW5jdGlvbnMgZm9yIGVhY2ggZXZlbnQuXG4gKiBNdXRhdGluZyB0aGUgZXZlbnQncyBtZW1iZXJzIGFsbG93cyB1cyB0byBub3QgaGF2ZSB0byBjcmVhdGUgYSB3cmFwcGluZ1xuICogXCJkaXNwYXRjaFwiIG9iamVjdCB0aGF0IHBhaXJzIHRoZSBldmVudCB3aXRoIHRoZSBsaXN0ZW5lci5cbiAqL1xuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdGlvbmFsRGlzcGF0Y2hlcyhkb21JRCwgdXB3YXJkcywgZXZlbnQpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhkb21JRCwgJ0Rpc3BhdGNoaW5nIGlkIG11c3Qgbm90IGJlIG51bGwnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgcGhhc2UgPSB1cHdhcmRzID8gUHJvcGFnYXRpb25QaGFzZXMuYnViYmxlZCA6IFByb3BhZ2F0aW9uUGhhc2VzLmNhcHR1cmVkO1xuICB2YXIgbGlzdGVuZXIgPSBsaXN0ZW5lckF0UGhhc2UoZG9tSUQsIGV2ZW50LCBwaGFzZSk7XG4gIGlmIChsaXN0ZW5lcikge1xuICAgIGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaExpc3RlbmVycywgbGlzdGVuZXIpO1xuICAgIGV2ZW50Ll9kaXNwYXRjaElEcyA9IGFjY3VtdWxhdGVJbnRvKGV2ZW50Ll9kaXNwYXRjaElEcywgZG9tSUQpO1xuICB9XG59XG5cbi8qKlxuICogQ29sbGVjdCBkaXNwYXRjaGVzIChtdXN0IGJlIGVudGlyZWx5IGNvbGxlY3RlZCBiZWZvcmUgZGlzcGF0Y2hpbmcgLSBzZWUgdW5pdFxuICogdGVzdHMpLiBMYXppbHkgYWxsb2NhdGUgdGhlIGFycmF5IHRvIGNvbnNlcnZlIG1lbW9yeS4gIFdlIG11c3QgbG9vcCB0aHJvdWdoXG4gKiBlYWNoIGV2ZW50IGFuZCBwZXJmb3JtIHRoZSB0cmF2ZXJzYWwgZm9yIGVhY2ggb25lLiBXZSBjYW5ub3QgcGVyZm9ybSBhXG4gKiBzaW5nbGUgdHJhdmVyc2FsIGZvciB0aGUgZW50aXJlIGNvbGxlY3Rpb24gb2YgZXZlbnRzIGJlY2F1c2UgZWFjaCBldmVudCBtYXlcbiAqIGhhdmUgYSBkaWZmZXJlbnQgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlKGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlVHdvUGhhc2UoZXZlbnQuZGlzcGF0Y2hNYXJrZXIsIGFjY3VtdWxhdGVEaXJlY3Rpb25hbERpc3BhdGNoZXMsIGV2ZW50KTtcbiAgfVxufVxuXG4vKipcbiAqIFNhbWUgYXMgYGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVgLCBidXQgc2tpcHMgb3ZlciB0aGUgdGFyZ2V0SUQuXG4gKi9cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTaW5nbGVTa2lwVGFyZ2V0KGV2ZW50KSB7XG4gIGlmIChldmVudCAmJiBldmVudC5kaXNwYXRjaENvbmZpZy5waGFzZWRSZWdpc3RyYXRpb25OYW1lcykge1xuICAgIEV2ZW50UGx1Z2luSHViLmluamVjdGlvbi5nZXRJbnN0YW5jZUhhbmRsZSgpLnRyYXZlcnNlVHdvUGhhc2VTa2lwVGFyZ2V0KGV2ZW50LmRpc3BhdGNoTWFya2VyLCBhY2N1bXVsYXRlRGlyZWN0aW9uYWxEaXNwYXRjaGVzLCBldmVudCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyB3aXRob3V0IHJlZ2FyZCB0byBkaXJlY3Rpb24sIGRvZXMgbm90IGxvb2sgZm9yIHBoYXNlZFxuICogcmVnaXN0cmF0aW9uIG5hbWVzLiBTYW1lIGFzIGBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZWAgYnV0IHdpdGhvdXRcbiAqIHJlcXVpcmluZyB0aGF0IHRoZSBgZGlzcGF0Y2hNYXJrZXJgIGJlIHRoZSBzYW1lIGFzIHRoZSBkaXNwYXRjaGVkIElELlxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlzcGF0Y2hlcyhpZCwgaWdub3JlZERpcmVjdGlvbiwgZXZlbnQpIHtcbiAgaWYgKGV2ZW50ICYmIGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICB2YXIgcmVnaXN0cmF0aW9uTmFtZSA9IGV2ZW50LmRpc3BhdGNoQ29uZmlnLnJlZ2lzdHJhdGlvbk5hbWU7XG4gICAgdmFyIGxpc3RlbmVyID0gZ2V0TGlzdGVuZXIoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpO1xuICAgIGlmIChsaXN0ZW5lcikge1xuICAgICAgZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzID0gYWNjdW11bGF0ZUludG8oZXZlbnQuX2Rpc3BhdGNoTGlzdGVuZXJzLCBsaXN0ZW5lcik7XG4gICAgICBldmVudC5fZGlzcGF0Y2hJRHMgPSBhY2N1bXVsYXRlSW50byhldmVudC5fZGlzcGF0Y2hJRHMsIGlkKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBBY2N1bXVsYXRlcyBkaXNwYXRjaGVzIG9uIGFuIGBTeW50aGV0aWNFdmVudGAsIGJ1dCBvbmx5IGZvciB0aGVcbiAqIGBkaXNwYXRjaE1hcmtlcmAuXG4gKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudFxuICovXG5mdW5jdGlvbiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlc1NpbmdsZShldmVudCkge1xuICBpZiAoZXZlbnQgJiYgZXZlbnQuZGlzcGF0Y2hDb25maWcucmVnaXN0cmF0aW9uTmFtZSkge1xuICAgIGFjY3VtdWxhdGVEaXNwYXRjaGVzKGV2ZW50LmRpc3BhdGNoTWFya2VyLCBudWxsLCBldmVudCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudHMpIHtcbiAgZm9yRWFjaEFjY3VtdWxhdGVkKGV2ZW50cywgYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NpbmdsZSk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXNTa2lwVGFyZ2V0KGV2ZW50cykge1xuICBmb3JFYWNoQWNjdW11bGF0ZWQoZXZlbnRzLCBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2luZ2xlU2tpcFRhcmdldCk7XG59XG5cbmZ1bmN0aW9uIGFjY3VtdWxhdGVFbnRlckxlYXZlRGlzcGF0Y2hlcyhsZWF2ZSwgZW50ZXIsIGZyb21JRCwgdG9JRCkge1xuICBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24uZ2V0SW5zdGFuY2VIYW5kbGUoKS50cmF2ZXJzZUVudGVyTGVhdmUoZnJvbUlELCB0b0lELCBhY2N1bXVsYXRlRGlzcGF0Y2hlcywgbGVhdmUsIGVudGVyKTtcbn1cblxuZnVuY3Rpb24gYWNjdW11bGF0ZURpcmVjdERpc3BhdGNoZXMoZXZlbnRzKSB7XG4gIGZvckVhY2hBY2N1bXVsYXRlZChldmVudHMsIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzU2luZ2xlKTtcbn1cblxuLyoqXG4gKiBBIHNtYWxsIHNldCBvZiBwcm9wYWdhdGlvbiBwYXR0ZXJucywgZWFjaCBvZiB3aGljaCB3aWxsIGFjY2VwdCBhIHNtYWxsIGFtb3VudFxuICogb2YgaW5mb3JtYXRpb24sIGFuZCBnZW5lcmF0ZSBhIHNldCBvZiBcImRpc3BhdGNoIHJlYWR5IGV2ZW50IG9iamVjdHNcIiAtIHdoaWNoXG4gKiBhcmUgc2V0cyBvZiBldmVudHMgdGhhdCBoYXZlIGFscmVhZHkgYmVlbiBhbm5vdGF0ZWQgd2l0aCBhIHNldCBvZiBkaXNwYXRjaGVkXG4gKiBsaXN0ZW5lciBmdW5jdGlvbnMvaWRzLiBUaGUgQVBJIGlzIGRlc2lnbmVkIHRoaXMgd2F5IHRvIGRpc2NvdXJhZ2UgdGhlc2VcbiAqIHByb3BhZ2F0aW9uIHN0cmF0ZWdpZXMgZnJvbSBhY3R1YWxseSBleGVjdXRpbmcgdGhlIGRpc3BhdGNoZXMsIHNpbmNlIHdlXG4gKiBhbHdheXMgd2FudCB0byBjb2xsZWN0IHRoZSBlbnRpcmUgc2V0IG9mIGRpc3BhdGNoZXMgYmVmb3JlIGV4ZWN1dGluZyBldmVudCBhXG4gKiBzaW5nbGUgb25lLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBFdmVudFByb3BhZ2F0b3JzXG4gKi9cbnZhciBFdmVudFByb3BhZ2F0b3JzID0ge1xuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzOiBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzLFxuICBhY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzU2tpcFRhcmdldDogYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlc1NraXBUYXJnZXQsXG4gIGFjY3VtdWxhdGVEaXJlY3REaXNwYXRjaGVzOiBhY2N1bXVsYXRlRGlyZWN0RGlzcGF0Y2hlcyxcbiAgYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzOiBhY2N1bXVsYXRlRW50ZXJMZWF2ZURpc3BhdGNoZXNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRQcm9wYWdhdG9ycztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9FdmVudFByb3BhZ2F0b3JzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBUaGlzIGhlbHBlciBjbGFzcyBzdG9yZXMgaW5mb3JtYXRpb24gYWJvdXQgdGV4dCBjb250ZW50IG9mIGEgdGFyZ2V0IG5vZGUsXG4gKiBhbGxvd2luZyBjb21wYXJpc29uIG9mIGNvbnRlbnQgYmVmb3JlIGFuZCBhZnRlciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIElkZW50aWZ5IHRoZSBub2RlIHdoZXJlIHNlbGVjdGlvbiBjdXJyZW50bHkgYmVnaW5zLCB0aGVuIG9ic2VydmVcbiAqIGJvdGggaXRzIHRleHQgY29udGVudCBhbmQgaXRzIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIERPTS4gU2luY2UgdGhlXG4gKiBicm93c2VyIG1heSBuYXRpdmVseSByZXBsYWNlIHRoZSB0YXJnZXQgbm9kZSBkdXJpbmcgY29tcG9zaXRpb24sIHdlIGNhblxuICogdXNlIGl0cyBwb3NpdGlvbiB0byBmaW5kIGl0cyByZXBsYWNlbWVudC5cbiAqXG4gKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSByb290XG4gKi9cbmZ1bmN0aW9uIEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZShyb290KSB7XG4gIHRoaXMuX3Jvb3QgPSByb290O1xuICB0aGlzLl9zdGFydFRleHQgPSB0aGlzLmdldFRleHQoKTtcbiAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbn1cblxuYXNzaWduKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3Jvb3QgPSBudWxsO1xuICAgIHRoaXMuX3N0YXJ0VGV4dCA9IG51bGw7XG4gICAgdGhpcy5fZmFsbGJhY2tUZXh0ID0gbnVsbDtcbiAgfSxcblxuICAvKipcbiAgICogR2V0IGN1cnJlbnQgdGV4dCBvZiBpbnB1dC5cbiAgICpcbiAgICogQHJldHVybiB7c3RyaW5nfVxuICAgKi9cbiAgZ2V0VGV4dDogZnVuY3Rpb24gKCkge1xuICAgIGlmICgndmFsdWUnIGluIHRoaXMuX3Jvb3QpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yb290LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcm9vdFtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldO1xuICB9LFxuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmUgdGhlIGRpZmZlcmluZyBzdWJzdHJpbmcgYmV0d2VlbiB0aGUgaW5pdGlhbGx5IHN0b3JlZFxuICAgKiB0ZXh0IGNvbnRlbnQgYW5kIHRoZSBjdXJyZW50IGNvbnRlbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge3N0cmluZ31cbiAgICovXG4gIGdldERhdGE6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZmFsbGJhY2tUZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICAgIH1cblxuICAgIHZhciBzdGFydDtcbiAgICB2YXIgc3RhcnRWYWx1ZSA9IHRoaXMuX3N0YXJ0VGV4dDtcbiAgICB2YXIgc3RhcnRMZW5ndGggPSBzdGFydFZhbHVlLmxlbmd0aDtcbiAgICB2YXIgZW5kO1xuICAgIHZhciBlbmRWYWx1ZSA9IHRoaXMuZ2V0VGV4dCgpO1xuICAgIHZhciBlbmRMZW5ndGggPSBlbmRWYWx1ZS5sZW5ndGg7XG5cbiAgICBmb3IgKHN0YXJ0ID0gMDsgc3RhcnQgPCBzdGFydExlbmd0aDsgc3RhcnQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRdICE9PSBlbmRWYWx1ZVtzdGFydF0pIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIG1pbkVuZCA9IHN0YXJ0TGVuZ3RoIC0gc3RhcnQ7XG4gICAgZm9yIChlbmQgPSAxOyBlbmQgPD0gbWluRW5kOyBlbmQrKykge1xuICAgICAgaWYgKHN0YXJ0VmFsdWVbc3RhcnRMZW5ndGggLSBlbmRdICE9PSBlbmRWYWx1ZVtlbmRMZW5ndGggLSBlbmRdKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBzbGljZVRhaWwgPSBlbmQgPiAxID8gMSAtIGVuZCA6IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mYWxsYmFja1RleHQgPSBlbmRWYWx1ZS5zbGljZShzdGFydCwgc2xpY2VUYWlsKTtcbiAgICByZXR1cm4gdGhpcy5fZmFsbGJhY2tUZXh0O1xuICB9XG59KTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKEZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmFsbGJhY2tDb21wb3NpdGlvblN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0ZhbGxiYWNrQ29tcG9zaXRpb25TdGF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRUZXh0Q29udGVudEFjY2Vzc29yXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgY29udGVudEtleSA9IG51bGw7XG5cbi8qKlxuICogR2V0cyB0aGUga2V5IHVzZWQgdG8gYWNjZXNzIHRleHQgY29udGVudCBvbiBhIERPTSBub2RlLlxuICpcbiAqIEByZXR1cm4gez9zdHJpbmd9IEtleSB1c2VkIHRvIGFjY2VzcyB0ZXh0IGNvbnRlbnQuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZ2V0VGV4dENvbnRlbnRBY2Nlc3NvcigpIHtcbiAgaWYgKCFjb250ZW50S2V5ICYmIEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAgIC8vIFByZWZlciB0ZXh0Q29udGVudCB0byBpbm5lclRleHQgYmVjYXVzZSBtYW55IGJyb3dzZXJzIHN1cHBvcnQgYm90aCBidXRcbiAgICAvLyBTVkcgPHRleHQ+IGVsZW1lbnRzIGRvbid0IHN1cHBvcnQgaW5uZXJUZXh0IGV2ZW4gd2hlbiA8ZGl2PiBkb2VzLlxuICAgIGNvbnRlbnRLZXkgPSAndGV4dENvbnRlbnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/ICd0ZXh0Q29udGVudCcgOiAnaW5uZXJUZXh0JztcbiAgfVxuICByZXR1cm4gY29udGVudEtleTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRUZXh0Q29udGVudEFjY2Vzc29yO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2dldFRleHRDb250ZW50QWNjZXNzb3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljQ29tcG9zaXRpb25FdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWNvbXBvc2l0aW9uZXZlbnRzXG4gKi9cbnZhciBDb21wb3NpdGlvbkV2ZW50SW50ZXJmYWNlID0ge1xuICBkYXRhOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ29tcG9zaXRpb25FdmVudCwgQ29tcG9zaXRpb25FdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljQ29tcG9zaXRpb25FdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDb21wb3NpdGlvbkV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHR5cGU6IG51bGwsXG4gIHRhcmdldDogbnVsbCxcbiAgLy8gY3VycmVudFRhcmdldCBpcyBzZXQgd2hlbiBkaXNwYXRjaGluZzsgbm8gdXNlIGluIGNvcHlpbmcgaXQgaGVyZVxuICBjdXJyZW50VGFyZ2V0OiBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zTnVsbCxcbiAgZXZlbnRQaGFzZTogbnVsbCxcbiAgYnViYmxlczogbnVsbCxcbiAgY2FuY2VsYWJsZTogbnVsbCxcbiAgdGltZVN0YW1wOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG4gIH0sXG4gIGRlZmF1bHRQcmV2ZW50ZWQ6IG51bGwsXG4gIGlzVHJ1c3RlZDogbnVsbFxufTtcblxuLyoqXG4gKiBTeW50aGV0aWMgZXZlbnRzIGFyZSBkaXNwYXRjaGVkIGJ5IGV2ZW50IHBsdWdpbnMsIHR5cGljYWxseSBpbiByZXNwb25zZSB0byBhXG4gKiB0b3AtbGV2ZWwgZXZlbnQgZGVsZWdhdGlvbiBoYW5kbGVyLlxuICpcbiAqIFRoZXNlIHN5c3RlbXMgc2hvdWxkIGdlbmVyYWxseSB1c2UgcG9vbGluZyB0byByZWR1Y2UgdGhlIGZyZXF1ZW5jeSBvZiBnYXJiYWdlXG4gKiBjb2xsZWN0aW9uLiBUaGUgc3lzdGVtIHNob3VsZCBjaGVjayBgaXNQZXJzaXN0ZW50YCB0byBkZXRlcm1pbmUgd2hldGhlciB0aGVcbiAqIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBpbnRvIHRoZSBwb29sIGFmdGVyIGJlaW5nIGRpc3BhdGNoZWQuIFVzZXJzIHRoYXRcbiAqIG5lZWQgYSBwZXJzaXN0ZWQgZXZlbnQgc2hvdWxkIGludm9rZSBgcGVyc2lzdGAuXG4gKlxuICogU3ludGhldGljIGV2ZW50cyAoYW5kIHN1YmNsYXNzZXMpIGltcGxlbWVudCB0aGUgRE9NIExldmVsIDMgRXZlbnRzIEFQSSBieVxuICogbm9ybWFsaXppbmcgYnJvd3NlciBxdWlya3MuIFN1YmNsYXNzZXMgZG8gbm90IG5lY2Vzc2FyaWx5IGhhdmUgdG8gaW1wbGVtZW50IGFcbiAqIERPTSBpbnRlcmZhY2U7IGN1c3RvbSBhcHBsaWNhdGlvbi1zcGVjaWZpYyBldmVudHMgY2FuIGFsc28gc3ViY2xhc3MgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0V2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIHRoaXMuZGlzcGF0Y2hDb25maWcgPSBkaXNwYXRjaENvbmZpZztcbiAgdGhpcy5kaXNwYXRjaE1hcmtlciA9IGRpc3BhdGNoTWFya2VyO1xuICB0aGlzLm5hdGl2ZUV2ZW50ID0gbmF0aXZlRXZlbnQ7XG5cbiAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBJbnRlcmZhY2UpIHtcbiAgICBpZiAoIUludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICB2YXIgbm9ybWFsaXplID0gSW50ZXJmYWNlW3Byb3BOYW1lXTtcbiAgICBpZiAobm9ybWFsaXplKSB7XG4gICAgICB0aGlzW3Byb3BOYW1lXSA9IG5vcm1hbGl6ZShuYXRpdmVFdmVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9wTmFtZSA9PT0gJ3RhcmdldCcpIHtcbiAgICAgICAgdGhpcy50YXJnZXQgPSBuYXRpdmVFdmVudFRhcmdldDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbcHJvcE5hbWVdID0gbmF0aXZlRXZlbnRbcHJvcE5hbWVdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBkZWZhdWx0UHJldmVudGVkID0gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCAhPSBudWxsID8gbmF0aXZlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCA6IG5hdGl2ZUV2ZW50LnJldHVyblZhbHVlID09PSBmYWxzZTtcbiAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICB0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUcnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0ZhbHNlO1xuICB9XG4gIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2U7XG59XG5cbmFzc2lnbihTeW50aGV0aWNFdmVudC5wcm90b3R5cGUsIHtcblxuICBwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZGVmYXVsdFByZXZlbnRlZCA9IHRydWU7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHByZXZlbnREZWZhdWx0YCBvbiBhICcgKyAncmVsZWFzZWQvbnVsbGlmaWVkIHN5bnRoZXRpYyBldmVudC4gVGhpcyBpcyBhIG5vLW9wLiBTZWUgJyArICdodHRwczovL2ZiLm1lL3JlYWN0LWV2ZW50LXBvb2xpbmcgZm9yIG1vcmUgaW5mb3JtYXRpb24uJykgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGlmICghZXZlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZXZlbnQucHJldmVudERlZmF1bHQpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgc3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50ID0gdGhpcy5uYXRpdmVFdmVudDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZXZlbnQsICdUaGlzIHN5bnRoZXRpYyBldmVudCBpcyByZXVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMuIElmIHlvdVxcJ3JlICcgKyAnc2VlaW5nIHRoaXMsIHlvdVxcJ3JlIGNhbGxpbmcgYHN0b3BQcm9wYWdhdGlvbmAgb24gYSAnICsgJ3JlbGVhc2VkL251bGxpZmllZCBzeW50aGV0aWMgZXZlbnQuIFRoaXMgaXMgYSBuby1vcC4gU2VlICcgKyAnaHR0cHM6Ly9mYi5tZS9yZWFjdC1ldmVudC1wb29saW5nIGZvciBtb3JlIGluZm9ybWF0aW9uLicpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xuICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSBlbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZTtcbiAgfSxcblxuICAvKipcbiAgICogV2UgcmVsZWFzZSBhbGwgZGlzcGF0Y2hlZCBgU3ludGhldGljRXZlbnRgcyBhZnRlciBlYWNoIGV2ZW50IGxvb3AsIGFkZGluZ1xuICAgKiB0aGVtIGJhY2sgaW50byB0aGUgcG9vbC4gVGhpcyBhbGxvd3MgYSB3YXkgdG8gaG9sZCBvbnRvIGEgcmVmZXJlbmNlIHRoYXRcbiAgICogd29uJ3QgYmUgYWRkZWQgYmFjayBpbnRvIHRoZSBwb29sLlxuICAgKi9cbiAgcGVyc2lzdDogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaXNQZXJzaXN0ZW50ID0gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc1RydWU7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGlzIGV2ZW50IHNob3VsZCBiZSByZWxlYXNlZCBiYWNrIGludG8gdGhlIHBvb2wuXG4gICAqXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhpcyBzaG91bGQgbm90IGJlIHJlbGVhc2VkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBpc1BlcnNpc3RlbnQ6IGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNGYWxzZSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgYGRlc3RydWN0b3JgIG9uIGVhY2ggaW5zdGFuY2UgaXQgcmVsZWFzZXMuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIEludGVyZmFjZSA9IHRoaXMuY29uc3RydWN0b3IuSW50ZXJmYWNlO1xuICAgIGZvciAodmFyIHByb3BOYW1lIGluIEludGVyZmFjZSkge1xuICAgICAgdGhpc1twcm9wTmFtZV0gPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmRpc3BhdGNoQ29uZmlnID0gbnVsbDtcbiAgICB0aGlzLmRpc3BhdGNoTWFya2VyID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgfVxuXG59KTtcblxuU3ludGhldGljRXZlbnQuSW50ZXJmYWNlID0gRXZlbnRJbnRlcmZhY2U7XG5cbi8qKlxuICogSGVscGVyIHRvIHJlZHVjZSBib2lsZXJwbGF0ZSB3aGVuIGNyZWF0aW5nIHN1YmNsYXNzZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gQ2xhc3NcbiAqIEBwYXJhbSB7P29iamVjdH0gSW50ZXJmYWNlXG4gKi9cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyA9IGZ1bmN0aW9uIChDbGFzcywgSW50ZXJmYWNlKSB7XG4gIHZhciBTdXBlciA9IHRoaXM7XG5cbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoU3VwZXIucHJvdG90eXBlKTtcbiAgYXNzaWduKHByb3RvdHlwZSwgQ2xhc3MucHJvdG90eXBlKTtcbiAgQ2xhc3MucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICBDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDbGFzcztcblxuICBDbGFzcy5JbnRlcmZhY2UgPSBhc3NpZ24oe30sIFN1cGVyLkludGVyZmFjZSwgSW50ZXJmYWNlKTtcbiAgQ2xhc3MuYXVnbWVudENsYXNzID0gU3VwZXIuYXVnbWVudENsYXNzO1xuXG4gIFBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhDbGFzcywgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcbn07XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhTeW50aGV0aWNFdmVudCwgUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNJbnB1dEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAxMzExMDVcbiAqICAgICAgLyNldmVudHMtaW5wdXRldmVudHNcbiAqL1xudmFyIElucHV0RXZlbnRJbnRlcmZhY2UgPSB7XG4gIGRhdGE6IG51bGxcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0lucHV0RXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY0V2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNJbnB1dEV2ZW50LCBJbnB1dEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNJbnB1dEV2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0lucHV0RXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUga2V5T2ZcbiAqL1xuXG4vKipcbiAqIEFsbG93cyBleHRyYWN0aW9uIG9mIGEgbWluaWZpZWQga2V5LiBMZXQncyB0aGUgYnVpbGQgc3lzdGVtIG1pbmlmeSBrZXlzXG4gKiB3aXRob3V0IGxvc2luZyB0aGUgYWJpbGl0eSB0byBkeW5hbWljYWxseSB1c2Uga2V5IHN0cmluZ3MgYXMgdmFsdWVzXG4gKiB0aGVtc2VsdmVzLiBQYXNzIGluIGFuIG9iamVjdCB3aXRoIGEgc2luZ2xlIGtleS92YWwgcGFpciBhbmQgaXQgd2lsbCByZXR1cm5cbiAqIHlvdSB0aGUgc3RyaW5nIGtleSBvZiB0aGF0IHNpbmdsZSByZWNvcmQuIFN1cHBvc2UgeW91IHdhbnQgdG8gZ3JhYiB0aGVcbiAqIHZhbHVlIGZvciBhIGtleSAnY2xhc3NOYW1lJyBpbnNpZGUgb2YgYW4gb2JqZWN0LiBLZXkvdmFsIG1pbmlmaWNhdGlvbiBtYXlcbiAqIGhhdmUgYWxpYXNlZCB0aGF0IGtleSB0byBiZSAneGExMicuIGtleU9mKHtjbGFzc05hbWU6IG51bGx9KSB3aWxsIHJldHVyblxuICogJ3hhMTInIGluIHRoYXQgY2FzZS4gUmVzb2x2ZSBrZXlzIHlvdSB3YW50IHRvIHVzZSBvbmNlIGF0IHN0YXJ0dXAgdGltZSwgdGhlblxuICogcmV1c2UgdGhvc2UgcmVzb2x1dGlvbnMuXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG52YXIga2V5T2YgPSBmdW5jdGlvbiAob25lS2V5T2JqKSB7XG4gIHZhciBrZXk7XG4gIGZvciAoa2V5IGluIG9uZUtleU9iaikge1xuICAgIGlmICghb25lS2V5T2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICByZXR1cm4ga2V5O1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBrZXlPZjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIva2V5T2YuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2hhbmdlRXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFBsdWdpbkh1YiA9IHJlcXVpcmUoJy4vRXZlbnRQbHVnaW5IdWInKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBpc0V2ZW50U3VwcG9ydGVkID0gcmVxdWlyZSgnLi9pc0V2ZW50U3VwcG9ydGVkJyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIGV2ZW50VHlwZXMgPSB7XG4gIGNoYW5nZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2hhbmdlOiBudWxsIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DaGFuZ2VDYXB0dXJlOiBudWxsIH0pXG4gICAgfSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcEJsdXIsIHRvcExldmVsVHlwZXMudG9wQ2hhbmdlLCB0b3BMZXZlbFR5cGVzLnRvcENsaWNrLCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcElucHV0LCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wS2V5VXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG4vKipcbiAqIEZvciBJRSBzaGltc1xuICovXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xudmFyIGFjdGl2ZUVsZW1lbnRWYWx1ZVByb3AgPSBudWxsO1xuXG4vKipcbiAqIFNFQ1RJT046IGhhbmRsZSBgY2hhbmdlYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDaGFuZ2VFdmVudChlbGVtKSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICByZXR1cm4gbm9kZU5hbWUgPT09ICdzZWxlY3QnIHx8IG5vZGVOYW1lID09PSAnaW5wdXQnICYmIGVsZW0udHlwZSA9PT0gJ2ZpbGUnO1xufVxuXG52YXIgZG9lc0NoYW5nZUV2ZW50QnViYmxlID0gZmFsc2U7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIC8vIFNlZSBgaGFuZGxlQ2hhbmdlYCBjb21tZW50IGJlbG93XG4gIGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSA9IGlzRXZlbnRTdXBwb3J0ZWQoJ2NoYW5nZScpICYmICghKCdkb2N1bWVudE1vZGUnIGluIGRvY3VtZW50KSB8fCBkb2N1bWVudC5kb2N1bWVudE1vZGUgPiA4KTtcbn1cblxuZnVuY3Rpb24gbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudChuYXRpdmVFdmVudCkge1xuICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIGFjdGl2ZUVsZW1lbnRJRCwgbmF0aXZlRXZlbnQsIGdldEV2ZW50VGFyZ2V0KG5hdGl2ZUV2ZW50KSk7XG4gIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG5cbiAgLy8gSWYgY2hhbmdlIGFuZCBwcm9wZXJ0eWNoYW5nZSBidWJibGVkLCB3ZSdkIGp1c3QgYmluZCB0byBpdCBsaWtlIGFsbCB0aGVcbiAgLy8gb3RoZXIgZXZlbnRzIGFuZCBoYXZlIGl0IGdvIHRocm91Z2ggUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLiBTaW5jZSBpdFxuICAvLyBkb2Vzbid0LCB3ZSBtYW51YWxseSBsaXN0ZW4gZm9yIHRoZSBldmVudHMgYW5kIHNvIHdlIGhhdmUgdG8gZW5xdWV1ZSBhbmRcbiAgLy8gcHJvY2VzcyB0aGUgYWJzdHJhY3QgZXZlbnQgbWFudWFsbHkuXG4gIC8vXG4gIC8vIEJhdGNoaW5nIGlzIG5lY2Vzc2FyeSBoZXJlIGluIG9yZGVyIHRvIGVuc3VyZSB0aGF0IGFsbCBldmVudCBoYW5kbGVycyBydW5cbiAgLy8gYmVmb3JlIHRoZSBuZXh0IHJlcmVuZGVyIChpbmNsdWRpbmcgZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgdG8gYW5jZXN0b3JcbiAgLy8gZWxlbWVudHMgaW5zdGVhZCBvZiBkaXJlY3RseSBvbiB0aGUgaW5wdXQpLiBXaXRob3V0IHRoaXMsIGNvbnRyb2xsZWRcbiAgLy8gY29tcG9uZW50cyBkb24ndCB3b3JrIHByb3Blcmx5IGluIGNvbmp1bmN0aW9uIHdpdGggZXZlbnQgYnViYmxpbmcgYmVjYXVzZVxuICAvLyB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQgYW5kIHRoZSB2YWx1ZSByZXZlcnRlZCBiZWZvcmUgYWxsIHRoZSBldmVudFxuICAvLyBoYW5kbGVycyBjYW4gcnVuLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy83MDguXG4gIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhydW5FdmVudEluQmF0Y2gsIGV2ZW50KTtcbn1cblxuZnVuY3Rpb24gcnVuRXZlbnRJbkJhdGNoKGV2ZW50KSB7XG4gIEV2ZW50UGx1Z2luSHViLmVucXVldWVFdmVudHMoZXZlbnQpO1xuICBFdmVudFBsdWdpbkh1Yi5wcm9jZXNzRXZlbnRRdWV1ZShmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0YXJnZXQsIHRhcmdldElEKSB7XG4gIGFjdGl2ZUVsZW1lbnQgPSB0YXJnZXQ7XG4gIGFjdGl2ZUVsZW1lbnRJRCA9IHRhcmdldElEO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbmNoYW5nZScsIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQpO1xufVxuXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnQuZGV0YWNoRXZlbnQoJ29uY2hhbmdlJywgbWFudWFsRGlzcGF0Y2hDaGFuZ2VFdmVudCk7XG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BDaGFuZ2UpIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuZnVuY3Rpb24gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTgodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCkge1xuICBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzKSB7XG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JDaGFuZ2VFdmVudElFOCgpO1xuICB9XG59XG5cbi8qKlxuICogU0VDVElPTjogaGFuZGxlIGBpbnB1dGAgZXZlbnRcbiAqL1xudmFyIGlzSW5wdXRFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuaWYgKEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSkge1xuICAvLyBJRTkgY2xhaW1zIHRvIHN1cHBvcnQgdGhlIGlucHV0IGV2ZW50IGJ1dCBmYWlscyB0byB0cmlnZ2VyIGl0IHdoZW5cbiAgLy8gZGVsZXRpbmcgdGV4dCwgc28gd2UgaWdub3JlIGl0cyBpbnB1dCBldmVudHNcbiAgaXNJbnB1dEV2ZW50U3VwcG9ydGVkID0gaXNFdmVudFN1cHBvcnRlZCgnaW5wdXQnKSAmJiAoISgnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCkgfHwgZG9jdW1lbnQuZG9jdW1lbnRNb2RlID4gOSk7XG59XG5cbi8qKlxuICogKEZvciBvbGQgSUUuKSBSZXBsYWNlbWVudCBnZXR0ZXIvc2V0dGVyIGZvciB0aGUgYHZhbHVlYCBwcm9wZXJ0eSB0aGF0IGdldHNcbiAqIHNldCBvbiB0aGUgYWN0aXZlIGVsZW1lbnQuXG4gKi9cbnZhciBuZXdWYWx1ZVByb3AgPSB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhY3RpdmVFbGVtZW50VmFsdWVQcm9wLmdldC5jYWxsKHRoaXMpO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWwpIHtcbiAgICAvLyBDYXN0IHRvIGEgc3RyaW5nIHNvIHdlIGNhbiBkbyBlcXVhbGl0eSBjaGVja3MuXG4gICAgYWN0aXZlRWxlbWVudFZhbHVlID0gJycgKyB2YWw7XG4gICAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcC5zZXQuY2FsbCh0aGlzLCB2YWwpO1xuICB9XG59O1xuXG4vKipcbiAqIChGb3Igb2xkIElFLikgU3RhcnRzIHRyYWNraW5nIHByb3BlcnR5Y2hhbmdlIGV2ZW50cyBvbiB0aGUgcGFzc2VkLWluIGVsZW1lbnRcbiAqIGFuZCBvdmVycmlkZSB0aGUgdmFsdWUgcHJvcGVydHkgc28gdGhhdCB3ZSBjYW4gZGlzdGluZ3Vpc2ggdXNlciBldmVudHMgZnJvbVxuICogdmFsdWUgY2hhbmdlcyBpbiBKUy5cbiAqL1xuZnVuY3Rpb24gc3RhcnRXYXRjaGluZ0ZvclZhbHVlQ2hhbmdlKHRhcmdldCwgdGFyZ2V0SUQpIHtcbiAgYWN0aXZlRWxlbWVudCA9IHRhcmdldDtcbiAgYWN0aXZlRWxlbWVudElEID0gdGFyZ2V0SUQ7XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHRhcmdldC52YWx1ZTtcbiAgYWN0aXZlRWxlbWVudFZhbHVlUHJvcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LmNvbnN0cnVjdG9yLnByb3RvdHlwZSwgJ3ZhbHVlJyk7XG5cbiAgLy8gTm90IGd1YXJkZWQgaW4gYSBjYW5EZWZpbmVQcm9wZXJ0eSBjaGVjazogSUU4IHN1cHBvcnRzIGRlZmluZVByb3BlcnR5IG9ubHlcbiAgLy8gb24gRE9NIGVsZW1lbnRzXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShhY3RpdmVFbGVtZW50LCAndmFsdWUnLCBuZXdWYWx1ZVByb3ApO1xuICBhY3RpdmVFbGVtZW50LmF0dGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xufVxuXG4vKipcbiAqIChGb3Igb2xkIElFLikgUmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXJzIGZyb20gdGhlIGN1cnJlbnRseS10cmFja2VkIGVsZW1lbnQsXG4gKiBpZiBhbnkgZXhpc3RzLlxuICovXG5mdW5jdGlvbiBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpIHtcbiAgaWYgKCFhY3RpdmVFbGVtZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gZGVsZXRlIHJlc3RvcmVzIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZWZpbml0aW9uXG4gIGRlbGV0ZSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICBhY3RpdmVFbGVtZW50LmRldGFjaEV2ZW50KCdvbnByb3BlcnR5Y2hhbmdlJywgaGFuZGxlUHJvcGVydHlDaGFuZ2UpO1xuXG4gIGFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50SUQgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWUgPSBudWxsO1xuICBhY3RpdmVFbGVtZW50VmFsdWVQcm9wID0gbnVsbDtcbn1cblxuLyoqXG4gKiAoRm9yIG9sZCBJRS4pIEhhbmRsZXMgYSBwcm9wZXJ0eWNoYW5nZSBldmVudCwgc2VuZGluZyBhIGBjaGFuZ2VgIGV2ZW50IGlmXG4gKiB0aGUgdmFsdWUgb2YgdGhlIGFjdGl2ZSBlbGVtZW50IGhhcyBjaGFuZ2VkLlxuICovXG5mdW5jdGlvbiBoYW5kbGVQcm9wZXJ0eUNoYW5nZShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQucHJvcGVydHlOYW1lICE9PSAndmFsdWUnKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciB2YWx1ZSA9IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQudmFsdWU7XG4gIGlmICh2YWx1ZSA9PT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGFjdGl2ZUVsZW1lbnRWYWx1ZSA9IHZhbHVlO1xuXG4gIG1hbnVhbERpc3BhdGNoQ2hhbmdlRXZlbnQobmF0aXZlRXZlbnQpO1xufVxuXG4vKipcbiAqIElmIGEgYGNoYW5nZWAgZXZlbnQgc2hvdWxkIGJlIGZpcmVkLCByZXR1cm5zIHRoZSB0YXJnZXQncyBJRC5cbiAqL1xuZnVuY3Rpb24gZ2V0VGFyZ2V0SURGb3JJbnB1dEV2ZW50KHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BJbnB1dCkge1xuICAgIC8vIEluIG1vZGVybiBicm93c2VycyAoaS5lLiwgbm90IElFOCBvciBJRTkpLCB0aGUgaW5wdXQgZXZlbnQgaXMgZXhhY3RseVxuICAgIC8vIHdoYXQgd2Ugd2FudCBzbyBmYWxsIHRocm91Z2ggaGVyZSBhbmQgdHJpZ2dlciBhbiBhYnN0cmFjdCBldmVudFxuICAgIHJldHVybiB0b3BMZXZlbFRhcmdldElEO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGhhbmRsZUV2ZW50c0ZvcklucHV0RXZlbnRJRSh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wRm9jdXMpIHtcbiAgICAvLyBJbiBJRTgsIHdlIGNhbiBjYXB0dXJlIGFsbW9zdCBhbGwgLnZhbHVlIGNoYW5nZXMgYnkgYWRkaW5nIGFcbiAgICAvLyBwcm9wZXJ0eWNoYW5nZSBoYW5kbGVyIGFuZCBsb29raW5nIGZvciBldmVudHMgd2l0aCBwcm9wZXJ0eU5hbWVcbiAgICAvLyBlcXVhbCB0byAndmFsdWUnXG4gICAgLy8gSW4gSUU5LCBwcm9wZXJ0eWNoYW5nZSBmaXJlcyBmb3IgbW9zdCBpbnB1dCBldmVudHMgYnV0IGlzIGJ1Z2d5IGFuZFxuICAgIC8vIGRvZXNuJ3QgZmlyZSB3aGVuIHRleHQgaXMgZGVsZXRlZCwgYnV0IGNvbnZlbmllbnRseSwgc2VsZWN0aW9uY2hhbmdlXG4gICAgLy8gYXBwZWFycyB0byBmaXJlIGluIGFsbCBvZiB0aGUgcmVtYWluaW5nIGNhc2VzIHNvIHdlIGNhdGNoIHRob3NlIGFuZFxuICAgIC8vIGZvcndhcmQgdGhlIGV2ZW50IGlmIHRoZSB2YWx1ZSBoYXMgY2hhbmdlZFxuICAgIC8vIEluIGVpdGhlciBjYXNlLCB3ZSBkb24ndCB3YW50IHRvIGNhbGwgdGhlIGV2ZW50IGhhbmRsZXIgaWYgdGhlIHZhbHVlXG4gICAgLy8gaXMgY2hhbmdlZCBmcm9tIEpTIHNvIHdlIHJlZGVmaW5lIGEgc2V0dGVyIGZvciBgLnZhbHVlYCB0aGF0IHVwZGF0ZXNcbiAgICAvLyBvdXIgYWN0aXZlRWxlbWVudFZhbHVlIHZhcmlhYmxlLCBhbGxvd2luZyB1cyB0byBpZ25vcmUgdGhvc2UgY2hhbmdlc1xuICAgIC8vXG4gICAgLy8gc3RvcFdhdGNoaW5nKCkgc2hvdWxkIGJlIGEgbm9vcCBoZXJlIGJ1dCB3ZSBjYWxsIGl0IGp1c3QgaW4gY2FzZSB3ZVxuICAgIC8vIG1pc3NlZCBhIGJsdXIgZXZlbnQgc29tZWhvdy5cbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICAgIHN0YXJ0V2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSh0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gIH0gZWxzZSBpZiAodG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEJsdXIpIHtcbiAgICBzdG9wV2F0Y2hpbmdGb3JWYWx1ZUNoYW5nZSgpO1xuICB9XG59XG5cbi8vIEZvciBJRTggYW5kIElFOS5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9ySW5wdXRFdmVudElFKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQpIHtcbiAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BTZWxlY3Rpb25DaGFuZ2UgfHwgdG9wTGV2ZWxUeXBlID09PSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwIHx8IHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duKSB7XG4gICAgLy8gT24gdGhlIHNlbGVjdGlvbmNoYW5nZSBldmVudCwgdGhlIHRhcmdldCBpcyBqdXN0IGRvY3VtZW50IHdoaWNoIGlzbid0XG4gICAgLy8gaGVscGZ1bCBmb3IgdXMgc28ganVzdCBjaGVjayBhY3RpdmVFbGVtZW50IGluc3RlYWQuXG4gICAgLy9cbiAgICAvLyA5OSUgb2YgdGhlIHRpbWUsIGtleWRvd24gYW5kIGtleXVwIGFyZW4ndCBuZWNlc3NhcnkuIElFOCBmYWlscyB0byBmaXJlXG4gICAgLy8gcHJvcGVydHljaGFuZ2Ugb24gdGhlIGZpcnN0IGlucHV0IGV2ZW50IGFmdGVyIHNldHRpbmcgYHZhbHVlYCBmcm9tIGFcbiAgICAvLyBzY3JpcHQgYW5kIGZpcmVzIG9ubHkga2V5ZG93biwga2V5cHJlc3MsIGtleXVwLiBDYXRjaGluZyBrZXl1cCB1c3VhbGx5XG4gICAgLy8gZ2V0cyBpdCBhbmQgY2F0Y2hpbmcga2V5ZG93biBsZXRzIHVzIGZpcmUgYW4gZXZlbnQgZm9yIHRoZSBmaXJzdFxuICAgIC8vIGtleXN0cm9rZSBpZiB1c2VyIGRvZXMgYSBrZXkgcmVwZWF0IChpdCdsbCBiZSBhIGxpdHRsZSBkZWxheWVkOiByaWdodFxuICAgIC8vIGJlZm9yZSB0aGUgc2Vjb25kIGtleXN0cm9rZSkuIE90aGVyIGlucHV0IG1ldGhvZHMgKGUuZy4sIHBhc3RlKSBzZWVtIHRvXG4gICAgLy8gZmlyZSBzZWxlY3Rpb25jaGFuZ2Ugbm9ybWFsbHkuXG4gICAgaWYgKGFjdGl2ZUVsZW1lbnQgJiYgYWN0aXZlRWxlbWVudC52YWx1ZSAhPT0gYWN0aXZlRWxlbWVudFZhbHVlKSB7XG4gICAgICBhY3RpdmVFbGVtZW50VmFsdWUgPSBhY3RpdmVFbGVtZW50LnZhbHVlO1xuICAgICAgcmV0dXJuIGFjdGl2ZUVsZW1lbnRJRDtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBTRUNUSU9OOiBoYW5kbGUgYGNsaWNrYCBldmVudFxuICovXG5mdW5jdGlvbiBzaG91bGRVc2VDbGlja0V2ZW50KGVsZW0pIHtcbiAgLy8gVXNlIHRoZSBgY2xpY2tgIGV2ZW50IHRvIGRldGVjdCBjaGFuZ2VzIHRvIGNoZWNrYm94IGFuZCByYWRpbyBpbnB1dHMuXG4gIC8vIFRoaXMgYXBwcm9hY2ggd29ya3MgYWNyb3NzIGFsbCBicm93c2Vycywgd2hlcmVhcyBgY2hhbmdlYCBkb2VzIG5vdCBmaXJlXG4gIC8vIHVudGlsIGBibHVyYCBpbiBJRTguXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JyAmJiAoZWxlbS50eXBlID09PSAnY2hlY2tib3gnIHx8IGVsZW0udHlwZSA9PT0gJ3JhZGlvJyk7XG59XG5cbmZ1bmN0aW9uIGdldFRhcmdldElERm9yQ2xpY2tFdmVudCh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKSB7XG4gIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wQ2xpY2spIHtcbiAgICByZXR1cm4gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgfVxufVxuXG4vKipcbiAqIFRoaXMgcGx1Z2luIGNyZWF0ZXMgYW4gYG9uQ2hhbmdlYCBldmVudCB0aGF0IG5vcm1hbGl6ZXMgY2hhbmdlIGV2ZW50c1xuICogYWNyb3NzIGZvcm0gZWxlbWVudHMuIFRoaXMgZXZlbnQgZmlyZXMgYXQgYSB0aW1lIHdoZW4gaXQncyBwb3NzaWJsZSB0b1xuICogY2hhbmdlIHRoZSBlbGVtZW50J3MgdmFsdWUgd2l0aG91dCBzZWVpbmcgYSBmbGlja2VyLlxuICpcbiAqIFN1cHBvcnRlZCBlbGVtZW50cyBhcmU6XG4gKiAtIGlucHV0IChzZWUgYGlzVGV4dElucHV0RWxlbWVudGApXG4gKiAtIHRleHRhcmVhXG4gKiAtIHNlbGVjdFxuICovXG52YXIgQ2hhbmdlRXZlbnRQbHVnaW4gPSB7XG5cbiAgZXZlbnRUeXBlczogZXZlbnRUeXBlcyxcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRvcExldmVsVHlwZSBSZWNvcmQgZnJvbSBgRXZlbnRDb25zdGFudHNgLlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0b3BMZXZlbFRhcmdldCBUaGUgbGlzdGVuaW5nIGNvbXBvbmVudCByb290IG5vZGUuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFRhcmdldElEIElEIG9mIGB0b3BMZXZlbFRhcmdldGAuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAgICogQHJldHVybiB7Kn0gQW4gYWNjdW11bGF0aW9uIG9mIHN5bnRoZXRpYyBldmVudHMuXG4gICAqIEBzZWUge0V2ZW50UGx1Z2luSHViLmV4dHJhY3RFdmVudHN9XG4gICAqL1xuICBleHRyYWN0RXZlbnRzOiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG5cbiAgICB2YXIgZ2V0VGFyZ2V0SURGdW5jLCBoYW5kbGVFdmVudEZ1bmM7XG4gICAgaWYgKHNob3VsZFVzZUNoYW5nZUV2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgaWYgKGRvZXNDaGFuZ2VFdmVudEJ1YmJsZSkge1xuICAgICAgICBnZXRUYXJnZXRJREZ1bmMgPSBnZXRUYXJnZXRJREZvckNoYW5nZUV2ZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFuZGxlRXZlbnRGdW5jID0gaGFuZGxlRXZlbnRzRm9yQ2hhbmdlRXZlbnRJRTg7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RleHRJbnB1dEVsZW1lbnQodG9wTGV2ZWxUYXJnZXQpKSB7XG4gICAgICBpZiAoaXNJbnB1dEV2ZW50U3VwcG9ydGVkKSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdldFRhcmdldElERnVuYyA9IGdldFRhcmdldElERm9ySW5wdXRFdmVudElFO1xuICAgICAgICBoYW5kbGVFdmVudEZ1bmMgPSBoYW5kbGVFdmVudHNGb3JJbnB1dEV2ZW50SUU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzaG91bGRVc2VDbGlja0V2ZW50KHRvcExldmVsVGFyZ2V0KSkge1xuICAgICAgZ2V0VGFyZ2V0SURGdW5jID0gZ2V0VGFyZ2V0SURGb3JDbGlja0V2ZW50O1xuICAgIH1cblxuICAgIGlmIChnZXRUYXJnZXRJREZ1bmMpIHtcbiAgICAgIHZhciB0YXJnZXRJRCA9IGdldFRhcmdldElERnVuYyh0b3BMZXZlbFR5cGUsIHRvcExldmVsVGFyZ2V0LCB0b3BMZXZlbFRhcmdldElEKTtcbiAgICAgIGlmICh0YXJnZXRJRCkge1xuICAgICAgICB2YXIgZXZlbnQgPSBTeW50aGV0aWNFdmVudC5nZXRQb29sZWQoZXZlbnRUeXBlcy5jaGFuZ2UsIHRhcmdldElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgICAgICBldmVudC50eXBlID0gJ2NoYW5nZSc7XG4gICAgICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZVR3b1BoYXNlRGlzcGF0Y2hlcyhldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaGFuZGxlRXZlbnRGdW5jKSB7XG4gICAgICBoYW5kbGVFdmVudEZ1bmModG9wTGV2ZWxUeXBlLCB0b3BMZXZlbFRhcmdldCwgdG9wTGV2ZWxUYXJnZXRJRCk7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ2hhbmdlRXZlbnRQbHVnaW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvQ2hhbmdlRXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0RXZlbnRUYXJnZXRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEdldHMgdGhlIHRhcmdldCBub2RlIGZyb20gYSBuYXRpdmUgYnJvd3NlciBldmVudCBieSBhY2NvdW50aW5nIGZvclxuICogaW5jb25zaXN0ZW5jaWVzIGluIGJyb3dzZXIgRE9NIEFQSXMuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7RE9NRXZlbnRUYXJnZXR9IFRhcmdldCBub2RlLlxuICovXG5mdW5jdGlvbiBnZXRFdmVudFRhcmdldChuYXRpdmVFdmVudCkge1xuICB2YXIgdGFyZ2V0ID0gbmF0aXZlRXZlbnQudGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnNyY0VsZW1lbnQgfHwgd2luZG93O1xuICAvLyBTYWZhcmkgbWF5IGZpcmUgZXZlbnRzIG9uIHRleHQgbm9kZXMgKE5vZGUuVEVYVF9OT0RFIGlzIDMpLlxuICAvLyBAc2VlIGh0dHA6Ly93d3cucXVpcmtzbW9kZS5vcmcvanMvZXZlbnRzX3Byb3BlcnRpZXMuaHRtbFxuICByZXR1cm4gdGFyZ2V0Lm5vZGVUeXBlID09PSAzID8gdGFyZ2V0LnBhcmVudE5vZGUgOiB0YXJnZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRUYXJnZXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvZ2V0RXZlbnRUYXJnZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaXNUZXh0SW5wdXRFbGVtZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEBzZWUgaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvdGhlLWlucHV0LWVsZW1lbnQuaHRtbCNpbnB1dC10eXBlLWF0dHItc3VtbWFyeVxuICovXG52YXIgc3VwcG9ydGVkSW5wdXRUeXBlcyA9IHtcbiAgJ2NvbG9yJzogdHJ1ZSxcbiAgJ2RhdGUnOiB0cnVlLFxuICAnZGF0ZXRpbWUnOiB0cnVlLFxuICAnZGF0ZXRpbWUtbG9jYWwnOiB0cnVlLFxuICAnZW1haWwnOiB0cnVlLFxuICAnbW9udGgnOiB0cnVlLFxuICAnbnVtYmVyJzogdHJ1ZSxcbiAgJ3Bhc3N3b3JkJzogdHJ1ZSxcbiAgJ3JhbmdlJzogdHJ1ZSxcbiAgJ3NlYXJjaCc6IHRydWUsXG4gICd0ZWwnOiB0cnVlLFxuICAndGV4dCc6IHRydWUsXG4gICd0aW1lJzogdHJ1ZSxcbiAgJ3VybCc6IHRydWUsXG4gICd3ZWVrJzogdHJ1ZVxufTtcblxuZnVuY3Rpb24gaXNUZXh0SW5wdXRFbGVtZW50KGVsZW0pIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbSAmJiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBzdXBwb3J0ZWRJbnB1dFR5cGVzW2VsZW0udHlwZV0gfHwgbm9kZU5hbWUgPT09ICd0ZXh0YXJlYScpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGlzVGV4dElucHV0RWxlbWVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9pc1RleHRJbnB1dEVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgQ2xpZW50UmVhY3RSb290SW5kZXhcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbmV4dFJlYWN0Um9vdEluZGV4ID0gMDtcblxudmFyIENsaWVudFJlYWN0Um9vdEluZGV4ID0ge1xuICBjcmVhdGVSZWFjdFJvb3RJbmRleDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBuZXh0UmVhY3RSb290SW5kZXgrKztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDbGllbnRSZWFjdFJvb3RJbmRleDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9DbGllbnRSZWFjdFJvb3RJbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBEZWZhdWx0RXZlbnRQbHVnaW5PcmRlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxuLyoqXG4gKiBNb2R1bGUgdGhhdCBpcyBpbmplY3RhYmxlIGludG8gYEV2ZW50UGx1Z2luSHViYCwgdGhhdCBzcGVjaWZpZXMgYVxuICogZGV0ZXJtaW5pc3RpYyBvcmRlcmluZyBvZiBgRXZlbnRQbHVnaW5gcy4gQSBjb252ZW5pZW50IHdheSB0byByZWFzb24gYWJvdXRcbiAqIHBsdWdpbnMsIHdpdGhvdXQgaGF2aW5nIHRvIHBhY2thZ2UgZXZlcnkgb25lIG9mIHRoZW0uIFRoaXMgaXMgYmV0dGVyIHRoYW5cbiAqIGhhdmluZyBwbHVnaW5zIGJlIG9yZGVyZWQgaW4gdGhlIHNhbWUgb3JkZXIgdGhhdCB0aGV5IGFyZSBpbmplY3RlZCBiZWNhdXNlXG4gKiB0aGF0IG9yZGVyaW5nIHdvdWxkIGJlIGluZmx1ZW5jZWQgYnkgdGhlIHBhY2thZ2luZyBvcmRlci5cbiAqIGBSZXNwb25kZXJFdmVudFBsdWdpbmAgbXVzdCBvY2N1ciBiZWZvcmUgYFNpbXBsZUV2ZW50UGx1Z2luYCBzbyB0aGF0XG4gKiBwcmV2ZW50aW5nIGRlZmF1bHQgb24gZXZlbnRzIGlzIGNvbnZlbmllbnQgaW4gYFNpbXBsZUV2ZW50UGx1Z2luYCBoYW5kbGVycy5cbiAqL1xudmFyIERlZmF1bHRFdmVudFBsdWdpbk9yZGVyID0gW2tleU9mKHsgUmVzcG9uZGVyRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgU2ltcGxlRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgVGFwRXZlbnRQbHVnaW46IG51bGwgfSksIGtleU9mKHsgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IENoYW5nZUV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IFNlbGVjdEV2ZW50UGx1Z2luOiBudWxsIH0pLCBrZXlPZih7IEJlZm9yZUlucHV0RXZlbnRQbHVnaW46IG51bGwgfSldO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERlZmF1bHRFdmVudFBsdWdpbk9yZGVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0RlZmF1bHRFdmVudFBsdWdpbk9yZGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEVudGVyTGVhdmVFdmVudFBsdWdpblxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcblxudmFyIHRvcExldmVsVHlwZXMgPSBFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzO1xudmFyIGdldEZpcnN0UmVhY3RET00gPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET007XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBtb3VzZUVudGVyOiB7XG4gICAgcmVnaXN0cmF0aW9uTmFtZToga2V5T2YoeyBvbk1vdXNlRW50ZXI6IG51bGwgfSksXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCwgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU92ZXJdXG4gIH0sXG4gIG1vdXNlTGVhdmU6IHtcbiAgICByZWdpc3RyYXRpb25OYW1lOiBrZXlPZih7IG9uTW91c2VMZWF2ZTogbnVsbCB9KSxcbiAgICBkZXBlbmRlbmNpZXM6IFt0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3V0LCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcl1cbiAgfVxufTtcblxudmFyIGV4dHJhY3RlZEV2ZW50cyA9IFtudWxsLCBudWxsXTtcblxudmFyIEVudGVyTGVhdmVFdmVudFBsdWdpbiA9IHtcblxuICBldmVudFR5cGVzOiBldmVudFR5cGVzLFxuXG4gIC8qKlxuICAgKiBGb3IgYWxtb3N0IGV2ZXJ5IGludGVyYWN0aW9uIHdlIGNhcmUgYWJvdXQsIHRoZXJlIHdpbGwgYmUgYm90aCBhIHRvcC1sZXZlbFxuICAgKiBgbW91c2VvdmVyYCBhbmQgYG1vdXNlb3V0YCBldmVudCB0aGF0IG9jY3Vycy4gT25seSB1c2UgYG1vdXNlb3V0YCBzbyB0aGF0XG4gICAqIHdlIGRvIG5vdCBleHRyYWN0IGR1cGxpY2F0ZSBldmVudHMuIEhvd2V2ZXIsIG1vdmluZyB0aGUgbW91c2UgaW50byB0aGVcbiAgICogYnJvd3NlciBmcm9tIG91dHNpZGUgd2lsbCBub3QgZmlyZSBhIGBtb3VzZW91dGAgZXZlbnQuIEluIHRoaXMgY2FzZSwgd2UgdXNlXG4gICAqIHRoZSBgbW91c2VvdmVyYCB0b3AtbGV2ZWwgZXZlbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICh0b3BMZXZlbFR5cGUgPT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyICYmIChuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LmZyb21FbGVtZW50KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGlmICh0b3BMZXZlbFR5cGUgIT09IHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQgJiYgdG9wTGV2ZWxUeXBlICE9PSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlT3Zlcikge1xuICAgICAgLy8gTXVzdCBub3QgYmUgYSBtb3VzZSBpbiBvciBtb3VzZSBvdXQgLSBpZ25vcmluZy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciB3aW47XG4gICAgaWYgKHRvcExldmVsVGFyZ2V0LndpbmRvdyA9PT0gdG9wTGV2ZWxUYXJnZXQpIHtcbiAgICAgIC8vIGB0b3BMZXZlbFRhcmdldGAgaXMgcHJvYmFibHkgYSB3aW5kb3cgb2JqZWN0LlxuICAgICAgd2luID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRPRE86IEZpZ3VyZSBvdXQgd2h5IGBvd25lckRvY3VtZW50YCBpcyBzb21ldGltZXMgdW5kZWZpbmVkIGluIElFOC5cbiAgICAgIHZhciBkb2MgPSB0b3BMZXZlbFRhcmdldC5vd25lckRvY3VtZW50O1xuICAgICAgaWYgKGRvYykge1xuICAgICAgICB3aW4gPSBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpbiA9IHdpbmRvdztcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG4gICAgdmFyIGZyb21JRCA9ICcnO1xuICAgIHZhciB0b0lEID0gJyc7XG4gICAgaWYgKHRvcExldmVsVHlwZSA9PT0gdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU91dCkge1xuICAgICAgZnJvbSA9IHRvcExldmVsVGFyZ2V0O1xuICAgICAgZnJvbUlEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgIHRvID0gZ2V0Rmlyc3RSZWFjdERPTShuYXRpdmVFdmVudC5yZWxhdGVkVGFyZ2V0IHx8IG5hdGl2ZUV2ZW50LnRvRWxlbWVudCk7XG4gICAgICBpZiAodG8pIHtcbiAgICAgICAgdG9JRCA9IFJlYWN0TW91bnQuZ2V0SUQodG8pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdG8gPSB3aW47XG4gICAgICB9XG4gICAgICB0byA9IHRvIHx8IHdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgZnJvbSA9IHdpbjtcbiAgICAgIHRvID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICB0b0lEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICB9XG5cbiAgICBpZiAoZnJvbSA9PT0gdG8pIHtcbiAgICAgIC8vIE5vdGhpbmcgcGVydGFpbnMgdG8gb3VyIG1hbmFnZWQgY29tcG9uZW50cy5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHZhciBsZWF2ZSA9IFN5bnRoZXRpY01vdXNlRXZlbnQuZ2V0UG9vbGVkKGV2ZW50VHlwZXMubW91c2VMZWF2ZSwgZnJvbUlELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuICAgIGxlYXZlLnR5cGUgPSAnbW91c2VsZWF2ZSc7XG4gICAgbGVhdmUudGFyZ2V0ID0gZnJvbTtcbiAgICBsZWF2ZS5yZWxhdGVkVGFyZ2V0ID0gdG87XG5cbiAgICB2YXIgZW50ZXIgPSBTeW50aGV0aWNNb3VzZUV2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLm1vdXNlRW50ZXIsIHRvSUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgZW50ZXIudHlwZSA9ICdtb3VzZWVudGVyJztcbiAgICBlbnRlci50YXJnZXQgPSB0bztcbiAgICBlbnRlci5yZWxhdGVkVGFyZ2V0ID0gZnJvbTtcblxuICAgIEV2ZW50UHJvcGFnYXRvcnMuYWNjdW11bGF0ZUVudGVyTGVhdmVEaXNwYXRjaGVzKGxlYXZlLCBlbnRlciwgZnJvbUlELCB0b0lEKTtcblxuICAgIGV4dHJhY3RlZEV2ZW50c1swXSA9IGxlYXZlO1xuICAgIGV4dHJhY3RlZEV2ZW50c1sxXSA9IGVudGVyO1xuXG4gICAgcmV0dXJuIGV4dHJhY3RlZEV2ZW50cztcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEVudGVyTGVhdmVFdmVudFBsdWdpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9FbnRlckxlYXZlRXZlbnRQbHVnaW4uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljTW91c2VFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgVmlld3BvcnRNZXRyaWNzID0gcmVxdWlyZSgnLi9WaWV3cG9ydE1ldHJpY3MnKTtcblxudmFyIGdldEV2ZW50TW9kaWZpZXJTdGF0ZSA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRNb2RpZmllclN0YXRlJyk7XG5cbi8qKlxuICogQGludGVyZmFjZSBNb3VzZUV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIE1vdXNlRXZlbnRJbnRlcmZhY2UgPSB7XG4gIHNjcmVlblg6IG51bGwsXG4gIHNjcmVlblk6IG51bGwsXG4gIGNsaWVudFg6IG51bGwsXG4gIGNsaWVudFk6IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIGdldE1vZGlmaWVyU3RhdGU6IGdldEV2ZW50TW9kaWZpZXJTdGF0ZSxcbiAgYnV0dG9uOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBXZWJraXQsIEZpcmVmb3gsIElFOStcbiAgICAvLyB3aGljaDogIDEgMiAzXG4gICAgLy8gYnV0dG9uOiAwIDEgMiAoc3RhbmRhcmQpXG4gICAgdmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcbiAgICBpZiAoJ3doaWNoJyBpbiBldmVudCkge1xuICAgICAgcmV0dXJuIGJ1dHRvbjtcbiAgICB9XG4gICAgLy8gSUU8OVxuICAgIC8vIHdoaWNoOiAgdW5kZWZpbmVkXG4gICAgLy8gYnV0dG9uOiAwIDAgMFxuICAgIC8vIGJ1dHRvbjogMSA0IDIgKG9ubW91c2V1cClcbiAgICByZXR1cm4gYnV0dG9uID09PSAyID8gMiA6IGJ1dHRvbiA9PT0gNCA/IDEgOiAwO1xuICB9LFxuICBidXR0b25zOiBudWxsLFxuICByZWxhdGVkVGFyZ2V0OiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCAoZXZlbnQuZnJvbUVsZW1lbnQgPT09IGV2ZW50LnNyY0VsZW1lbnQgPyBldmVudC50b0VsZW1lbnQgOiBldmVudC5mcm9tRWxlbWVudCk7XG4gIH0sXG4gIC8vIFwiUHJvcHJpZXRhcnlcIiBJbnRlcmZhY2UuXG4gIHBhZ2VYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ3BhZ2VYJyBpbiBldmVudCA/IGV2ZW50LnBhZ2VYIDogZXZlbnQuY2xpZW50WCArIFZpZXdwb3J0TWV0cmljcy5jdXJyZW50U2Nyb2xsTGVmdDtcbiAgfSxcbiAgcGFnZVk6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAncGFnZVknIGluIGV2ZW50ID8gZXZlbnQucGFnZVkgOiBldmVudC5jbGllbnRZICsgVmlld3BvcnRNZXRyaWNzLmN1cnJlbnRTY3JvbGxUb3A7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY01vdXNlRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljVUlFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljVUlFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljTW91c2VFdmVudCwgTW91c2VFdmVudEludGVyZmFjZSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3ludGhldGljTW91c2VFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNNb3VzZUV2ZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFN5bnRoZXRpY1VJRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0V2ZW50Jyk7XG5cbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFVJRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgVUlFdmVudEludGVyZmFjZSA9IHtcbiAgdmlldzogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnZpZXcpIHtcbiAgICAgIHJldHVybiBldmVudC52aWV3O1xuICAgIH1cblxuICAgIHZhciB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChldmVudCk7XG4gICAgaWYgKHRhcmdldCAhPSBudWxsICYmIHRhcmdldC53aW5kb3cgPT09IHRhcmdldCkge1xuICAgICAgLy8gdGFyZ2V0IGlzIGEgd2luZG93IG9iamVjdFxuICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICB9XG5cbiAgICB2YXIgZG9jID0gdGFyZ2V0Lm93bmVyRG9jdW1lbnQ7XG4gICAgLy8gVE9ETzogRmlndXJlIG91dCB3aHkgYG93bmVyRG9jdW1lbnRgIGlzIHNvbWV0aW1lcyB1bmRlZmluZWQgaW4gSUU4LlxuICAgIGlmIChkb2MpIHtcbiAgICAgIHJldHVybiBkb2MuZGVmYXVsdFZpZXcgfHwgZG9jLnBhcmVudFdpbmRvdztcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gIH0sXG4gIGRldGFpbDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuIGV2ZW50LmRldGFpbCB8fCAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljVUlFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1VJRXZlbnQsIFVJRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1VJRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvU3ludGhldGljVUlFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudE1vZGlmaWVyU3RhdGVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRyYW5zbGF0aW9uIGZyb20gbW9kaWZpZXIga2V5IHRvIHRoZSBhc3NvY2lhdGVkIHByb3BlcnR5IGluIHRoZSBldmVudC5cbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNrZXlzLU1vZGlmaWVyc1xuICovXG5cbnZhciBtb2RpZmllcktleVRvUHJvcCA9IHtcbiAgJ0FsdCc6ICdhbHRLZXknLFxuICAnQ29udHJvbCc6ICdjdHJsS2V5JyxcbiAgJ01ldGEnOiAnbWV0YUtleScsXG4gICdTaGlmdCc6ICdzaGlmdEtleSdcbn07XG5cbi8vIElFOCBkb2VzIG5vdCBpbXBsZW1lbnQgZ2V0TW9kaWZpZXJTdGF0ZSBzbyB3ZSBzaW1wbHkgbWFwIGl0IHRvIHRoZSBvbmx5XG4vLyBtb2RpZmllciBrZXlzIGV4cG9zZWQgYnkgdGhlIGV2ZW50IGl0c2VsZiwgZG9lcyBub3Qgc3VwcG9ydCBMb2NrLWtleXMuXG4vLyBDdXJyZW50bHksIGFsbCBtYWpvciBicm93c2VycyBleGNlcHQgQ2hyb21lIHNlZW1zIHRvIHN1cHBvcnQgTG9jay1rZXlzLlxuZnVuY3Rpb24gbW9kaWZpZXJTdGF0ZUdldHRlcihrZXlBcmcpIHtcbiAgdmFyIHN5bnRoZXRpY0V2ZW50ID0gdGhpcztcbiAgdmFyIG5hdGl2ZUV2ZW50ID0gc3ludGhldGljRXZlbnQubmF0aXZlRXZlbnQ7XG4gIGlmIChuYXRpdmVFdmVudC5nZXRNb2RpZmllclN0YXRlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUV2ZW50LmdldE1vZGlmaWVyU3RhdGUoa2V5QXJnKTtcbiAgfVxuICB2YXIga2V5UHJvcCA9IG1vZGlmaWVyS2V5VG9Qcm9wW2tleUFyZ107XG4gIHJldHVybiBrZXlQcm9wID8gISFuYXRpdmVFdmVudFtrZXlQcm9wXSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRFdmVudE1vZGlmaWVyU3RhdGUobmF0aXZlRXZlbnQpIHtcbiAgcmV0dXJuIG1vZGlmaWVyU3RhdGVHZXR0ZXI7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRNb2RpZmllclN0YXRlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2dldEV2ZW50TW9kaWZpZXJTdGF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBIVE1MRE9NUHJvcGVydHlDb25maWdcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBNVVNUX1VTRV9BVFRSSUJVVEUgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uTVVTVF9VU0VfQVRUUklCVVRFO1xudmFyIE1VU1RfVVNFX1BST1BFUlRZID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX1BST1BFUlRZO1xudmFyIEhBU19CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19CT09MRUFOX1ZBTFVFO1xudmFyIEhBU19TSURFX0VGRkVDVFMgPSBET01Qcm9wZXJ0eS5pbmplY3Rpb24uSEFTX1NJREVfRUZGRUNUUztcbnZhciBIQVNfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSA9IERPTVByb3BlcnR5LmluamVjdGlvbi5IQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRTtcbnZhciBIQVNfT1ZFUkxPQURFRF9CT09MRUFOX1ZBTFVFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLkhBU19PVkVSTE9BREVEX0JPT0xFQU5fVkFMVUU7XG5cbnZhciBoYXNTVkc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciBpbXBsZW1lbnRhdGlvbiA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uO1xuICBoYXNTVkcgPSBpbXBsZW1lbnRhdGlvbiAmJiBpbXBsZW1lbnRhdGlvbi5oYXNGZWF0dXJlICYmIGltcGxlbWVudGF0aW9uLmhhc0ZlYXR1cmUoJ2h0dHA6Ly93d3cudzMub3JnL1RSL1NWRzExL2ZlYXR1cmUjQmFzaWNTdHJ1Y3R1cmUnLCAnMS4xJyk7XG59XG5cbnZhciBIVE1MRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIGlzQ3VzdG9tQXR0cmlidXRlOiBSZWdFeHAucHJvdG90eXBlLnRlc3QuYmluZCgvXihkYXRhfGFyaWEpLVthLXpfXVthLXpcXGRfLlxcLV0qJC8pLFxuICBQcm9wZXJ0aWVzOiB7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFjY2VwdDogbnVsbCxcbiAgICBhY2NlcHRDaGFyc2V0OiBudWxsLFxuICAgIGFjY2Vzc0tleTogbnVsbCxcbiAgICBhY3Rpb246IG51bGwsXG4gICAgYWxsb3dGdWxsU2NyZWVuOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBhbGxvd1RyYW5zcGFyZW5jeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGFsdDogbnVsbCxcbiAgICBhc3luYzogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgYXV0b0NvbXBsZXRlOiBudWxsLFxuICAgIC8vIGF1dG9Gb2N1cyBpcyBwb2x5ZmlsbGVkL25vcm1hbGl6ZWQgYnkgQXV0b0ZvY3VzVXRpbHNcbiAgICAvLyBhdXRvRm9jdXM6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGF1dG9QbGF5OiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjYXB0dXJlOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjZWxsUGFkZGluZzogbnVsbCxcbiAgICBjZWxsU3BhY2luZzogbnVsbCxcbiAgICBjaGFyU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hhbGxlbmdlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY2hlY2tlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjbGFzc0lEOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gVG8gc2V0IGNsYXNzTmFtZSBvbiBTVkcgZWxlbWVudHMsIGl0J3MgbmVjZXNzYXJ5IHRvIHVzZSAuc2V0QXR0cmlidXRlO1xuICAgIC8vIHRoaXMgd29ya3Mgb24gSFRNTCBlbGVtZW50cyB0b28gaW4gYWxsIGJyb3dzZXJzIGV4Y2VwdCBJRTguIENvbnZlbmllbnRseSxcbiAgICAvLyBJRTggZG9lc24ndCBzdXBwb3J0IFNWRyBhbmQgc28gd2UgY2FuIHNpbXBseSB1c2UgdGhlIGF0dHJpYnV0ZSBpblxuICAgIC8vIGJyb3dzZXJzIHRoYXQgc3VwcG9ydCBTVkcgYW5kIHRoZSBwcm9wZXJ0eSBpbiBicm93c2VycyB0aGF0IGRvbid0LFxuICAgIC8vIHJlZ2FyZGxlc3Mgb2Ygd2hldGhlciB0aGUgZWxlbWVudCBpcyBIVE1MIG9yIFNWRy5cbiAgICBjbGFzc05hbWU6IGhhc1NWRyA/IE1VU1RfVVNFX0FUVFJJQlVURSA6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGNvbHM6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIGNvbFNwYW46IG51bGwsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBjb250ZW50RWRpdGFibGU6IG51bGwsXG4gICAgY29udGV4dE1lbnU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBjb250cm9sczogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBjb29yZHM6IG51bGwsXG4gICAgY3Jvc3NPcmlnaW46IG51bGwsXG4gICAgZGF0YTogbnVsbCwgLy8gRm9yIGA8b2JqZWN0IC8+YCBhY3RzIGFzIGBzcmNgLlxuICAgIGRhdGVUaW1lOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ2RlZmF1bHQnOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkZWZlcjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgZGlyOiBudWxsLFxuICAgIGRpc2FibGVkOiBNVVNUX1VTRV9BVFRSSUJVVEUgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBkb3dubG9hZDogSEFTX09WRVJMT0FERURfQk9PTEVBTl9WQUxVRSxcbiAgICBkcmFnZ2FibGU6IG51bGwsXG4gICAgZW5jVHlwZTogbnVsbCxcbiAgICBmb3JtOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybUFjdGlvbjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1FbmNUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZm9ybU1ldGhvZDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvcm1Ob1ZhbGlkYXRlOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBmb3JtVGFyZ2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnJhbWVCb3JkZXI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBoZWFkZXJzOiBudWxsLFxuICAgIGhlaWdodDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGhpZGRlbjogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgaGlnaDogbnVsbCxcbiAgICBocmVmOiBudWxsLFxuICAgIGhyZWZMYW5nOiBudWxsLFxuICAgIGh0bWxGb3I6IG51bGwsXG4gICAgaHR0cEVxdWl2OiBudWxsLFxuICAgIGljb246IG51bGwsXG4gICAgaWQ6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIGlucHV0TW9kZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGludGVncml0eTogbnVsbCxcbiAgICBpczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVBhcmFtczogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGtleVR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBraW5kOiBudWxsLFxuICAgIGxhYmVsOiBudWxsLFxuICAgIGxhbmc6IG51bGwsXG4gICAgbGlzdDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGxvb3A6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgbG93OiBudWxsLFxuICAgIG1hbmlmZXN0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbWFyZ2luSGVpZ2h0OiBudWxsLFxuICAgIG1hcmdpbldpZHRoOiBudWxsLFxuICAgIG1heDogbnVsbCxcbiAgICBtYXhMZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtZWRpYTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG1lZGlhR3JvdXA6IG51bGwsXG4gICAgbWV0aG9kOiBudWxsLFxuICAgIG1pbjogbnVsbCxcbiAgICBtaW5MZW5ndGg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtdWx0aXBsZTogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBtdXRlZDogTVVTVF9VU0VfUFJPUEVSVFkgfCBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICBuYW1lOiBudWxsLFxuICAgIG5vbmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgbm9WYWxpZGF0ZTogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3BlbjogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgb3B0aW11bTogbnVsbCxcbiAgICBwYXR0ZXJuOiBudWxsLFxuICAgIHBsYWNlaG9sZGVyOiBudWxsLFxuICAgIHBvc3RlcjogbnVsbCxcbiAgICBwcmVsb2FkOiBudWxsLFxuICAgIHJhZGlvR3JvdXA6IG51bGwsXG4gICAgcmVhZE9ubHk6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcmVsOiBudWxsLFxuICAgIHJlcXVpcmVkOiBIQVNfQk9PTEVBTl9WQUxVRSxcbiAgICByZXZlcnNlZDogSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgcm9sZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJvd3M6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19QT1NJVElWRV9OVU1FUklDX1ZBTFVFLFxuICAgIHJvd1NwYW46IG51bGwsXG4gICAgc2FuZGJveDogbnVsbCxcbiAgICBzY29wZTogbnVsbCxcbiAgICBzY29wZWQ6IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIHNjcm9sbGluZzogbnVsbCxcbiAgICBzZWFtbGVzczogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2VsZWN0ZWQ6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX0JPT0xFQU5fVkFMVUUsXG4gICAgc2hhcGU6IG51bGwsXG4gICAgc2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFIHwgSEFTX1BPU0lUSVZFX05VTUVSSUNfVkFMVUUsXG4gICAgc2l6ZXM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzcGFuOiBIQVNfUE9TSVRJVkVfTlVNRVJJQ19WQUxVRSxcbiAgICBzcGVsbENoZWNrOiBudWxsLFxuICAgIHNyYzogbnVsbCxcbiAgICBzcmNEb2M6IE1VU1RfVVNFX1BST1BFUlRZLFxuICAgIHNyY0xhbmc6IG51bGwsXG4gICAgc3JjU2V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RhcnQ6IEhBU19OVU1FUklDX1ZBTFVFLFxuICAgIHN0ZXA6IG51bGwsXG4gICAgc3R5bGU6IG51bGwsXG4gICAgc3VtbWFyeTogbnVsbCxcbiAgICB0YWJJbmRleDogbnVsbCxcbiAgICB0YXJnZXQ6IG51bGwsXG4gICAgdGl0bGU6IG51bGwsXG4gICAgdHlwZTogbnVsbCxcbiAgICB1c2VNYXA6IG51bGwsXG4gICAgdmFsdWU6IE1VU1RfVVNFX1BST1BFUlRZIHwgSEFTX1NJREVfRUZGRUNUUyxcbiAgICB3aWR0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHdtb2RlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgd3JhcDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIFJERmEgUHJvcGVydGllc1xuICAgICAqL1xuICAgIGFib3V0OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZGF0YXR5cGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpbmxpc3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwcmVmaXg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBwcm9wZXJ0eSBpcyBhbHNvIHN1cHBvcnRlZCBmb3IgT3BlbkdyYXBoIGluIG1ldGEgdGFncy5cbiAgICBwcm9wZXJ0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJlc291cmNlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgJ3R5cGVvZic6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2b2NhYjogTVVTVF9VU0VfQVRUUklCVVRFLFxuXG4gICAgLyoqXG4gICAgICogTm9uLXN0YW5kYXJkIFByb3BlcnRpZXNcbiAgICAgKi9cbiAgICAvLyBhdXRvQ2FwaXRhbGl6ZSBhbmQgYXV0b0NvcnJlY3QgYXJlIHN1cHBvcnRlZCBpbiBNb2JpbGUgU2FmYXJpIGZvclxuICAgIC8vIGtleWJvYXJkIGhpbnRzLlxuICAgIGF1dG9DYXBpdGFsaXplOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgYXV0b0NvcnJlY3Q6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyBhdXRvU2F2ZSBhbGxvd3MgV2ViS2l0L0JsaW5rIHRvIHBlcnNpc3QgdmFsdWVzIG9mIGlucHV0IGZpZWxkcyBvbiBwYWdlIHJlbG9hZHNcbiAgICBhdXRvU2F2ZTogbnVsbCxcbiAgICAvLyBjb2xvciBpcyBmb3IgU2FmYXJpIG1hc2staWNvbiBsaW5rXG4gICAgY29sb3I6IG51bGwsXG4gICAgLy8gaXRlbVByb3AsIGl0ZW1TY29wZSwgaXRlbVR5cGUgYXJlIGZvclxuICAgIC8vIE1pY3JvZGF0YSBzdXBwb3J0LiBTZWUgaHR0cDovL3NjaGVtYS5vcmcvZG9jcy9ncy5odG1sXG4gICAgaXRlbVByb3A6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBpdGVtU2NvcGU6IE1VU1RfVVNFX0FUVFJJQlVURSB8IEhBU19CT09MRUFOX1ZBTFVFLFxuICAgIGl0ZW1UeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gaXRlbUlEIGFuZCBpdGVtUmVmIGFyZSBmb3IgTWljcm9kYXRhIHN1cHBvcnQgYXMgd2VsbCBidXRcbiAgICAvLyBvbmx5IHNwZWNpZmllZCBpbiB0aGUgdGhlIFdIQVRXRyBzcGVjIGRvY3VtZW50LiBTZWVcbiAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9taWNyb2RhdGEuaHRtbCNtaWNyb2RhdGEtZG9tLWFwaVxuICAgIGl0ZW1JRDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGl0ZW1SZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICAvLyByZXN1bHRzIHNob3cgbG9va2luZyBnbGFzcyBpY29uIGFuZCByZWNlbnQgc2VhcmNoZXMgb24gaW5wdXRcbiAgICAvLyBzZWFyY2ggZmllbGRzIGluIFdlYktpdC9CbGlua1xuICAgIHJlc3VsdHM6IG51bGwsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBzcGVjaWZpZXMgc2VjdXJpdHkgcmVzdHJpY3Rpb25zIG9uIGFuIGlmcmFtZVxuICAgIC8vIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBzYW5kYm94IGF0dHJpYnV0ZSBvbiBJRTwxMFxuICAgIHNlY3VyaXR5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgLy8gSUUtb25seSBhdHRyaWJ1dGUgdGhhdCBjb250cm9scyBmb2N1cyBiZWhhdmlvclxuICAgIHVuc2VsZWN0YWJsZTogTVVTVF9VU0VfQVRUUklCVVRFXG4gIH0sXG4gIERPTUF0dHJpYnV0ZU5hbWVzOiB7XG4gICAgYWNjZXB0Q2hhcnNldDogJ2FjY2VwdC1jaGFyc2V0JyxcbiAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgaHRtbEZvcjogJ2ZvcicsXG4gICAgaHR0cEVxdWl2OiAnaHR0cC1lcXVpdidcbiAgfSxcbiAgRE9NUHJvcGVydHlOYW1lczoge1xuICAgIGF1dG9Db21wbGV0ZTogJ2F1dG9jb21wbGV0ZScsXG4gICAgYXV0b0ZvY3VzOiAnYXV0b2ZvY3VzJyxcbiAgICBhdXRvUGxheTogJ2F1dG9wbGF5JyxcbiAgICBhdXRvU2F2ZTogJ2F1dG9zYXZlJyxcbiAgICAvLyBgZW5jb2RpbmdgIGlzIGVxdWl2YWxlbnQgdG8gYGVuY3R5cGVgLCBJRTggbGFja3MgYW4gYGVuY3R5cGVgIHNldHRlci5cbiAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9odG1sNS9mb3Jtcy5odG1sI2RvbS1mcy1lbmNvZGluZ1xuICAgIGVuY1R5cGU6ICdlbmNvZGluZycsXG4gICAgaHJlZkxhbmc6ICdocmVmbGFuZycsXG4gICAgcmFkaW9Hcm91cDogJ3JhZGlvZ3JvdXAnLFxuICAgIHNwZWxsQ2hlY2s6ICdzcGVsbGNoZWNrJyxcbiAgICBzcmNEb2M6ICdzcmNkb2MnLFxuICAgIHNyY1NldDogJ3NyY3NldCdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBIVE1MRE9NUHJvcGVydHlDb25maWc7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvSFRNTERPTVByb3BlcnR5Q29uZmlnLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RJbnN0YW5jZU1hcCA9IHJlcXVpcmUoJy4vUmVhY3RJbnN0YW5jZU1hcCcpO1xuXG52YXIgZmluZERPTU5vZGUgPSByZXF1aXJlKCcuL2ZpbmRET01Ob2RlJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRpZFdhcm5LZXkgPSAnX2dldERPTU5vZGVEaWRXYXJuJztcblxudmFyIFJlYWN0QnJvd3NlckNvbXBvbmVudE1peGluID0ge1xuICAvKipcbiAgICogUmV0dXJucyB0aGUgRE9NIG5vZGUgcmVuZGVyZWQgYnkgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEByZXR1cm4ge0RPTUVsZW1lbnR9IFRoZSByb290IG5vZGUgb2YgdGhpcyBjb21wb25lbnQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHJvdGVjdGVkXG4gICAqL1xuICBnZXRET01Ob2RlOiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcy5jb25zdHJ1Y3RvcltkaWRXYXJuS2V5XSwgJyVzLmdldERPTU5vZGUoLi4uKSBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlICcgKyAnUmVhY3RET00uZmluZERPTU5vZGUoaW5zdGFuY2UpIGluc3RlYWQuJywgUmVhY3RJbnN0YW5jZU1hcC5nZXQodGhpcykuZ2V0TmFtZSgpIHx8IHRoaXMudGFnTmFtZSB8fCAnVW5rbm93bicpIDogdW5kZWZpbmVkO1xuICAgIHRoaXMuY29uc3RydWN0b3JbZGlkV2FybktleV0gPSB0cnVlO1xuICAgIHJldHVybiBmaW5kRE9NTm9kZSh0aGlzKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEJyb3dzZXJDb21wb25lbnRNaXhpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmaW5kRE9NTm9kZVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEluc3RhbmNlTWFwID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlTWFwJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xuXG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBET00gbm9kZSByZW5kZXJlZCBieSB0aGlzIGVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHtSZWFjdENvbXBvbmVudHxET01FbGVtZW50fSBjb21wb25lbnRPckVsZW1lbnRcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fSBUaGUgcm9vdCBub2RlIG9mIHRoaXMgZWxlbWVudC5cbiAqL1xuZnVuY3Rpb24gZmluZERPTU5vZGUoY29tcG9uZW50T3JFbGVtZW50KSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIG93bmVyID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudDtcbiAgICBpZiAob3duZXIgIT09IG51bGwpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKG93bmVyLl93YXJuZWRBYm91dFJlZnNJblJlbmRlciwgJyVzIGlzIGFjY2Vzc2luZyBnZXRET01Ob2RlIG9yIGZpbmRET01Ob2RlIGluc2lkZSBpdHMgcmVuZGVyKCkuICcgKyAncmVuZGVyKCkgc2hvdWxkIGJlIGEgcHVyZSBmdW5jdGlvbiBvZiBwcm9wcyBhbmQgc3RhdGUuIEl0IHNob3VsZCAnICsgJ25ldmVyIGFjY2VzcyBzb21ldGhpbmcgdGhhdCByZXF1aXJlcyBzdGFsZSBkYXRhIGZyb20gdGhlIHByZXZpb3VzICcgKyAncmVuZGVyLCBzdWNoIGFzIHJlZnMuIE1vdmUgdGhpcyBsb2dpYyB0byBjb21wb25lbnREaWRNb3VudCBhbmQgJyArICdjb21wb25lbnREaWRVcGRhdGUgaW5zdGVhZC4nLCBvd25lci5nZXROYW1lKCkgfHwgJ0EgY29tcG9uZW50JykgOiB1bmRlZmluZWQ7XG4gICAgICBvd25lci5fd2FybmVkQWJvdXRSZWZzSW5SZW5kZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50ID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29tcG9uZW50T3JFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudE9yRWxlbWVudDtcbiAgfVxuICBpZiAoUmVhY3RJbnN0YW5jZU1hcC5oYXMoY29tcG9uZW50T3JFbGVtZW50KSkge1xuICAgIHJldHVybiBSZWFjdE1vdW50LmdldE5vZGVGcm9tSW5zdGFuY2UoY29tcG9uZW50T3JFbGVtZW50KTtcbiAgfVxuICAhKGNvbXBvbmVudE9yRWxlbWVudC5yZW5kZXIgPT0gbnVsbCB8fCB0eXBlb2YgY29tcG9uZW50T3JFbGVtZW50LnJlbmRlciAhPT0gJ2Z1bmN0aW9uJykgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnZmluZERPTU5vZGUgd2FzIGNhbGxlZCBvbiBhbiB1bm1vdW50ZWQgY29tcG9uZW50LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0VsZW1lbnQgYXBwZWFycyB0byBiZSBuZWl0aGVyIFJlYWN0Q29tcG9uZW50IG5vciBET01Ob2RlIChrZXlzOiAlcyknLCBPYmplY3Qua2V5cyhjb21wb25lbnRPckVsZW1lbnQpKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmluZERPTU5vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvZmluZERPTU5vZGUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG52YXIgUkVTRVRfQkFUQ0hFRF9VUERBVEVTID0ge1xuICBpbml0aWFsaXplOiBlbXB0eUZ1bmN0aW9uLFxuICBjbG9zZTogZnVuY3Rpb24gKCkge1xuICAgIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXMgPSBmYWxzZTtcbiAgfVxufTtcblxudmFyIEZMVVNIX0JBVENIRURfVVBEQVRFUyA9IHtcbiAgaW5pdGlhbGl6ZTogZW1wdHlGdW5jdGlvbixcbiAgY2xvc2U6IFJlYWN0VXBkYXRlcy5mbHVzaEJhdGNoZWRVcGRhdGVzLmJpbmQoUmVhY3RVcGRhdGVzKVxufTtcblxudmFyIFRSQU5TQUNUSU9OX1dSQVBQRVJTID0gW0ZMVVNIX0JBVENIRURfVVBEQVRFUywgUkVTRVRfQkFUQ0hFRF9VUERBVEVTXTtcblxuZnVuY3Rpb24gUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneVRyYW5zYWN0aW9uKCkge1xuICB0aGlzLnJlaW5pdGlhbGl6ZVRyYW5zYWN0aW9uKCk7XG59XG5cbmFzc2lnbihSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5VHJhbnNhY3Rpb24ucHJvdG90eXBlLCBUcmFuc2FjdGlvbi5NaXhpbiwge1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9XG59KTtcblxudmFyIHRyYW5zYWN0aW9uID0gbmV3IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3lUcmFuc2FjdGlvbigpO1xuXG52YXIgUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSA9IHtcbiAgaXNCYXRjaGluZ1VwZGF0ZXM6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBDYWxsIHRoZSBwcm92aWRlZCBmdW5jdGlvbiBpbiBhIGNvbnRleHQgd2l0aGluIHdoaWNoIGNhbGxzIHRvIGBzZXRTdGF0ZWBcbiAgICogYW5kIGZyaWVuZHMgYXJlIGJhdGNoZWQgc3VjaCB0aGF0IGNvbXBvbmVudHMgYXJlbid0IHVwZGF0ZWQgdW5uZWNlc3NhcmlseS5cbiAgICovXG4gIGJhdGNoZWRVcGRhdGVzOiBmdW5jdGlvbiAoY2FsbGJhY2ssIGEsIGIsIGMsIGQsIGUpIHtcbiAgICB2YXIgYWxyZWFkeUJhdGNoaW5nVXBkYXRlcyA9IFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuaXNCYXRjaGluZ1VwZGF0ZXM7XG5cbiAgICBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5LmlzQmF0Y2hpbmdVcGRhdGVzID0gdHJ1ZTtcblxuICAgIC8vIFRoZSBjb2RlIGlzIHdyaXR0ZW4gdGhpcyB3YXkgdG8gYXZvaWQgZXh0cmEgYWxsb2NhdGlvbnNcbiAgICBpZiAoYWxyZWFkeUJhdGNoaW5nVXBkYXRlcykge1xuICAgICAgY2FsbGJhY2soYSwgYiwgYywgZCwgZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyYW5zYWN0aW9uLnBlcmZvcm0oY2FsbGJhY2ssIG51bGwsIGEsIGIsIGMsIGQsIGUpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01Db21wb25lbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuLyogZ2xvYmFsIGhhc093blByb3BlcnR5OnRydWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQXV0b0ZvY3VzVXRpbHMgPSByZXF1aXJlKCcuL0F1dG9Gb2N1c1V0aWxzJyk7XG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0gcmVxdWlyZSgnLi9DU1NQcm9wZXJ0eU9wZXJhdGlvbnMnKTtcbnZhciBET01Qcm9wZXJ0eSA9IHJlcXVpcmUoJy4vRE9NUHJvcGVydHknKTtcbnZhciBET01Qcm9wZXJ0eU9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5T3BlcmF0aW9ucycpO1xudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4vUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyk7XG52YXIgUmVhY3RDb21wb25lbnRCcm93c2VyRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50Jyk7XG52YXIgUmVhY3RET01CdXR0b24gPSByZXF1aXJlKCcuL1JlYWN0RE9NQnV0dG9uJyk7XG52YXIgUmVhY3RET01JbnB1dCA9IHJlcXVpcmUoJy4vUmVhY3RET01JbnB1dCcpO1xudmFyIFJlYWN0RE9NT3B0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTU9wdGlvbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSByZXF1aXJlKCcuL1JlYWN0RE9NVGV4dGFyZWEnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RNdWx0aUNoaWxkID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0VXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGNhbkRlZmluZVByb3BlcnR5ID0gcmVxdWlyZSgnLi9jYW5EZWZpbmVQcm9wZXJ0eScpO1xudmFyIGVzY2FwZVRleHRDb250ZW50Rm9yQnJvd3NlciA9IHJlcXVpcmUoJy4vZXNjYXBlVGV4dENvbnRlbnRGb3JCcm93c2VyJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgaXNFdmVudFN1cHBvcnRlZCA9IHJlcXVpcmUoJy4vaXNFdmVudFN1cHBvcnRlZCcpO1xudmFyIGtleU9mID0gcmVxdWlyZSgnZmJqcy9saWIva2V5T2YnKTtcbnZhciBzZXRJbm5lckhUTUwgPSByZXF1aXJlKCcuL3NldElubmVySFRNTCcpO1xudmFyIHNldFRleHRDb250ZW50ID0gcmVxdWlyZSgnLi9zZXRUZXh0Q29udGVudCcpO1xudmFyIHNoYWxsb3dFcXVhbCA9IHJlcXVpcmUoJ2ZianMvbGliL3NoYWxsb3dFcXVhbCcpO1xudmFyIHZhbGlkYXRlRE9NTmVzdGluZyA9IHJlcXVpcmUoJy4vdmFsaWRhdGVET01OZXN0aW5nJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIGRlbGV0ZUxpc3RlbmVyID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmRlbGV0ZUxpc3RlbmVyO1xudmFyIGxpc3RlblRvID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmxpc3RlblRvO1xudmFyIHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzID0gUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzO1xuXG4vLyBGb3IgcXVpY2tseSBtYXRjaGluZyBjaGlsZHJlbiB0eXBlLCB0byB0ZXN0IGlmIGNhbiBiZSB0cmVhdGVkIGFzIGNvbnRlbnQuXG52YXIgQ09OVEVOVF9UWVBFUyA9IHsgJ3N0cmluZyc6IHRydWUsICdudW1iZXInOiB0cnVlIH07XG5cbnZhciBDSElMRFJFTiA9IGtleU9mKHsgY2hpbGRyZW46IG51bGwgfSk7XG52YXIgU1RZTEUgPSBrZXlPZih7IHN0eWxlOiBudWxsIH0pO1xudmFyIEhUTUwgPSBrZXlPZih7IF9faHRtbDogbnVsbCB9KTtcblxudmFyIEVMRU1FTlRfTk9ERV9UWVBFID0gMTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGludGVybmFsSW5zdGFuY2UpIHtcbiAgaWYgKGludGVybmFsSW5zdGFuY2UpIHtcbiAgICB2YXIgb3duZXIgPSBpbnRlcm5hbEluc3RhbmNlLl9jdXJyZW50RWxlbWVudC5fb3duZXIgfHwgbnVsbDtcbiAgICBpZiAob3duZXIpIHtcbiAgICAgIHZhciBuYW1lID0gb3duZXIuZ2V0TmFtZSgpO1xuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICcgVGhpcyBET00gbm9kZSB3YXMgcmVuZGVyZWQgYnkgYCcgKyBuYW1lICsgJ2AuJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbGVnYWN5UHJvcHNEZXNjcmlwdG9yO1xuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgbGVnYWN5UHJvcHNEZXNjcmlwdG9yID0ge1xuICAgIHByb3BzOiB7XG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAucHJvcHMgb2YgYSBET00gbm9kZTsgaW5zdGVhZCwgJyArICdyZWNyZWF0ZSB0aGUgcHJvcHMgYXMgYHJlbmRlcmAgZGlkIG9yaWdpbmFsbHkgb3IgcmVhZCB0aGUgRE9NICcgKyAncHJvcGVydGllcy9hdHRyaWJ1dGVzIGRpcmVjdGx5IGZyb20gdGhpcyBub2RlIChlLmcuLCAnICsgJ3RoaXMucmVmcy5ib3guY2xhc3NOYW1lKS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBsZWdhY3lHZXRET01Ob2RlKCkge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLmdldERPTU5vZGUoKSBvZiBhIERPTSBub2RlOyAnICsgJ2luc3RlYWQsIHVzZSB0aGUgbm9kZSBkaXJlY3RseS4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICByZXR1cm4gdGhpcztcbn1cblxuZnVuY3Rpb24gbGVnYWN5SXNNb3VudGVkKCkge1xuICB2YXIgY29tcG9uZW50ID0gdGhpcy5fcmVhY3RJbnRlcm5hbENvbXBvbmVudDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1JlYWN0RE9NQ29tcG9uZW50OiBEbyBub3QgYWNjZXNzIC5pc01vdW50ZWQoKSBvZiBhIERPTSBub2RlLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiAhIWNvbXBvbmVudDtcbn1cblxuZnVuY3Rpb24gbGVnYWN5U2V0U3RhdGVFdGMoKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIGNvbXBvbmVudCA9IHRoaXMuX3JlYWN0SW50ZXJuYWxDb21wb25lbnQ7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdSZWFjdERPTUNvbXBvbmVudDogRG8gbm90IGFjY2VzcyAuc2V0U3RhdGUoKSwgLnJlcGxhY2VTdGF0ZSgpLCBvciAnICsgJy5mb3JjZVVwZGF0ZSgpIG9mIGEgRE9NIG5vZGUuIFRoaXMgaXMgYSBuby1vcC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWdhY3lTZXRQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnNldFByb3BzKCkgb2YgYSBET00gbm9kZS4gJyArICdJbnN0ZWFkLCBjYWxsIFJlYWN0RE9NLnJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmICghY29tcG9uZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZVNldFByb3BzSW50ZXJuYWwoY29tcG9uZW50LCBwYXJ0aWFsUHJvcHMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVDYWxsYmFja0ludGVybmFsKGNvbXBvbmVudCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIGxlZ2FjeVJlcGxhY2VQcm9wcyhwYXJ0aWFsUHJvcHMsIGNhbGxiYWNrKSB7XG4gIHZhciBjb21wb25lbnQgPSB0aGlzLl9yZWFjdEludGVybmFsQ29tcG9uZW50O1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnUmVhY3RET01Db21wb25lbnQ6IERvIG5vdCBhY2Nlc3MgLnJlcGxhY2VQcm9wcygpIG9mIGEgRE9NIG5vZGUuICcgKyAnSW5zdGVhZCwgY2FsbCBSZWFjdERPTS5yZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4lcycsIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShjb21wb25lbnQpKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoIWNvbXBvbmVudCkge1xuICAgIHJldHVybjtcbiAgfVxuICBSZWFjdFVwZGF0ZVF1ZXVlLmVucXVldWVSZXBsYWNlUHJvcHNJbnRlcm5hbChjb21wb25lbnQsIHBhcnRpYWxQcm9wcyk7XG4gIGlmIChjYWxsYmFjaykge1xuICAgIFJlYWN0VXBkYXRlUXVldWUuZW5xdWV1ZUNhbGxiYWNrSW50ZXJuYWwoY29tcG9uZW50LCBjYWxsYmFjayk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZnJpZW5kbHlTdHJpbmdpZnkob2JqKSB7XG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgIHJldHVybiAnWycgKyBvYmoubWFwKGZyaWVuZGx5U3RyaW5naWZ5KS5qb2luKCcsICcpICsgJ10nO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcGFpcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgICB2YXIga2V5RXNjYXBlZCA9IC9eW2EteiRfXVtcXHckX10qJC9pLnRlc3Qoa2V5KSA/IGtleSA6IEpTT04uc3RyaW5naWZ5KGtleSk7XG4gICAgICAgICAgcGFpcnMucHVzaChrZXlFc2NhcGVkICsgJzogJyArIGZyaWVuZGx5U3RyaW5naWZ5KG9ialtrZXldKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAneycgKyBwYWlycy5qb2luKCcsICcpICsgJ30nO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShvYmopO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gJ1tmdW5jdGlvbiBvYmplY3RdJztcbiAgfVxuICAvLyBEaWZmZXJzIGZyb20gSlNPTi5zdHJpbmdpZnkgaW4gdGhhdCB1bmRlZmluZWQgYmVjYXVzZXMgdW5kZWZpbmVkIGFuZCB0aGF0XG4gIC8vIGluZiBhbmQgbmFuIGRvbid0IGJlY29tZSBudWxsXG4gIHJldHVybiBTdHJpbmcob2JqKTtcbn1cblxudmFyIHN0eWxlTXV0YXRpb25XYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZShzdHlsZTEsIHN0eWxlMiwgY29tcG9uZW50KSB7XG4gIGlmIChzdHlsZTEgPT0gbnVsbCB8fCBzdHlsZTIgPT0gbnVsbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hhbGxvd0VxdWFsKHN0eWxlMSwgc3R5bGUyKSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50Ll90YWc7XG4gIHZhciBvd25lciA9IGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICB2YXIgb3duZXJOYW1lO1xuICBpZiAob3duZXIpIHtcbiAgICBvd25lck5hbWUgPSBvd25lci5nZXROYW1lKCk7XG4gIH1cblxuICB2YXIgaGFzaCA9IG93bmVyTmFtZSArICd8JyArIGNvbXBvbmVudE5hbWU7XG5cbiAgaWYgKHN0eWxlTXV0YXRpb25XYXJuaW5nLmhhc093blByb3BlcnR5KGhhc2gpKSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgc3R5bGVNdXRhdGlvbldhcm5pbmdbaGFzaF0gPSB0cnVlO1xuXG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYCVzYCB3YXMgcGFzc2VkIGEgc3R5bGUgb2JqZWN0IHRoYXQgaGFzIHByZXZpb3VzbHkgYmVlbiBtdXRhdGVkLiAnICsgJ011dGF0aW5nIGBzdHlsZWAgaXMgZGVwcmVjYXRlZC4gQ29uc2lkZXIgY2xvbmluZyBpdCBiZWZvcmVoYW5kLiBDaGVjayAnICsgJ3RoZSBgcmVuZGVyYCAlcy4gUHJldmlvdXMgc3R5bGU6ICVzLiBNdXRhdGVkIHN0eWxlOiAlcy4nLCBjb21wb25lbnROYW1lLCBvd25lciA/ICdvZiBgJyArIG93bmVyTmFtZSArICdgJyA6ICd1c2luZyA8JyArIGNvbXBvbmVudE5hbWUgKyAnPicsIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMSksIGZyaWVuZGx5U3RyaW5naWZ5KHN0eWxlMikpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnRcbiAqIEBwYXJhbSB7P29iamVjdH0gcHJvcHNcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0VmFsaWRQcm9wcyhjb21wb25lbnQsIHByb3BzKSB7XG4gIGlmICghcHJvcHMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gTm90ZSB0aGUgdXNlIG9mIGA9PWAgd2hpY2ggY2hlY2tzIGZvciBudWxsIG9yIHVuZGVmaW5lZC5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAodm9pZEVsZW1lbnRUYWdzW2NvbXBvbmVudC5fdGFnXSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcocHJvcHMuY2hpbGRyZW4gPT0gbnVsbCAmJiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PSBudWxsLCAnJXMgaXMgYSB2b2lkIGVsZW1lbnQgdGFnIGFuZCBtdXN0IG5vdCBoYXZlIGBjaGlsZHJlbmAgb3IgJyArICd1c2UgYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4lcycsIGNvbXBvbmVudC5fdGFnLCBjb21wb25lbnQuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/ICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgJyArIGNvbXBvbmVudC5fY3VycmVudEVsZW1lbnQuX293bmVyLmdldE5hbWUoKSArICcuJyA6ICcnKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cbiAgaWYgKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MICE9IG51bGwpIHtcbiAgICAhKHByb3BzLmNoaWxkcmVuID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0NhbiBvbmx5IHNldCBvbmUgb2YgYGNoaWxkcmVuYCBvciBgcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUxgLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAhKHR5cGVvZiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCA9PT0gJ29iamVjdCcgJiYgSFRNTCBpbiBwcm9wcy5kYW5nZXJvdXNseVNldElubmVySFRNTCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnYHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYCBtdXN0IGJlIGluIHRoZSBmb3JtIGB7X19odG1sOiAuLi59YC4gJyArICdQbGVhc2UgdmlzaXQgaHR0cHM6Ly9mYi5tZS9yZWFjdC1pbnZhcmlhbnQtZGFuZ2Vyb3VzbHktc2V0LWlubmVyLWh0bWwgJyArICdmb3IgbW9yZSBpbmZvcm1hdGlvbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhwcm9wcy5pbm5lckhUTUwgPT0gbnVsbCwgJ0RpcmVjdGx5IHNldHRpbmcgcHJvcGVydHkgYGlubmVySFRNTGAgaXMgbm90IHBlcm1pdHRlZC4gJyArICdGb3IgbW9yZSBpbmZvcm1hdGlvbiwgbG9va3VwIGRvY3VtZW50YXRpb24gb24gYGRhbmdlcm91c2x5U2V0SW5uZXJIVE1MYC4nKSA6IHVuZGVmaW5lZDtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghcHJvcHMuY29udGVudEVkaXRhYmxlIHx8IHByb3BzLmNoaWxkcmVuID09IG51bGwsICdBIGNvbXBvbmVudCBpcyBgY29udGVudEVkaXRhYmxlYCBhbmQgY29udGFpbnMgYGNoaWxkcmVuYCBtYW5hZ2VkIGJ5ICcgKyAnUmVhY3QuIEl0IGlzIG5vdyB5b3VyIHJlc3BvbnNpYmlsaXR5IHRvIGd1YXJhbnRlZSB0aGF0IG5vbmUgb2YgJyArICd0aG9zZSBub2RlcyBhcmUgdW5leHBlY3RlZGx5IG1vZGlmaWVkIG9yIGR1cGxpY2F0ZWQuIFRoaXMgaXMgJyArICdwcm9iYWJseSBub3QgaW50ZW50aW9uYWwuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgIShwcm9wcy5zdHlsZSA9PSBudWxsIHx8IHR5cGVvZiBwcm9wcy5zdHlsZSA9PT0gJ29iamVjdCcpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1RoZSBgc3R5bGVgIHByb3AgZXhwZWN0cyBhIG1hcHBpbmcgZnJvbSBzdHlsZSBwcm9wZXJ0aWVzIHRvIHZhbHVlcywgJyArICdub3QgYSBzdHJpbmcuIEZvciBleGFtcGxlLCBzdHlsZT17e21hcmdpblJpZ2h0OiBzcGFjaW5nICsgXFwnZW1cXCd9fSB3aGVuICcgKyAndXNpbmcgSlNYLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKGNvbXBvbmVudCkpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZW5xdWV1ZVB1dExpc3RlbmVyKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lciwgdHJhbnNhY3Rpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAvLyBJRTggaGFzIG5vIEFQSSBmb3IgZXZlbnQgY2FwdHVyaW5nIGFuZCB0aGUgYG9uU2Nyb2xsYCBldmVudCBkb2Vzbid0XG4gICAgLy8gYnViYmxlLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHJlZ2lzdHJhdGlvbk5hbWUgIT09ICdvblNjcm9sbCcgfHwgaXNFdmVudFN1cHBvcnRlZCgnc2Nyb2xsJywgdHJ1ZSksICdUaGlzIGJyb3dzZXIgZG9lc25cXCd0IHN1cHBvcnQgdGhlIGBvblNjcm9sbGAgZXZlbnQnKSA6IHVuZGVmaW5lZDtcbiAgfVxuICB2YXIgY29udGFpbmVyID0gUmVhY3RNb3VudC5maW5kUmVhY3RDb250YWluZXJGb3JJRChpZCk7XG4gIGlmIChjb250YWluZXIpIHtcbiAgICB2YXIgZG9jID0gY29udGFpbmVyLm5vZGVUeXBlID09PSBFTEVNRU5UX05PREVfVFlQRSA/IGNvbnRhaW5lci5vd25lckRvY3VtZW50IDogY29udGFpbmVyO1xuICAgIGxpc3RlblRvKHJlZ2lzdHJhdGlvbk5hbWUsIGRvYyk7XG4gIH1cbiAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwdXRMaXN0ZW5lciwge1xuICAgIGlkOiBpZCxcbiAgICByZWdpc3RyYXRpb25OYW1lOiByZWdpc3RyYXRpb25OYW1lLFxuICAgIGxpc3RlbmVyOiBsaXN0ZW5lclxuICB9KTtcbn1cblxuZnVuY3Rpb24gcHV0TGlzdGVuZXIoKSB7XG4gIHZhciBsaXN0ZW5lclRvUHV0ID0gdGhpcztcbiAgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnB1dExpc3RlbmVyKGxpc3RlbmVyVG9QdXQuaWQsIGxpc3RlbmVyVG9QdXQucmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXJUb1B1dC5saXN0ZW5lcik7XG59XG5cbi8vIFRoZXJlIGFyZSBzbyBtYW55IG1lZGlhIGV2ZW50cywgaXQgbWFrZXMgc2Vuc2UgdG8ganVzdFxuLy8gbWFpbnRhaW4gYSBsaXN0IHJhdGhlciB0aGFuIGNyZWF0ZSBhIGB0cmFwQnViYmxlZEV2ZW50YCBmb3IgZWFjaFxudmFyIG1lZGlhRXZlbnRzID0ge1xuICB0b3BBYm9ydDogJ2Fib3J0JyxcbiAgdG9wQ2FuUGxheTogJ2NhbnBsYXknLFxuICB0b3BDYW5QbGF5VGhyb3VnaDogJ2NhbnBsYXl0aHJvdWdoJyxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6ICdkdXJhdGlvbmNoYW5nZScsXG4gIHRvcEVtcHRpZWQ6ICdlbXB0aWVkJyxcbiAgdG9wRW5jcnlwdGVkOiAnZW5jcnlwdGVkJyxcbiAgdG9wRW5kZWQ6ICdlbmRlZCcsXG4gIHRvcEVycm9yOiAnZXJyb3InLFxuICB0b3BMb2FkZWREYXRhOiAnbG9hZGVkZGF0YScsXG4gIHRvcExvYWRlZE1ldGFkYXRhOiAnbG9hZGVkbWV0YWRhdGEnLFxuICB0b3BMb2FkU3RhcnQ6ICdsb2Fkc3RhcnQnLFxuICB0b3BQYXVzZTogJ3BhdXNlJyxcbiAgdG9wUGxheTogJ3BsYXknLFxuICB0b3BQbGF5aW5nOiAncGxheWluZycsXG4gIHRvcFByb2dyZXNzOiAncHJvZ3Jlc3MnLFxuICB0b3BSYXRlQ2hhbmdlOiAncmF0ZWNoYW5nZScsXG4gIHRvcFNlZWtlZDogJ3NlZWtlZCcsXG4gIHRvcFNlZWtpbmc6ICdzZWVraW5nJyxcbiAgdG9wU3RhbGxlZDogJ3N0YWxsZWQnLFxuICB0b3BTdXNwZW5kOiAnc3VzcGVuZCcsXG4gIHRvcFRpbWVVcGRhdGU6ICd0aW1ldXBkYXRlJyxcbiAgdG9wVm9sdW1lQ2hhbmdlOiAndm9sdW1lY2hhbmdlJyxcbiAgdG9wV2FpdGluZzogJ3dhaXRpbmcnXG59O1xuXG5mdW5jdGlvbiB0cmFwQnViYmxlZEV2ZW50c0xvY2FsKCkge1xuICB2YXIgaW5zdCA9IHRoaXM7XG4gIC8vIElmIGEgY29tcG9uZW50IHJlbmRlcnMgdG8gbnVsbCBvciBpZiBhbm90aGVyIGNvbXBvbmVudCBmYXRhbHMgYW5kIGNhdXNlc1xuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHRyZWUgdG8gYmUgY29ycnVwdGVkLCBgbm9kZWAgaGVyZSBjYW4gYmUgbnVsbC5cbiAgIWluc3QuX3Jvb3ROb2RlSUQgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnTXVzdCBiZSBtb3VudGVkIHRvIHRyYXAgZXZlbnRzJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZShpbnN0Ll9yb290Tm9kZUlEKTtcbiAgIW5vZGUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAndHJhcEJ1YmJsZWRFdmVudCguLi4pOiBSZXF1aXJlcyBub2RlIHRvIGJlIHJlbmRlcmVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICBzd2l0Y2ggKGluc3QuX3RhZykge1xuICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wTG9hZCwgJ2xvYWQnLCBub2RlKV07XG4gICAgICBicmVhaztcbiAgICBjYXNlICd2aWRlbyc6XG4gICAgY2FzZSAnYXVkaW8nOlxuXG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW107XG4gICAgICAvLyBjcmVhdGUgbGlzdGVuZXIgZm9yIGVhY2ggbWVkaWEgZXZlbnRcbiAgICAgIGZvciAodmFyIGV2ZW50IGluIG1lZGlhRXZlbnRzKSB7XG4gICAgICAgIGlmIChtZWRpYUV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudCkpIHtcbiAgICAgICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzLnB1c2goUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLnRyYXBCdWJibGVkRXZlbnQoRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlc1tldmVudF0sIG1lZGlhRXZlbnRzW2V2ZW50XSwgbm9kZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ltZyc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wRXJyb3IsICdlcnJvcicsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcExvYWQsICdsb2FkJywgbm9kZSldO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZm9ybSc6XG4gICAgICBpbnN0Ll93cmFwcGVyU3RhdGUubGlzdGVuZXJzID0gW1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlci50cmFwQnViYmxlZEV2ZW50KEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXMudG9wUmVzZXQsICdyZXNldCcsIG5vZGUpLCBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIudHJhcEJ1YmJsZWRFdmVudChFdmVudENvbnN0YW50cy50b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdCwgJ3N1Ym1pdCcsIG5vZGUpXTtcbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1vdW50UmVhZHlJbnB1dFdyYXBwZXIoKSB7XG4gIFJlYWN0RE9NSW5wdXQubW91bnRSZWFkeVdyYXBwZXIodGhpcyk7XG59XG5cbmZ1bmN0aW9uIHBvc3RVcGRhdGVTZWxlY3RXcmFwcGVyKCkge1xuICBSZWFjdERPTVNlbGVjdC5wb3N0VXBkYXRlV3JhcHBlcih0aGlzKTtcbn1cblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBzaG91bGQgb21pdCB0aGVpciBjbG9zZSB0YWcuIFdlIGtlZXAgYSB3aGl0ZWxpc3QgZm9yXG4vLyB0aG9zZSBzcGVjaWFsIGNhc2VkIHRhZ3MuXG5cbnZhciBvbWl0dGVkQ2xvc2VUYWdzID0ge1xuICAnYXJlYSc6IHRydWUsXG4gICdiYXNlJzogdHJ1ZSxcbiAgJ2JyJzogdHJ1ZSxcbiAgJ2NvbCc6IHRydWUsXG4gICdlbWJlZCc6IHRydWUsXG4gICdocic6IHRydWUsXG4gICdpbWcnOiB0cnVlLFxuICAnaW5wdXQnOiB0cnVlLFxuICAna2V5Z2VuJzogdHJ1ZSxcbiAgJ2xpbmsnOiB0cnVlLFxuICAnbWV0YSc6IHRydWUsXG4gICdwYXJhbSc6IHRydWUsXG4gICdzb3VyY2UnOiB0cnVlLFxuICAndHJhY2snOiB0cnVlLFxuICAnd2JyJzogdHJ1ZVxufTtcblxuLy8gTk9URTogbWVudWl0ZW0ncyBjbG9zZSB0YWcgc2hvdWxkIGJlIG9taXR0ZWQsIGJ1dCB0aGF0IGNhdXNlcyBwcm9ibGVtcy5cbnZhciBuZXdsaW5lRWF0aW5nVGFncyA9IHtcbiAgJ2xpc3RpbmcnOiB0cnVlLFxuICAncHJlJzogdHJ1ZSxcbiAgJ3RleHRhcmVhJzogdHJ1ZVxufTtcblxuLy8gRm9yIEhUTUwsIGNlcnRhaW4gdGFncyBjYW5ub3QgaGF2ZSBjaGlsZHJlbi4gVGhpcyBoYXMgdGhlIHNhbWUgcHVycG9zZSBhc1xuLy8gYG9taXR0ZWRDbG9zZVRhZ3NgIGV4Y2VwdCB0aGF0IGBtZW51aXRlbWAgc2hvdWxkIHN0aWxsIGhhdmUgaXRzIGNsb3NpbmcgdGFnLlxuXG52YXIgdm9pZEVsZW1lbnRUYWdzID0gYXNzaWduKHtcbiAgJ21lbnVpdGVtJzogdHJ1ZVxufSwgb21pdHRlZENsb3NlVGFncyk7XG5cbi8vIFdlIGFjY2VwdCBhbnkgdGFnIHRvIGJlIHJlbmRlcmVkIGJ1dCBzaW5jZSB0aGlzIGdldHMgaW5qZWN0ZWQgaW50byBhcmJpdHJhcnlcbi8vIEhUTUwsIHdlIHdhbnQgdG8gbWFrZSBzdXJlIHRoYXQgaXQncyBhIHNhZmUgdGFnLlxuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvUkVDLXhtbC8jTlQtTmFtZVxuXG52YXIgVkFMSURfVEFHX1JFR0VYID0gL15bYS16QS1aXVthLXpBLVo6X1xcLlxcLVxcZF0qJC87IC8vIFNpbXBsaWZpZWQgc3Vic2V0XG52YXIgdmFsaWRhdGVkVGFnQ2FjaGUgPSB7fTtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9ICh7fSkuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGFuZ2Vyb3VzVGFnKHRhZykge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwodmFsaWRhdGVkVGFnQ2FjaGUsIHRhZykpIHtcbiAgICAhVkFMSURfVEFHX1JFR0VYLnRlc3QodGFnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdJbnZhbGlkIHRhZzogJXMnLCB0YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB2YWxpZGF0ZWRUYWdDYWNoZVt0YWddID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIGluc3QpIHtcbiAgLy8gUGFzcyBkb3duIG91ciB0YWcgbmFtZSB0byBjaGlsZCBjb21wb25lbnRzIGZvciB2YWxpZGF0aW9uIHB1cnBvc2VzXG4gIGNvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICB2YXIgaW5mbyA9IGNvbnRleHRbdmFsaWRhdGVET01OZXN0aW5nLmFuY2VzdG9ySW5mb0NvbnRleHRLZXldO1xuICBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSA9IHZhbGlkYXRlRE9NTmVzdGluZy51cGRhdGVkQW5jZXN0b3JJbmZvKGluZm8sIGluc3QuX3RhZywgaW5zdCk7XG4gIHJldHVybiBjb250ZXh0O1xufVxuXG5mdW5jdGlvbiBpc0N1c3RvbUNvbXBvbmVudCh0YWdOYW1lLCBwcm9wcykge1xuICByZXR1cm4gdGFnTmFtZS5pbmRleE9mKCctJykgPj0gMCB8fCBwcm9wcy5pcyAhPSBudWxsO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUmVhY3QgY2xhc3MgdGhhdCBpcyBpZGVtcG90ZW50IGFuZCBjYXBhYmxlIG9mIGNvbnRhaW5pbmcgb3RoZXJcbiAqIFJlYWN0IGNvbXBvbmVudHMuIEl0IGFjY2VwdHMgZXZlbnQgbGlzdGVuZXJzIGFuZCBET00gcHJvcGVydGllcyB0aGF0IGFyZVxuICogdmFsaWQgYWNjb3JkaW5nIHRvIGBET01Qcm9wZXJ0eWAuXG4gKlxuICogIC0gRXZlbnQgbGlzdGVuZXJzOiBgb25DbGlja2AsIGBvbk1vdXNlRG93bmAsIGV0Yy5cbiAqICAtIERPTSBwcm9wZXJ0aWVzOiBgY2xhc3NOYW1lYCwgYG5hbWVgLCBgdGl0bGVgLCBldGMuXG4gKlxuICogVGhlIGBzdHlsZWAgcHJvcGVydHkgZnVuY3Rpb25zIGRpZmZlcmVudGx5IGZyb20gdGhlIERPTSBBUEkuIEl0IGFjY2VwdHMgYW5cbiAqIG9iamVjdCBtYXBwaW5nIG9mIHN0eWxlIHByb3BlcnRpZXMgdG8gdmFsdWVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBSZWFjdERPTUNvbXBvbmVudFxuICogQGV4dGVuZHMgUmVhY3RNdWx0aUNoaWxkXG4gKi9cbmZ1bmN0aW9uIFJlYWN0RE9NQ29tcG9uZW50KHRhZykge1xuICB2YWxpZGF0ZURhbmdlcm91c1RhZyh0YWcpO1xuICB0aGlzLl90YWcgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gIHRoaXMuX3ByZXZpb3VzU3R5bGUgPSBudWxsO1xuICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gIHRoaXMuX3Jvb3ROb2RlSUQgPSBudWxsO1xuICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICB0aGlzLl90b3BMZXZlbFdyYXBwZXIgPSBudWxsO1xuICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gICAgdGhpcy5fcHJvY2Vzc2VkQ29udGV4dERldiA9IG51bGw7XG4gIH1cbn1cblxuUmVhY3RET01Db21wb25lbnQuZGlzcGxheU5hbWUgPSAnUmVhY3RET01Db21wb25lbnQnO1xuXG5SZWFjdERPTUNvbXBvbmVudC5NaXhpbiA9IHtcblxuICBjb25zdHJ1Y3Q6IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5fY3VycmVudEVsZW1lbnQgPSBlbGVtZW50O1xuICB9LFxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgcm9vdCB0YWcgbWFya3VwIHRoZW4gcmVjdXJzZXMuIFRoaXMgbWV0aG9kIGhhcyBzaWRlIGVmZmVjdHMgYW5kXG4gICAqIGlzIG5vdCBpZGVtcG90ZW50LlxuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICogQHBhcmFtIHtzdHJpbmd9IHJvb3RJRCBUaGUgcm9vdCBET00gSUQgZm9yIHRoaXMgbm9kZS5cbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBjb250ZXh0XG4gICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGNvbXB1dGVkIG1hcmt1cC5cbiAgICovXG4gIG1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAocm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIHRoaXMuX3Jvb3ROb2RlSUQgPSByb290SUQ7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdpZnJhbWUnOlxuICAgICAgY2FzZSAnaW1nJzpcbiAgICAgIGNhc2UgJ2Zvcm0nOlxuICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAgICAgbGlzdGVuZXJzOiBudWxsXG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zYWN0aW9uLmdldFJlYWN0TW91bnRSZWFkeSgpLmVucXVldWUodHJhcEJ1YmJsZWRFdmVudHNMb2NhbCwgdGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnYnV0dG9uJzpcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaW5wdXQnOlxuICAgICAgICBSZWFjdERPTUlucHV0Lm1vdW50V3JhcHBlcih0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIHByb3BzID0gUmVhY3RET01JbnB1dC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgUmVhY3RET01PcHRpb24ubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2VsZWN0JzpcbiAgICAgICAgUmVhY3RET01TZWxlY3QubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVNlbGVjdC5nZXROYXRpdmVQcm9wcyh0aGlzLCBwcm9wcywgY29udGV4dCk7XG4gICAgICAgIGNvbnRleHQgPSBSZWFjdERPTVNlbGVjdC5wcm9jZXNzQ2hpbGRDb250ZXh0KHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0ZXh0YXJlYSc6XG4gICAgICAgIFJlYWN0RE9NVGV4dGFyZWEubW91bnRXcmFwcGVyKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgcHJvcHMgPSBSZWFjdERPTVRleHRhcmVhLmdldE5hdGl2ZVByb3BzKHRoaXMsIHByb3BzLCBjb250ZXh0KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBwcm9wcyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSkge1xuICAgICAgICB2YWxpZGF0ZURPTU5lc3RpbmcodGhpcy5fdGFnLCB0aGlzLCBjb250ZXh0W3ZhbGlkYXRlRE9NTmVzdGluZy5hbmNlc3RvckluZm9Db250ZXh0S2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2ID0gcHJvY2Vzc0NoaWxkQ29udGV4dERldihjb250ZXh0LCB0aGlzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzLl9wcm9jZXNzZWRDb250ZXh0RGV2O1xuICAgIH1cblxuICAgIHZhciBtb3VudEltYWdlO1xuICAgIGlmICh0cmFuc2FjdGlvbi51c2VDcmVhdGVFbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXJEb2N1bWVudCA9IGNvbnRleHRbUmVhY3RNb3VudC5vd25lckRvY3VtZW50Q29udGV4dEtleV07XG4gICAgICB2YXIgZWwgPSBvd25lckRvY3VtZW50LmNyZWF0ZUVsZW1lbnQodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSk7XG4gICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuc2V0QXR0cmlidXRlRm9ySUQoZWwsIHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgICAgLy8gUG9wdWxhdGUgbm9kZSBjYWNoZVxuICAgICAgUmVhY3RNb3VudC5nZXRJRChlbCk7XG4gICAgICB0aGlzLl91cGRhdGVET01Qcm9wZXJ0aWVzKHt9LCBwcm9wcywgdHJhbnNhY3Rpb24sIGVsKTtcbiAgICAgIHRoaXMuX2NyZWF0ZUluaXRpYWxDaGlsZHJlbih0cmFuc2FjdGlvbiwgcHJvcHMsIGNvbnRleHQsIGVsKTtcbiAgICAgIG1vdW50SW1hZ2UgPSBlbDtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHRhZ09wZW4gPSB0aGlzLl9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzKHRyYW5zYWN0aW9uLCBwcm9wcyk7XG4gICAgICB2YXIgdGFnQ29udGVudCA9IHRoaXMuX2NyZWF0ZUNvbnRlbnRNYXJrdXAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KTtcbiAgICAgIGlmICghdGFnQ29udGVudCAmJiBvbWl0dGVkQ2xvc2VUYWdzW3RoaXMuX3RhZ10pIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnLz4nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbW91bnRJbWFnZSA9IHRhZ09wZW4gKyAnPicgKyB0YWdDb250ZW50ICsgJzwvJyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGUgKyAnPic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShtb3VudFJlYWR5SW5wdXRXcmFwcGVyLCB0aGlzKTtcbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgJ2J1dHRvbic6XG4gICAgICBjYXNlICdzZWxlY3QnOlxuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBpZiAocHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShBdXRvRm9jdXNVdGlscy5mb2N1c0RPTUNvbXBvbmVudCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1vdW50SW1hZ2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgbWFya3VwIGZvciB0aGUgb3BlbiB0YWcgYW5kIGFsbCBhdHRyaWJ1dGVzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBoYXMgc2lkZSBlZmZlY3RzIGJlY2F1c2UgZXZlbnRzIGdldCByZWdpc3RlcmVkLlxuICAgKlxuICAgKiBJdGVyYXRpbmcgb3ZlciBvYmplY3QgcHJvcGVydGllcyBpcyBmYXN0ZXIgdGhhbiBpdGVyYXRpbmcgb3ZlciBhcnJheXMuXG4gICAqIEBzZWUgaHR0cDovL2pzcGVyZi5jb20vb2JqLXZzLWFyci1pdGVyYXRpb25cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wc1xuICAgKiBAcmV0dXJuIHtzdHJpbmd9IE1hcmt1cCBvZiBvcGVuaW5nIHRhZy5cbiAgICovXG4gIF9jcmVhdGVPcGVuVGFnTWFya3VwQW5kUHV0TGlzdGVuZXJzOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzKSB7XG4gICAgdmFyIHJldCA9ICc8JyArIHRoaXMuX2N1cnJlbnRFbGVtZW50LnR5cGU7XG5cbiAgICBmb3IgKHZhciBwcm9wS2V5IGluIHByb3BzKSB7XG4gICAgICBpZiAoIXByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BLZXldO1xuICAgICAgaWYgKHByb3BWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICBlbnF1ZXVlUHV0TGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSwgcHJvcFZhbHVlLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcm9wS2V5ID09PSBTVFlMRSkge1xuICAgICAgICAgIGlmIChwcm9wVmFsdWUpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgICAgIC8vIFNlZSBgX3VwZGF0ZURPTVByb3BlcnRpZXNgLiBzdHlsZSBibG9ja1xuICAgICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gcHJvcFZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvcFZhbHVlID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIHByb3BzLnN0eWxlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJvcFZhbHVlID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclN0eWxlcyhwcm9wVmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtYXJrdXAgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5fdGFnICE9IG51bGwgJiYgaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBwcm9wcykpIHtcbiAgICAgICAgICBpZiAocHJvcEtleSAhPT0gQ0hJTERSRU4pIHtcbiAgICAgICAgICAgIG1hcmt1cCA9IERPTVByb3BlcnR5T3BlcmF0aW9ucy5jcmVhdGVNYXJrdXBGb3JDdXN0b21BdHRyaWJ1dGUocHJvcEtleSwgcHJvcFZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWFya3VwID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvclByb3BlcnR5KHByb3BLZXksIHByb3BWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hcmt1cCkge1xuICAgICAgICAgIHJldCArPSAnICcgKyBtYXJrdXA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3Igc3RhdGljIHBhZ2VzLCBubyBuZWVkIHRvIHB1dCBSZWFjdCBJRCBhbmQgY2hlY2tzdW0uIFNhdmVzIGxvdHMgb2ZcbiAgICAvLyBieXRlcy5cbiAgICBpZiAodHJhbnNhY3Rpb24ucmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgdmFyIG1hcmt1cEZvcklEID0gRE9NUHJvcGVydHlPcGVyYXRpb25zLmNyZWF0ZU1hcmt1cEZvcklEKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHJldHVybiByZXQgKyAnICcgKyBtYXJrdXBGb3JJRDtcbiAgfSxcblxuICAvKipcbiAgICogQ3JlYXRlcyBtYXJrdXAgZm9yIHRoZSBjb250ZW50IGJldHdlZW4gdGhlIHRhZ3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbnxSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7c3RyaW5nfSBDb250ZW50IG1hcmt1cC5cbiAgICovXG4gIF9jcmVhdGVDb250ZW50TWFya3VwOiBmdW5jdGlvbiAodHJhbnNhY3Rpb24sIHByb3BzLCBjb250ZXh0KSB7XG4gICAgdmFyIHJldCA9ICcnO1xuXG4gICAgLy8gSW50ZW50aW9uYWwgdXNlIG9mICE9IHRvIGF2b2lkIGNhdGNoaW5nIHplcm8vZmFsc2UuXG4gICAgdmFyIGlubmVySFRNTCA9IHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MO1xuICAgIGlmIChpbm5lckhUTUwgIT0gbnVsbCkge1xuICAgICAgaWYgKGlubmVySFRNTC5fX2h0bWwgIT0gbnVsbCkge1xuICAgICAgICByZXQgPSBpbm5lckhUTUwuX19odG1sO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGVudFRvVXNlID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgcHJvcHMuY2hpbGRyZW5dID8gcHJvcHMuY2hpbGRyZW4gOiBudWxsO1xuICAgICAgdmFyIGNoaWxkcmVuVG9Vc2UgPSBjb250ZW50VG9Vc2UgIT0gbnVsbCA/IG51bGwgOiBwcm9wcy5jaGlsZHJlbjtcbiAgICAgIGlmIChjb250ZW50VG9Vc2UgIT0gbnVsbCkge1xuICAgICAgICAvLyBUT0RPOiBWYWxpZGF0ZSB0aGF0IHRleHQgaXMgYWxsb3dlZCBhcyBhIGNoaWxkIG9mIHRoaXMgbm9kZVxuICAgICAgICByZXQgPSBlc2NhcGVUZXh0Q29udGVudEZvckJyb3dzZXIoY29udGVudFRvVXNlKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGRyZW5Ub1VzZSAhPSBudWxsKSB7XG4gICAgICAgIHZhciBtb3VudEltYWdlcyA9IHRoaXMubW91bnRDaGlsZHJlbihjaGlsZHJlblRvVXNlLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIHJldCA9IG1vdW50SW1hZ2VzLmpvaW4oJycpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmV3bGluZUVhdGluZ1RhZ3NbdGhpcy5fdGFnXSAmJiByZXQuY2hhckF0KDApID09PSAnXFxuJykge1xuICAgICAgLy8gdGV4dC9odG1sIGlnbm9yZXMgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGVzZSB0YWdzIGlmIGl0J3MgYSBuZXdsaW5lXG4gICAgICAvLyBQcmVmZXIgdG8gYnJlYWsgYXBwbGljYXRpb24veG1sIG92ZXIgdGV4dC9odG1sIChmb3Igbm93KSBieSBhZGRpbmdcbiAgICAgIC8vIGEgbmV3bGluZSBzcGVjaWZpY2FsbHkgdG8gZ2V0IGVhdGVuIGJ5IHRoZSBwYXJzZXIuIChBbHRlcm5hdGVseSBmb3JcbiAgICAgIC8vIHRleHRhcmVhcywgcmVwbGFjaW5nIFwiXlxcblwiIHdpdGggXCJcXHJcXG5cIiBkb2Vzbid0IGdldCBlYXRlbiwgYW5kIHRoZSBmaXJzdFxuICAgICAgLy8gXFxyIGlzIG5vcm1hbGl6ZWQgb3V0IGJ5IEhUTUxUZXh0QXJlYUVsZW1lbnQjdmFsdWUuKVxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbC1wb2x5Z2xvdC8jbmV3bGluZXMtaW4tdGV4dGFyZWEtYW5kLXByZT5cbiAgICAgIC8vIFNlZTogPGh0dHA6Ly93d3cudzMub3JnL1RSL2h0bWw1L3N5bnRheC5odG1sI2VsZW1lbnQtcmVzdHJpY3Rpb25zPlxuICAgICAgLy8gU2VlOiA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjbmV3bGluZXM+XG4gICAgICAvLyBTZWU6IFBhcnNpbmcgb2YgXCJ0ZXh0YXJlYVwiIFwibGlzdGluZ1wiIGFuZCBcInByZVwiIGVsZW1lbnRzXG4gICAgICAvLyAgZnJvbSA8aHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvc3ludGF4Lmh0bWwjcGFyc2luZy1tYWluLWluYm9keT5cbiAgICAgIHJldHVybiAnXFxuJyArIHJldDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sXG5cbiAgX2NyZWF0ZUluaXRpYWxDaGlsZHJlbjogZnVuY3Rpb24gKHRyYW5zYWN0aW9uLCBwcm9wcywgY29udGV4dCwgZWwpIHtcbiAgICAvLyBJbnRlbnRpb25hbCB1c2Ugb2YgIT0gdG8gYXZvaWQgY2F0Y2hpbmcgemVyby9mYWxzZS5cbiAgICB2YXIgaW5uZXJIVE1MID0gcHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUw7XG4gICAgaWYgKGlubmVySFRNTCAhPSBudWxsKSB7XG4gICAgICBpZiAoaW5uZXJIVE1MLl9faHRtbCAhPSBudWxsKSB7XG4gICAgICAgIHNldElubmVySFRNTChlbCwgaW5uZXJIVE1MLl9faHRtbCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjb250ZW50VG9Vc2UgPSBDT05URU5UX1RZUEVTW3R5cGVvZiBwcm9wcy5jaGlsZHJlbl0gPyBwcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgICB2YXIgY2hpbGRyZW5Ub1VzZSA9IGNvbnRlbnRUb1VzZSAhPSBudWxsID8gbnVsbCA6IHByb3BzLmNoaWxkcmVuO1xuICAgICAgaWYgKGNvbnRlbnRUb1VzZSAhPSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFZhbGlkYXRlIHRoYXQgdGV4dCBpcyBhbGxvd2VkIGFzIGEgY2hpbGQgb2YgdGhpcyBub2RlXG4gICAgICAgIHNldFRleHRDb250ZW50KGVsLCBjb250ZW50VG9Vc2UpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZHJlblRvVXNlICE9IG51bGwpIHtcbiAgICAgICAgdmFyIG1vdW50SW1hZ2VzID0gdGhpcy5tb3VudENoaWxkcmVuKGNoaWxkcmVuVG9Vc2UsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtb3VudEltYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGVsLmFwcGVuZENoaWxkKG1vdW50SW1hZ2VzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjZWl2ZXMgYSBuZXh0IGVsZW1lbnQgYW5kIHVwZGF0ZXMgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb258UmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICovXG4gIHJlY2VpdmVDb21wb25lbnQ6IGZ1bmN0aW9uIChuZXh0RWxlbWVudCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICB2YXIgcHJldkVsZW1lbnQgPSB0aGlzLl9jdXJyZW50RWxlbWVudDtcbiAgICB0aGlzLl9jdXJyZW50RWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgIHRoaXMudXBkYXRlQ29tcG9uZW50KHRyYW5zYWN0aW9uLCBwcmV2RWxlbWVudCwgbmV4dEVsZW1lbnQsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIGEgbmF0aXZlIERPTSBjb21wb25lbnQgYWZ0ZXIgaXQgaGFzIGFscmVhZHkgYmVlbiBhbGxvY2F0ZWQgYW5kXG4gICAqIGF0dGFjaGVkIHRvIHRoZSBET00uIFJlY29uY2lsZXMgdGhlIHJvb3QgRE9NIG5vZGUsIHRoZW4gcmVjdXJzZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IHByZXZFbGVtZW50XG4gICAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBuZXh0RWxlbWVudFxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IGZ1bmN0aW9uICh0cmFuc2FjdGlvbiwgcHJldkVsZW1lbnQsIG5leHRFbGVtZW50LCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RQcm9wcyA9IHByZXZFbGVtZW50LnByb3BzO1xuICAgIHZhciBuZXh0UHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICAgIHN3aXRjaCAodGhpcy5fdGFnKSB7XG4gICAgICBjYXNlICdidXR0b24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTUJ1dHRvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2lucHV0JzpcbiAgICAgICAgUmVhY3RET01JbnB1dC51cGRhdGVXcmFwcGVyKHRoaXMpO1xuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTUlucHV0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NSW5wdXQuZ2V0TmF0aXZlUHJvcHModGhpcywgbmV4dFByb3BzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICBsYXN0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBsYXN0UHJvcHMpO1xuICAgICAgICBuZXh0UHJvcHMgPSBSZWFjdERPTU9wdGlvbi5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3NlbGVjdCc6XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIGxhc3RQcm9wcyk7XG4gICAgICAgIG5leHRQcm9wcyA9IFJlYWN0RE9NU2VsZWN0LmdldE5hdGl2ZVByb3BzKHRoaXMsIG5leHRQcm9wcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dGFyZWEnOlxuICAgICAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gICAgICAgIGxhc3RQcm9wcyA9IFJlYWN0RE9NVGV4dGFyZWEuZ2V0TmF0aXZlUHJvcHModGhpcywgbGFzdFByb3BzKTtcbiAgICAgICAgbmV4dFByb3BzID0gUmVhY3RET01UZXh0YXJlYS5nZXROYXRpdmVQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgICAgICBicmVhaztcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gSWYgdGhlIGNvbnRleHQgaXMgcmVmZXJlbmNlLWVxdWFsIHRvIHRoZSBvbGQgb25lLCBwYXNzIGRvd24gdGhlIHNhbWVcbiAgICAgIC8vIHByb2Nlc3NlZCBvYmplY3Qgc28gdGhlIHVwZGF0ZSBiYWlsb3V0IGluIFJlYWN0UmVjb25jaWxlciBiZWhhdmVzXG4gICAgICAvLyBjb3JyZWN0bHkgKGFuZCBpZGVudGljYWxseSBpbiBkZXYgYW5kIHByb2QpLiBTZWUgIzUwMDUuXG4gICAgICBpZiAodGhpcy5fdW5wcm9jZXNzZWRDb250ZXh0RGV2ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuX3VucHJvY2Vzc2VkQ29udGV4dERldiA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXYgPSBwcm9jZXNzQ2hpbGRDb250ZXh0RGV2KGNvbnRleHQsIHRoaXMpO1xuICAgICAgfVxuICAgICAgY29udGV4dCA9IHRoaXMuX3Byb2Nlc3NlZENvbnRleHREZXY7XG4gICAgfVxuXG4gICAgYXNzZXJ0VmFsaWRQcm9wcyh0aGlzLCBuZXh0UHJvcHMpO1xuICAgIHRoaXMuX3VwZGF0ZURPTVByb3BlcnRpZXMobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBudWxsKTtcbiAgICB0aGlzLl91cGRhdGVET01DaGlsZHJlbihsYXN0UHJvcHMsIG5leHRQcm9wcywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuXG4gICAgaWYgKCFjYW5EZWZpbmVQcm9wZXJ0eSAmJiB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHRoaXMuX25vZGVXaXRoTGVnYWN5UHJvcGVydGllcy5wcm9wcyA9IG5leHRQcm9wcztcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fdGFnID09PSAnc2VsZWN0Jykge1xuICAgICAgLy8gPHNlbGVjdD4gdmFsdWUgdXBkYXRlIG5lZWRzIHRvIG9jY3VyIGFmdGVyIDxvcHRpb24+IGNoaWxkcmVuXG4gICAgICAvLyByZWNvbmNpbGlhdGlvblxuICAgICAgdHJhbnNhY3Rpb24uZ2V0UmVhY3RNb3VudFJlYWR5KCkuZW5xdWV1ZShwb3N0VXBkYXRlU2VsZWN0V3JhcHBlciwgdGhpcyk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZWNvbmNpbGVzIHRoZSBwcm9wZXJ0aWVzIGJ5IGRldGVjdGluZyBkaWZmZXJlbmNlcyBpbiBwcm9wZXJ0eSB2YWx1ZXMgYW5kXG4gICAqIHVwZGF0aW5nIHRoZSBET00gYXMgbmVjZXNzYXJ5LiBUaGlzIGZ1bmN0aW9uIGlzIHByb2JhYmx5IHRoZSBzaW5nbGUgbW9zdFxuICAgKiBjcml0aWNhbCBwYXRoIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24uXG4gICAqXG4gICAqIFRPRE86IEJlbmNobWFyayB3aGV0aGVyIGNoZWNraW5nIGZvciBjaGFuZ2VkIHZhbHVlcyBpbiBtZW1vcnkgYWN0dWFsbHlcbiAgICogICAgICAgaW1wcm92ZXMgcGVyZm9ybWFuY2UgKGVzcGVjaWFsbHkgc3RhdGljYWxseSBwb3NpdGlvbmVkIGVsZW1lbnRzKS5cbiAgICogVE9ETzogQmVuY2htYXJrIHRoZSBlZmZlY3RzIG9mIHB1dHRpbmcgdGhpcyBhdCB0aGUgdG9wIHNpbmNlIDk5JSBvZiBwcm9wc1xuICAgKiAgICAgICBkbyBub3QgY2hhbmdlIGZvciBhIGdpdmVuIHJlY29uY2lsaWF0aW9uLlxuICAgKiBUT0RPOiBCZW5jaG1hcmsgYXJlYXMgdGhhdCBjYW4gYmUgaW1wcm92ZWQgd2l0aCBjYWNoaW5nLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0gez9ET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBfdXBkYXRlRE9NUHJvcGVydGllczogZnVuY3Rpb24gKGxhc3RQcm9wcywgbmV4dFByb3BzLCB0cmFuc2FjdGlvbiwgbm9kZSkge1xuICAgIHZhciBwcm9wS2V5O1xuICAgIHZhciBzdHlsZU5hbWU7XG4gICAgdmFyIHN0eWxlVXBkYXRlcztcbiAgICBmb3IgKHByb3BLZXkgaW4gbGFzdFByb3BzKSB7XG4gICAgICBpZiAobmV4dFByb3BzLmhhc093blByb3BlcnR5KHByb3BLZXkpIHx8ICFsYXN0UHJvcHMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgdmFyIGxhc3RTdHlsZSA9IHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5O1xuICAgICAgICBmb3IgKHN0eWxlTmFtZSBpbiBsYXN0U3R5bGUpIHtcbiAgICAgICAgICBpZiAobGFzdFN0eWxlLmhhc093blByb3BlcnR5KHN0eWxlTmFtZSkpIHtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IHN0eWxlVXBkYXRlcyB8fCB7fTtcbiAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3ByZXZpb3VzU3R5bGVDb3B5ID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAocmVnaXN0cmF0aW9uTmFtZU1vZHVsZXMuaGFzT3duUHJvcGVydHkocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKGxhc3RQcm9wc1twcm9wS2V5XSkge1xuICAgICAgICAgIC8vIE9ubHkgY2FsbCBkZWxldGVMaXN0ZW5lciBpZiB0aGVyZSB3YXMgYSBsaXN0ZW5lciBwcmV2aW91c2x5IG9yXG4gICAgICAgICAgLy8gZWxzZSB3aWxsRGVsZXRlTGlzdGVuZXIgZ2V0cyBjYWxsZWQgd2hlbiB0aGVyZSB3YXNuJ3QgYWN0dWFsbHkgYVxuICAgICAgICAgIC8vIGxpc3RlbmVyIChlLmcuLCBvbkNsaWNrPXtudWxsfSlcbiAgICAgICAgICBkZWxldGVMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChET01Qcm9wZXJ0eS5wcm9wZXJ0aWVzW3Byb3BLZXldIHx8IERPTVByb3BlcnR5LmlzQ3VzdG9tQXR0cmlidXRlKHByb3BLZXkpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgRE9NUHJvcGVydHlPcGVyYXRpb25zLmRlbGV0ZVZhbHVlRm9yUHJvcGVydHkobm9kZSwgcHJvcEtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZvciAocHJvcEtleSBpbiBuZXh0UHJvcHMpIHtcbiAgICAgIHZhciBuZXh0UHJvcCA9IG5leHRQcm9wc1twcm9wS2V5XTtcbiAgICAgIHZhciBsYXN0UHJvcCA9IHByb3BLZXkgPT09IFNUWUxFID8gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgOiBsYXN0UHJvcHNbcHJvcEtleV07XG4gICAgICBpZiAoIW5leHRQcm9wcy5oYXNPd25Qcm9wZXJ0eShwcm9wS2V5KSB8fCBuZXh0UHJvcCA9PT0gbGFzdFByb3ApIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAocHJvcEtleSA9PT0gU1RZTEUpIHtcbiAgICAgICAgaWYgKG5leHRQcm9wKSB7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIGNoZWNrQW5kV2FybkZvck11dGF0ZWRTdHlsZSh0aGlzLl9wcmV2aW91c1N0eWxlQ29weSwgdGhpcy5fcHJldmlvdXNTdHlsZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlID0gbmV4dFByb3A7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5leHRQcm9wID0gdGhpcy5fcHJldmlvdXNTdHlsZUNvcHkgPSBhc3NpZ24oe30sIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9wcmV2aW91c1N0eWxlQ29weSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgLy8gVW5zZXQgc3R5bGVzIG9uIGBsYXN0UHJvcGAgYnV0IG5vdCBvbiBgbmV4dFByb3BgLlxuICAgICAgICAgIGZvciAoc3R5bGVOYW1lIGluIGxhc3RQcm9wKSB7XG4gICAgICAgICAgICBpZiAobGFzdFByb3AuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSAmJiAoIW5leHRQcm9wIHx8ICFuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSkge1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXMgPSBzdHlsZVVwZGF0ZXMgfHwge307XG4gICAgICAgICAgICAgIHN0eWxlVXBkYXRlc1tzdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIFVwZGF0ZSBzdHlsZXMgdGhhdCBjaGFuZ2VkIHNpbmNlIGBsYXN0UHJvcGAuXG4gICAgICAgICAgZm9yIChzdHlsZU5hbWUgaW4gbmV4dFByb3ApIHtcbiAgICAgICAgICAgIGlmIChuZXh0UHJvcC5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpICYmIGxhc3RQcm9wW3N0eWxlTmFtZV0gIT09IG5leHRQcm9wW3N0eWxlTmFtZV0pIHtcbiAgICAgICAgICAgICAgc3R5bGVVcGRhdGVzID0gc3R5bGVVcGRhdGVzIHx8IHt9O1xuICAgICAgICAgICAgICBzdHlsZVVwZGF0ZXNbc3R5bGVOYW1lXSA9IG5leHRQcm9wW3N0eWxlTmFtZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFJlbGllcyBvbiBgdXBkYXRlU3R5bGVzQnlJRGAgbm90IG11dGF0aW5nIGBzdHlsZVVwZGF0ZXNgLlxuICAgICAgICAgIHN0eWxlVXBkYXRlcyA9IG5leHRQcm9wO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHJlZ2lzdHJhdGlvbk5hbWVNb2R1bGVzLmhhc093blByb3BlcnR5KHByb3BLZXkpKSB7XG4gICAgICAgIGlmIChuZXh0UHJvcCkge1xuICAgICAgICAgIGVucXVldWVQdXRMaXN0ZW5lcih0aGlzLl9yb290Tm9kZUlELCBwcm9wS2V5LCBuZXh0UHJvcCwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9IGVsc2UgaWYgKGxhc3RQcm9wKSB7XG4gICAgICAgICAgZGVsZXRlTGlzdGVuZXIodGhpcy5fcm9vdE5vZGVJRCwgcHJvcEtleSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNDdXN0b21Db21wb25lbnQodGhpcy5fdGFnLCBuZXh0UHJvcHMpKSB7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgIG5vZGUgPSBSZWFjdE1vdW50LmdldE5vZGUodGhpcy5fcm9vdE5vZGVJRCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BLZXkgPT09IENISUxEUkVOKSB7XG4gICAgICAgICAgbmV4dFByb3AgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvckF0dHJpYnV0ZShub2RlLCBwcm9wS2V5LCBuZXh0UHJvcCk7XG4gICAgICB9IGVsc2UgaWYgKERPTVByb3BlcnR5LnByb3BlcnRpZXNbcHJvcEtleV0gfHwgRE9NUHJvcGVydHkuaXNDdXN0b21BdHRyaWJ1dGUocHJvcEtleSkpIHtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSdyZSB1cGRhdGluZyB0byBudWxsIG9yIHVuZGVmaW5lZCwgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgcHJvcGVydHlcbiAgICAgICAgLy8gZnJvbSB0aGUgRE9NIG5vZGUgaW5zdGVhZCBvZiBpbmFkdmVydGFudGx5IHNldHRpbmcgdG8gYSBzdHJpbmcuIFRoaXNcbiAgICAgICAgLy8gYnJpbmdzIHVzIGluIGxpbmUgd2l0aCB0aGUgc2FtZSBiZWhhdmlvciB3ZSBoYXZlIG9uIGluaXRpYWwgcmVuZGVyLlxuICAgICAgICBpZiAobmV4dFByb3AgIT0gbnVsbCkge1xuICAgICAgICAgIERPTVByb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclByb3BlcnR5KG5vZGUsIHByb3BLZXksIG5leHRQcm9wKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBET01Qcm9wZXJ0eU9wZXJhdGlvbnMuZGVsZXRlVmFsdWVGb3JQcm9wZXJ0eShub2RlLCBwcm9wS2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc3R5bGVVcGRhdGVzKSB7XG4gICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICAgIH1cbiAgICAgIENTU1Byb3BlcnR5T3BlcmF0aW9ucy5zZXRWYWx1ZUZvclN0eWxlcyhub2RlLCBzdHlsZVVwZGF0ZXMpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogUmVjb25jaWxlcyB0aGUgY2hpbGRyZW4gd2l0aCB0aGUgdmFyaW91cyBwcm9wZXJ0aWVzIHRoYXQgYWZmZWN0IHRoZVxuICAgKiBjaGlsZHJlbiBjb250ZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbGFzdFByb3BzXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAcGFyYW0ge29iamVjdH0gY29udGV4dFxuICAgKi9cbiAgX3VwZGF0ZURPTUNoaWxkcmVuOiBmdW5jdGlvbiAobGFzdFByb3BzLCBuZXh0UHJvcHMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgdmFyIGxhc3RDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbGFzdFByb3BzLmNoaWxkcmVuXSA/IGxhc3RQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG4gICAgdmFyIG5leHRDb250ZW50ID0gQ09OVEVOVF9UWVBFU1t0eXBlb2YgbmV4dFByb3BzLmNoaWxkcmVuXSA/IG5leHRQcm9wcy5jaGlsZHJlbiA6IG51bGw7XG5cbiAgICB2YXIgbGFzdEh0bWwgPSBsYXN0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbGFzdFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcbiAgICB2YXIgbmV4dEh0bWwgPSBuZXh0UHJvcHMuZGFuZ2Vyb3VzbHlTZXRJbm5lckhUTUwgJiYgbmV4dFByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MLl9faHRtbDtcblxuICAgIC8vIE5vdGUgdGhlIHVzZSBvZiBgIT1gIHdoaWNoIGNoZWNrcyBmb3IgbnVsbCBvciB1bmRlZmluZWQuXG4gICAgdmFyIGxhc3RDaGlsZHJlbiA9IGxhc3RDb250ZW50ICE9IG51bGwgPyBudWxsIDogbGFzdFByb3BzLmNoaWxkcmVuO1xuICAgIHZhciBuZXh0Q2hpbGRyZW4gPSBuZXh0Q29udGVudCAhPSBudWxsID8gbnVsbCA6IG5leHRQcm9wcy5jaGlsZHJlbjtcblxuICAgIC8vIElmIHdlJ3JlIHN3aXRjaGluZyBmcm9tIGNoaWxkcmVuIHRvIGNvbnRlbnQvaHRtbCBvciB2aWNlIHZlcnNhLCByZW1vdmVcbiAgICAvLyB0aGUgb2xkIGNvbnRlbnRcbiAgICB2YXIgbGFzdEhhc0NvbnRlbnRPckh0bWwgPSBsYXN0Q29udGVudCAhPSBudWxsIHx8IGxhc3RIdG1sICE9IG51bGw7XG4gICAgdmFyIG5leHRIYXNDb250ZW50T3JIdG1sID0gbmV4dENvbnRlbnQgIT0gbnVsbCB8fCBuZXh0SHRtbCAhPSBudWxsO1xuICAgIGlmIChsYXN0Q2hpbGRyZW4gIT0gbnVsbCAmJiBuZXh0Q2hpbGRyZW4gPT0gbnVsbCkge1xuICAgICAgdGhpcy51cGRhdGVDaGlsZHJlbihudWxsLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfSBlbHNlIGlmIChsYXN0SGFzQ29udGVudE9ySHRtbCAmJiAhbmV4dEhhc0NvbnRlbnRPckh0bWwpIHtcbiAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycpO1xuICAgIH1cblxuICAgIGlmIChuZXh0Q29udGVudCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdENvbnRlbnQgIT09IG5leHRDb250ZW50KSB7XG4gICAgICAgIHRoaXMudXBkYXRlVGV4dENvbnRlbnQoJycgKyBuZXh0Q29udGVudCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0SHRtbCAhPSBudWxsKSB7XG4gICAgICBpZiAobGFzdEh0bWwgIT09IG5leHRIdG1sKSB7XG4gICAgICAgIHRoaXMudXBkYXRlTWFya3VwKCcnICsgbmV4dEh0bWwpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAobmV4dENoaWxkcmVuICE9IG51bGwpIHtcbiAgICAgIHRoaXMudXBkYXRlQ2hpbGRyZW4obmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBEZXN0cm95cyBhbGwgZXZlbnQgcmVnaXN0cmF0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS4gRG9lcyBub3QgcmVtb3ZlIGZyb21cbiAgICogdGhlIERPTS4gVGhhdCBtdXN0IGJlIGRvbmUgYnkgdGhlIHBhcmVudC5cbiAgICpcbiAgICogQGludGVybmFsXG4gICAqL1xuICB1bm1vdW50Q29tcG9uZW50OiBmdW5jdGlvbiAoKSB7XG4gICAgc3dpdGNoICh0aGlzLl90YWcpIHtcbiAgICAgIGNhc2UgJ2lmcmFtZSc6XG4gICAgICBjYXNlICdpbWcnOlxuICAgICAgY2FzZSAnZm9ybSc6XG4gICAgICBjYXNlICd2aWRlbyc6XG4gICAgICBjYXNlICdhdWRpbyc6XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSB0aGlzLl93cmFwcGVyU3RhdGUubGlzdGVuZXJzO1xuICAgICAgICBpZiAobGlzdGVuZXJzKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0ZW5lcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5yZW1vdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdpbnB1dCc6XG4gICAgICAgIFJlYWN0RE9NSW5wdXQudW5tb3VudFdyYXBwZXIodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnaHRtbCc6XG4gICAgICBjYXNlICdoZWFkJzpcbiAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAvKipcbiAgICAgICAgICogQ29tcG9uZW50cyBsaWtlIDxodG1sPiA8aGVhZD4gYW5kIDxib2R5PiBjYW4ndCBiZSByZW1vdmVkIG9yIGFkZGVkXG4gICAgICAgICAqIGVhc2lseSBpbiBhIGNyb3NzLWJyb3dzZXIgd2F5LCBob3dldmVyIGl0J3MgdmFsdWFibGUgdG8gYmUgYWJsZSB0b1xuICAgICAgICAgKiB0YWtlIGFkdmFudGFnZSBvZiBSZWFjdCdzIHJlY29uY2lsaWF0aW9uIGZvciBzdHlsaW5nIGFuZCA8dGl0bGU+XG4gICAgICAgICAqIG1hbmFnZW1lbnQuIFNvIHdlIGp1c3QgZG9jdW1lbnQgaXQgYW5kIHRocm93IGluIGRhbmdlcm91cyBjYXNlcy5cbiAgICAgICAgICovXG4gICAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICc8JXM+IHRyaWVkIHRvIHVubW91bnQuIEJlY2F1c2Ugb2YgY3Jvc3MtYnJvd3NlciBxdWlya3MgaXQgaXMgJyArICdpbXBvc3NpYmxlIHRvIHVubW91bnQgc29tZSB0b3AtbGV2ZWwgY29tcG9uZW50cyAoZWcgPGh0bWw+LCAnICsgJzxoZWFkPiwgYW5kIDxib2R5PikgcmVsaWFibHkgYW5kIGVmZmljaWVudGx5LiBUbyBmaXggdGhpcywgaGF2ZSBhICcgKyAnc2luZ2xlIHRvcC1sZXZlbCBjb21wb25lbnQgdGhhdCBuZXZlciB1bm1vdW50cyByZW5kZXIgdGhlc2UgJyArICdlbGVtZW50cy4nLCB0aGlzLl90YWcpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuXG4gICAgdGhpcy51bm1vdW50Q2hpbGRyZW4oKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuZGVsZXRlQWxsTGlzdGVuZXJzKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIFJlYWN0Q29tcG9uZW50QnJvd3NlckVudmlyb25tZW50LnVubW91bnRJREZyb21FbnZpcm9ubWVudCh0aGlzLl9yb290Tm9kZUlEKTtcbiAgICB0aGlzLl9yb290Tm9kZUlEID0gbnVsbDtcbiAgICB0aGlzLl93cmFwcGVyU3RhdGUgPSBudWxsO1xuICAgIGlmICh0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMpIHtcbiAgICAgIHZhciBub2RlID0gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IG51bGw7XG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBudWxsO1xuICAgIH1cbiAgfSxcblxuICBnZXRQdWJsaWNJbnN0YW5jZTogZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzKSB7XG4gICAgICB2YXIgbm9kZSA9IFJlYWN0TW91bnQuZ2V0Tm9kZSh0aGlzLl9yb290Tm9kZUlEKTtcblxuICAgICAgbm9kZS5fcmVhY3RJbnRlcm5hbENvbXBvbmVudCA9IHRoaXM7XG4gICAgICBub2RlLmdldERPTU5vZGUgPSBsZWdhY3lHZXRET01Ob2RlO1xuICAgICAgbm9kZS5pc01vdW50ZWQgPSBsZWdhY3lJc01vdW50ZWQ7XG4gICAgICBub2RlLnNldFN0YXRlID0gbGVnYWN5U2V0U3RhdGVFdGM7XG4gICAgICBub2RlLnJlcGxhY2VTdGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5mb3JjZVVwZGF0ZSA9IGxlZ2FjeVNldFN0YXRlRXRjO1xuICAgICAgbm9kZS5zZXRQcm9wcyA9IGxlZ2FjeVNldFByb3BzO1xuICAgICAgbm9kZS5yZXBsYWNlUHJvcHMgPSBsZWdhY3lSZXBsYWNlUHJvcHM7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKG5vZGUsIGxlZ2FjeVByb3BzRGVzY3JpcHRvcik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdXBkYXRlQ29tcG9uZW50IHdpbGwgdXBkYXRlIHRoaXMgcHJvcGVydHkgb24gc3Vic2VxdWVudCByZW5kZXJzXG4gICAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1cGRhdGVDb21wb25lbnQgd2lsbCB1cGRhdGUgdGhpcyBwcm9wZXJ0eSBvbiBzdWJzZXF1ZW50IHJlbmRlcnNcbiAgICAgICAgbm9kZS5wcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9ub2RlV2l0aExlZ2FjeVByb3BlcnRpZXMgPSBub2RlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fbm9kZVdpdGhMZWdhY3lQcm9wZXJ0aWVzO1xuICB9XG5cbn07XG5cblJlYWN0UGVyZi5tZWFzdXJlTWV0aG9kcyhSZWFjdERPTUNvbXBvbmVudCwgJ1JlYWN0RE9NQ29tcG9uZW50Jywge1xuICBtb3VudENvbXBvbmVudDogJ21vdW50Q29tcG9uZW50JyxcbiAgdXBkYXRlQ29tcG9uZW50OiAndXBkYXRlQ29tcG9uZW50J1xufSk7XG5cbmFzc2lnbihSZWFjdERPTUNvbXBvbmVudC5wcm90b3R5cGUsIFJlYWN0RE9NQ29tcG9uZW50Lk1peGluLCBSZWFjdE11bHRpQ2hpbGQuTWl4aW4pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NQ29tcG9uZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0RE9NQ29tcG9uZW50LmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIEF1dG9Gb2N1c1V0aWxzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcblxudmFyIGZpbmRET01Ob2RlID0gcmVxdWlyZSgnLi9maW5kRE9NTm9kZScpO1xudmFyIGZvY3VzTm9kZSA9IHJlcXVpcmUoJ2ZianMvbGliL2ZvY3VzTm9kZScpO1xuXG52YXIgTWl4aW4gPSB7XG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucHJvcHMuYXV0b0ZvY3VzKSB7XG4gICAgICBmb2N1c05vZGUoZmluZERPTU5vZGUodGhpcykpO1xuICAgIH1cbiAgfVxufTtcblxudmFyIEF1dG9Gb2N1c1V0aWxzID0ge1xuICBNaXhpbjogTWl4aW4sXG5cbiAgZm9jdXNET01Db21wb25lbnQ6IGZ1bmN0aW9uICgpIHtcbiAgICBmb2N1c05vZGUoUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBBdXRvRm9jdXNVdGlscztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9BdXRvRm9jdXNVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBmb2N1c05vZGVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlIGlucHV0L3RleHRhcmVhIHRvIGZvY3VzXG4gKi9cbmZ1bmN0aW9uIGZvY3VzTm9kZShub2RlKSB7XG4gIC8vIElFOCBjYW4gdGhyb3cgXCJDYW4ndCBtb3ZlIGZvY3VzIHRvIHRoZSBjb250cm9sIGJlY2F1c2UgaXQgaXMgaW52aXNpYmxlLFxuICAvLyBub3QgZW5hYmxlZCwgb3Igb2YgYSB0eXBlIHRoYXQgZG9lcyBub3QgYWNjZXB0IHRoZSBmb2N1cy5cIiBmb3IgYWxsIGtpbmRzIG9mXG4gIC8vIHJlYXNvbnMgdGhhdCBhcmUgdG9vIGV4cGVuc2l2ZSBhbmQgZnJhZ2lsZSB0byB0ZXN0LlxuICB0cnkge1xuICAgIG5vZGUuZm9jdXMoKTtcbiAgfSBjYXRjaCAoZSkge31cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmb2N1c05vZGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL2ZvY3VzTm9kZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eU9wZXJhdGlvbnNcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBjYW1lbGl6ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2NhbWVsaXplU3R5bGVOYW1lJyk7XG52YXIgZGFuZ2Vyb3VzU3R5bGVWYWx1ZSA9IHJlcXVpcmUoJy4vZGFuZ2Vyb3VzU3R5bGVWYWx1ZScpO1xudmFyIGh5cGhlbmF0ZVN0eWxlTmFtZSA9IHJlcXVpcmUoJ2ZianMvbGliL2h5cGhlbmF0ZVN0eWxlTmFtZScpO1xudmFyIG1lbW9pemVTdHJpbmdPbmx5ID0gcmVxdWlyZSgnZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHknKTtcbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG52YXIgcHJvY2Vzc1N0eWxlTmFtZSA9IG1lbW9pemVTdHJpbmdPbmx5KGZ1bmN0aW9uIChzdHlsZU5hbWUpIHtcbiAgcmV0dXJuIGh5cGhlbmF0ZVN0eWxlTmFtZShzdHlsZU5hbWUpO1xufSk7XG5cbnZhciBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyA9IGZhbHNlO1xudmFyIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdjc3NGbG9hdCc7XG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHZhciB0ZW1wU3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKS5zdHlsZTtcbiAgdHJ5IHtcbiAgICAvLyBJRTggdGhyb3dzIFwiSW52YWxpZCBhcmd1bWVudC5cIiBpZiByZXNldHRpbmcgc2hvcnRoYW5kIHN0eWxlIHByb3BlcnRpZXMuXG4gICAgdGVtcFN0eWxlLmZvbnQgPSAnJztcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhc1Nob3J0aGFuZFByb3BlcnR5QnVnID0gdHJ1ZTtcbiAgfVxuICAvLyBJRTggb25seSBzdXBwb3J0cyBhY2Nlc3NpbmcgY3NzRmxvYXQgKHN0YW5kYXJkKSBhcyBzdHlsZUZsb2F0XG4gIGlmIChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuY3NzRmxvYXQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0eWxlRmxvYXRBY2Nlc3NvciA9ICdzdHlsZUZsb2F0JztcbiAgfVxufVxuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAvLyAnbXNUcmFuc2Zvcm0nIGlzIGNvcnJlY3QsIGJ1dCB0aGUgb3RoZXIgcHJlZml4ZXMgc2hvdWxkIGJlIGNhcGl0YWxpemVkXG4gIHZhciBiYWRWZW5kb3JlZFN0eWxlTmFtZVBhdHRlcm4gPSAvXig/OndlYmtpdHxtb3p8bylbQS1aXS87XG5cbiAgLy8gc3R5bGUgdmFsdWVzIHNob3VsZG4ndCBjb250YWluIGEgc2VtaWNvbG9uXG4gIHZhciBiYWRTdHlsZVZhbHVlV2l0aFNlbWljb2xvblBhdHRlcm4gPSAvO1xccyokLztcblxuICB2YXIgd2FybmVkU3R5bGVOYW1lcyA9IHt9O1xuICB2YXIgd2FybmVkU3R5bGVWYWx1ZXMgPSB7fTtcblxuICB2YXIgd2Fybkh5cGhlbmF0ZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHN0eWxlIHByb3BlcnR5ICVzLiBEaWQgeW91IG1lYW4gJXM/JywgbmFtZSwgY2FtZWxpemVTdHlsZU5hbWUobmFtZSkpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIHZhciB3YXJuQmFkVmVuZG9yZWRTdHlsZU5hbWUgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIGlmICh3YXJuZWRTdHlsZU5hbWVzLmhhc093blByb3BlcnR5KG5hbWUpICYmIHdhcm5lZFN0eWxlTmFtZXNbbmFtZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZU5hbWVzW25hbWVdID0gdHJ1ZTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ1Vuc3VwcG9ydGVkIHZlbmRvci1wcmVmaXhlZCBzdHlsZSBwcm9wZXJ0eSAlcy4gRGlkIHlvdSBtZWFuICVzPycsIG5hbWUsIG5hbWUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKDEpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICB2YXIgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKHdhcm5lZFN0eWxlVmFsdWVzLmhhc093blByb3BlcnR5KHZhbHVlKSAmJiB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRTdHlsZVZhbHVlc1t2YWx1ZV0gPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnU3R5bGUgcHJvcGVydHkgdmFsdWVzIHNob3VsZG5cXCd0IGNvbnRhaW4gYSBzZW1pY29sb24uICcgKyAnVHJ5IFwiJXM6ICVzXCIgaW5zdGVhZC4nLCBuYW1lLCB2YWx1ZS5yZXBsYWNlKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybiwgJycpKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKi9cbiAgdmFyIHdhcm5WYWxpZFN0eWxlID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgaWYgKG5hbWUuaW5kZXhPZignLScpID4gLTEpIHtcbiAgICAgIHdhcm5IeXBoZW5hdGVkU3R5bGVOYW1lKG5hbWUpO1xuICAgIH0gZWxzZSBpZiAoYmFkVmVuZG9yZWRTdHlsZU5hbWVQYXR0ZXJuLnRlc3QobmFtZSkpIHtcbiAgICAgIHdhcm5CYWRWZW5kb3JlZFN0eWxlTmFtZShuYW1lKTtcbiAgICB9IGVsc2UgaWYgKGJhZFN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uUGF0dGVybi50ZXN0KHZhbHVlKSkge1xuICAgICAgd2FyblN0eWxlVmFsdWVXaXRoU2VtaWNvbG9uKG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogT3BlcmF0aW9ucyBmb3IgZGVhbGluZyB3aXRoIENTUyBwcm9wZXJ0aWVzLlxuICovXG52YXIgQ1NTUHJvcGVydHlPcGVyYXRpb25zID0ge1xuXG4gIC8qKlxuICAgKiBTZXJpYWxpemVzIGEgbWFwcGluZyBvZiBzdHlsZSBwcm9wZXJ0aWVzIGZvciB1c2UgYXMgaW5saW5lIHN0eWxlczpcbiAgICpcbiAgICogICA+IGNyZWF0ZU1hcmt1cEZvclN0eWxlcyh7d2lkdGg6ICcyMDBweCcsIGhlaWdodDogMH0pXG4gICAqICAgXCJ3aWR0aDoyMDBweDtoZWlnaHQ6MDtcIlxuICAgKlxuICAgKiBVbmRlZmluZWQgdmFsdWVzIGFyZSBpZ25vcmVkIHNvIHRoYXQgZGVjbGFyYXRpdmUgcHJvZ3JhbW1pbmcgaXMgZWFzaWVyLlxuICAgKiBUaGUgcmVzdWx0IHNob3VsZCBiZSBIVE1MLWVzY2FwZWQgYmVmb3JlIGluc2VydGlvbiBpbnRvIHRoZSBET00uXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBzdHlsZXNcbiAgICogQHJldHVybiB7P3N0cmluZ31cbiAgICovXG4gIGNyZWF0ZU1hcmt1cEZvclN0eWxlczogZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBzZXJpYWxpemVkID0gJyc7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBzdHlsZVZhbHVlID0gc3R5bGVzW3N0eWxlTmFtZV07XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB3YXJuVmFsaWRTdHlsZShzdHlsZU5hbWUsIHN0eWxlVmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHN0eWxlVmFsdWUgIT0gbnVsbCkge1xuICAgICAgICBzZXJpYWxpemVkICs9IHByb2Nlc3NTdHlsZU5hbWUoc3R5bGVOYW1lKSArICc6JztcbiAgICAgICAgc2VyaWFsaXplZCArPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVWYWx1ZSkgKyAnOyc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkIHx8IG51bGw7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHZhbHVlIGZvciBtdWx0aXBsZSBzdHlsZXMgb24gYSBub2RlLiAgSWYgYSB2YWx1ZSBpcyBzcGVjaWZpZWQgYXNcbiAgICogJycgKGVtcHR5IHN0cmluZyksIHRoZSBjb3JyZXNwb25kaW5nIHN0eWxlIHByb3BlcnR5IHdpbGwgYmUgdW5zZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICAgKiBAcGFyYW0ge29iamVjdH0gc3R5bGVzXG4gICAqL1xuICBzZXRWYWx1ZUZvclN0eWxlczogZnVuY3Rpb24gKG5vZGUsIHN0eWxlcykge1xuICAgIHZhciBzdHlsZSA9IG5vZGUuc3R5bGU7XG4gICAgZm9yICh2YXIgc3R5bGVOYW1lIGluIHN0eWxlcykge1xuICAgICAgaWYgKCFzdHlsZXMuaGFzT3duUHJvcGVydHkoc3R5bGVOYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm5WYWxpZFN0eWxlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgfVxuICAgICAgdmFyIHN0eWxlVmFsdWUgPSBkYW5nZXJvdXNTdHlsZVZhbHVlKHN0eWxlTmFtZSwgc3R5bGVzW3N0eWxlTmFtZV0pO1xuICAgICAgaWYgKHN0eWxlTmFtZSA9PT0gJ2Zsb2F0Jykge1xuICAgICAgICBzdHlsZU5hbWUgPSBzdHlsZUZsb2F0QWNjZXNzb3I7XG4gICAgICB9XG4gICAgICBpZiAoc3R5bGVWYWx1ZSkge1xuICAgICAgICBzdHlsZVtzdHlsZU5hbWVdID0gc3R5bGVWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBleHBhbnNpb24gPSBoYXNTaG9ydGhhbmRQcm9wZXJ0eUJ1ZyAmJiBDU1NQcm9wZXJ0eS5zaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNbc3R5bGVOYW1lXTtcbiAgICAgICAgaWYgKGV4cGFuc2lvbikge1xuICAgICAgICAgIC8vIFNob3J0aGFuZCBwcm9wZXJ0eSB0aGF0IElFOCB3b24ndCBsaWtlIHVuc2V0dGluZywgc28gdW5zZXQgZWFjaFxuICAgICAgICAgIC8vIGNvbXBvbmVudCB0byBwbGFjYXRlIGl0XG4gICAgICAgICAgZm9yICh2YXIgaW5kaXZpZHVhbFN0eWxlTmFtZSBpbiBleHBhbnNpb24pIHtcbiAgICAgICAgICAgIHN0eWxlW2luZGl2aWR1YWxTdHlsZU5hbWVdID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHN0eWxlW3N0eWxlTmFtZV0gPSAnJztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG5SZWFjdFBlcmYubWVhc3VyZU1ldGhvZHMoQ1NTUHJvcGVydHlPcGVyYXRpb25zLCAnQ1NTUHJvcGVydHlPcGVyYXRpb25zJywge1xuICBzZXRWYWx1ZUZvclN0eWxlczogJ3NldFZhbHVlRm9yU3R5bGVzJ1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHlPcGVyYXRpb25zO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL0NTU1Byb3BlcnR5T3BlcmF0aW9ucy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBDU1NQcm9wZXJ0eVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDU1MgcHJvcGVydGllcyB3aGljaCBhY2NlcHQgbnVtYmVycyBidXQgYXJlIG5vdCBpbiB1bml0cyBvZiBcInB4XCIuXG4gKi9cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0ge1xuICBhbmltYXRpb25JdGVyYXRpb25Db3VudDogdHJ1ZSxcbiAgYm94RmxleDogdHJ1ZSxcbiAgYm94RmxleEdyb3VwOiB0cnVlLFxuICBib3hPcmRpbmFsR3JvdXA6IHRydWUsXG4gIGNvbHVtbkNvdW50OiB0cnVlLFxuICBmbGV4OiB0cnVlLFxuICBmbGV4R3JvdzogdHJ1ZSxcbiAgZmxleFBvc2l0aXZlOiB0cnVlLFxuICBmbGV4U2hyaW5rOiB0cnVlLFxuICBmbGV4TmVnYXRpdmU6IHRydWUsXG4gIGZsZXhPcmRlcjogdHJ1ZSxcbiAgZm9udFdlaWdodDogdHJ1ZSxcbiAgbGluZUNsYW1wOiB0cnVlLFxuICBsaW5lSGVpZ2h0OiB0cnVlLFxuICBvcGFjaXR5OiB0cnVlLFxuICBvcmRlcjogdHJ1ZSxcbiAgb3JwaGFuczogdHJ1ZSxcbiAgdGFiU2l6ZTogdHJ1ZSxcbiAgd2lkb3dzOiB0cnVlLFxuICB6SW5kZXg6IHRydWUsXG4gIHpvb206IHRydWUsXG5cbiAgLy8gU1ZHLXJlbGF0ZWQgcHJvcGVydGllc1xuICBmaWxsT3BhY2l0eTogdHJ1ZSxcbiAgc3RvcE9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZURhc2hvZmZzZXQ6IHRydWUsXG4gIHN0cm9rZU9wYWNpdHk6IHRydWUsXG4gIHN0cm9rZVdpZHRoOiB0cnVlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBwcmVmaXggdmVuZG9yLXNwZWNpZmljIHByZWZpeCwgZWc6IFdlYmtpdFxuICogQHBhcmFtIHtzdHJpbmd9IGtleSBzdHlsZSBuYW1lLCBlZzogdHJhbnNpdGlvbkR1cmF0aW9uXG4gKiBAcmV0dXJuIHtzdHJpbmd9IHN0eWxlIG5hbWUgcHJlZml4ZWQgd2l0aCBgcHJlZml4YCwgcHJvcGVybHkgY2FtZWxDYXNlZCwgZWc6XG4gKiBXZWJraXRUcmFuc2l0aW9uRHVyYXRpb25cbiAqL1xuZnVuY3Rpb24gcHJlZml4S2V5KHByZWZpeCwga2V5KSB7XG4gIHJldHVybiBwcmVmaXggKyBrZXkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBrZXkuc3Vic3RyaW5nKDEpO1xufVxuXG4vKipcbiAqIFN1cHBvcnQgc3R5bGUgbmFtZXMgdGhhdCBtYXkgY29tZSBwYXNzZWQgaW4gcHJlZml4ZWQgYnkgYWRkaW5nIHBlcm11dGF0aW9uc1xuICogb2YgdmVuZG9yIHByZWZpeGVzLlxuICovXG52YXIgcHJlZml4ZXMgPSBbJ1dlYmtpdCcsICdtcycsICdNb3onLCAnTyddO1xuXG4vLyBVc2luZyBPYmplY3Qua2V5cyBoZXJlLCBvciBlbHNlIHRoZSB2YW5pbGxhIGZvci1pbiBsb29wIG1ha2VzIElFOCBnbyBpbnRvIGFuXG4vLyBpbmZpbml0ZSBsb29wLCBiZWNhdXNlIGl0IGl0ZXJhdGVzIG92ZXIgdGhlIG5ld2x5IGFkZGVkIHByb3BzIHRvby5cbk9iamVjdC5rZXlzKGlzVW5pdGxlc3NOdW1iZXIpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgcHJlZml4ZXMuZm9yRWFjaChmdW5jdGlvbiAocHJlZml4KSB7XG4gICAgaXNVbml0bGVzc051bWJlcltwcmVmaXhLZXkocHJlZml4LCBwcm9wKV0gPSBpc1VuaXRsZXNzTnVtYmVyW3Byb3BdO1xuICB9KTtcbn0pO1xuXG4vKipcbiAqIE1vc3Qgc3R5bGUgcHJvcGVydGllcyBjYW4gYmUgdW5zZXQgYnkgZG9pbmcgLnN0eWxlW3Byb3BdID0gJycgYnV0IElFOFxuICogZG9lc24ndCBsaWtlIGRvaW5nIHRoYXQgd2l0aCBzaG9ydGhhbmQgcHJvcGVydGllcyBzbyBmb3IgdGhlIHByb3BlcnRpZXMgdGhhdFxuICogSUU4IGJyZWFrcyBvbiwgd2hpY2ggYXJlIGxpc3RlZCBoZXJlLCB3ZSBpbnN0ZWFkIHVuc2V0IGVhY2ggb2YgdGhlXG4gKiBpbmRpdmlkdWFsIHByb3BlcnRpZXMuIFNlZSBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMjM4NS5cbiAqIFRoZSA0LXZhbHVlICdjbG9jaycgcHJvcGVydGllcyBsaWtlIG1hcmdpbiwgcGFkZGluZywgYm9yZGVyLXdpZHRoIHNlZW0gdG9cbiAqIGJlaGF2ZSB3aXRob3V0IGFueSBwcm9ibGVtcy4gQ3VyaW91c2x5LCBsaXN0LXN0eWxlIHdvcmtzIHRvbyB3aXRob3V0IGFueVxuICogc3BlY2lhbCBwcm9kZGluZy5cbiAqL1xudmFyIHNob3J0aGFuZFByb3BlcnR5RXhwYW5zaW9ucyA9IHtcbiAgYmFja2dyb3VuZDoge1xuICAgIGJhY2tncm91bmRBdHRhY2htZW50OiB0cnVlLFxuICAgIGJhY2tncm91bmRDb2xvcjogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kSW1hZ2U6IHRydWUsXG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlLFxuICAgIGJhY2tncm91bmRSZXBlYXQ6IHRydWVcbiAgfSxcbiAgYmFja2dyb3VuZFBvc2l0aW9uOiB7XG4gICAgYmFja2dyb3VuZFBvc2l0aW9uWDogdHJ1ZSxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiB0cnVlXG4gIH0sXG4gIGJvcmRlcjoge1xuICAgIGJvcmRlcldpZHRoOiB0cnVlLFxuICAgIGJvcmRlclN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckJvdHRvbToge1xuICAgIGJvcmRlckJvdHRvbVdpZHRoOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbVN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckJvdHRvbUNvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlckxlZnQ6IHtcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyTGVmdFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlckxlZnRDb2xvcjogdHJ1ZVxuICB9LFxuICBib3JkZXJSaWdodDoge1xuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHRydWUsXG4gICAgYm9yZGVyUmlnaHRTdHlsZTogdHJ1ZSxcbiAgICBib3JkZXJSaWdodENvbG9yOiB0cnVlXG4gIH0sXG4gIGJvcmRlclRvcDoge1xuICAgIGJvcmRlclRvcFdpZHRoOiB0cnVlLFxuICAgIGJvcmRlclRvcFN0eWxlOiB0cnVlLFxuICAgIGJvcmRlclRvcENvbG9yOiB0cnVlXG4gIH0sXG4gIGZvbnQ6IHtcbiAgICBmb250U3R5bGU6IHRydWUsXG4gICAgZm9udFZhcmlhbnQ6IHRydWUsXG4gICAgZm9udFdlaWdodDogdHJ1ZSxcbiAgICBmb250U2l6ZTogdHJ1ZSxcbiAgICBsaW5lSGVpZ2h0OiB0cnVlLFxuICAgIGZvbnRGYW1pbHk6IHRydWVcbiAgfSxcbiAgb3V0bGluZToge1xuICAgIG91dGxpbmVXaWR0aDogdHJ1ZSxcbiAgICBvdXRsaW5lU3R5bGU6IHRydWUsXG4gICAgb3V0bGluZUNvbG9yOiB0cnVlXG4gIH1cbn07XG5cbnZhciBDU1NQcm9wZXJ0eSA9IHtcbiAgaXNVbml0bGVzc051bWJlcjogaXNVbml0bGVzc051bWJlcixcbiAgc2hvcnRoYW5kUHJvcGVydHlFeHBhbnNpb25zOiBzaG9ydGhhbmRQcm9wZXJ0eUV4cGFuc2lvbnNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ1NTUHJvcGVydHk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvQ1NTUHJvcGVydHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgY2FtZWxpemVTdHlsZU5hbWVcbiAqIEB0eXBlY2hlY2tzXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY2FtZWxpemUgPSByZXF1aXJlKCcuL2NhbWVsaXplJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXi1tcy0vO1xuXG4vKipcbiAqIENhbWVsY2FzZXMgYSBoeXBoZW5hdGVkIENTUyBwcm9wZXJ0eSBuYW1lLCBmb3IgZXhhbXBsZTpcbiAqXG4gKiAgID4gY2FtZWxpemVTdHlsZU5hbWUoJ2JhY2tncm91bmQtY29sb3InKVxuICogICA8IFwiYmFja2dyb3VuZENvbG9yXCJcbiAqICAgPiBjYW1lbGl6ZVN0eWxlTmFtZSgnLW1vei10cmFuc2l0aW9uJylcbiAqICAgPCBcIk1velRyYW5zaXRpb25cIlxuICogICA+IGNhbWVsaXplU3R5bGVOYW1lKCctbXMtdHJhbnNpdGlvbicpXG4gKiAgIDwgXCJtc1RyYW5zaXRpb25cIlxuICpcbiAqIEFzIEFuZGkgU21pdGggc3VnZ2VzdHNcbiAqIChodHRwOi8vd3d3LmFuZGlzbWl0aC5jb20vYmxvZy8yMDEyLzAyL21vZGVybml6ci1wcmVmaXhlZC8pLCBhbiBgLW1zYCBwcmVmaXhcbiAqIGlzIGNvbnZlcnRlZCB0byBsb3dlcmNhc2UgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNhbWVsaXplU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gY2FtZWxpemUoc3RyaW5nLnJlcGxhY2UobXNQYXR0ZXJuLCAnbXMtJykpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNhbWVsaXplU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9jYW1lbGl6ZVN0eWxlTmFtZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBjYW1lbGl6ZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIF9oeXBoZW5QYXR0ZXJuID0gLy0oLikvZztcblxuLyoqXG4gKiBDYW1lbGNhc2VzIGEgaHlwaGVuYXRlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBjYW1lbGl6ZSgnYmFja2dyb3VuZC1jb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kQ29sb3JcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gY2FtZWxpemUoc3RyaW5nKSB7XG4gIHJldHVybiBzdHJpbmcucmVwbGFjZShfaHlwaGVuUGF0dGVybiwgZnVuY3Rpb24gKF8sIGNoYXJhY3Rlcikge1xuICAgIHJldHVybiBjaGFyYWN0ZXIudG9VcHBlckNhc2UoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY2FtZWxpemU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL2NhbWVsaXplLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGRhbmdlcm91c1N0eWxlVmFsdWVcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ1NTUHJvcGVydHkgPSByZXF1aXJlKCcuL0NTU1Byb3BlcnR5Jyk7XG5cbnZhciBpc1VuaXRsZXNzTnVtYmVyID0gQ1NTUHJvcGVydHkuaXNVbml0bGVzc051bWJlcjtcblxuLyoqXG4gKiBDb252ZXJ0IGEgdmFsdWUgaW50byB0aGUgcHJvcGVyIGNzcyB3cml0YWJsZSB2YWx1ZS4gVGhlIHN0eWxlIG5hbWUgYG5hbWVgXG4gKiBzaG91bGQgYmUgbG9naWNhbCAobm8gaHlwaGVucyksIGFzIHNwZWNpZmllZFxuICogaW4gYENTU1Byb3BlcnR5LmlzVW5pdGxlc3NOdW1iZXJgLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIENTUyBwcm9wZXJ0eSBuYW1lIHN1Y2ggYXMgYHRvcE1hcmdpbmAuXG4gKiBAcGFyYW0geyp9IHZhbHVlIENTUyBwcm9wZXJ0eSB2YWx1ZSBzdWNoIGFzIGAxMHB4YC5cbiAqIEByZXR1cm4ge3N0cmluZ30gTm9ybWFsaXplZCBzdHlsZSB2YWx1ZSB3aXRoIGRpbWVuc2lvbnMgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZGFuZ2Vyb3VzU3R5bGVWYWx1ZShuYW1lLCB2YWx1ZSkge1xuICAvLyBOb3RlIHRoYXQgd2UndmUgcmVtb3ZlZCBlc2NhcGVUZXh0Rm9yQnJvd3NlcigpIGNhbGxzIGhlcmUgc2luY2UgdGhlXG4gIC8vIHdob2xlIHN0cmluZyB3aWxsIGJlIGVzY2FwZWQgd2hlbiB0aGUgYXR0cmlidXRlIGlzIGluamVjdGVkIGludG9cbiAgLy8gdGhlIG1hcmt1cC4gSWYgeW91IHByb3ZpZGUgdW5zYWZlIHVzZXIgZGF0YSBoZXJlIHRoZXkgY2FuIGluamVjdFxuICAvLyBhcmJpdHJhcnkgQ1NTIHdoaWNoIG1heSBiZSBwcm9ibGVtYXRpYyAoSSBjb3VsZG4ndCByZXBybyB0aGlzKTpcbiAgLy8gaHR0cHM6Ly93d3cub3dhc3Aub3JnL2luZGV4LnBocC9YU1NfRmlsdGVyX0V2YXNpb25fQ2hlYXRfU2hlZXRcbiAgLy8gaHR0cDovL3d3dy50aGVzcGFubmVyLmNvLnVrLzIwMDcvMTEvMjYvdWx0aW1hdGUteHNzLWNzcy1pbmplY3Rpb24vXG4gIC8vIFRoaXMgaXMgbm90IGFuIFhTUyBob2xlIGJ1dCBpbnN0ZWFkIGEgcG90ZW50aWFsIENTUyBpbmplY3Rpb24gaXNzdWVcbiAgLy8gd2hpY2ggaGFzIGxlYWQgdG8gYSBncmVhdGVyIGRpc2N1c3Npb24gYWJvdXQgaG93IHdlJ3JlIGdvaW5nIHRvXG4gIC8vIHRydXN0IFVSTHMgbW92aW5nIGZvcndhcmQuIFNlZSAjMjExNTkwMVxuXG4gIHZhciBpc0VtcHR5ID0gdmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJyB8fCB2YWx1ZSA9PT0gJyc7XG4gIGlmIChpc0VtcHR5KSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgdmFyIGlzTm9uTnVtZXJpYyA9IGlzTmFOKHZhbHVlKTtcbiAgaWYgKGlzTm9uTnVtZXJpYyB8fCB2YWx1ZSA9PT0gMCB8fCBpc1VuaXRsZXNzTnVtYmVyLmhhc093blByb3BlcnR5KG5hbWUpICYmIGlzVW5pdGxlc3NOdW1iZXJbbmFtZV0pIHtcbiAgICByZXR1cm4gJycgKyB2YWx1ZTsgLy8gY2FzdCB0byBzdHJpbmdcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHZhbHVlICsgJ3B4Jztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkYW5nZXJvdXNTdHlsZVZhbHVlO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2Rhbmdlcm91c1N0eWxlVmFsdWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlU3R5bGVOYW1lXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGh5cGhlbmF0ZSA9IHJlcXVpcmUoJy4vaHlwaGVuYXRlJyk7XG5cbnZhciBtc1BhdHRlcm4gPSAvXm1zLS87XG5cbi8qKlxuICogSHlwaGVuYXRlcyBhIGNhbWVsY2FzZWQgQ1NTIHByb3BlcnR5IG5hbWUsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ01velRyYW5zaXRpb24nKVxuICogICA8IFwiLW1vei10cmFuc2l0aW9uXCJcbiAqICAgPiBoeXBoZW5hdGVTdHlsZU5hbWUoJ21zVHJhbnNpdGlvbicpXG4gKiAgIDwgXCItbXMtdHJhbnNpdGlvblwiXG4gKlxuICogQXMgTW9kZXJuaXpyIHN1Z2dlc3RzIChodHRwOi8vbW9kZXJuaXpyLmNvbS9kb2NzLyNwcmVmaXhlZCksIGFuIGBtc2AgcHJlZml4XG4gKiBpcyBjb252ZXJ0ZWQgdG8gYC1tcy1gLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmdcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gaHlwaGVuYXRlU3R5bGVOYW1lKHN0cmluZykge1xuICByZXR1cm4gaHlwaGVuYXRlKHN0cmluZykucmVwbGFjZShtc1BhdHRlcm4sICctbXMtJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaHlwaGVuYXRlU3R5bGVOYW1lO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9oeXBoZW5hdGVTdHlsZU5hbWUuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgaHlwaGVuYXRlXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF91cHBlcmNhc2VQYXR0ZXJuID0gLyhbQS1aXSkvZztcblxuLyoqXG4gKiBIeXBoZW5hdGVzIGEgY2FtZWxjYXNlZCBzdHJpbmcsIGZvciBleGFtcGxlOlxuICpcbiAqICAgPiBoeXBoZW5hdGUoJ2JhY2tncm91bmRDb2xvcicpXG4gKiAgIDwgXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbiAqXG4gKiBGb3IgQ1NTIHN0eWxlIG5hbWVzLCB1c2UgYGh5cGhlbmF0ZVN0eWxlTmFtZWAgaW5zdGVhZCB3aGljaCB3b3JrcyBwcm9wZXJseVxuICogd2l0aCBhbGwgdmVuZG9yIHByZWZpeGVzLCBpbmNsdWRpbmcgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGh5cGhlbmF0ZShzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKF91cHBlcmNhc2VQYXR0ZXJuLCAnLSQxJykudG9Mb3dlckNhc2UoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoeXBoZW5hdGU7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL2h5cGhlbmF0ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBtZW1vaXplU3RyaW5nT25seVxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWVtb2l6ZXMgdGhlIHJldHVybiB2YWx1ZSBvZiBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyBvbmUgc3RyaW5nIGFyZ3VtZW50LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gbWVtb2l6ZVN0cmluZ09ubHkoY2FsbGJhY2spIHtcbiAgdmFyIGNhY2hlID0ge307XG4gIHJldHVybiBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgaWYgKCFjYWNoZS5oYXNPd25Qcm9wZXJ0eShzdHJpbmcpKSB7XG4gICAgICBjYWNoZVtzdHJpbmddID0gY2FsbGJhY2suY2FsbCh0aGlzLCBzdHJpbmcpO1xuICAgIH1cbiAgICByZXR1cm4gY2FjaGVbc3RyaW5nXTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtZW1vaXplU3RyaW5nT25seTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIvbWVtb2l6ZVN0cmluZ09ubHkuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01CdXR0b25cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBtb3VzZUxpc3RlbmVyTmFtZXMgPSB7XG4gIG9uQ2xpY2s6IHRydWUsXG4gIG9uRG91YmxlQ2xpY2s6IHRydWUsXG4gIG9uTW91c2VEb3duOiB0cnVlLFxuICBvbk1vdXNlTW92ZTogdHJ1ZSxcbiAgb25Nb3VzZVVwOiB0cnVlLFxuXG4gIG9uQ2xpY2tDYXB0dXJlOiB0cnVlLFxuICBvbkRvdWJsZUNsaWNrQ2FwdHVyZTogdHJ1ZSxcbiAgb25Nb3VzZURvd25DYXB0dXJlOiB0cnVlLFxuICBvbk1vdXNlTW92ZUNhcHR1cmU6IHRydWUsXG4gIG9uTW91c2VVcENhcHR1cmU6IHRydWVcbn07XG5cbi8qKlxuICogSW1wbGVtZW50cyBhIDxidXR0b24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCBkb2VzIG5vdCByZWNlaXZlIG1vdXNlIGV2ZW50c1xuICogd2hlbiBgZGlzYWJsZWRgIGlzIHNldC5cbiAqL1xudmFyIFJlYWN0RE9NQnV0dG9uID0ge1xuICBnZXROYXRpdmVQcm9wczogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKCFwcm9wcy5kaXNhYmxlZCkge1xuICAgICAgcmV0dXJuIHByb3BzO1xuICAgIH1cblxuICAgIC8vIENvcHkgdGhlIHByb3BzLCBleGNlcHQgdGhlIG1vdXNlIGxpc3RlbmVyc1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKHByb3BzLmhhc093blByb3BlcnR5KGtleSkgJiYgIW1vdXNlTGlzdGVuZXJOYW1lc1trZXldKSB7XG4gICAgICAgIG5hdGl2ZVByb3BzW2tleV0gPSBwcm9wc1trZXldO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERPTUJ1dHRvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdERPTUJ1dHRvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUlucHV0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RET01JRE9wZXJhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0RE9NSURPcGVyYXRpb25zJyk7XG52YXIgTGlua2VkVmFsdWVVdGlscyA9IHJlcXVpcmUoJy4vTGlua2VkVmFsdWVVdGlscycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG5cbnZhciBpbnN0YW5jZXNCeVJlYWN0SUQgPSB7fTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTUlucHV0LnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxpbnB1dD4gbmF0aXZlIGNvbXBvbmVudCB0aGF0IGFsbG93cyBzZXR0aW5nIHRoZXNlIG9wdGlvbmFsXG4gKiBwcm9wczogYGNoZWNrZWRgLCBgdmFsdWVgLCBgZGVmYXVsdENoZWNrZWRgLCBhbmQgYGRlZmF1bHRWYWx1ZWAuXG4gKlxuICogSWYgYGNoZWNrZWRgIG9yIGB2YWx1ZWAgYXJlIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnNcbiAqIHRoYXQgYWZmZWN0IHRoZSBjaGVja2VkIHN0YXRlIG9yIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIHRoZXkgYXJlIHN1cHBsaWVkIChhbmQgbm90IG51bGwvdW5kZWZpbmVkKSwgdGhlIHJlbmRlcmVkIGVsZW1lbnQgd2lsbCBub3RcbiAqIHRyaWdnZXIgdXBkYXRlcyB0byB0aGUgZWxlbWVudC4gSW5zdGVhZCwgdGhlIHByb3BzIG11c3QgY2hhbmdlIGluIG9yZGVyIGZvclxuICogdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIGFzIHVuY2hlY2tlZCAob3IgYGRlZmF1bHRDaGVja2VkYClcbiAqIHdpdGggYW4gZW1wdHkgdmFsdWUgKG9yIGBkZWZhdWx0VmFsdWVgKS5cbiAqXG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTIvV0QtaHRtbDUtMjAxMjEwMjUvdGhlLWlucHV0LWVsZW1lbnQuaHRtbFxuICovXG52YXIgUmVhY3RET01JbnB1dCA9IHtcbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIHZhciBjaGVja2VkID0gTGlua2VkVmFsdWVVdGlscy5nZXRDaGVja2VkKHByb3BzKTtcblxuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgIGRlZmF1bHRDaGVja2VkOiB1bmRlZmluZWQsXG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBpbnN0Ll93cmFwcGVyU3RhdGUuaW5pdGlhbFZhbHVlLFxuICAgICAgY2hlY2tlZDogY2hlY2tlZCAhPSBudWxsID8gY2hlY2tlZCA6IGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsQ2hlY2tlZCxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdpbnB1dCcsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgaW5pdGlhbENoZWNrZWQ6IHByb3BzLmRlZmF1bHRDaGVja2VkIHx8IGZhbHNlLFxuICAgICAgaW5pdGlhbFZhbHVlOiBkZWZhdWx0VmFsdWUgIT0gbnVsbCA/IGRlZmF1bHRWYWx1ZSA6IG51bGwsXG4gICAgICBvbkNoYW5nZTogX2hhbmRsZUNoYW5nZS5iaW5kKGluc3QpXG4gICAgfTtcbiAgfSxcblxuICBtb3VudFJlYWR5V3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICAvLyBDYW4ndCBiZSBpbiBtb3VudFdyYXBwZXIgb3IgZWxzZSBzZXJ2ZXIgcmVuZGVyaW5nIGxlYWtzLlxuICAgIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXSA9IGluc3Q7XG4gIH0sXG5cbiAgdW5tb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0KSB7XG4gICAgZGVsZXRlIGluc3RhbmNlc0J5UmVhY3RJRFtpbnN0Ll9yb290Tm9kZUlEXTtcbiAgfSxcblxuICB1cGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gVE9ETzogU2hvdWxkbid0IHRoaXMgYmUgZ2V0Q2hlY2tlZChwcm9wcyk/XG4gICAgdmFyIGNoZWNrZWQgPSBwcm9wcy5jaGVja2VkO1xuICAgIGlmIChjaGVja2VkICE9IG51bGwpIHtcbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAnY2hlY2tlZCcsIGNoZWNrZWQgfHwgZmFsc2UpO1xuICAgIH1cblxuICAgIHZhciB2YWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZ2V0VmFsdWUocHJvcHMpO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAvLyBDYXN0IGB2YWx1ZWAgdG8gYSBzdHJpbmcgdG8gZW5zdXJlIHRoZSB2YWx1ZSBpcyBzZXQgY29ycmVjdGx5LiBXaGlsZVxuICAgICAgLy8gYnJvd3NlcnMgdHlwaWNhbGx5IGRvIHRoaXMgYXMgbmVjZXNzYXJ5LCBqc2RvbSBkb2Vzbid0LlxuICAgICAgUmVhY3RET01JRE9wZXJhdGlvbnMudXBkYXRlUHJvcGVydHlCeUlEKGluc3QuX3Jvb3ROb2RlSUQsICd2YWx1ZScsICcnICsgdmFsdWUpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX2hhbmRsZUNoYW5nZShldmVudCkge1xuICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcblxuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIC8vIEhlcmUgd2UgdXNlIGFzYXAgdG8gd2FpdCB1bnRpbCBhbGwgdXBkYXRlcyBoYXZlIHByb3BhZ2F0ZWQsIHdoaWNoXG4gIC8vIGlzIGltcG9ydGFudCB3aGVuIHVzaW5nIGNvbnRyb2xsZWQgY29tcG9uZW50cyB3aXRoaW4gbGF5ZXJzOlxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE2OThcbiAgUmVhY3RVcGRhdGVzLmFzYXAoZm9yY2VVcGRhdGVJZk1vdW50ZWQsIHRoaXMpO1xuXG4gIHZhciBuYW1lID0gcHJvcHMubmFtZTtcbiAgaWYgKHByb3BzLnR5cGUgPT09ICdyYWRpbycgJiYgbmFtZSAhPSBudWxsKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gUmVhY3RNb3VudC5nZXROb2RlKHRoaXMuX3Jvb3ROb2RlSUQpO1xuICAgIHZhciBxdWVyeVJvb3QgPSByb290Tm9kZTtcblxuICAgIHdoaWxlIChxdWVyeVJvb3QucGFyZW50Tm9kZSkge1xuICAgICAgcXVlcnlSb290ID0gcXVlcnlSb290LnBhcmVudE5vZGU7XG4gICAgfVxuXG4gICAgLy8gSWYgYHJvb3ROb2RlLmZvcm1gIHdhcyBub24tbnVsbCwgdGhlbiB3ZSBjb3VsZCB0cnkgYGZvcm0uZWxlbWVudHNgLFxuICAgIC8vIGJ1dCB0aGF0IHNvbWV0aW1lcyBiZWhhdmVzIHN0cmFuZ2VseSBpbiBJRTguIFdlIGNvdWxkIGFsc28gdHJ5IHVzaW5nXG4gICAgLy8gYGZvcm0uZ2V0RWxlbWVudHNCeU5hbWVgLCBidXQgdGhhdCB3aWxsIG9ubHkgcmV0dXJuIGRpcmVjdCBjaGlsZHJlblxuICAgIC8vIGFuZCB3b24ndCBpbmNsdWRlIGlucHV0cyB0aGF0IHVzZSB0aGUgSFRNTDUgYGZvcm09YCBhdHRyaWJ1dGUuIFNpbmNlXG4gICAgLy8gdGhlIGlucHV0IG1pZ2h0IG5vdCBldmVuIGJlIGluIGEgZm9ybSwgbGV0J3MganVzdCB1c2UgdGhlIGdsb2JhbFxuICAgIC8vIGBxdWVyeVNlbGVjdG9yQWxsYCB0byBlbnN1cmUgd2UgZG9uJ3QgbWlzcyBhbnl0aGluZy5cbiAgICB2YXIgZ3JvdXAgPSBxdWVyeVJvb3QucXVlcnlTZWxlY3RvckFsbCgnaW5wdXRbbmFtZT0nICsgSlNPTi5zdHJpbmdpZnkoJycgKyBuYW1lKSArICddW3R5cGU9XCJyYWRpb1wiXScpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG90aGVyTm9kZSA9IGdyb3VwW2ldO1xuICAgICAgaWYgKG90aGVyTm9kZSA9PT0gcm9vdE5vZGUgfHwgb3RoZXJOb2RlLmZvcm0gIT09IHJvb3ROb2RlLmZvcm0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgaWYgcmFkaW8gYnV0dG9ucyByZW5kZXJlZCBieSBkaWZmZXJlbnQgY29waWVzIG9mIFJlYWN0XG4gICAgICAvLyBhbmQgdGhlIHNhbWUgbmFtZSBhcmUgcmVuZGVyZWQgaW50byB0aGUgc2FtZSBmb3JtIChzYW1lIGFzICMxOTM5KS5cbiAgICAgIC8vIFRoYXQncyBwcm9iYWJseSBva2F5OyB3ZSBkb24ndCBzdXBwb3J0IGl0IGp1c3QgYXMgd2UgZG9uJ3Qgc3VwcG9ydFxuICAgICAgLy8gbWl4aW5nIFJlYWN0IHdpdGggbm9uLVJlYWN0LlxuICAgICAgdmFyIG90aGVySUQgPSBSZWFjdE1vdW50LmdldElEKG90aGVyTm9kZSk7XG4gICAgICAhb3RoZXJJRCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdERPTUlucHV0OiBNaXhpbmcgUmVhY3QgYW5kIG5vbi1SZWFjdCByYWRpbyBpbnB1dHMgd2l0aCB0aGUgJyArICdzYW1lIGBuYW1lYCBpcyBub3Qgc3VwcG9ydGVkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciBvdGhlckluc3RhbmNlID0gaW5zdGFuY2VzQnlSZWFjdElEW290aGVySURdO1xuICAgICAgIW90aGVySW5zdGFuY2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RET01JbnB1dDogVW5rbm93biByYWRpbyBidXR0b24gSUQgJXMuJywgb3RoZXJJRCkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgLy8gSWYgdGhpcyBpcyBhIGNvbnRyb2xsZWQgcmFkaW8gYnV0dG9uIGdyb3VwLCBmb3JjaW5nIHRoZSBpbnB1dCB0aGF0XG4gICAgICAvLyB3YXMgcHJldmlvdXNseSBjaGVja2VkIHRvIHVwZGF0ZSB3aWxsIGNhdXNlIGl0IHRvIGJlIGNvbWUgcmUtY2hlY2tlZFxuICAgICAgLy8gYXMgYXBwcm9wcmlhdGUuXG4gICAgICBSZWFjdFVwZGF0ZXMuYXNhcChmb3JjZVVwZGF0ZUlmTW91bnRlZCwgb3RoZXJJbnN0YW5jZSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NSW5wdXQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01JbnB1dC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBMaW5rZWRWYWx1ZVV0aWxzXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlcycpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBoYXNSZWFkT25seVZhbHVlID0ge1xuICAnYnV0dG9uJzogdHJ1ZSxcbiAgJ2NoZWNrYm94JzogdHJ1ZSxcbiAgJ2ltYWdlJzogdHJ1ZSxcbiAgJ2hpZGRlbic6IHRydWUsXG4gICdyYWRpbyc6IHRydWUsXG4gICdyZXNldCc6IHRydWUsXG4gICdzdWJtaXQnOiB0cnVlXG59O1xuXG5mdW5jdGlvbiBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKSB7XG4gICEoaW5wdXRQcm9wcy5jaGVja2VkTGluayA9PSBudWxsIHx8IGlucHV0UHJvcHMudmFsdWVMaW5rID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0Nhbm5vdCBwcm92aWRlIGEgY2hlY2tlZExpbmsgYW5kIGEgdmFsdWVMaW5rLiBJZiB5b3Ugd2FudCB0byB1c2UgJyArICdjaGVja2VkTGluaywgeW91IHByb2JhYmx5IGRvblxcJ3Qgd2FudCB0byB1c2UgdmFsdWVMaW5rIGFuZCB2aWNlIHZlcnNhLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIF9hc3NlcnRWYWx1ZUxpbmsoaW5wdXRQcm9wcykge1xuICBfYXNzZXJ0U2luZ2xlTGluayhpbnB1dFByb3BzKTtcbiAgIShpbnB1dFByb3BzLnZhbHVlID09IG51bGwgJiYgaW5wdXRQcm9wcy5vbkNoYW5nZSA9PSBudWxsKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdDYW5ub3QgcHJvdmlkZSBhIHZhbHVlTGluayBhbmQgYSB2YWx1ZSBvciBvbkNoYW5nZSBldmVudC4gSWYgeW91IHdhbnQgJyArICd0byB1c2UgdmFsdWUgb3Igb25DaGFuZ2UsIHlvdSBwcm9iYWJseSBkb25cXCd0IHdhbnQgdG8gdXNlIHZhbHVlTGluay4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIF9hc3NlcnRDaGVja2VkTGluayhpbnB1dFByb3BzKSB7XG4gIF9hc3NlcnRTaW5nbGVMaW5rKGlucHV0UHJvcHMpO1xuICAhKGlucHV0UHJvcHMuY2hlY2tlZCA9PSBudWxsICYmIGlucHV0UHJvcHMub25DaGFuZ2UgPT0gbnVsbCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnQ2Fubm90IHByb3ZpZGUgYSBjaGVja2VkTGluayBhbmQgYSBjaGVja2VkIHByb3BlcnR5IG9yIG9uQ2hhbmdlIGV2ZW50LiAnICsgJ0lmIHlvdSB3YW50IHRvIHVzZSBjaGVja2VkIG9yIG9uQ2hhbmdlLCB5b3UgcHJvYmFibHkgZG9uXFwndCB3YW50IHRvICcgKyAndXNlIGNoZWNrZWRMaW5rJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xufVxuXG52YXIgcHJvcFR5cGVzID0ge1xuICB2YWx1ZTogZnVuY3Rpb24gKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICAgIGlmICghcHJvcHNbcHJvcE5hbWVdIHx8IGhhc1JlYWRPbmx5VmFsdWVbcHJvcHMudHlwZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgdmFsdWVgIHByb3AgdG8gYSBmb3JtIGZpZWxkIHdpdGhvdXQgYW4gJyArICdgb25DaGFuZ2VgIGhhbmRsZXIuIFRoaXMgd2lsbCByZW5kZXIgYSByZWFkLW9ubHkgZmllbGQuIElmICcgKyAndGhlIGZpZWxkIHNob3VsZCBiZSBtdXRhYmxlIHVzZSBgZGVmYXVsdFZhbHVlYC4gT3RoZXJ3aXNlLCAnICsgJ3NldCBlaXRoZXIgYG9uQ2hhbmdlYCBvciBgcmVhZE9ubHlgLicpO1xuICB9LFxuICBjaGVja2VkOiBmdW5jdGlvbiAocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAgaWYgKCFwcm9wc1twcm9wTmFtZV0gfHwgcHJvcHMub25DaGFuZ2UgfHwgcHJvcHMucmVhZE9ubHkgfHwgcHJvcHMuZGlzYWJsZWQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEVycm9yKCdZb3UgcHJvdmlkZWQgYSBgY2hlY2tlZGAgcHJvcCB0byBhIGZvcm0gZmllbGQgd2l0aG91dCBhbiAnICsgJ2BvbkNoYW5nZWAgaGFuZGxlci4gVGhpcyB3aWxsIHJlbmRlciBhIHJlYWQtb25seSBmaWVsZC4gSWYgJyArICd0aGUgZmllbGQgc2hvdWxkIGJlIG11dGFibGUgdXNlIGBkZWZhdWx0Q2hlY2tlZGAuIE90aGVyd2lzZSwgJyArICdzZXQgZWl0aGVyIGBvbkNoYW5nZWAgb3IgYHJlYWRPbmx5YC4nKTtcbiAgfSxcbiAgb25DaGFuZ2U6IFJlYWN0UHJvcFR5cGVzLmZ1bmNcbn07XG5cbnZhciBsb2dnZWRUeXBlRmFpbHVyZXMgPSB7fTtcbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG4vKipcbiAqIFByb3ZpZGUgYSBsaW5rZWQgYHZhbHVlYCBhdHRyaWJ1dGUgZm9yIGNvbnRyb2xsZWQgZm9ybXMuIFlvdSBzaG91bGQgbm90IHVzZVxuICogdGhpcyBvdXRzaWRlIG9mIHRoZSBSZWFjdERPTSBjb250cm9sbGVkIGZvcm0gY29tcG9uZW50cy5cbiAqL1xudmFyIExpbmtlZFZhbHVlVXRpbHMgPSB7XG4gIGNoZWNrUHJvcFR5cGVzOiBmdW5jdGlvbiAodGFnTmFtZSwgcHJvcHMsIG93bmVyKSB7XG4gICAgZm9yICh2YXIgcHJvcE5hbWUgaW4gcHJvcFR5cGVzKSB7XG4gICAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3IgPSBwcm9wVHlwZXNbcHJvcE5hbWVdKHByb3BzLCBwcm9wTmFtZSwgdGFnTmFtZSwgUmVhY3RQcm9wVHlwZUxvY2F0aW9ucy5wcm9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcik7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRmFpbGVkIGZvcm0gcHJvcFR5cGU6ICVzJXMnLCBlcnJvci5tZXNzYWdlLCBhZGRlbmR1bSkgOiB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge29iamVjdH0gaW5wdXRQcm9wcyBQcm9wcyBmb3IgZm9ybSBjb21wb25lbnRcbiAgICogQHJldHVybiB7Kn0gY3VycmVudCB2YWx1ZSBvZiB0aGUgaW5wdXQgZWl0aGVyIGZyb20gdmFsdWUgcHJvcCBvciBsaW5rLlxuICAgKi9cbiAgZ2V0VmFsdWU6IGZ1bmN0aW9uIChpbnB1dFByb3BzKSB7XG4gICAgaWYgKGlucHV0UHJvcHMudmFsdWVMaW5rKSB7XG4gICAgICBfYXNzZXJ0VmFsdWVMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMudmFsdWVMaW5rLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXRQcm9wcy52YWx1ZTtcbiAgfSxcblxuICAvKipcbiAgICogQHBhcmFtIHtvYmplY3R9IGlucHV0UHJvcHMgUHJvcHMgZm9yIGZvcm0gY29tcG9uZW50XG4gICAqIEByZXR1cm4geyp9IGN1cnJlbnQgY2hlY2tlZCBzdGF0dXMgb2YgdGhlIGlucHV0IGVpdGhlciBmcm9tIGNoZWNrZWQgcHJvcFxuICAgKiAgICAgICAgICAgICBvciBsaW5rLlxuICAgKi9cbiAgZ2V0Q2hlY2tlZDogZnVuY3Rpb24gKGlucHV0UHJvcHMpIHtcbiAgICBpZiAoaW5wdXRQcm9wcy5jaGVja2VkTGluaykge1xuICAgICAgX2Fzc2VydENoZWNrZWRMaW5rKGlucHV0UHJvcHMpO1xuICAgICAgcmV0dXJuIGlucHV0UHJvcHMuY2hlY2tlZExpbmsudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBpbnB1dFByb3BzLmNoZWNrZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBpbnB1dFByb3BzIFByb3BzIGZvciBmb3JtIGNvbXBvbmVudFxuICAgKiBAcGFyYW0ge1N5bnRoZXRpY0V2ZW50fSBldmVudCBjaGFuZ2UgZXZlbnQgdG8gaGFuZGxlXG4gICAqL1xuICBleGVjdXRlT25DaGFuZ2U6IGZ1bmN0aW9uIChpbnB1dFByb3BzLCBldmVudCkge1xuICAgIGlmIChpbnB1dFByb3BzLnZhbHVlTGluaykge1xuICAgICAgX2Fzc2VydFZhbHVlTGluayhpbnB1dFByb3BzKTtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLnZhbHVlTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIGlmIChpbnB1dFByb3BzLmNoZWNrZWRMaW5rKSB7XG4gICAgICBfYXNzZXJ0Q2hlY2tlZExpbmsoaW5wdXRQcm9wcyk7XG4gICAgICByZXR1cm4gaW5wdXRQcm9wcy5jaGVja2VkTGluay5yZXF1ZXN0Q2hhbmdlKGV2ZW50LnRhcmdldC5jaGVja2VkKTtcbiAgICB9IGVsc2UgaWYgKGlucHV0UHJvcHMub25DaGFuZ2UpIHtcbiAgICAgIHJldHVybiBpbnB1dFByb3BzLm9uQ2hhbmdlLmNhbGwodW5kZWZpbmVkLCBldmVudCk7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IExpbmtlZFZhbHVlVXRpbHM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvTGlua2VkVmFsdWVVdGlscy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFByb3BUeXBlc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGdldEl0ZXJhdG9yRm4gPSByZXF1aXJlKCcuL2dldEl0ZXJhdG9yRm4nKTtcblxuLyoqXG4gKiBDb2xsZWN0aW9uIG9mIG1ldGhvZHMgdGhhdCBhbGxvdyBkZWNsYXJhdGlvbiBhbmQgdmFsaWRhdGlvbiBvZiBwcm9wcyB0aGF0IGFyZVxuICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAqXG4gKiAgIHZhciBQcm9wcyA9IHJlcXVpcmUoJ1JlYWN0UHJvcFR5cGVzJyk7XG4gKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gKiAgICAgcHJvcFR5cGVzOiB7XG4gKiAgICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgcHJvcCBuYW1lZCBcImRlc2NyaXB0aW9uXCIuXG4gKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICpcbiAqICAgICAgIC8vIEEgcmVxdWlyZWQgZW51bSBwcm9wIG5hbWVkIFwiY2F0ZWdvcnlcIi5cbiAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAqXG4gKiAgICAgICAvLyBBIHByb3AgbmFtZWQgXCJkaWFsb2dcIiB0aGF0IHJlcXVpcmVzIGFuIGluc3RhbmNlIG9mIERpYWxvZy5cbiAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAqICAgICB9LFxuICogICAgIHJlbmRlcjogZnVuY3Rpb24oKSB7IC4uLiB9XG4gKiAgIH0pO1xuICpcbiAqIEEgbW9yZSBmb3JtYWwgc3BlY2lmaWNhdGlvbiBvZiBob3cgdGhlc2UgbWV0aG9kcyBhcmUgdXNlZDpcbiAqXG4gKiAgIHR5cGUgOj0gYXJyYXl8Ym9vbHxmdW5jfG9iamVjdHxudW1iZXJ8c3RyaW5nfG9uZU9mKFsuLi5dKXxpbnN0YW5jZU9mKC4uLilcbiAqICAgZGVjbCA6PSBSZWFjdFByb3BUeXBlcy57dHlwZX0oLmlzUmVxdWlyZWQpP1xuICpcbiAqIEVhY2ggYW5kIGV2ZXJ5IGRlY2xhcmF0aW9uIHByb2R1Y2VzIGEgZnVuY3Rpb24gd2l0aCB0aGUgc2FtZSBzaWduYXR1cmUuIFRoaXNcbiAqIGFsbG93cyB0aGUgY3JlYXRpb24gb2YgY3VzdG9tIHZhbGlkYXRpb24gZnVuY3Rpb25zLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiAgdmFyIE15TGluayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgIHByb3BUeXBlczoge1xuICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gKiAgICAgIGhyZWY6IGZ1bmN0aW9uKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICogICAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gKiAgICAgICAgICAgICEocHJvcFZhbHVlIGluc3RhbmNlb2YgVVJJKSkge1xuICogICAgICAgICAgcmV0dXJuIG5ldyBFcnJvcihcbiAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAqICAgICAgICAgICAgY29tcG9uZW50TmFtZVxuICogICAgICAgICAgKTtcbiAqICAgICAgICB9XG4gKiAgICAgIH1cbiAqICAgIH0sXG4gKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAqICB9KTtcbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG52YXIgQU5PTllNT1VTID0gJzw8YW5vbnltb3VzPj4nO1xuXG52YXIgUmVhY3RQcm9wVHlwZXMgPSB7XG4gIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgYm9vbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Jvb2xlYW4nKSxcbiAgZnVuYzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ2Z1bmN0aW9uJyksXG4gIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICBvYmplY3Q6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdvYmplY3QnKSxcbiAgc3RyaW5nOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignc3RyaW5nJyksXG5cbiAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICBhcnJheU9mOiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIsXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnRUeXBlQ2hlY2tlcigpLFxuICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICBub2RlOiBjcmVhdGVOb2RlQ2hlY2tlcigpLFxuICBvYmplY3RPZjogY3JlYXRlT2JqZWN0T2ZUeXBlQ2hlY2tlcixcbiAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgb25lT2ZUeXBlOiBjcmVhdGVVbmlvblR5cGVDaGVja2VyLFxuICBzaGFwZTogY3JlYXRlU2hhcGVUeXBlQ2hlY2tlclxufTtcblxuZnVuY3Rpb24gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpIHtcbiAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnROYW1lIHx8IEFOT05ZTU9VUztcbiAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG4gICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PSBudWxsKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBFcnJvcignUmVxdWlyZWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCB3YXMgbm90IHNwZWNpZmllZCBpbiAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgfVxuICB9XG5cbiAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gIGNoYWluZWRDaGVja1R5cGUuaXNSZXF1aXJlZCA9IGNoZWNrVHlwZS5iaW5kKG51bGwsIHRydWUpO1xuXG4gIHJldHVybiBjaGFpbmVkQ2hlY2tUeXBlO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcihleHBlY3RlZFR5cGUpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgLy8gYHByb3BWYWx1ZWAgYmVpbmcgaW5zdGFuY2Ugb2YsIHNheSwgZGF0ZS9yZWdleHAsIHBhc3MgdGhlICdvYmplY3QnXG4gICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgIC8vICdvZiB0eXBlIGBvYmplY3RgJy5cbiAgICAgIHZhciBwcmVjaXNlVHlwZSA9IGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSk7XG5cbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJlY2lzZVR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgJykgKyAoJ2AnICsgZXhwZWN0ZWRUeXBlICsgJ2AuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpIHtcbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnMobnVsbCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVBcnJheU9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScpO1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGlmICghUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agc3VwcGxpZWQgdG8gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGEgc2luZ2xlIFJlYWN0RWxlbWVudC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlVHlwZUNoZWNrZXIoZXhwZWN0ZWRDbGFzcykge1xuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICBpZiAoIShwcm9wc1twcm9wTmFtZV0gaW5zdGFuY2VvZiBleHBlY3RlZENsYXNzKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICB2YXIgYWN0dWFsQ2xhc3NOYW1lID0gZ2V0Q2xhc3NOYW1lKHByb3BzW3Byb3BOYW1lXSk7XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIGFjdHVhbENsYXNzTmFtZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCAnKSArICgnaW5zdGFuY2Ugb2YgYCcgKyBleHBlY3RlZENsYXNzTmFtZSArICdgLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRW51bVR5cGVDaGVja2VyKGV4cGVjdGVkVmFsdWVzKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShleHBlY3RlZFZhbHVlcykpIHtcbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIoZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZiwgZXhwZWN0ZWQgYW4gaW5zdGFuY2Ugb2YgYXJyYXkuJyk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgPT09IGV4cGVjdGVkVmFsdWVzW2ldKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVPYmplY3RPZlR5cGVDaGVja2VyKHR5cGVDaGVja2VyKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICBpZiAocHJvcFR5cGUgIT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgbG9jYXRpb25OYW1lID0gUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dO1xuICAgICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhbiBvYmplY3QuJykpO1xuICAgIH1cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcFZhbHVlKSB7XG4gICAgICBpZiAocHJvcFZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXkpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGFycmF5T2ZUeXBlQ2hlY2tlcnMpKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLCBleHBlY3RlZCBhbiBpbnN0YW5jZSBvZiBhcnJheS4nKTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKGNoZWNrZXIocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgcmV0dXJuIG5ldyBFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb25OYW1lICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIHN1cHBsaWVkIHRvICcgKyAoJ2AnICsgY29tcG9uZW50TmFtZSArICdgLicpKTtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgaWYgKCFpc05vZGUocHJvcHNbcHJvcE5hbWVdKSkge1xuICAgICAgdmFyIGxvY2F0aW9uTmFtZSA9IFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXTtcbiAgICAgIHJldHVybiBuZXcgRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uTmFtZSArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHZhciBsb2NhdGlvbk5hbWUgPSBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl07XG4gICAgICByZXR1cm4gbmV3IEVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbk5hbWUgKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSBgJyArIHByb3BUeXBlICsgJ2AgJyArICgnc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGBvYmplY3RgLicpKTtcbiAgICB9XG4gICAgZm9yICh2YXIga2V5IGluIHNoYXBlVHlwZXMpIHtcbiAgICAgIHZhciBjaGVja2VyID0gc2hhcGVUeXBlc1trZXldO1xuICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSk7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xufVxuXG5mdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gIHN3aXRjaCAodHlwZW9mIHByb3BWYWx1ZSkge1xuICAgIGNhc2UgJ251bWJlcic6XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICBjYXNlICd1bmRlZmluZWQnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gIXByb3BWYWx1ZTtcbiAgICBjYXNlICdvYmplY3QnOlxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICByZXR1cm4gcHJvcFZhbHVlLmV2ZXJ5KGlzTm9kZSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IFJlYWN0RWxlbWVudC5pc1ZhbGlkRWxlbWVudChwcm9wVmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4ocHJvcFZhbHVlKTtcbiAgICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICB2YXIgc3RlcDtcbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IHByb3BWYWx1ZS5lbnRyaWVzKSB7XG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKCFpc05vZGUoc3RlcC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgIGlmICghaXNOb2RlKGVudHJ5WzFdKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbi8vIEVxdWl2YWxlbnQgb2YgYHR5cGVvZmAgYnV0IHdpdGggc3BlY2lhbCBoYW5kbGluZyBmb3IgYXJyYXkgYW5kIHJlZ2V4cC5cbmZ1bmN0aW9uIGdldFByb3BUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICBpZiAoQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgcmV0dXJuICdhcnJheSc7XG4gIH1cbiAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgIC8vIE9sZCB3ZWJraXRzIChhdCBsZWFzdCB1bnRpbCBBbmRyb2lkIDQuMCkgcmV0dXJuICdmdW5jdGlvbicgcmF0aGVyIHRoYW5cbiAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAvLyBwYXNzZXMgUHJvcFR5cGVzLm9iamVjdC5cbiAgICByZXR1cm4gJ29iamVjdCc7XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBUaGlzIGhhbmRsZXMgbW9yZSB0eXBlcyB0aGFuIGBnZXRQcm9wVHlwZWAuIE9ubHkgdXNlZCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4vLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbmZ1bmN0aW9uIGdldFByZWNpc2VUeXBlKHByb3BWYWx1ZSkge1xuICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICBpZiAocHJvcFR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiAncmVnZXhwJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHByb3BUeXBlO1xufVxuXG4vLyBSZXR1cm5zIGNsYXNzIG5hbWUgb2YgdGhlIG9iamVjdCwgaWYgYW55LlxuZnVuY3Rpb24gZ2V0Q2xhc3NOYW1lKHByb3BWYWx1ZSkge1xuICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICByZXR1cm4gJzw8YW5vbnltb3VzPj4nO1xuICB9XG4gIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFByb3BUeXBlcy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRJdGVyYXRvckZuXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZ2xvYmFsIFN5bWJvbCAqL1xudmFyIElURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InOyAvLyBCZWZvcmUgU3ltYm9sIHNwZWMuXG5cbi8qKlxuICogUmV0dXJucyB0aGUgaXRlcmF0b3IgbWV0aG9kIGZ1bmN0aW9uIGNvbnRhaW5lZCBvbiB0aGUgaXRlcmFibGUgb2JqZWN0LlxuICpcbiAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICpcbiAqICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obXlJdGVyYWJsZSk7XG4gKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAqICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChteUl0ZXJhYmxlKTtcbiAqICAgICAgIC4uLlxuICogICAgIH1cbiAqXG4gKiBAcGFyYW0gez9vYmplY3R9IG1heWJlSXRlcmFibGVcbiAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAqL1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBpdGVyYXRvckZuO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0SXRlcmF0b3JGbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9nZXRJdGVyYXRvckZuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NT3B0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDaGlsZHJlbiA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZHJlbicpO1xudmFyIFJlYWN0RE9NU2VsZWN0ID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdCcpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIHZhbHVlQ29udGV4dEtleSA9IFJlYWN0RE9NU2VsZWN0LnZhbHVlQ29udGV4dEtleTtcblxuLyoqXG4gKiBJbXBsZW1lbnRzIGFuIDxvcHRpb24+IG5hdGl2ZSBjb21wb25lbnQgdGhhdCB3YXJucyB3aGVuIGBzZWxlY3RlZGAgaXMgc2V0LlxuICovXG52YXIgUmVhY3RET01PcHRpb24gPSB7XG4gIG1vdW50V3JhcHBlcjogZnVuY3Rpb24gKGluc3QsIHByb3BzLCBjb250ZXh0KSB7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGBzZWxlY3RlZGAgaW4gPG9wdGlvbj4uXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHByb3BzLnNlbGVjdGVkID09IG51bGwsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgb24gPHNlbGVjdD4gaW5zdGVhZCBvZiAnICsgJ3NldHRpbmcgYHNlbGVjdGVkYCBvbiA8b3B0aW9uPi4nKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBMb29rIHVwIHdoZXRoZXIgdGhpcyBvcHRpb24gaXMgJ3NlbGVjdGVkJyB2aWEgY29udGV4dFxuICAgIHZhciBzZWxlY3RWYWx1ZSA9IGNvbnRleHRbdmFsdWVDb250ZXh0S2V5XTtcblxuICAgIC8vIElmIGNvbnRleHQga2V5IGlzIG51bGwgKGUuZy4sIG5vIHNwZWNpZmllZCB2YWx1ZSBvciBhZnRlciBpbml0aWFsIG1vdW50KVxuICAgIC8vIG9yIG1pc3NpbmcgKGUuZy4sIGZvciA8ZGF0YWxpc3Q+KSwgd2UgZG9uJ3QgY2hhbmdlIHByb3BzLnNlbGVjdGVkXG4gICAgdmFyIHNlbGVjdGVkID0gbnVsbDtcbiAgICBpZiAoc2VsZWN0VmFsdWUgIT0gbnVsbCkge1xuICAgICAgc2VsZWN0ZWQgPSBmYWxzZTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdFZhbHVlKSkge1xuICAgICAgICAvLyBtdWx0aXBsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGVjdFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgaWYgKCcnICsgc2VsZWN0VmFsdWVbaV0gPT09ICcnICsgcHJvcHMudmFsdWUpIHtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VsZWN0ZWQgPSAnJyArIHNlbGVjdFZhbHVlID09PSAnJyArIHByb3BzLnZhbHVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZSA9IHsgc2VsZWN0ZWQ6IHNlbGVjdGVkIH07XG4gIH0sXG5cbiAgZ2V0TmF0aXZlUHJvcHM6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIHZhciBuYXRpdmVQcm9wcyA9IGFzc2lnbih7IHNlbGVjdGVkOiB1bmRlZmluZWQsIGNoaWxkcmVuOiB1bmRlZmluZWQgfSwgcHJvcHMpO1xuXG4gICAgLy8gUmVhZCBzdGF0ZSBvbmx5IGZyb20gaW5pdGlhbCBtb3VudCBiZWNhdXNlIDxzZWxlY3Q+IHVwZGF0ZXMgdmFsdWVcbiAgICAvLyBtYW51YWxseTsgd2UgbmVlZCB0aGUgaW5pdGlhbCBzdGF0ZSBvbmx5IGZvciBzZXJ2ZXIgcmVuZGVyaW5nXG4gICAgaWYgKGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZCAhPSBudWxsKSB7XG4gICAgICBuYXRpdmVQcm9wcy5zZWxlY3RlZCA9IGluc3QuX3dyYXBwZXJTdGF0ZS5zZWxlY3RlZDtcbiAgICB9XG5cbiAgICB2YXIgY29udGVudCA9ICcnO1xuXG4gICAgLy8gRmxhdHRlbiBjaGlsZHJlbiBhbmQgd2FybiBpZiB0aGV5IGFyZW4ndCBzdHJpbmdzIG9yIG51bWJlcnM7XG4gICAgLy8gaW52YWxpZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICBSZWFjdENoaWxkcmVuLmZvckVhY2gocHJvcHMuY2hpbGRyZW4sIGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIGNoaWxkID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb250ZW50ICs9IGNoaWxkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdPbmx5IHN0cmluZ3MgYW5kIG51bWJlcnMgYXJlIHN1cHBvcnRlZCBhcyA8b3B0aW9uPiBjaGlsZHJlbi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGlmIChjb250ZW50KSB7XG4gICAgICBuYXRpdmVQcm9wcy5jaGlsZHJlbiA9IGNvbnRlbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdGl2ZVByb3BzO1xuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01PcHRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01PcHRpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RDaGlsZHJlblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFBvb2xlZENsYXNzID0gcmVxdWlyZSgnLi9Qb29sZWRDbGFzcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIHRyYXZlcnNlQWxsQ2hpbGRyZW4gPSByZXF1aXJlKCcuL3RyYXZlcnNlQWxsQ2hpbGRyZW4nKTtcblxudmFyIHR3b0FyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MudHdvQXJndW1lbnRQb29sZXI7XG52YXIgZm91ckFyZ3VtZW50UG9vbGVyID0gUG9vbGVkQ2xhc3MuZm91ckFyZ3VtZW50UG9vbGVyO1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXggPSAvXFwvKD8hXFwvKS9nO1xuZnVuY3Rpb24gZXNjYXBlVXNlclByb3ZpZGVkS2V5KHRleHQpIHtcbiAgcmV0dXJuICgnJyArIHRleHQpLnJlcGxhY2UodXNlclByb3ZpZGVkS2V5RXNjYXBlUmVnZXgsICcvLycpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogdHJhdmVyc2FsLiBBbGxvd3MgYXZvaWRpbmcgYmluZGluZyBjYWxsYmFja3MuXG4gKlxuICogQGNvbnN0cnVjdG9yIEZvckVhY2hCb29rS2VlcGluZ1xuICogQHBhcmFtIHshZnVuY3Rpb259IGZvckVhY2hGdW5jdGlvbiBGdW5jdGlvbiB0byBwZXJmb3JtIHRyYXZlcnNhbCB3aXRoLlxuICogQHBhcmFtIHs/Kn0gZm9yRWFjaENvbnRleHQgQ29udGV4dCB0byBwZXJmb3JtIGNvbnRleHQgd2l0aC5cbiAqL1xuZnVuY3Rpb24gRm9yRWFjaEJvb2tLZWVwaW5nKGZvckVhY2hGdW5jdGlvbiwgZm9yRWFjaENvbnRleHQpIHtcbiAgdGhpcy5mdW5jID0gZm9yRWFjaEZ1bmN0aW9uO1xuICB0aGlzLmNvbnRleHQgPSBmb3JFYWNoQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5Gb3JFYWNoQm9va0tlZXBpbmcucHJvdG90eXBlLmRlc3RydWN0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhGb3JFYWNoQm9va0tlZXBpbmcsIHR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkKGJvb2tLZWVwaW5nLCBjaGlsZCwgbmFtZSkge1xuICB2YXIgZnVuYyA9IGJvb2tLZWVwaW5nLmZ1bmM7XG4gIHZhciBjb250ZXh0ID0gYm9va0tlZXBpbmcuY29udGV4dDtcblxuICBmdW5jLmNhbGwoY29udGV4dCwgY2hpbGQsIGJvb2tLZWVwaW5nLmNvdW50KyspO1xufVxuXG4vKipcbiAqIEl0ZXJhdGVzIHRocm91Z2ggY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBmb3JFYWNoRnVuYyhjaGlsZCwgaW5kZXgpIHdpbGwgYmUgY2FsbGVkIGZvciBlYWNoXG4gKiBsZWFmIGNoaWxkLlxuICpcbiAqIEBwYXJhbSB7Pyp9IGNoaWxkcmVuIENoaWxkcmVuIHRyZWUgY29udGFpbmVyLlxuICogQHBhcmFtIHtmdW5jdGlvbigqLCBpbnQpfSBmb3JFYWNoRnVuY1xuICogQHBhcmFtIHsqfSBmb3JFYWNoQ29udGV4dCBDb250ZXh0IGZvciBmb3JFYWNoQ29udGV4dC5cbiAqL1xuZnVuY3Rpb24gZm9yRWFjaENoaWxkcmVuKGNoaWxkcmVuLCBmb3JFYWNoRnVuYywgZm9yRWFjaENvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gY2hpbGRyZW47XG4gIH1cbiAgdmFyIHRyYXZlcnNlQ29udGV4dCA9IEZvckVhY2hCb29rS2VlcGluZy5nZXRQb29sZWQoZm9yRWFjaEZ1bmMsIGZvckVhY2hDb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZm9yRWFjaFNpbmdsZUNoaWxkLCB0cmF2ZXJzZUNvbnRleHQpO1xuICBGb3JFYWNoQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIFBvb2xlZENsYXNzIHJlcHJlc2VudGluZyB0aGUgYm9va2tlZXBpbmcgYXNzb2NpYXRlZCB3aXRoIHBlcmZvcm1pbmcgYSBjaGlsZFxuICogbWFwcGluZy4gQWxsb3dzIGF2b2lkaW5nIGJpbmRpbmcgY2FsbGJhY2tzLlxuICpcbiAqIEBjb25zdHJ1Y3RvciBNYXBCb29rS2VlcGluZ1xuICogQHBhcmFtIHshKn0gbWFwUmVzdWx0IE9iamVjdCBjb250YWluaW5nIHRoZSBvcmRlcmVkIG1hcCBvZiByZXN1bHRzLlxuICogQHBhcmFtIHshZnVuY3Rpb259IG1hcEZ1bmN0aW9uIEZ1bmN0aW9uIHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICogQHBhcmFtIHs/Kn0gbWFwQ29udGV4dCBDb250ZXh0IHRvIHBlcmZvcm0gbWFwcGluZyB3aXRoLlxuICovXG5mdW5jdGlvbiBNYXBCb29rS2VlcGluZyhtYXBSZXN1bHQsIGtleVByZWZpeCwgbWFwRnVuY3Rpb24sIG1hcENvbnRleHQpIHtcbiAgdGhpcy5yZXN1bHQgPSBtYXBSZXN1bHQ7XG4gIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICB0aGlzLmZ1bmMgPSBtYXBGdW5jdGlvbjtcbiAgdGhpcy5jb250ZXh0ID0gbWFwQ29udGV4dDtcbiAgdGhpcy5jb3VudCA9IDA7XG59XG5NYXBCb29rS2VlcGluZy5wcm90b3R5cGUuZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5yZXN1bHQgPSBudWxsO1xuICB0aGlzLmtleVByZWZpeCA9IG51bGw7XG4gIHRoaXMuZnVuYyA9IG51bGw7XG4gIHRoaXMuY29udGV4dCA9IG51bGw7XG4gIHRoaXMuY291bnQgPSAwO1xufTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhNYXBCb29rS2VlcGluZywgZm91ckFyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dChib29rS2VlcGluZywgY2hpbGQsIGNoaWxkS2V5KSB7XG4gIHZhciByZXN1bHQgPSBib29rS2VlcGluZy5yZXN1bHQ7XG4gIHZhciBrZXlQcmVmaXggPSBib29rS2VlcGluZy5rZXlQcmVmaXg7XG4gIHZhciBmdW5jID0gYm9va0tlZXBpbmcuZnVuYztcbiAgdmFyIGNvbnRleHQgPSBib29rS2VlcGluZy5jb250ZXh0O1xuXG4gIHZhciBtYXBwZWRDaGlsZCA9IGZ1bmMuY2FsbChjb250ZXh0LCBjaGlsZCwgYm9va0tlZXBpbmcuY291bnQrKyk7XG4gIGlmIChBcnJheS5pc0FycmF5KG1hcHBlZENoaWxkKSkge1xuICAgIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwobWFwcGVkQ2hpbGQsIHJlc3VsdCwgY2hpbGRLZXksIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNBcmd1bWVudCk7XG4gIH0gZWxzZSBpZiAobWFwcGVkQ2hpbGQgIT0gbnVsbCkge1xuICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobWFwcGVkQ2hpbGQpKSB7XG4gICAgICBtYXBwZWRDaGlsZCA9IFJlYWN0RWxlbWVudC5jbG9uZUFuZFJlcGxhY2VLZXkobWFwcGVkQ2hpbGQsXG4gICAgICAvLyBLZWVwIGJvdGggdGhlIChtYXBwZWQpIGFuZCBvbGQga2V5cyBpZiB0aGV5IGRpZmZlciwganVzdCBhc1xuICAgICAgLy8gdHJhdmVyc2VBbGxDaGlsZHJlbiB1c2VkIHRvIGRvIGZvciBvYmplY3RzIGFzIGNoaWxkcmVuXG4gICAgICBrZXlQcmVmaXggKyAobWFwcGVkQ2hpbGQgIT09IGNoaWxkID8gZXNjYXBlVXNlclByb3ZpZGVkS2V5KG1hcHBlZENoaWxkLmtleSB8fCAnJykgKyAnLycgOiAnJykgKyBjaGlsZEtleSk7XG4gICAgfVxuICAgIHJlc3VsdC5wdXNoKG1hcHBlZENoaWxkKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXBJbnRvV2l0aEtleVByZWZpeEludGVybmFsKGNoaWxkcmVuLCBhcnJheSwgcHJlZml4LCBmdW5jLCBjb250ZXh0KSB7XG4gIHZhciBlc2NhcGVkUHJlZml4ID0gJyc7XG4gIGlmIChwcmVmaXggIT0gbnVsbCkge1xuICAgIGVzY2FwZWRQcmVmaXggPSBlc2NhcGVVc2VyUHJvdmlkZWRLZXkocHJlZml4KSArICcvJztcbiAgfVxuICB2YXIgdHJhdmVyc2VDb250ZXh0ID0gTWFwQm9va0tlZXBpbmcuZ2V0UG9vbGVkKGFycmF5LCBlc2NhcGVkUHJlZml4LCBmdW5jLCBjb250ZXh0KTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgbWFwU2luZ2xlQ2hpbGRJbnRvQ29udGV4dCwgdHJhdmVyc2VDb250ZXh0KTtcbiAgTWFwQm9va0tlZXBpbmcucmVsZWFzZSh0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG4vKipcbiAqIE1hcHMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLlxuICpcbiAqIFRoZSBwcm92aWRlZCBtYXBGdW5jdGlvbihjaGlsZCwga2V5LCBpbmRleCkgd2lsbCBiZSBjYWxsZWQgZm9yIGVhY2hcbiAqIGxlYWYgY2hpbGQuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0ge2Z1bmN0aW9uKCosIGludCl9IGZ1bmMgVGhlIG1hcCBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBDb250ZXh0IGZvciBtYXBGdW5jdGlvbi5cbiAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IGNvbnRhaW5pbmcgdGhlIG9yZGVyZWQgbWFwIG9mIHJlc3VsdHMuXG4gKi9cbmZ1bmN0aW9uIG1hcENoaWxkcmVuKGNoaWxkcmVuLCBmdW5jLCBjb250ZXh0KSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSBbXTtcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbChjaGlsZHJlbiwgcmVzdWx0LCBudWxsLCBmdW5jLCBjb250ZXh0KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gZm9yRWFjaFNpbmdsZUNoaWxkRHVtbXkodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICByZXR1cm4gbnVsbDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIGNoaWxkcmVuIHRoYXQgYXJlIHR5cGljYWxseSBzcGVjaWZpZWQgYXNcbiAqIGBwcm9wcy5jaGlsZHJlbmAuXG4gKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgY2hpbGRyZW4uXG4gKi9cbmZ1bmN0aW9uIGNvdW50Q2hpbGRyZW4oY2hpbGRyZW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGZvckVhY2hTaW5nbGVDaGlsZER1bW15LCBudWxsKTtcbn1cblxuLyoqXG4gKiBGbGF0dGVuIGEgY2hpbGRyZW4gb2JqZWN0ICh0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmApIGFuZFxuICogcmV0dXJuIGFuIGFycmF5IHdpdGggYXBwcm9wcmlhdGVseSByZS1rZXllZCBjaGlsZHJlbi5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheShjaGlsZHJlbikge1xuICB2YXIgcmVzdWx0ID0gW107XG4gIG1hcEludG9XaXRoS2V5UHJlZml4SW50ZXJuYWwoY2hpbGRyZW4sIHJlc3VsdCwgbnVsbCwgZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc0FyZ3VtZW50KTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxudmFyIFJlYWN0Q2hpbGRyZW4gPSB7XG4gIGZvckVhY2g6IGZvckVhY2hDaGlsZHJlbixcbiAgbWFwOiBtYXBDaGlsZHJlbixcbiAgbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbDogbWFwSW50b1dpdGhLZXlQcmVmaXhJbnRlcm5hbCxcbiAgY291bnQ6IGNvdW50Q2hpbGRyZW4sXG4gIHRvQXJyYXk6IHRvQXJyYXlcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZHJlbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENoaWxkcmVuLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHRyYXZlcnNlQWxsQ2hpbGRyZW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEN1cnJlbnRPd25lciA9IHJlcXVpcmUoJy4vUmVhY3RDdXJyZW50T3duZXInKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xuXG52YXIgZ2V0SXRlcmF0b3JGbiA9IHJlcXVpcmUoJy4vZ2V0SXRlcmF0b3JGbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciBTRVBBUkFUT1IgPSBSZWFjdEluc3RhbmNlSGFuZGxlcy5TRVBBUkFUT1I7XG52YXIgU1VCU0VQQVJBVE9SID0gJzonO1xuXG4vKipcbiAqIFRPRE86IFRlc3QgdGhhdCBhIHNpbmdsZSBjaGlsZCBhbmQgYW4gYXJyYXkgd2l0aCBvbmUgaXRlbSBoYXZlIHRoZSBzYW1lIGtleVxuICogcGF0dGVybi5cbiAqL1xuXG52YXIgdXNlclByb3ZpZGVkS2V5RXNjYXBlckxvb2t1cCA9IHtcbiAgJz0nOiAnPTAnLFxuICAnLic6ICc9MScsXG4gICc6JzogJz0yJ1xufTtcblxudmFyIHVzZXJQcm92aWRlZEtleUVzY2FwZVJlZ2V4ID0gL1s9LjpdL2c7XG5cbnZhciBkaWRXYXJuQWJvdXRNYXBzID0gZmFsc2U7XG5cbmZ1bmN0aW9uIHVzZXJQcm92aWRlZEtleUVzY2FwZXIobWF0Y2gpIHtcbiAgcmV0dXJuIHVzZXJQcm92aWRlZEtleUVzY2FwZXJMb29rdXBbbWF0Y2hdO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGEga2V5IHN0cmluZyB0aGF0IGlkZW50aWZpZXMgYSBjb21wb25lbnQgd2l0aGluIGEgc2V0LlxuICpcbiAqIEBwYXJhbSB7Kn0gY29tcG9uZW50IEEgY29tcG9uZW50IHRoYXQgY291bGQgY29udGFpbiBhIG1hbnVhbCBrZXkuXG4gKiBAcGFyYW0ge251bWJlcn0gaW5kZXggSW5kZXggdGhhdCBpcyB1c2VkIGlmIGEgbWFudWFsIGtleSBpcyBub3QgcHJvdmlkZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudEtleShjb21wb25lbnQsIGluZGV4KSB7XG4gIGlmIChjb21wb25lbnQgJiYgY29tcG9uZW50LmtleSAhPSBudWxsKSB7XG4gICAgLy8gRXhwbGljaXQga2V5XG4gICAgcmV0dXJuIHdyYXBVc2VyUHJvdmlkZWRLZXkoY29tcG9uZW50LmtleSk7XG4gIH1cbiAgLy8gSW1wbGljaXQga2V5IGRldGVybWluZWQgYnkgdGhlIGluZGV4IGluIHRoZSBzZXRcbiAgcmV0dXJuIGluZGV4LnRvU3RyaW5nKDM2KTtcbn1cblxuLyoqXG4gKiBFc2NhcGUgYSBjb21wb25lbnQga2V5IHNvIHRoYXQgaXQgaXMgc2FmZSB0byB1c2UgaW4gYSByZWFjdGlkLlxuICpcbiAqIEBwYXJhbSB7Kn0gdGV4dCBDb21wb25lbnQga2V5IHRvIGJlIGVzY2FwZWQuXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEFuIGVzY2FwZWQgc3RyaW5nLlxuICovXG5mdW5jdGlvbiBlc2NhcGVVc2VyUHJvdmlkZWRLZXkodGV4dCkge1xuICByZXR1cm4gKCcnICsgdGV4dCkucmVwbGFjZSh1c2VyUHJvdmlkZWRLZXlFc2NhcGVSZWdleCwgdXNlclByb3ZpZGVkS2V5RXNjYXBlcik7XG59XG5cbi8qKlxuICogV3JhcCBhIGBrZXlgIHZhbHVlIGV4cGxpY2l0bHkgcHJvdmlkZWQgYnkgdGhlIHVzZXIgdG8gZGlzdGluZ3Vpc2ggaXQgZnJvbVxuICogaW1wbGljaXRseS1nZW5lcmF0ZWQga2V5cyBnZW5lcmF0ZWQgYnkgYSBjb21wb25lbnQncyBpbmRleCBpbiBpdHMgcGFyZW50LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVmFsdWUgb2YgYSB1c2VyLXByb3ZpZGVkIGBrZXlgIGF0dHJpYnV0ZVxuICogQHJldHVybiB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiB3cmFwVXNlclByb3ZpZGVkS2V5KGtleSkge1xuICByZXR1cm4gJyQnICsgZXNjYXBlVXNlclByb3ZpZGVkS2V5KGtleSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHs/Kn0gY2hpbGRyZW4gQ2hpbGRyZW4gdHJlZSBjb250YWluZXIuXG4gKiBAcGFyYW0geyFzdHJpbmd9IG5hbWVTb0ZhciBOYW1lIG9mIHRoZSBrZXkgcGF0aCBzbyBmYXIuXG4gKiBAcGFyYW0geyFmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgdG8gaW52b2tlIHdpdGggZWFjaCBjaGlsZCBmb3VuZC5cbiAqIEBwYXJhbSB7Pyp9IHRyYXZlcnNlQ29udGV4dCBVc2VkIHRvIHBhc3MgaW5mb3JtYXRpb24gdGhyb3VnaG91dCB0aGUgdHJhdmVyc2FsXG4gKiBwcm9jZXNzLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW5JbXBsKGNoaWxkcmVuLCBuYW1lU29GYXIsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgY2hpbGRyZW47XG5cbiAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGUgPT09ICdib29sZWFuJykge1xuICAgIC8vIEFsbCBvZiB0aGUgYWJvdmUgYXJlIHBlcmNlaXZlZCBhcyBudWxsLlxuICAgIGNoaWxkcmVuID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaGlsZHJlbiA9PT0gbnVsbCB8fCB0eXBlID09PSAnc3RyaW5nJyB8fCB0eXBlID09PSAnbnVtYmVyJyB8fCBSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGRyZW4pKSB7XG4gICAgY2FsbGJhY2sodHJhdmVyc2VDb250ZXh0LCBjaGlsZHJlbixcbiAgICAvLyBJZiBpdCdzIHRoZSBvbmx5IGNoaWxkLCB0cmVhdCB0aGUgbmFtZSBhcyBpZiBpdCB3YXMgd3JhcHBlZCBpbiBhbiBhcnJheVxuICAgIC8vIHNvIHRoYXQgaXQncyBjb25zaXN0ZW50IGlmIHRoZSBudW1iZXIgb2YgY2hpbGRyZW4gZ3Jvd3MuXG4gICAgbmFtZVNvRmFyID09PSAnJyA/IFNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZHJlbiwgMCkgOiBuYW1lU29GYXIpO1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIGNoaWxkO1xuICB2YXIgbmV4dE5hbWU7XG4gIHZhciBzdWJ0cmVlQ291bnQgPSAwOyAvLyBDb3VudCBvZiBjaGlsZHJlbiBmb3VuZCBpbiB0aGUgY3VycmVudCBzdWJ0cmVlLlxuICB2YXIgbmV4dE5hbWVQcmVmaXggPSBuYW1lU29GYXIgPT09ICcnID8gU0VQQVJBVE9SIDogbmFtZVNvRmFyICsgU1VCU0VQQVJBVE9SO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgICBuZXh0TmFtZSA9IG5leHROYW1lUHJlZml4ICsgZ2V0Q29tcG9uZW50S2V5KGNoaWxkLCBpKTtcbiAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4oY2hpbGRyZW4pO1xuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICB2YXIgaXRlcmF0b3IgPSBpdGVyYXRvckZuLmNhbGwoY2hpbGRyZW4pO1xuICAgICAgdmFyIHN0ZXA7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gY2hpbGRyZW4uZW50cmllcykge1xuICAgICAgICB2YXIgaWkgPSAwO1xuICAgICAgICB3aGlsZSAoIShzdGVwID0gaXRlcmF0b3IubmV4dCgpKS5kb25lKSB7XG4gICAgICAgICAgY2hpbGQgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyBnZXRDb21wb25lbnRLZXkoY2hpbGQsIGlpKyspO1xuICAgICAgICAgIHN1YnRyZWVDb3VudCArPSB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZCwgbmV4dE5hbWUsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGRpZFdhcm5BYm91dE1hcHMsICdVc2luZyBNYXBzIGFzIGNoaWxkcmVuIGlzIG5vdCB5ZXQgZnVsbHkgc3VwcG9ydGVkLiBJdCBpcyBhbiAnICsgJ2V4cGVyaW1lbnRhbCBmZWF0dXJlIHRoYXQgbWlnaHQgYmUgcmVtb3ZlZC4gQ29udmVydCBpdCB0byBhICcgKyAnc2VxdWVuY2UgLyBpdGVyYWJsZSBvZiBrZXllZCBSZWFjdEVsZW1lbnRzIGluc3RlYWQuJykgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgZGlkV2FybkFib3V0TWFwcyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSXRlcmF0b3Igd2lsbCBwcm92aWRlIGVudHJ5IFtrLHZdIHR1cGxlcyByYXRoZXIgdGhhbiB2YWx1ZXMuXG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBzdGVwLnZhbHVlO1xuICAgICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgICAgY2hpbGQgPSBlbnRyeVsxXTtcbiAgICAgICAgICAgIG5leHROYW1lID0gbmV4dE5hbWVQcmVmaXggKyB3cmFwVXNlclByb3ZpZGVkS2V5KGVudHJ5WzBdKSArIFNVQlNFUEFSQVRPUiArIGdldENvbXBvbmVudEtleShjaGlsZCwgMCk7XG4gICAgICAgICAgICBzdWJ0cmVlQ291bnQgKz0gdHJhdmVyc2VBbGxDaGlsZHJlbkltcGwoY2hpbGQsIG5leHROYW1lLCBjYWxsYmFjaywgdHJhdmVyc2VDb250ZXh0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICB2YXIgYWRkZW5kdW0gPSAnJztcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGFkZGVuZHVtID0gJyBJZiB5b3UgbWVhbnQgdG8gcmVuZGVyIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiwgdXNlIGFuIGFycmF5ICcgKyAnaW5zdGVhZCBvciB3cmFwIHRoZSBvYmplY3QgdXNpbmcgY3JlYXRlRnJhZ21lbnQob2JqZWN0KSBmcm9tIHRoZSAnICsgJ1JlYWN0IGFkZC1vbnMuJztcbiAgICAgICAgaWYgKGNoaWxkcmVuLl9pc1JlYWN0RWxlbWVudCkge1xuICAgICAgICAgIGFkZGVuZHVtID0gJyBJdCBsb29rcyBsaWtlIHlvdVxcJ3JlIHVzaW5nIGFuIGVsZW1lbnQgY3JlYXRlZCBieSBhIGRpZmZlcmVudCAnICsgJ3ZlcnNpb24gb2YgUmVhY3QuIE1ha2Ugc3VyZSB0byB1c2Ugb25seSBvbmUgY29weSBvZiBSZWFjdC4nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50KSB7XG4gICAgICAgICAgdmFyIG5hbWUgPSBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LmdldE5hbWUoKTtcbiAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgYWRkZW5kdW0gKz0gJyBDaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGNoaWxkcmVuU3RyaW5nID0gU3RyaW5nKGNoaWxkcmVuKTtcbiAgICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdPYmplY3RzIGFyZSBub3QgdmFsaWQgYXMgYSBSZWFjdCBjaGlsZCAoZm91bmQ6ICVzKS4lcycsIGNoaWxkcmVuU3RyaW5nID09PSAnW29iamVjdCBPYmplY3RdJyA/ICdvYmplY3Qgd2l0aCBrZXlzIHsnICsgT2JqZWN0LmtleXMoY2hpbGRyZW4pLmpvaW4oJywgJykgKyAnfScgOiBjaGlsZHJlblN0cmluZywgYWRkZW5kdW0pIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3VidHJlZUNvdW50O1xufVxuXG4vKipcbiAqIFRyYXZlcnNlcyBjaGlsZHJlbiB0aGF0IGFyZSB0eXBpY2FsbHkgc3BlY2lmaWVkIGFzIGBwcm9wcy5jaGlsZHJlbmAsIGJ1dFxuICogbWlnaHQgYWxzbyBiZSBzcGVjaWZpZWQgdGhyb3VnaCBhdHRyaWJ1dGVzOlxuICpcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5jaGlsZHJlbiwgLi4uKWBcbiAqIC0gYHRyYXZlcnNlQWxsQ2hpbGRyZW4odGhpcy5wcm9wcy5sZWZ0UGFuZWxDaGlsZHJlbiwgLi4uKWBcbiAqXG4gKiBUaGUgYHRyYXZlcnNlQ29udGV4dGAgaXMgYW4gb3B0aW9uYWwgYXJndW1lbnQgdGhhdCBpcyBwYXNzZWQgdGhyb3VnaCB0aGVcbiAqIGVudGlyZSB0cmF2ZXJzYWwuIEl0IGNhbiBiZSB1c2VkIHRvIHN0b3JlIGFjY3VtdWxhdGlvbnMgb3IgYW55dGhpbmcgZWxzZSB0aGF0XG4gKiB0aGUgY2FsbGJhY2sgbWlnaHQgZmluZCByZWxldmFudC5cbiAqXG4gKiBAcGFyYW0gez8qfSBjaGlsZHJlbiBDaGlsZHJlbiB0cmVlIG9iamVjdC5cbiAqIEBwYXJhbSB7IWZ1bmN0aW9ufSBjYWxsYmFjayBUbyBpbnZva2UgdXBvbiB0cmF2ZXJzaW5nIGVhY2ggY2hpbGQuXG4gKiBAcGFyYW0gez8qfSB0cmF2ZXJzZUNvbnRleHQgQ29udGV4dCBmb3IgdHJhdmVyc2FsLlxuICogQHJldHVybiB7IW51bWJlcn0gVGhlIG51bWJlciBvZiBjaGlsZHJlbiBpbiB0aGlzIHN1YnRyZWUuXG4gKi9cbmZ1bmN0aW9uIHRyYXZlcnNlQWxsQ2hpbGRyZW4oY2hpbGRyZW4sIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpIHtcbiAgaWYgKGNoaWxkcmVuID09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuXG4gIHJldHVybiB0cmF2ZXJzZUFsbENoaWxkcmVuSW1wbChjaGlsZHJlbiwgJycsIGNhbGxiYWNrLCB0cmF2ZXJzZUNvbnRleHQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHRyYXZlcnNlQWxsQ2hpbGRyZW47XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvdHJhdmVyc2VBbGxDaGlsZHJlbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlbGVjdFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG52YXIgUmVhY3RVcGRhdGVzID0gcmVxdWlyZSgnLi9SZWFjdFVwZGF0ZXMnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbnZhciB2YWx1ZUNvbnRleHRLZXkgPSAnX19SZWFjdERPTVNlbGVjdF92YWx1ZSQnICsgTWF0aC5yYW5kb20oKS50b1N0cmluZygzNikuc2xpY2UoMik7XG5cbmZ1bmN0aW9uIHVwZGF0ZU9wdGlvbnNJZlBlbmRpbmdVcGRhdGVBbmRNb3VudGVkKCkge1xuICBpZiAodGhpcy5fcm9vdE5vZGVJRCAmJiB0aGlzLl93cmFwcGVyU3RhdGUucGVuZGluZ1VwZGF0ZSkge1xuICAgIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gZmFsc2U7XG5cbiAgICB2YXIgcHJvcHMgPSB0aGlzLl9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcblxuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICB1cGRhdGVPcHRpb25zKHRoaXMsIEJvb2xlYW4ocHJvcHMubXVsdGlwbGUpLCB2YWx1ZSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bShvd25lcikge1xuICBpZiAob3duZXIpIHtcbiAgICB2YXIgbmFtZSA9IG93bmVyLmdldE5hbWUoKTtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuICcgQ2hlY2sgdGhlIHJlbmRlciBtZXRob2Qgb2YgYCcgKyBuYW1lICsgJ2AuJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgdmFsdWVQcm9wTmFtZXMgPSBbJ3ZhbHVlJywgJ2RlZmF1bHRWYWx1ZSddO1xuXG4vKipcbiAqIFZhbGlkYXRpb24gZnVuY3Rpb24gZm9yIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tTZWxlY3RQcm9wVHlwZXMoaW5zdCwgcHJvcHMpIHtcbiAgdmFyIG93bmVyID0gaW5zdC5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCdzZWxlY3QnLCBwcm9wcywgb3duZXIpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVQcm9wTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcHJvcE5hbWUgPSB2YWx1ZVByb3BOYW1lc1tpXTtcbiAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAocHJvcHMubXVsdGlwbGUpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKEFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhbiBhcnJheSBpZiAnICsgJ2BtdWx0aXBsZWAgaXMgdHJ1ZS4lcycsIHByb3BOYW1lLCBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0ob3duZXIpKSA6IHVuZGVmaW5lZDtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUFycmF5LmlzQXJyYXkocHJvcHNbcHJvcE5hbWVdKSwgJ1RoZSBgJXNgIHByb3Agc3VwcGxpZWQgdG8gPHNlbGVjdD4gbXVzdCBiZSBhIHNjYWxhciAnICsgJ3ZhbHVlIGlmIGBtdWx0aXBsZWAgaXMgZmFsc2UuJXMnLCBwcm9wTmFtZSwgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKG93bmVyKSkgOiB1bmRlZmluZWQ7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtSZWFjdERPTUNvbXBvbmVudH0gaW5zdFxuICogQHBhcmFtIHtib29sZWFufSBtdWx0aXBsZVxuICogQHBhcmFtIHsqfSBwcm9wVmFsdWUgQSBzdHJpbmdhYmxlICh3aXRoIGBtdWx0aXBsZWAsIGEgbGlzdCBvZiBzdHJpbmdhYmxlcykuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB1cGRhdGVPcHRpb25zKGluc3QsIG11bHRpcGxlLCBwcm9wVmFsdWUpIHtcbiAgdmFyIHNlbGVjdGVkVmFsdWUsIGk7XG4gIHZhciBvcHRpb25zID0gUmVhY3RNb3VudC5nZXROb2RlKGluc3QuX3Jvb3ROb2RlSUQpLm9wdGlvbnM7XG5cbiAgaWYgKG11bHRpcGxlKSB7XG4gICAgc2VsZWN0ZWRWYWx1ZSA9IHt9O1xuICAgIGZvciAoaSA9IDA7IGkgPCBwcm9wVmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgIHNlbGVjdGVkVmFsdWVbJycgKyBwcm9wVmFsdWVbaV1dID0gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IG9wdGlvbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBzZWxlY3RlZCA9IHNlbGVjdGVkVmFsdWUuaGFzT3duUHJvcGVydHkob3B0aW9uc1tpXS52YWx1ZSk7XG4gICAgICBpZiAob3B0aW9uc1tpXS5zZWxlY3RlZCAhPT0gc2VsZWN0ZWQpIHtcbiAgICAgICAgb3B0aW9uc1tpXS5zZWxlY3RlZCA9IHNlbGVjdGVkO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBEbyBub3Qgc2V0IGBzZWxlY3QudmFsdWVgIGFzIGV4YWN0IGJlaGF2aW9yIGlzbid0IGNvbnNpc3RlbnQgYWNyb3NzIGFsbFxuICAgIC8vIGJyb3dzZXJzIGZvciBhbGwgY2FzZXMuXG4gICAgc2VsZWN0ZWRWYWx1ZSA9ICcnICsgcHJvcFZhbHVlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBvcHRpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAob3B0aW9uc1tpXS52YWx1ZSA9PT0gc2VsZWN0ZWRWYWx1ZSkge1xuICAgICAgICBvcHRpb25zW2ldLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob3B0aW9ucy5sZW5ndGgpIHtcbiAgICAgIG9wdGlvbnNbMF0uc2VsZWN0ZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEltcGxlbWVudHMgYSA8c2VsZWN0PiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIG9wdGlvbmFsbHkgc2V0dGluZyB0aGVcbiAqIHByb3BzIGB2YWx1ZWAgYW5kIGBkZWZhdWx0VmFsdWVgLiBJZiBgbXVsdGlwbGVgIGlzIGZhbHNlLCB0aGUgcHJvcCBtdXN0IGJlIGFcbiAqIHN0cmluZ2FibGUuIElmIGBtdWx0aXBsZWAgaXMgdHJ1ZSwgdGhlIHByb3AgbXVzdCBiZSBhbiBhcnJheSBvZiBzdHJpbmdhYmxlcy5cbiAqXG4gKiBJZiBgdmFsdWVgIGlzIG5vdCBzdXBwbGllZCAob3IgbnVsbC91bmRlZmluZWQpLCB1c2VyIGFjdGlvbnMgdGhhdCBjaGFuZ2UgdGhlXG4gKiBzZWxlY3RlZCBvcHRpb24gd2lsbCB0cmlnZ2VyIHVwZGF0ZXMgdG8gdGhlIHJlbmRlcmVkIG9wdGlvbnMuXG4gKlxuICogSWYgaXQgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgb3B0aW9ucyB3aWxsIG5vdFxuICogdXBkYXRlIGluIHJlc3BvbnNlIHRvIHVzZXIgYWN0aW9ucy4gSW5zdGVhZCwgdGhlIGB2YWx1ZWAgcHJvcCBtdXN0IGNoYW5nZSBpblxuICogb3JkZXIgZm9yIHRoZSByZW5kZXJlZCBvcHRpb25zIHRvIHVwZGF0ZS5cbiAqXG4gKiBJZiBgZGVmYXVsdFZhbHVlYCBpcyBwcm92aWRlZCwgYW55IG9wdGlvbnMgd2l0aCB0aGUgc3VwcGxpZWQgdmFsdWVzIHdpbGwgYmVcbiAqIHNlbGVjdGVkLlxuICovXG52YXIgUmVhY3RET01TZWxlY3QgPSB7XG4gIHZhbHVlQ29udGV4dEtleTogdmFsdWVDb250ZXh0S2V5LFxuXG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgb25DaGFuZ2U6IGluc3QuX3dyYXBwZXJTdGF0ZS5vbkNoYW5nZSxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWRcbiAgICB9KTtcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBjaGVja1NlbGVjdFByb3BUeXBlcyhpbnN0LCBwcm9wcyk7XG4gICAgfVxuXG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlID0ge1xuICAgICAgcGVuZGluZ1VwZGF0ZTogZmFsc2UsXG4gICAgICBpbml0aWFsVmFsdWU6IHZhbHVlICE9IG51bGwgPyB2YWx1ZSA6IHByb3BzLmRlZmF1bHRWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBfaGFuZGxlQ2hhbmdlLmJpbmQoaW5zdCksXG4gICAgICB3YXNNdWx0aXBsZTogQm9vbGVhbihwcm9wcy5tdWx0aXBsZSlcbiAgICB9O1xuICB9LFxuXG4gIHByb2Nlc3NDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcywgY29udGV4dCkge1xuICAgIC8vIFBhc3MgZG93biBpbml0aWFsIHZhbHVlIHNvIGluaXRpYWwgZ2VuZXJhdGVkIG1hcmt1cCBoYXMgY29ycmVjdFxuICAgIC8vIGBzZWxlY3RlZGAgYXR0cmlidXRlc1xuICAgIHZhciBjaGlsZENvbnRleHQgPSBhc3NpZ24oe30sIGNvbnRleHQpO1xuICAgIGNoaWxkQ29udGV4dFt2YWx1ZUNvbnRleHRLZXldID0gaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZTtcbiAgICByZXR1cm4gY2hpbGRDb250ZXh0O1xuICB9LFxuXG4gIHBvc3RVcGRhdGVXcmFwcGVyOiBmdW5jdGlvbiAoaW5zdCkge1xuICAgIHZhciBwcm9wcyA9IGluc3QuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuXG4gICAgLy8gQWZ0ZXIgdGhlIGluaXRpYWwgbW91bnQsIHdlIGNvbnRyb2wgc2VsZWN0ZWQtbmVzcyBtYW51YWxseSBzbyBkb24ndCBwYXNzXG4gICAgLy8gdGhlIGNvbnRleHQgdmFsdWUgZG93blxuICAgIGluc3QuX3dyYXBwZXJTdGF0ZS5pbml0aWFsVmFsdWUgPSB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd2FzTXVsdGlwbGUgPSBpbnN0Ll93cmFwcGVyU3RhdGUud2FzTXVsdGlwbGU7XG4gICAgaW5zdC5fd3JhcHBlclN0YXRlLndhc011bHRpcGxlID0gQm9vbGVhbihwcm9wcy5tdWx0aXBsZSk7XG5cbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgaW5zdC5fd3JhcHBlclN0YXRlLnBlbmRpbmdVcGRhdGUgPSBmYWxzZTtcbiAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHdhc011bHRpcGxlICE9PSBCb29sZWFuKHByb3BzLm11bHRpcGxlKSkge1xuICAgICAgLy8gRm9yIHNpbXBsaWNpdHksIHJlYXBwbHkgYGRlZmF1bHRWYWx1ZWAgaWYgYG11bHRpcGxlYCBpcyB0b2dnbGVkLlxuICAgICAgaWYgKHByb3BzLmRlZmF1bHRWYWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLmRlZmF1bHRWYWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXZlcnQgdGhlIHNlbGVjdCBiYWNrIHRvIGl0cyBkZWZhdWx0IHVuc2VsZWN0ZWQgc3RhdGUuXG4gICAgICAgIHVwZGF0ZU9wdGlvbnMoaW5zdCwgQm9vbGVhbihwcm9wcy5tdWx0aXBsZSksIHByb3BzLm11bHRpcGxlID8gW10gOiAnJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBfaGFuZGxlQ2hhbmdlKGV2ZW50KSB7XG4gIHZhciBwcm9wcyA9IHRoaXMuX2N1cnJlbnRFbGVtZW50LnByb3BzO1xuICB2YXIgcmV0dXJuVmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmV4ZWN1dGVPbkNoYW5nZShwcm9wcywgZXZlbnQpO1xuXG4gIHRoaXMuX3dyYXBwZXJTdGF0ZS5wZW5kaW5nVXBkYXRlID0gdHJ1ZTtcbiAgUmVhY3RVcGRhdGVzLmFzYXAodXBkYXRlT3B0aW9uc0lmUGVuZGluZ1VwZGF0ZUFuZE1vdW50ZWQsIHRoaXMpO1xuICByZXR1cm4gcmV0dXJuVmFsdWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3QuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RET01UZXh0YXJlYVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIExpbmtlZFZhbHVlVXRpbHMgPSByZXF1aXJlKCcuL0xpbmtlZFZhbHVlVXRpbHMnKTtcbnZhciBSZWFjdERPTUlET3BlcmF0aW9ucyA9IHJlcXVpcmUoJy4vUmVhY3RET01JRE9wZXJhdGlvbnMnKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZm9yY2VVcGRhdGVJZk1vdW50ZWQoKSB7XG4gIGlmICh0aGlzLl9yb290Tm9kZUlEKSB7XG4gICAgLy8gRE9NIGNvbXBvbmVudCBpcyBzdGlsbCBtb3VudGVkOyB1cGRhdGVcbiAgICBSZWFjdERPTVRleHRhcmVhLnVwZGF0ZVdyYXBwZXIodGhpcyk7XG4gIH1cbn1cblxuLyoqXG4gKiBJbXBsZW1lbnRzIGEgPHRleHRhcmVhPiBuYXRpdmUgY29tcG9uZW50IHRoYXQgYWxsb3dzIHNldHRpbmcgYHZhbHVlYCwgYW5kXG4gKiBgZGVmYXVsdFZhbHVlYC4gVGhpcyBkaWZmZXJzIGZyb20gdGhlIHRyYWRpdGlvbmFsIERPTSBBUEkgYmVjYXVzZSB2YWx1ZSBpc1xuICogdXN1YWxseSBzZXQgYXMgUENEQVRBIGNoaWxkcmVuLlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgbm90IHN1cHBsaWVkIChvciBudWxsL3VuZGVmaW5lZCksIHVzZXIgYWN0aW9ucyB0aGF0IGFmZmVjdCB0aGVcbiAqIHZhbHVlIHdpbGwgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LlxuICpcbiAqIElmIGB2YWx1ZWAgaXMgc3VwcGxpZWQgKGFuZCBub3QgbnVsbC91bmRlZmluZWQpLCB0aGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsXG4gKiBub3QgdHJpZ2dlciB1cGRhdGVzIHRvIHRoZSBlbGVtZW50LiBJbnN0ZWFkLCB0aGUgYHZhbHVlYCBwcm9wIG11c3QgY2hhbmdlIGluXG4gKiBvcmRlciBmb3IgdGhlIHJlbmRlcmVkIGVsZW1lbnQgdG8gYmUgdXBkYXRlZC5cbiAqXG4gKiBUaGUgcmVuZGVyZWQgZWxlbWVudCB3aWxsIGJlIGluaXRpYWxpemVkIHdpdGggYW4gZW1wdHkgdmFsdWUsIHRoZSBwcm9wXG4gKiBgZGVmYXVsdFZhbHVlYCBpZiBzcGVjaWZpZWQsIG9yIHRoZSBjaGlsZHJlbiBjb250ZW50IChkZXByZWNhdGVkKS5cbiAqL1xudmFyIFJlYWN0RE9NVGV4dGFyZWEgPSB7XG4gIGdldE5hdGl2ZVByb3BzOiBmdW5jdGlvbiAoaW5zdCwgcHJvcHMsIGNvbnRleHQpIHtcbiAgICAhKHByb3BzLmRhbmdlcm91c2x5U2V0SW5uZXJIVE1MID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ2BkYW5nZXJvdXNseVNldElubmVySFRNTGAgZG9lcyBub3QgbWFrZSBzZW5zZSBvbiA8dGV4dGFyZWE+LicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgIC8vIEFsd2F5cyBzZXQgY2hpbGRyZW4gdG8gdGhlIHNhbWUgdGhpbmcuIEluIElFOSwgdGhlIHNlbGVjdGlvbiByYW5nZSB3aWxsXG4gICAgLy8gZ2V0IHJlc2V0IGlmIGB0ZXh0Q29udGVudGAgaXMgbXV0YXRlZC5cbiAgICB2YXIgbmF0aXZlUHJvcHMgPSBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICBkZWZhdWx0VmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICBjaGlsZHJlbjogaW5zdC5fd3JhcHBlclN0YXRlLmluaXRpYWxWYWx1ZSxcbiAgICAgIG9uQ2hhbmdlOiBpbnN0Ll93cmFwcGVyU3RhdGUub25DaGFuZ2VcbiAgICB9KTtcblxuICAgIHJldHVybiBuYXRpdmVQcm9wcztcbiAgfSxcblxuICBtb3VudFdyYXBwZXI6IGZ1bmN0aW9uIChpbnN0LCBwcm9wcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBMaW5rZWRWYWx1ZVV0aWxzLmNoZWNrUHJvcFR5cGVzKCd0ZXh0YXJlYScsIHByb3BzLCBpbnN0Ll9jdXJyZW50RWxlbWVudC5fb3duZXIpO1xuICAgIH1cblxuICAgIHZhciBkZWZhdWx0VmFsdWUgPSBwcm9wcy5kZWZhdWx0VmFsdWU7XG4gICAgLy8gVE9ETyAoeXVuZ3N0ZXJzKTogUmVtb3ZlIHN1cHBvcnQgZm9yIGNoaWxkcmVuIGNvbnRlbnQgaW4gPHRleHRhcmVhPi5cbiAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcbiAgICBpZiAoY2hpbGRyZW4gIT0gbnVsbCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICdVc2UgdGhlIGBkZWZhdWx0VmFsdWVgIG9yIGB2YWx1ZWAgcHJvcHMgaW5zdGVhZCBvZiBzZXR0aW5nICcgKyAnY2hpbGRyZW4gb24gPHRleHRhcmVhPi4nKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgICEoZGVmYXVsdFZhbHVlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ0lmIHlvdSBzdXBwbHkgYGRlZmF1bHRWYWx1ZWAgb24gYSA8dGV4dGFyZWE+LCBkbyBub3QgcGFzcyBjaGlsZHJlbi4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgIShjaGlsZHJlbi5sZW5ndGggPD0gMSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnPHRleHRhcmVhPiBjYW4gb25seSBoYXZlIGF0IG1vc3Qgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY2hpbGRyZW4gPSBjaGlsZHJlblswXTtcbiAgICAgIH1cblxuICAgICAgZGVmYXVsdFZhbHVlID0gJycgKyBjaGlsZHJlbjtcbiAgICB9XG4gICAgaWYgKGRlZmF1bHRWYWx1ZSA9PSBudWxsKSB7XG4gICAgICBkZWZhdWx0VmFsdWUgPSAnJztcbiAgICB9XG4gICAgdmFyIHZhbHVlID0gTGlua2VkVmFsdWVVdGlscy5nZXRWYWx1ZShwcm9wcyk7XG5cbiAgICBpbnN0Ll93cmFwcGVyU3RhdGUgPSB7XG4gICAgICAvLyBXZSBzYXZlIHRoZSBpbml0aWFsIHZhbHVlIHNvIHRoYXQgYFJlYWN0RE9NQ29tcG9uZW50YCBkb2Vzbid0IHVwZGF0ZVxuICAgICAgLy8gYHRleHRDb250ZW50YCAodW5uZWNlc3Nhcnkgc2luY2Ugd2UgdXBkYXRlIHZhbHVlKS5cbiAgICAgIC8vIFRoZSBpbml0aWFsIHZhbHVlIGNhbiBiZSBhIGJvb2xlYW4gb3Igb2JqZWN0IHNvIHRoYXQncyB3aHkgaXQnc1xuICAgICAgLy8gZm9yY2VkIHRvIGJlIGEgc3RyaW5nLlxuICAgICAgaW5pdGlhbFZhbHVlOiAnJyArICh2YWx1ZSAhPSBudWxsID8gdmFsdWUgOiBkZWZhdWx0VmFsdWUpLFxuICAgICAgb25DaGFuZ2U6IF9oYW5kbGVDaGFuZ2UuYmluZChpbnN0KVxuICAgIH07XG4gIH0sXG5cbiAgdXBkYXRlV3JhcHBlcjogZnVuY3Rpb24gKGluc3QpIHtcbiAgICB2YXIgcHJvcHMgPSBpbnN0Ll9jdXJyZW50RWxlbWVudC5wcm9wcztcbiAgICB2YXIgdmFsdWUgPSBMaW5rZWRWYWx1ZVV0aWxzLmdldFZhbHVlKHByb3BzKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgLy8gQ2FzdCBgdmFsdWVgIHRvIGEgc3RyaW5nIHRvIGVuc3VyZSB0aGUgdmFsdWUgaXMgc2V0IGNvcnJlY3RseS4gV2hpbGVcbiAgICAgIC8vIGJyb3dzZXJzIHR5cGljYWxseSBkbyB0aGlzIGFzIG5lY2Vzc2FyeSwganNkb20gZG9lc24ndC5cbiAgICAgIFJlYWN0RE9NSURPcGVyYXRpb25zLnVwZGF0ZVByb3BlcnR5QnlJRChpbnN0Ll9yb290Tm9kZUlELCAndmFsdWUnLCAnJyArIHZhbHVlKTtcbiAgICB9XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9oYW5kbGVDaGFuZ2UoZXZlbnQpIHtcbiAgdmFyIHByb3BzID0gdGhpcy5fY3VycmVudEVsZW1lbnQucHJvcHM7XG4gIHZhciByZXR1cm5WYWx1ZSA9IExpbmtlZFZhbHVlVXRpbHMuZXhlY3V0ZU9uQ2hhbmdlKHByb3BzLCBldmVudCk7XG4gIFJlYWN0VXBkYXRlcy5hc2FwKGZvcmNlVXBkYXRlSWZNb3VudGVkLCB0aGlzKTtcbiAgcmV0dXJuIHJldHVyblZhbHVlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RE9NVGV4dGFyZWE7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01UZXh0YXJlYS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdE11bHRpQ2hpbGRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzID0gcmVxdWlyZSgnLi9SZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcycpO1xuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG52YXIgUmVhY3RSZWNvbmNpbGVyID0gcmVxdWlyZSgnLi9SZWFjdFJlY29uY2lsZXInKTtcbnZhciBSZWFjdENoaWxkUmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RDaGlsZFJlY29uY2lsZXInKTtcblxudmFyIGZsYXR0ZW5DaGlsZHJlbiA9IHJlcXVpcmUoJy4vZmxhdHRlbkNoaWxkcmVuJyk7XG5cbi8qKlxuICogVXBkYXRpbmcgY2hpbGRyZW4gb2YgYSBjb21wb25lbnQgbWF5IHRyaWdnZXIgcmVjdXJzaXZlIHVwZGF0ZXMuIFRoZSBkZXB0aCBpc1xuICogdXNlZCB0byBiYXRjaCByZWN1cnNpdmUgdXBkYXRlcyB0byByZW5kZXIgbWFya3VwIG1vcmUgZWZmaWNpZW50bHkuXG4gKlxuICogQHR5cGUge251bWJlcn1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciB1cGRhdGVEZXB0aCA9IDA7XG5cbi8qKlxuICogUXVldWUgb2YgdXBkYXRlIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAqXG4gKiBFYWNoIG9iamVjdCBoYXMgYSBgdHlwZWAgcHJvcGVydHkgdGhhdCBpcyBpbiBgUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXNgLlxuICpcbiAqIEB0eXBlIHthcnJheTxvYmplY3Q+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIHVwZGF0ZVF1ZXVlID0gW107XG5cbi8qKlxuICogUXVldWUgb2YgbWFya3VwIHRvIGJlIHJlbmRlcmVkLlxuICpcbiAqIEB0eXBlIHthcnJheTxzdHJpbmc+fVxuICogQHByaXZhdGVcbiAqL1xudmFyIG1hcmt1cFF1ZXVlID0gW107XG5cbi8qKlxuICogRW5xdWV1ZXMgbWFya3VwIHRvIGJlIHJlbmRlcmVkIGFuZCBpbnNlcnRlZCBhdCBhIHN1cHBsaWVkIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gdG9JbmRleCBEZXN0aW5hdGlvbiBpbmRleC5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVJbnNlcnRNYXJrdXAocGFyZW50SUQsIG1hcmt1cCwgdG9JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLklOU0VSVF9NQVJLVVAsXG4gICAgbWFya3VwSW5kZXg6IG1hcmt1cFF1ZXVlLnB1c2gobWFya3VwKSAtIDEsXG4gICAgY29udGVudDogbnVsbCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogdG9JbmRleFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBtb3ZpbmcgYW4gZXhpc3RpbmcgZWxlbWVudCB0byBhbm90aGVyIGluZGV4LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggU291cmNlIGluZGV4IG9mIHRoZSBleGlzdGluZyBlbGVtZW50LlxuICogQHBhcmFtIHtudW1iZXJ9IHRvSW5kZXggRGVzdGluYXRpb24gaW5kZXggb2YgdGhlIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlTW92ZShwYXJlbnRJRCwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuTU9WRV9FWElTVElORyxcbiAgICBtYXJrdXBJbmRleDogbnVsbCxcbiAgICBjb250ZW50OiBudWxsLFxuICAgIGZyb21JbmRleDogZnJvbUluZGV4LFxuICAgIHRvSW5kZXg6IHRvSW5kZXhcbiAgfSk7XG59XG5cbi8qKlxuICogRW5xdWV1ZXMgcmVtb3ZpbmcgYW4gZWxlbWVudCBhdCBhbiBpbmRleC5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcGFyZW50SUQgSUQgb2YgdGhlIHBhcmVudCBjb21wb25lbnQuXG4gKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IEluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVucXVldWVSZW1vdmUocGFyZW50SUQsIGZyb21JbmRleCkge1xuICAvLyBOT1RFOiBOdWxsIHZhbHVlcyByZWR1Y2UgaGlkZGVuIGNsYXNzZXMuXG4gIHVwZGF0ZVF1ZXVlLnB1c2goe1xuICAgIHBhcmVudElEOiBwYXJlbnRJRCxcbiAgICBwYXJlbnROb2RlOiBudWxsLFxuICAgIHR5cGU6IFJlYWN0TXVsdGlDaGlsZFVwZGF0ZVR5cGVzLlJFTU9WRV9OT0RFLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGwsXG4gICAgZnJvbUluZGV4OiBmcm9tSW5kZXgsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSBtYXJrdXAgb2YgYSBub2RlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXJlbnRJRCBJRCBvZiB0aGUgcGFyZW50IGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRoYXQgcmVuZGVycyBpbnRvIGFuIGVsZW1lbnQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlU2V0TWFya3VwKHBhcmVudElELCBtYXJrdXApIHtcbiAgLy8gTk9URTogTnVsbCB2YWx1ZXMgcmVkdWNlIGhpZGRlbiBjbGFzc2VzLlxuICB1cGRhdGVRdWV1ZS5wdXNoKHtcbiAgICBwYXJlbnRJRDogcGFyZW50SUQsXG4gICAgcGFyZW50Tm9kZTogbnVsbCxcbiAgICB0eXBlOiBSZWFjdE11bHRpQ2hpbGRVcGRhdGVUeXBlcy5TRVRfTUFSS1VQLFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IG1hcmt1cCxcbiAgICBmcm9tSW5kZXg6IG51bGwsXG4gICAgdG9JbmRleDogbnVsbFxuICB9KTtcbn1cblxuLyoqXG4gKiBFbnF1ZXVlcyBzZXR0aW5nIHRoZSB0ZXh0IGNvbnRlbnQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhcmVudElEIElEIG9mIHRoZSBwYXJlbnQgY29tcG9uZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRDb250ZW50IFRleHQgY29udGVudCB0byBzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbnF1ZXVlVGV4dENvbnRlbnQocGFyZW50SUQsIHRleHRDb250ZW50KSB7XG4gIC8vIE5PVEU6IE51bGwgdmFsdWVzIHJlZHVjZSBoaWRkZW4gY2xhc3Nlcy5cbiAgdXBkYXRlUXVldWUucHVzaCh7XG4gICAgcGFyZW50SUQ6IHBhcmVudElELFxuICAgIHBhcmVudE5vZGU6IG51bGwsXG4gICAgdHlwZTogUmVhY3RNdWx0aUNoaWxkVXBkYXRlVHlwZXMuVEVYVF9DT05URU5ULFxuICAgIG1hcmt1cEluZGV4OiBudWxsLFxuICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxuICAgIGZyb21JbmRleDogbnVsbCxcbiAgICB0b0luZGV4OiBudWxsXG4gIH0pO1xufVxuXG4vKipcbiAqIFByb2Nlc3NlcyBhbnkgZW5xdWV1ZWQgdXBkYXRlcy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwcm9jZXNzUXVldWUoKSB7XG4gIGlmICh1cGRhdGVRdWV1ZS5sZW5ndGgpIHtcbiAgICBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LnByb2Nlc3NDaGlsZHJlblVwZGF0ZXModXBkYXRlUXVldWUsIG1hcmt1cFF1ZXVlKTtcbiAgICBjbGVhclF1ZXVlKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBDbGVhcnMgYW55IGVucXVldWVkIHVwZGF0ZXMuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2xlYXJRdWV1ZSgpIHtcbiAgdXBkYXRlUXVldWUubGVuZ3RoID0gMDtcbiAgbWFya3VwUXVldWUubGVuZ3RoID0gMDtcbn1cblxuLyoqXG4gKiBSZWFjdE11bHRpQ2hpbGQgYXJlIGNhcGFibGUgb2YgcmVjb25jaWxpbmcgbXVsdGlwbGUgY2hpbGRyZW4uXG4gKlxuICogQGNsYXNzIFJlYWN0TXVsdGlDaGlsZFxuICogQGludGVybmFsXG4gKi9cbnZhciBSZWFjdE11bHRpQ2hpbGQgPSB7XG5cbiAgLyoqXG4gICAqIFByb3ZpZGVzIGNvbW1vbiBmdW5jdGlvbmFsaXR5IGZvciBjb21wb25lbnRzIHRoYXQgbXVzdCByZWNvbmNpbGUgbXVsdGlwbGVcbiAgICogY2hpbGRyZW4uIFRoaXMgaXMgdXNlZCBieSBgUmVhY3RET01Db21wb25lbnRgIHRvIG1vdW50LCB1cGRhdGUsIGFuZFxuICAgKiB1bm1vdW50IGNoaWxkIGNvbXBvbmVudHMuXG4gICAqXG4gICAqIEBsZW5kcyB7UmVhY3RNdWx0aUNoaWxkLnByb3RvdHlwZX1cbiAgICovXG4gIE1peGluOiB7XG5cbiAgICBfcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50RWxlbWVudCkge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50ID0gdGhpcy5fY3VycmVudEVsZW1lbnQuX293bmVyO1xuICAgICAgICAgICAgcmV0dXJuIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLmluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIuaW5zdGFudGlhdGVDaGlsZHJlbihuZXN0ZWRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBfcmVjb25jaWxlclVwZGF0ZUNoaWxkcmVuOiBmdW5jdGlvbiAocHJldkNoaWxkcmVuLCBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBuZXh0Q2hpbGRyZW47XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCA9IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lcjtcbiAgICAgICAgICAgIG5leHRDaGlsZHJlbiA9IGZsYXR0ZW5DaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyk7XG4gICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gUmVhY3RDaGlsZFJlY29uY2lsZXIudXBkYXRlQ2hpbGRyZW4ocHJldkNoaWxkcmVuLCBuZXh0Q2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmV4dENoaWxkcmVuID0gZmxhdHRlbkNoaWxkcmVuKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzKTtcbiAgICAgIHJldHVybiBSZWFjdENoaWxkUmVjb25jaWxlci51cGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHRDaGlsZHJlbiwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgICAqIG9mIGBSZWFjdERPTUNvbXBvbmVudGAsIGEgbW91bnQgaW1hZ2UgaXMgYSBzdHJpbmcgb2YgbWFya3VwLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZHJlbiBOZXN0ZWQgY2hpbGQgbWFwcy5cbiAgICAgKiBAcmV0dXJuIHthcnJheX0gQW4gYXJyYXkgb2YgbW91bnRlZCByZXByZXNlbnRhdGlvbnMuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdmFyIGNoaWxkcmVuID0gdGhpcy5fcmVjb25jaWxlckluc3RhbnRpYXRlQ2hpbGRyZW4obmVzdGVkQ2hpbGRyZW4sIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgIHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgICAgIHZhciBtb3VudEltYWdlcyA9IFtdO1xuICAgICAgdmFyIGluZGV4ID0gMDtcbiAgICAgIGZvciAodmFyIG5hbWUgaW4gY2hpbGRyZW4pIHtcbiAgICAgICAgaWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgdmFyIGNoaWxkID0gY2hpbGRyZW5bbmFtZV07XG4gICAgICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICAgICAgdmFyIHJvb3RJRCA9IHRoaXMuX3Jvb3ROb2RlSUQgKyBuYW1lO1xuICAgICAgICAgIHZhciBtb3VudEltYWdlID0gUmVhY3RSZWNvbmNpbGVyLm1vdW50Q29tcG9uZW50KGNoaWxkLCByb290SUQsIHRyYW5zYWN0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4Kys7XG4gICAgICAgICAgbW91bnRJbWFnZXMucHVzaChtb3VudEltYWdlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1vdW50SW1hZ2VzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIHRleHQgY29udGVudCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dENvbnRlbnQgU3RyaW5nIG9mIGNvbnRlbnQuXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgdXBkYXRlVGV4dENvbnRlbnQ6IGZ1bmN0aW9uIChuZXh0Q29udGVudCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5fcmVuZGVyZWRDaGlsZHJlbjtcbiAgICAgICAgLy8gUmVtb3ZlIGFueSByZW5kZXJlZCBjaGlsZHJlbi5cbiAgICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHByZXZDaGlsZHJlbik7XG4gICAgICAgIC8vIFRPRE86IFRoZSBzZXRUZXh0Q29udGVudCBvcGVyYXRpb24gc2hvdWxkIGJlIGVub3VnaFxuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGRyZW5bbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgbmV3IHRleHQgY29udGVudC5cbiAgICAgICAgdGhpcy5zZXRUZXh0Q29udGVudChuZXh0Q29udGVudCk7XG4gICAgICAgIGVycm9yVGhyb3duID0gZmFsc2U7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB1cGRhdGVEZXB0aC0tO1xuICAgICAgICBpZiAoIXVwZGF0ZURlcHRoKSB7XG4gICAgICAgICAgaWYgKGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb2Nlc3NRdWV1ZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyBhbnkgcmVuZGVyZWQgY2hpbGRyZW4gd2l0aCBhIG1hcmt1cCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV4dE1hcmt1cCBTdHJpbmcgb2YgbWFya3VwLlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVwZGF0ZU1hcmt1cDogZnVuY3Rpb24gKG5leHRNYXJrdXApIHtcbiAgICAgIHVwZGF0ZURlcHRoKys7XG4gICAgICB2YXIgZXJyb3JUaHJvd24gPSB0cnVlO1xuICAgICAgdHJ5IHtcbiAgICAgICAgdmFyIHByZXZDaGlsZHJlbiA9IHRoaXMuX3JlbmRlcmVkQ2hpbGRyZW47XG4gICAgICAgIC8vIFJlbW92ZSBhbnkgcmVuZGVyZWQgY2hpbGRyZW4uXG4gICAgICAgIFJlYWN0Q2hpbGRSZWNvbmNpbGVyLnVubW91bnRDaGlsZHJlbihwcmV2Q2hpbGRyZW4pO1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICAgIGlmIChwcmV2Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZEJ5TmFtZShwcmV2Q2hpbGRyZW5bbmFtZV0sIG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldE1hcmt1cChuZXh0TWFya3VwKTtcbiAgICAgICAgZXJyb3JUaHJvd24gPSBmYWxzZTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHVwZGF0ZURlcHRoLS07XG4gICAgICAgIGlmICghdXBkYXRlRGVwdGgpIHtcbiAgICAgICAgICBpZiAoZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgIGNsZWFyUXVldWUoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvY2Vzc1F1ZXVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVwZGF0ZXMgdGhlIHJlbmRlcmVkIGNoaWxkcmVuIHdpdGggbmV3IGNoaWxkcmVuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cyBOZXN0ZWQgY2hpbGQgZWxlbWVudCBtYXBzLlxuICAgICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgdXBkYXRlRGVwdGgrKztcbiAgICAgIHZhciBlcnJvclRocm93biA9IHRydWU7XG4gICAgICB0cnkge1xuICAgICAgICB0aGlzLl91cGRhdGVDaGlsZHJlbihuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICBlcnJvclRocm93biA9IGZhbHNlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgdXBkYXRlRGVwdGgtLTtcbiAgICAgICAgaWYgKCF1cGRhdGVEZXB0aCkge1xuICAgICAgICAgIGlmIChlcnJvclRocm93bikge1xuICAgICAgICAgICAgY2xlYXJRdWV1ZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzUXVldWUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogSW1wcm92ZSBwZXJmb3JtYW5jZSBieSBpc29sYXRpbmcgdGhpcyBob3QgY29kZSBwYXRoIGZyb20gdGhlIHRyeS9jYXRjaFxuICAgICAqIGJsb2NrIGluIGB1cGRhdGVDaGlsZHJlbmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzIE5lc3RlZCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBmaW5hbFxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfdXBkYXRlQ2hpbGRyZW46IGZ1bmN0aW9uIChuZXh0TmVzdGVkQ2hpbGRyZW5FbGVtZW50cywgdHJhbnNhY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcmV2Q2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgdmFyIG5leHRDaGlsZHJlbiA9IHRoaXMuX3JlY29uY2lsZXJVcGRhdGVDaGlsZHJlbihwcmV2Q2hpbGRyZW4sIG5leHROZXN0ZWRDaGlsZHJlbkVsZW1lbnRzLCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICB0aGlzLl9yZW5kZXJlZENoaWxkcmVuID0gbmV4dENoaWxkcmVuO1xuICAgICAgaWYgKCFuZXh0Q2hpbGRyZW4gJiYgIXByZXZDaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmFtZTtcbiAgICAgIC8vIGBuZXh0SW5kZXhgIHdpbGwgaW5jcmVtZW50IGZvciBlYWNoIGNoaWxkIGluIGBuZXh0Q2hpbGRyZW5gLCBidXRcbiAgICAgIC8vIGBsYXN0SW5kZXhgIHdpbGwgYmUgdGhlIGxhc3QgaW5kZXggdmlzaXRlZCBpbiBgcHJldkNoaWxkcmVuYC5cbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIG5leHRJbmRleCA9IDA7XG4gICAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICAgIGlmICghbmV4dENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByZXZDaGlsZCA9IHByZXZDaGlsZHJlbiAmJiBwcmV2Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIHZhciBuZXh0Q2hpbGQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICAgIGlmIChwcmV2Q2hpbGQgPT09IG5leHRDaGlsZCkge1xuICAgICAgICAgIHRoaXMubW92ZUNoaWxkKHByZXZDaGlsZCwgbmV4dEluZGV4LCBsYXN0SW5kZXgpO1xuICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICBwcmV2Q2hpbGQuX21vdW50SW5kZXggPSBuZXh0SW5kZXg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHByZXZDaGlsZCkge1xuICAgICAgICAgICAgLy8gVXBkYXRlIGBsYXN0SW5kZXhgIGJlZm9yZSBgX21vdW50SW5kZXhgIGdldHMgdW5zZXQgYnkgdW5tb3VudGluZy5cbiAgICAgICAgICAgIGxhc3RJbmRleCA9IE1hdGgubWF4KHByZXZDaGlsZC5fbW91bnRJbmRleCwgbGFzdEluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuX3VubW91bnRDaGlsZChwcmV2Q2hpbGQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUaGUgY2hpbGQgbXVzdCBiZSBpbnN0YW50aWF0ZWQgYmVmb3JlIGl0J3MgbW91bnRlZC5cbiAgICAgICAgICB0aGlzLl9tb3VudENoaWxkQnlOYW1lQXRJbmRleChuZXh0Q2hpbGQsIG5hbWUsIG5leHRJbmRleCwgdHJhbnNhY3Rpb24sIGNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIG5leHRJbmRleCsrO1xuICAgICAgfVxuICAgICAgLy8gUmVtb3ZlIGNoaWxkcmVuIHRoYXQgYXJlIG5vIGxvbmdlciBwcmVzZW50LlxuICAgICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgICBpZiAocHJldkNoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpICYmICEobmV4dENoaWxkcmVuICYmIG5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkpIHtcbiAgICAgICAgICB0aGlzLl91bm1vdW50Q2hpbGQocHJldkNoaWxkcmVuW25hbWVdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBVbm1vdW50cyBhbGwgcmVuZGVyZWQgY2hpbGRyZW4uIFRoaXMgc2hvdWxkIGJlIHVzZWQgdG8gY2xlYW4gdXAgY2hpbGRyZW5cbiAgICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHJlbmRlcmVkQ2hpbGRyZW4gPSB0aGlzLl9yZW5kZXJlZENoaWxkcmVuO1xuICAgICAgUmVhY3RDaGlsZFJlY29uY2lsZXIudW5tb3VudENoaWxkcmVuKHJlbmRlcmVkQ2hpbGRyZW4pO1xuICAgICAgdGhpcy5fcmVuZGVyZWRDaGlsZHJlbiA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdmVzIGEgY2hpbGQgY29tcG9uZW50IHRvIHRoZSBzdXBwbGllZCBpbmRleC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBtb3ZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB0b0luZGV4IERlc3RpbmF0aW9uIGluZGV4IG9mIHRoZSBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsYXN0SW5kZXggTGFzdCBpbmRleCB2aXNpdGVkIG9mIHRoZSBzaWJsaW5ncyBvZiBgY2hpbGRgLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBtb3ZlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgdG9JbmRleCwgbGFzdEluZGV4KSB7XG4gICAgICAvLyBJZiB0aGUgaW5kZXggb2YgYGNoaWxkYCBpcyBsZXNzIHRoYW4gYGxhc3RJbmRleGAsIHRoZW4gaXQgbmVlZHMgdG9cbiAgICAgIC8vIGJlIG1vdmVkLiBPdGhlcndpc2UsIHdlIGRvIG5vdCBuZWVkIHRvIG1vdmUgaXQgYmVjYXVzZSBhIGNoaWxkIHdpbGwgYmVcbiAgICAgIC8vIGluc2VydGVkIG9yIG1vdmVkIGJlZm9yZSBgY2hpbGRgLlxuICAgICAgaWYgKGNoaWxkLl9tb3VudEluZGV4IDwgbGFzdEluZGV4KSB7XG4gICAgICAgIGVucXVldWVNb3ZlKHRoaXMuX3Jvb3ROb2RlSUQsIGNoaWxkLl9tb3VudEluZGV4LCB0b0luZGV4KTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNoaWxkIGNvbXBvbmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhY3RDb21wb25lbnR9IGNoaWxkIENvbXBvbmVudCB0byBjcmVhdGUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1vdW50SW1hZ2UgTWFya3VwIHRvIGluc2VydC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgY3JlYXRlQ2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCwgbW91bnRJbWFnZSkge1xuICAgICAgZW5xdWV1ZUluc2VydE1hcmt1cCh0aGlzLl9yb290Tm9kZUlELCBtb3VudEltYWdlLCBjaGlsZC5fbW91bnRJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjaGlsZCBjb21wb25lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDaGlsZCB0byByZW1vdmUuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIHJlbW92ZUNoaWxkOiBmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgIGVucXVldWVSZW1vdmUodGhpcy5fcm9vdE5vZGVJRCwgY2hpbGQuX21vdW50SW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgdGV4dCBjb250ZW50IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0Q29udGVudCBUZXh0IGNvbnRlbnQgdG8gc2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBzZXRUZXh0Q29udGVudDogZnVuY3Rpb24gKHRleHRDb250ZW50KSB7XG4gICAgICBlbnF1ZXVlVGV4dENvbnRlbnQodGhpcy5fcm9vdE5vZGVJRCwgdGV4dENvbnRlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoaXMgbWFya3VwIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBtYXJrdXAgTWFya3VwIHRvIHNldC5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgc2V0TWFya3VwOiBmdW5jdGlvbiAobWFya3VwKSB7XG4gICAgICBlbnF1ZXVlU2V0TWFya3VwKHRoaXMuX3Jvb3ROb2RlSUQsIG1hcmt1cCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIE1vdW50cyBhIGNoaWxkIHdpdGggdGhlIHN1cHBsaWVkIG5hbWUuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gbW91bnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgTmFtZSBvZiB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IEluZGV4IGF0IHdoaWNoIHRvIGluc2VydCB0aGUgY2hpbGQuXG4gICAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX21vdW50Q2hpbGRCeU5hbWVBdEluZGV4OiBmdW5jdGlvbiAoY2hpbGQsIG5hbWUsIGluZGV4LCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgICAgLy8gSW5saW5lZCBmb3IgcGVyZm9ybWFuY2UsIHNlZSBgUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RJRGAuXG4gICAgICB2YXIgcm9vdElEID0gdGhpcy5fcm9vdE5vZGVJRCArIG5hbWU7XG4gICAgICB2YXIgbW91bnRJbWFnZSA9IFJlYWN0UmVjb25jaWxlci5tb3VudENvbXBvbmVudChjaGlsZCwgcm9vdElELCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IGluZGV4O1xuICAgICAgdGhpcy5jcmVhdGVDaGlsZChjaGlsZCwgbW91bnRJbWFnZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFVubW91bnRzIGEgcmVuZGVyZWQgY2hpbGQuXG4gICAgICpcbiAgICAgKiBOT1RFOiBUaGlzIGlzIHBhcnQgb2YgYHVwZGF0ZUNoaWxkcmVuYCBhbmQgaXMgaGVyZSBmb3IgcmVhZGFiaWxpdHkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlYWN0Q29tcG9uZW50fSBjaGlsZCBDb21wb25lbnQgdG8gdW5tb3VudC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF91bm1vdW50Q2hpbGQ6IGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgdGhpcy5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICBjaGlsZC5fbW91bnRJbmRleCA9IG51bGw7XG4gICAgfVxuXG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE11bHRpQ2hpbGQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RNdWx0aUNoaWxkLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2hpbGRSZWNvbmNpbGVyXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UmVjb25jaWxlciA9IHJlcXVpcmUoJy4vUmVhY3RSZWNvbmNpbGVyJyk7XG5cbnZhciBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9pbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL3Nob3VsZFVwZGF0ZVJlYWN0Q29tcG9uZW50Jyk7XG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbmZ1bmN0aW9uIGluc3RhbnRpYXRlQ2hpbGQoY2hpbGRJbnN0YW5jZXMsIGNoaWxkLCBuYW1lKSB7XG4gIC8vIFdlIGZvdW5kIGEgY29tcG9uZW50IGluc3RhbmNlLlxuICB2YXIga2V5VW5pcXVlID0gY2hpbGRJbnN0YW5jZXNbbmFtZV0gPT09IHVuZGVmaW5lZDtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhrZXlVbmlxdWUsICdmbGF0dGVuQ2hpbGRyZW4oLi4uKTogRW5jb3VudGVyZWQgdHdvIGNoaWxkcmVuIHdpdGggdGhlIHNhbWUga2V5LCAnICsgJ2Alc2AuIENoaWxkIGtleXMgbXVzdCBiZSB1bmlxdWU7IHdoZW4gdHdvIGNoaWxkcmVuIHNoYXJlIGEga2V5LCBvbmx5ICcgKyAndGhlIGZpcnN0IGNoaWxkIHdpbGwgYmUgdXNlZC4nLCBuYW1lKSA6IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAoY2hpbGQgIT0gbnVsbCAmJiBrZXlVbmlxdWUpIHtcbiAgICBjaGlsZEluc3RhbmNlc1tuYW1lXSA9IGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQoY2hpbGQsIG51bGwpO1xuICB9XG59XG5cbi8qKlxuICogUmVhY3RDaGlsZFJlY29uY2lsZXIgcHJvdmlkZXMgaGVscGVycyBmb3IgaW5pdGlhbGl6aW5nIG9yIHVwZGF0aW5nIGEgc2V0IG9mXG4gKiBjaGlsZHJlbi4gSXRzIG91dHB1dCBpcyBzdWl0YWJsZSBmb3IgcGFzc2luZyBpdCBvbnRvIFJlYWN0TXVsdGlDaGlsZCB3aGljaFxuICogZG9lcyBkaWZmZWQgcmVvcmRlcmluZyBhbmQgaW5zZXJ0aW9uLlxuICovXG52YXIgUmVhY3RDaGlsZFJlY29uY2lsZXIgPSB7XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBcIm1vdW50IGltYWdlXCIgZm9yIGVhY2ggb2YgdGhlIHN1cHBsaWVkIGNoaWxkcmVuLiBJbiB0aGUgY2FzZVxuICAgKiBvZiBgUmVhY3RET01Db21wb25lbnRgLCBhIG1vdW50IGltYWdlIGlzIGEgc3RyaW5nIG9mIG1hcmt1cC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXN0ZWRDaGlsZE5vZGVzIE5lc3RlZCBjaGlsZCBtYXBzLlxuICAgKiBAcmV0dXJuIHs/b2JqZWN0fSBBIHNldCBvZiBjaGlsZCBpbnN0YW5jZXMuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgaW5zdGFudGlhdGVDaGlsZHJlbjogZnVuY3Rpb24gKG5lc3RlZENoaWxkTm9kZXMsIHRyYW5zYWN0aW9uLCBjb250ZXh0KSB7XG4gICAgaWYgKG5lc3RlZENoaWxkTm9kZXMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHZhciBjaGlsZEluc3RhbmNlcyA9IHt9O1xuICAgIHRyYXZlcnNlQWxsQ2hpbGRyZW4obmVzdGVkQ2hpbGROb2RlcywgaW5zdGFudGlhdGVDaGlsZCwgY2hpbGRJbnN0YW5jZXMpO1xuICAgIHJldHVybiBjaGlsZEluc3RhbmNlcztcbiAgfSxcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgcmVuZGVyZWQgY2hpbGRyZW4gYW5kIHJldHVybnMgYSBuZXcgc2V0IG9mIGNoaWxkcmVuLlxuICAgKlxuICAgKiBAcGFyYW0gez9vYmplY3R9IHByZXZDaGlsZHJlbiBQcmV2aW91c2x5IGluaXRpYWxpemVkIHNldCBvZiBjaGlsZHJlbi5cbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q2hpbGRyZW4gRmxhdCBjaGlsZCBlbGVtZW50IG1hcHMuXG4gICAqIEBwYXJhbSB7UmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbn0gdHJhbnNhY3Rpb25cbiAgICogQHBhcmFtIHtvYmplY3R9IGNvbnRleHRcbiAgICogQHJldHVybiB7P29iamVjdH0gQSBuZXcgc2V0IG9mIGNoaWxkIGluc3RhbmNlcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICB1cGRhdGVDaGlsZHJlbjogZnVuY3Rpb24gKHByZXZDaGlsZHJlbiwgbmV4dENoaWxkcmVuLCB0cmFuc2FjdGlvbiwgY29udGV4dCkge1xuICAgIC8vIFdlIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgd2F5IHRvIHRyYWNrIG1vdmVzIGhlcmUgYnV0IGlmIHdlIHVzZSBpdGVyYXRvcnNcbiAgICAvLyBpbnN0ZWFkIG9mIGZvci4uaW4gd2UgY2FuIHppcCB0aGUgaXRlcmF0b3JzIGFuZCBjaGVjayBpZiBhbiBpdGVtIGhhc1xuICAgIC8vIG1vdmVkLlxuICAgIC8vIFRPRE86IElmIG5vdGhpbmcgaGFzIGNoYW5nZWQsIHJldHVybiB0aGUgcHJldkNoaWxkcmVuIG9iamVjdCBzbyB0aGF0IHdlXG4gICAgLy8gY2FuIHF1aWNrbHkgYmFpbG91dCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkLlxuICAgIGlmICghbmV4dENoaWxkcmVuICYmICFwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgbmFtZTtcbiAgICBmb3IgKG5hbWUgaW4gbmV4dENoaWxkcmVuKSB7XG4gICAgICBpZiAoIW5leHRDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2Q2hpbGQgPSBwcmV2Q2hpbGRyZW4gJiYgcHJldkNoaWxkcmVuW25hbWVdO1xuICAgICAgdmFyIHByZXZFbGVtZW50ID0gcHJldkNoaWxkICYmIHByZXZDaGlsZC5fY3VycmVudEVsZW1lbnQ7XG4gICAgICB2YXIgbmV4dEVsZW1lbnQgPSBuZXh0Q2hpbGRyZW5bbmFtZV07XG4gICAgICBpZiAocHJldkNoaWxkICE9IG51bGwgJiYgc2hvdWxkVXBkYXRlUmVhY3RDb21wb25lbnQocHJldkVsZW1lbnQsIG5leHRFbGVtZW50KSkge1xuICAgICAgICBSZWFjdFJlY29uY2lsZXIucmVjZWl2ZUNvbXBvbmVudChwcmV2Q2hpbGQsIG5leHRFbGVtZW50LCB0cmFuc2FjdGlvbiwgY29udGV4dCk7XG4gICAgICAgIG5leHRDaGlsZHJlbltuYW1lXSA9IHByZXZDaGlsZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmV2Q2hpbGQpIHtcbiAgICAgICAgICBSZWFjdFJlY29uY2lsZXIudW5tb3VudENvbXBvbmVudChwcmV2Q2hpbGQsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBjaGlsZCBtdXN0IGJlIGluc3RhbnRpYXRlZCBiZWZvcmUgaXQncyBtb3VudGVkLlxuICAgICAgICB2YXIgbmV4dENoaWxkSW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KG5leHRFbGVtZW50LCBudWxsKTtcbiAgICAgICAgbmV4dENoaWxkcmVuW25hbWVdID0gbmV4dENoaWxkSW5zdGFuY2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFVubW91bnQgY2hpbGRyZW4gdGhhdCBhcmUgbm8gbG9uZ2VyIHByZXNlbnQuXG4gICAgZm9yIChuYW1lIGluIHByZXZDaGlsZHJlbikge1xuICAgICAgaWYgKHByZXZDaGlsZHJlbi5oYXNPd25Qcm9wZXJ0eShuYW1lKSAmJiAhKG5leHRDaGlsZHJlbiAmJiBuZXh0Q2hpbGRyZW4uaGFzT3duUHJvcGVydHkobmFtZSkpKSB7XG4gICAgICAgIFJlYWN0UmVjb25jaWxlci51bm1vdW50Q29tcG9uZW50KHByZXZDaGlsZHJlbltuYW1lXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXh0Q2hpbGRyZW47XG4gIH0sXG5cbiAgLyoqXG4gICAqIFVubW91bnRzIGFsbCByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBzaG91bGQgYmUgdXNlZCB0byBjbGVhbiB1cCBjaGlsZHJlblxuICAgKiB3aGVuIHRoaXMgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSByZW5kZXJlZENoaWxkcmVuIFByZXZpb3VzbHkgaW5pdGlhbGl6ZWQgc2V0IG9mIGNoaWxkcmVuLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHVubW91bnRDaGlsZHJlbjogZnVuY3Rpb24gKHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIHJlbmRlcmVkQ2hpbGRyZW4pIHtcbiAgICAgIGlmIChyZW5kZXJlZENoaWxkcmVuLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgIHZhciByZW5kZXJlZENoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltuYW1lXTtcbiAgICAgICAgUmVhY3RSZWNvbmNpbGVyLnVubW91bnRDb21wb25lbnQocmVuZGVyZWRDaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDaGlsZFJlY29uY2lsZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RDaGlsZFJlY29uY2lsZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZmxhdHRlbkNoaWxkcmVuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdHJhdmVyc2VBbGxDaGlsZHJlbiA9IHJlcXVpcmUoJy4vdHJhdmVyc2VBbGxDaGlsZHJlbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gdHJhdmVyc2VDb250ZXh0IENvbnRleHQgcGFzc2VkIHRocm91Z2ggdHJhdmVyc2FsLlxuICogQHBhcmFtIHs/UmVhY3RDb21wb25lbnR9IGNoaWxkIFJlYWN0IGNoaWxkIGNvbXBvbmVudC5cbiAqIEBwYXJhbSB7IXN0cmluZ30gbmFtZSBTdHJpbmcgbmFtZSBvZiBrZXkgcGF0aCB0byBjaGlsZC5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQodHJhdmVyc2VDb250ZXh0LCBjaGlsZCwgbmFtZSkge1xuICAvLyBXZSBmb3VuZCBhIGNvbXBvbmVudCBpbnN0YW5jZS5cbiAgdmFyIHJlc3VsdCA9IHRyYXZlcnNlQ29udGV4dDtcbiAgdmFyIGtleVVuaXF1ZSA9IHJlc3VsdFtuYW1lXSA9PT0gdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGtleVVuaXF1ZSwgJ2ZsYXR0ZW5DaGlsZHJlbiguLi4pOiBFbmNvdW50ZXJlZCB0d28gY2hpbGRyZW4gd2l0aCB0aGUgc2FtZSBrZXksICcgKyAnYCVzYC4gQ2hpbGQga2V5cyBtdXN0IGJlIHVuaXF1ZTsgd2hlbiB0d28gY2hpbGRyZW4gc2hhcmUgYSBrZXksIG9ubHkgJyArICd0aGUgZmlyc3QgY2hpbGQgd2lsbCBiZSB1c2VkLicsIG5hbWUpIDogdW5kZWZpbmVkO1xuICB9XG4gIGlmIChrZXlVbmlxdWUgJiYgY2hpbGQgIT0gbnVsbCkge1xuICAgIHJlc3VsdFtuYW1lXSA9IGNoaWxkO1xuICB9XG59XG5cbi8qKlxuICogRmxhdHRlbnMgY2hpbGRyZW4gdGhhdCBhcmUgdHlwaWNhbGx5IHNwZWNpZmllZCBhcyBgcHJvcHMuY2hpbGRyZW5gLiBBbnkgbnVsbFxuICogY2hpbGRyZW4gd2lsbCBub3QgYmUgaW5jbHVkZWQgaW4gdGhlIHJlc3VsdGluZyBvYmplY3QuXG4gKiBAcmV0dXJuIHshb2JqZWN0fSBmbGF0dGVuZWQgY2hpbGRyZW4ga2V5ZWQgYnkgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmxhdHRlbkNoaWxkcmVuKGNoaWxkcmVuKSB7XG4gIGlmIChjaGlsZHJlbiA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGNoaWxkcmVuO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgdHJhdmVyc2VBbGxDaGlsZHJlbihjaGlsZHJlbiwgZmxhdHRlblNpbmdsZUNoaWxkSW50b0NvbnRleHQsIHJlc3VsdCk7XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZmxhdHRlbkNoaWxkcmVuO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2ZsYXR0ZW5DaGlsZHJlbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBzaGFsbG93RXF1YWxcbiAqIEB0eXBlY2hlY2tzXG4gKiBcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbi8qKlxuICogUGVyZm9ybXMgZXF1YWxpdHkgYnkgaXRlcmF0aW5nIHRocm91Z2gga2V5cyBvbiBhbiBvYmplY3QgYW5kIHJldHVybmluZyBmYWxzZVxuICogd2hlbiBhbnkga2V5IGhhcyB2YWx1ZXMgd2hpY2ggYXJlIG5vdCBzdHJpY3RseSBlcXVhbCBiZXR3ZWVuIHRoZSBhcmd1bWVudHMuXG4gKiBSZXR1cm5zIHRydWUgd2hlbiB0aGUgdmFsdWVzIG9mIGFsbCBrZXlzIGFyZSBzdHJpY3RseSBlcXVhbC5cbiAqL1xuZnVuY3Rpb24gc2hhbGxvd0VxdWFsKG9iakEsIG9iakIpIHtcbiAgaWYgKG9iakEgPT09IG9iakIpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqQSAhPT0gJ29iamVjdCcgfHwgb2JqQSA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqQiAhPT0gJ29iamVjdCcgfHwgb2JqQiA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKG9iakEpO1xuICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhvYmpCKTtcblxuICBpZiAoa2V5c0EubGVuZ3RoICE9PSBrZXlzQi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICAvLyBUZXN0IGZvciBBJ3Mga2V5cyBkaWZmZXJlbnQgZnJvbSBCLlxuICB2YXIgYkhhc093blByb3BlcnR5ID0gaGFzT3duUHJvcGVydHkuYmluZChvYmpCKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzQS5sZW5ndGg7IGkrKykge1xuICAgIGlmICghYkhhc093blByb3BlcnR5KGtleXNBW2ldKSB8fCBvYmpBW2tleXNBW2ldXSAhPT0gb2JqQltrZXlzQVtpXV0pIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaGFsbG93RXF1YWw7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL3NoYWxsb3dFcXVhbC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdEV2ZW50TGlzdGVuZXJcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXZlbnRMaXN0ZW5lciA9IHJlcXVpcmUoJ2ZianMvbGliL0V2ZW50TGlzdGVuZXInKTtcbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG52YXIgUG9vbGVkQ2xhc3MgPSByZXF1aXJlKCcuL1Bvb2xlZENsYXNzJyk7XG52YXIgUmVhY3RJbnN0YW5jZUhhbmRsZXMgPSByZXF1aXJlKCcuL1JlYWN0SW5zdGFuY2VIYW5kbGVzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBnZXRFdmVudFRhcmdldCA9IHJlcXVpcmUoJy4vZ2V0RXZlbnRUYXJnZXQnKTtcbnZhciBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uJyk7XG5cbnZhciBET0NVTUVOVF9GUkFHTUVOVF9OT0RFX1RZUEUgPSAxMTtcblxuLyoqXG4gKiBGaW5kcyB0aGUgcGFyZW50IFJlYWN0IGNvbXBvbmVudCBvZiBgbm9kZWAuXG4gKlxuICogQHBhcmFtIHsqfSBub2RlXG4gKiBAcmV0dXJuIHs/RE9NRXZlbnRUYXJnZXR9IFBhcmVudCBjb250YWluZXIsIG9yIGBudWxsYCBpZiB0aGUgc3BlY2lmaWVkIG5vZGVcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgaXMgbm90IG5lc3RlZC5cbiAqL1xuZnVuY3Rpb24gZmluZFBhcmVudChub2RlKSB7XG4gIC8vIFRPRE86IEl0IG1heSBiZSBhIGdvb2QgaWRlYSB0byBjYWNoZSB0aGlzIHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgRE9NXG4gIC8vIHRyYXZlcnNhbCwgYnV0IGNhY2hpbmcgaXMgZGlmZmljdWx0IHRvIGRvIGNvcnJlY3RseSB3aXRob3V0IHVzaW5nIGFcbiAgLy8gbXV0YXRpb24gb2JzZXJ2ZXIgdG8gbGlzdGVuIGZvciBhbGwgRE9NIGNoYW5nZXMuXG4gIHZhciBub2RlSUQgPSBSZWFjdE1vdW50LmdldElEKG5vZGUpO1xuICB2YXIgcm9vdElEID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuZ2V0UmVhY3RSb290SURGcm9tTm9kZUlEKG5vZGVJRCk7XG4gIHZhciBjb250YWluZXIgPSBSZWFjdE1vdW50LmZpbmRSZWFjdENvbnRhaW5lckZvcklEKHJvb3RJRCk7XG4gIHZhciBwYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY29udGFpbmVyKTtcbiAgcmV0dXJuIHBhcmVudDtcbn1cblxuLy8gVXNlZCB0byBzdG9yZSBhbmNlc3RvciBoaWVyYXJjaHkgaW4gdG9wIGxldmVsIGNhbGxiYWNrXG5mdW5jdGlvbiBUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICB0aGlzLnRvcExldmVsVHlwZSA9IHRvcExldmVsVHlwZTtcbiAgdGhpcy5uYXRpdmVFdmVudCA9IG5hdGl2ZUV2ZW50O1xuICB0aGlzLmFuY2VzdG9ycyA9IFtdO1xufVxuYXNzaWduKFRvcExldmVsQ2FsbGJhY2tCb29rS2VlcGluZy5wcm90b3R5cGUsIHtcbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudG9wTGV2ZWxUeXBlID0gbnVsbDtcbiAgICB0aGlzLm5hdGl2ZUV2ZW50ID0gbnVsbDtcbiAgICB0aGlzLmFuY2VzdG9ycy5sZW5ndGggPSAwO1xuICB9XG59KTtcblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhUb3BMZXZlbENhbGxiYWNrQm9va0tlZXBpbmcsIFBvb2xlZENsYXNzLnR3b0FyZ3VtZW50UG9vbGVyKTtcblxuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxJbXBsKGJvb2tLZWVwaW5nKSB7XG4gIC8vIFRPRE86IFJlLWVuYWJsZSBldmVudC5wYXRoIGhhbmRsaW5nXG4gIC8vXG4gIC8vIGlmIChib29rS2VlcGluZy5uYXRpdmVFdmVudC5wYXRoICYmIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGgubGVuZ3RoID4gMSkge1xuICAvLyAgIC8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9IGVsc2Uge1xuICAvLyAgIC8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuICAvLyAgIGhhbmRsZVRvcExldmVsV2l0aG91dFBhdGgoYm9va0tlZXBpbmcpO1xuICAvLyB9XG5cbiAgdm9pZCBoYW5kbGVUb3BMZXZlbFdpdGhQYXRoOyAvLyB0ZW1wb3JhcmlseSB1bnVzZWRcbiAgaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZyk7XG59XG5cbi8vIExlZ2FjeSBicm93c2VycyBkb24ndCBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRob3V0UGF0aChib29rS2VlcGluZykge1xuICB2YXIgdG9wTGV2ZWxUYXJnZXQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oZ2V0RXZlbnRUYXJnZXQoYm9va0tlZXBpbmcubmF0aXZlRXZlbnQpKSB8fCB3aW5kb3c7XG5cbiAgLy8gTG9vcCB0aHJvdWdoIHRoZSBoaWVyYXJjaHksIGluIGNhc2UgdGhlcmUncyBhbnkgbmVzdGVkIGNvbXBvbmVudHMuXG4gIC8vIEl0J3MgaW1wb3J0YW50IHRoYXQgd2UgYnVpbGQgdGhlIGFycmF5IG9mIGFuY2VzdG9ycyBiZWZvcmUgY2FsbGluZyBhbnlcbiAgLy8gZXZlbnQgaGFuZGxlcnMsIGJlY2F1c2UgZXZlbnQgaGFuZGxlcnMgY2FuIG1vZGlmeSB0aGUgRE9NLCBsZWFkaW5nIHRvXG4gIC8vIGluY29uc2lzdGVuY2llcyB3aXRoIFJlYWN0TW91bnQncyBub2RlIGNhY2hlLiBTZWUgIzExMDUuXG4gIHZhciBhbmNlc3RvciA9IHRvcExldmVsVGFyZ2V0O1xuICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChhbmNlc3Rvcik7XG4gICAgYW5jZXN0b3IgPSBmaW5kUGFyZW50KGFuY2VzdG9yKTtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYm9va0tlZXBpbmcuYW5jZXN0b3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgdG9wTGV2ZWxUYXJnZXQgPSBib29rS2VlcGluZy5hbmNlc3RvcnNbaV07XG4gICAgdmFyIHRvcExldmVsVGFyZ2V0SUQgPSBSZWFjdE1vdW50LmdldElEKHRvcExldmVsVGFyZ2V0KSB8fCAnJztcbiAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbi8vIE5ldyBicm93c2VycyBoYXZlIGEgcGF0aCBhdHRyaWJ1dGUgb24gbmF0aXZlIGV2ZW50c1xuZnVuY3Rpb24gaGFuZGxlVG9wTGV2ZWxXaXRoUGF0aChib29rS2VlcGluZykge1xuICB2YXIgcGF0aCA9IGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LnBhdGg7XG4gIHZhciBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFswXTtcbiAgdmFyIGV2ZW50c0ZpcmVkID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudCA9IHBhdGhbaV07XG4gICAgaWYgKGN1cnJlbnRQYXRoRWxlbWVudC5ub2RlVHlwZSA9PT0gRE9DVU1FTlRfRlJBR01FTlRfTk9ERV9UWVBFKSB7XG4gICAgICBjdXJyZW50TmF0aXZlVGFyZ2V0ID0gcGF0aFtpICsgMV07XG4gICAgfVxuICAgIC8vIFRPRE86IHNsb3dcbiAgICB2YXIgcmVhY3RQYXJlbnQgPSBSZWFjdE1vdW50LmdldEZpcnN0UmVhY3RET00oY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICBpZiAocmVhY3RQYXJlbnQgPT09IGN1cnJlbnRQYXRoRWxlbWVudCkge1xuICAgICAgdmFyIGN1cnJlbnRQYXRoRWxlbWVudElEID0gUmVhY3RNb3VudC5nZXRJRChjdXJyZW50UGF0aEVsZW1lbnQpO1xuICAgICAgdmFyIG5ld1Jvb3RJRCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmdldFJlYWN0Um9vdElERnJvbU5vZGVJRChjdXJyZW50UGF0aEVsZW1lbnRJRCk7XG4gICAgICBib29rS2VlcGluZy5hbmNlc3RvcnMucHVzaChjdXJyZW50UGF0aEVsZW1lbnQpO1xuXG4gICAgICB2YXIgdG9wTGV2ZWxUYXJnZXRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KSB8fCAnJztcbiAgICAgIGV2ZW50c0ZpcmVkKys7XG4gICAgICBSZWFjdEV2ZW50TGlzdGVuZXIuX2hhbmRsZVRvcExldmVsKGJvb2tLZWVwaW5nLnRvcExldmVsVHlwZSwgY3VycmVudFBhdGhFbGVtZW50LCB0b3BMZXZlbFRhcmdldElELCBib29rS2VlcGluZy5uYXRpdmVFdmVudCwgY3VycmVudE5hdGl2ZVRhcmdldCk7XG5cbiAgICAgIC8vIEp1bXAgdG8gdGhlIHJvb3Qgb2YgdGhpcyBSZWFjdCByZW5kZXIgdHJlZVxuICAgICAgd2hpbGUgKGN1cnJlbnRQYXRoRWxlbWVudElEICE9PSBuZXdSb290SUQpIHtcbiAgICAgICAgaSsrO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnQgPSBwYXRoW2ldO1xuICAgICAgICBjdXJyZW50UGF0aEVsZW1lbnRJRCA9IFJlYWN0TW91bnQuZ2V0SUQoY3VycmVudFBhdGhFbGVtZW50KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKGV2ZW50c0ZpcmVkID09PSAwKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbChib29rS2VlcGluZy50b3BMZXZlbFR5cGUsIHdpbmRvdywgJycsIGJvb2tLZWVwaW5nLm5hdGl2ZUV2ZW50LCBnZXRFdmVudFRhcmdldChib29rS2VlcGluZy5uYXRpdmVFdmVudCkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNjcm9sbFZhbHVlTW9uaXRvcihjYikge1xuICB2YXIgc2Nyb2xsUG9zaXRpb24gPSBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbih3aW5kb3cpO1xuICBjYihzY3JvbGxQb3NpdGlvbik7XG59XG5cbnZhciBSZWFjdEV2ZW50TGlzdGVuZXIgPSB7XG4gIF9lbmFibGVkOiB0cnVlLFxuICBfaGFuZGxlVG9wTGV2ZWw6IG51bGwsXG5cbiAgV0lORE9XX0hBTkRMRTogRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gd2luZG93IDogbnVsbCxcblxuICBzZXRIYW5kbGVUb3BMZXZlbDogZnVuY3Rpb24gKGhhbmRsZVRvcExldmVsKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9oYW5kbGVUb3BMZXZlbCA9IGhhbmRsZVRvcExldmVsO1xuICB9LFxuXG4gIHNldEVuYWJsZWQ6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkID0gISFlbmFibGVkO1xuICB9LFxuXG4gIGlzRW5hYmxlZDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBSZWFjdEV2ZW50TGlzdGVuZXIuX2VuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFRyYXBzIHRvcC1sZXZlbCBldmVudHMgYnkgdXNpbmcgZXZlbnQgYnViYmxpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcEJ1YmJsZWRFdmVudDogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgaGFuZGxlckJhc2VOYW1lLCBoYW5kbGUpIHtcbiAgICB2YXIgZWxlbWVudCA9IGhhbmRsZTtcbiAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gRXZlbnRMaXN0ZW5lci5saXN0ZW4oZWxlbWVudCwgaGFuZGxlckJhc2VOYW1lLCBSZWFjdEV2ZW50TGlzdGVuZXIuZGlzcGF0Y2hFdmVudC5iaW5kKG51bGwsIHRvcExldmVsVHlwZSkpO1xuICB9LFxuXG4gIC8qKlxuICAgKiBUcmFwcyBhIHRvcC1sZXZlbCBldmVudCBieSB1c2luZyBldmVudCBjYXB0dXJpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGhhbmRsZXJCYXNlTmFtZSBFdmVudCBuYW1lIChlLmcuIFwiY2xpY2tcIikuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBoYW5kbGUgRWxlbWVudCBvbiB3aGljaCB0byBhdHRhY2ggbGlzdGVuZXIuXG4gICAqIEByZXR1cm4gez9vYmplY3R9IEFuIG9iamVjdCB3aXRoIGEgcmVtb3ZlIGZ1bmN0aW9uIHdoaWNoIHdpbGwgZm9yY2VmdWxseVxuICAgKiAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUgbGlzdGVuZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdHJhcENhcHR1cmVkRXZlbnQ6IGZ1bmN0aW9uICh0b3BMZXZlbFR5cGUsIGhhbmRsZXJCYXNlTmFtZSwgaGFuZGxlKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBoYW5kbGU7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIEV2ZW50TGlzdGVuZXIuY2FwdHVyZShlbGVtZW50LCBoYW5kbGVyQmFzZU5hbWUsIFJlYWN0RXZlbnRMaXN0ZW5lci5kaXNwYXRjaEV2ZW50LmJpbmQobnVsbCwgdG9wTGV2ZWxUeXBlKSk7XG4gIH0sXG5cbiAgbW9uaXRvclNjcm9sbFZhbHVlOiBmdW5jdGlvbiAocmVmcmVzaCkge1xuICAgIHZhciBjYWxsYmFjayA9IHNjcm9sbFZhbHVlTW9uaXRvci5iaW5kKG51bGwsIHJlZnJlc2gpO1xuICAgIEV2ZW50TGlzdGVuZXIubGlzdGVuKHdpbmRvdywgJ3Njcm9sbCcsIGNhbGxiYWNrKTtcbiAgfSxcblxuICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbiAodG9wTGV2ZWxUeXBlLCBuYXRpdmVFdmVudCkge1xuICAgIGlmICghUmVhY3RFdmVudExpc3RlbmVyLl9lbmFibGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJvb2tLZWVwaW5nID0gVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLmdldFBvb2xlZCh0b3BMZXZlbFR5cGUsIG5hdGl2ZUV2ZW50KTtcbiAgICB0cnkge1xuICAgICAgLy8gRXZlbnQgcXVldWUgYmVpbmcgcHJvY2Vzc2VkIGluIHRoZSBzYW1lIGN5Y2xlIGFsbG93c1xuICAgICAgLy8gYHByZXZlbnREZWZhdWx0YC5cbiAgICAgIFJlYWN0VXBkYXRlcy5iYXRjaGVkVXBkYXRlcyhoYW5kbGVUb3BMZXZlbEltcGwsIGJvb2tLZWVwaW5nKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgVG9wTGV2ZWxDYWxsYmFja0Jvb2tLZWVwaW5nLnJlbGVhc2UoYm9va0tlZXBpbmcpO1xuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdEV2ZW50TGlzdGVuZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RFdmVudExpc3RlbmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBFdmVudExpc3RlbmVyXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBVcHN0cmVhbSB2ZXJzaW9uIG9mIGV2ZW50IGxpc3RlbmVyLiBEb2VzIG5vdCB0YWtlIGludG8gYWNjb3VudCBzcGVjaWZpY1xuICogbmF0dXJlIG9mIHBsYXRmb3JtLlxuICovXG52YXIgRXZlbnRMaXN0ZW5lciA9IHtcbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgYnViYmxlIHBoYXNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0RPTUV2ZW50VGFyZ2V0fSB0YXJnZXQgRE9NIGVsZW1lbnQgdG8gcmVnaXN0ZXIgbGlzdGVuZXIgb24uXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGUgRXZlbnQgdHlwZSwgZS5nLiAnY2xpY2snIG9yICdtb3VzZW92ZXInLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFjayBmdW5jdGlvbi5cbiAgICogQHJldHVybiB7b2JqZWN0fSBPYmplY3Qgd2l0aCBhIGByZW1vdmVgIG1ldGhvZC5cbiAgICovXG4gIGxpc3RlbjogZnVuY3Rpb24gKHRhcmdldCwgZXZlbnRUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRUeXBlLCBjYWxsYmFjaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XG4gICAgICB0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50VHlwZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgdGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIExpc3RlbiB0byBET00gZXZlbnRzIGR1cmluZyB0aGUgY2FwdHVyZSBwaGFzZS5cbiAgICpcbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdGFyZ2V0IERPTSBlbGVtZW50IHRvIHJlZ2lzdGVyIGxpc3RlbmVyIG9uLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlIEV2ZW50IHR5cGUsIGUuZy4gJ2NsaWNrJyBvciAnbW91c2VvdmVyJy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqIEByZXR1cm4ge29iamVjdH0gT2JqZWN0IHdpdGggYSBgcmVtb3ZlYCBtZXRob2QuXG4gICAqL1xuICBjYXB0dXJlOiBmdW5jdGlvbiAodGFyZ2V0LCBldmVudFR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRhcmdldC5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudFR5cGUsIGNhbGxiYWNrLCB0cnVlKTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50VHlwZSwgY2FsbGJhY2ssIHRydWUpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdBdHRlbXB0ZWQgdG8gbGlzdGVuIHRvIGV2ZW50cyBkdXJpbmcgdGhlIGNhcHR1cmUgcGhhc2Ugb24gYSAnICsgJ2Jyb3dzZXIgdGhhdCBkb2VzIG5vdCBzdXBwb3J0IHRoZSBjYXB0dXJlIHBoYXNlLiBZb3VyIGFwcGxpY2F0aW9uICcgKyAnd2lsbCBub3QgcmVjZWl2ZSBzb21lIGV2ZW50cy4nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHJlbW92ZTogZW1wdHlGdW5jdGlvblxuICAgICAgfTtcbiAgICB9XG4gIH0sXG5cbiAgcmVnaXN0ZXJEZWZhdWx0OiBmdW5jdGlvbiAoKSB7fVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBFdmVudExpc3RlbmVyO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9FdmVudExpc3RlbmVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uXG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHZXRzIHRoZSBzY3JvbGwgcG9zaXRpb24gb2YgdGhlIHN1cHBsaWVkIGVsZW1lbnQgb3Igd2luZG93LlxuICpcbiAqIFRoZSByZXR1cm4gdmFsdWVzIGFyZSB1bmJvdW5kZWQsIHVubGlrZSBgZ2V0U2Nyb2xsUG9zaXRpb25gLiBUaGlzIG1lYW5zIHRoZXlcbiAqIG1heSBiZSBuZWdhdGl2ZSBvciBleGNlZWQgdGhlIGVsZW1lbnQgYm91bmRhcmllcyAod2hpY2ggaXMgcG9zc2libGUgdXNpbmdcbiAqIGluZXJ0aWFsIHNjcm9sbGluZykuXG4gKlxuICogQHBhcmFtIHtET01XaW5kb3d8RE9NRWxlbWVudH0gc2Nyb2xsYWJsZVxuICogQHJldHVybiB7b2JqZWN0fSBNYXAgd2l0aCBgeGAgYW5kIGB5YCBrZXlzLlxuICovXG5mdW5jdGlvbiBnZXRVbmJvdW5kZWRTY3JvbGxQb3NpdGlvbihzY3JvbGxhYmxlKSB7XG4gIGlmIChzY3JvbGxhYmxlID09PSB3aW5kb3cpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogd2luZG93LnBhZ2VYT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxMZWZ0LFxuICAgICAgeTogd2luZG93LnBhZ2VZT2Zmc2V0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG4gIHJldHVybiB7XG4gICAgeDogc2Nyb2xsYWJsZS5zY3JvbGxMZWZ0LFxuICAgIHk6IHNjcm9sbGFibGUuc2Nyb2xsVG9wXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0VW5ib3VuZGVkU2Nyb2xsUG9zaXRpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL2dldFVuYm91bmRlZFNjcm9sbFBvc2l0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0SW5qZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRE9NUHJvcGVydHkgPSByZXF1aXJlKCcuL0RPTVByb3BlcnR5Jyk7XG52YXIgRXZlbnRQbHVnaW5IdWIgPSByZXF1aXJlKCcuL0V2ZW50UGx1Z2luSHViJyk7XG52YXIgUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnRFbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0Q2xhc3MgPSByZXF1aXJlKCcuL1JlYWN0Q2xhc3MnKTtcbnZhciBSZWFjdEVtcHR5Q29tcG9uZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVtcHR5Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9SZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXInKTtcbnZhciBSZWFjdE5hdGl2ZUNvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3ROYXRpdmVDb21wb25lbnQnKTtcbnZhciBSZWFjdFBlcmYgPSByZXF1aXJlKCcuL1JlYWN0UGVyZicpO1xudmFyIFJlYWN0Um9vdEluZGV4ID0gcmVxdWlyZSgnLi9SZWFjdFJvb3RJbmRleCcpO1xudmFyIFJlYWN0VXBkYXRlcyA9IHJlcXVpcmUoJy4vUmVhY3RVcGRhdGVzJyk7XG5cbnZhciBSZWFjdEluamVjdGlvbiA9IHtcbiAgQ29tcG9uZW50OiBSZWFjdENvbXBvbmVudEVudmlyb25tZW50LmluamVjdGlvbixcbiAgQ2xhc3M6IFJlYWN0Q2xhc3MuaW5qZWN0aW9uLFxuICBET01Qcm9wZXJ0eTogRE9NUHJvcGVydHkuaW5qZWN0aW9uLFxuICBFbXB0eUNvbXBvbmVudDogUmVhY3RFbXB0eUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIEV2ZW50UGx1Z2luSHViOiBFdmVudFBsdWdpbkh1Yi5pbmplY3Rpb24sXG4gIEV2ZW50RW1pdHRlcjogUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyLmluamVjdGlvbixcbiAgTmF0aXZlQ29tcG9uZW50OiBSZWFjdE5hdGl2ZUNvbXBvbmVudC5pbmplY3Rpb24sXG4gIFBlcmY6IFJlYWN0UGVyZi5pbmplY3Rpb24sXG4gIFJvb3RJbmRleDogUmVhY3RSb290SW5kZXguaW5qZWN0aW9uLFxuICBVcGRhdGVzOiBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0SW5qZWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0SW5qZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q2xhc3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENvbXBvbmVudCA9IHJlcXVpcmUoJy4vUmVhY3RDb21wb25lbnQnKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbnMnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMnKTtcbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHJlcXVpcmUoJy4vUmVhY3ROb29wVXBkYXRlUXVldWUnKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIGVtcHR5T2JqZWN0ID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlPYmplY3QnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcbnZhciBrZXlNaXJyb3IgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlNaXJyb3InKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxudmFyIE1JWElOU19LRVkgPSBrZXlPZih7IG1peGluczogbnVsbCB9KTtcblxuLyoqXG4gKiBQb2xpY2llcyB0aGF0IGRlc2NyaWJlIG1ldGhvZHMgaW4gYFJlYWN0Q2xhc3NJbnRlcmZhY2VgLlxuICovXG52YXIgU3BlY1BvbGljeSA9IGtleU1pcnJvcih7XG4gIC8qKlxuICAgKiBUaGVzZSBtZXRob2RzIG1heSBiZSBkZWZpbmVkIG9ubHkgb25jZSBieSB0aGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBvciBtaXhpbi5cbiAgICovXG4gIERFRklORV9PTkNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBtYXkgYmUgZGVmaW5lZCBieSBib3RoIHRoZSBjbGFzcyBzcGVjaWZpY2F0aW9uIGFuZCBtaXhpbnMuXG4gICAqIFN1YnNlcXVlbnQgZGVmaW5pdGlvbnMgd2lsbCBiZSBjaGFpbmVkLiBUaGVzZSBtZXRob2RzIG11c3QgcmV0dXJuIHZvaWQuXG4gICAqL1xuICBERUZJTkVfTUFOWTogbnVsbCxcbiAgLyoqXG4gICAqIFRoZXNlIG1ldGhvZHMgYXJlIG92ZXJyaWRpbmcgdGhlIGJhc2UgY2xhc3MuXG4gICAqL1xuICBPVkVSUklERV9CQVNFOiBudWxsLFxuICAvKipcbiAgICogVGhlc2UgbWV0aG9kcyBhcmUgc2ltaWxhciB0byBERUZJTkVfTUFOWSwgZXhjZXB0IHdlIGFzc3VtZSB0aGV5IHJldHVyblxuICAgKiBvYmplY3RzLiBXZSB0cnkgdG8gbWVyZ2UgdGhlIGtleXMgb2YgdGhlIHJldHVybiB2YWx1ZXMgb2YgYWxsIHRoZSBtaXhlZCBpblxuICAgKiBmdW5jdGlvbnMuIElmIHRoZXJlIGlzIGEga2V5IGNvbmZsaWN0IHdlIHRocm93LlxuICAgKi9cbiAgREVGSU5FX01BTllfTUVSR0VEOiBudWxsXG59KTtcblxudmFyIGluamVjdGVkTWl4aW5zID0gW107XG5cbnZhciB3YXJuZWRTZXRQcm9wcyA9IGZhbHNlO1xuZnVuY3Rpb24gd2FyblNldFByb3BzKCkge1xuICBpZiAoIXdhcm5lZFNldFByb3BzKSB7XG4gICAgd2FybmVkU2V0UHJvcHMgPSB0cnVlO1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnc2V0UHJvcHMoLi4uKSBhbmQgcmVwbGFjZVByb3BzKC4uLikgYXJlIGRlcHJlY2F0ZWQuICcgKyAnSW5zdGVhZCwgY2FsbCByZW5kZXIgYWdhaW4gYXQgdGhlIHRvcCBsZXZlbC4nKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIENvbXBvc2l0ZSBjb21wb25lbnRzIGFyZSBoaWdoZXItbGV2ZWwgY29tcG9uZW50cyB0aGF0IGNvbXBvc2Ugb3RoZXIgY29tcG9zaXRlXG4gKiBvciBuYXRpdmUgY29tcG9uZW50cy5cbiAqXG4gKiBUbyBjcmVhdGUgYSBuZXcgdHlwZSBvZiBgUmVhY3RDbGFzc2AsIHBhc3MgYSBzcGVjaWZpY2F0aW9uIG9mXG4gKiB5b3VyIG5ldyBjbGFzcyB0byBgUmVhY3QuY3JlYXRlQ2xhc3NgLiBUaGUgb25seSByZXF1aXJlbWVudCBvZiB5b3VyIGNsYXNzXG4gKiBzcGVjaWZpY2F0aW9uIGlzIHRoYXQgeW91IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC5cbiAqXG4gKiAgIHZhciBNeUNvbXBvbmVudCA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcbiAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICogICAgICAgcmV0dXJuIDxkaXY+SGVsbG8gV29ybGQ8L2Rpdj47XG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiBUaGUgY2xhc3Mgc3BlY2lmaWNhdGlvbiBzdXBwb3J0cyBhIHNwZWNpZmljIHByb3RvY29sIG9mIG1ldGhvZHMgdGhhdCBoYXZlXG4gKiBzcGVjaWFsIG1lYW5pbmcgKGUuZy4gYHJlbmRlcmApLiBTZWUgYFJlYWN0Q2xhc3NJbnRlcmZhY2VgIGZvclxuICogbW9yZSB0aGUgY29tcHJlaGVuc2l2ZSBwcm90b2NvbC4gQW55IG90aGVyIHByb3BlcnRpZXMgYW5kIG1ldGhvZHMgaW4gdGhlXG4gKiBjbGFzcyBzcGVjaWZpY2F0aW9uIHdpbGwgYmUgYXZhaWxhYmxlIG9uIHRoZSBwcm90b3R5cGUuXG4gKlxuICogQGludGVyZmFjZSBSZWFjdENsYXNzSW50ZXJmYWNlXG4gKiBAaW50ZXJuYWxcbiAqL1xudmFyIFJlYWN0Q2xhc3NJbnRlcmZhY2UgPSB7XG5cbiAgLyoqXG4gICAqIEFuIGFycmF5IG9mIE1peGluIG9iamVjdHMgdG8gaW5jbHVkZSB3aGVuIGRlZmluaW5nIHlvdXIgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7YXJyYXl9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgbWl4aW5zOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBwcm9wZXJ0aWVzIGFuZCBtZXRob2RzIHRoYXQgc2hvdWxkIGJlIGRlZmluZWQgb25cbiAgICogdGhlIGNvbXBvbmVudCdzIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgaXRzIHByb3RvdHlwZSAoc3RhdGljIG1ldGhvZHMpLlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHN0YXRpY3M6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIERlZmluaXRpb24gb2YgcHJvcCB0eXBlcyBmb3IgdGhpcyBjb21wb25lbnQuXG4gICAqXG4gICAqIEB0eXBlIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgcHJvcFR5cGVzOiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBEZWZpbml0aW9uIG9mIGNvbnRleHQgdHlwZXMgZm9yIHRoaXMgY29tcG9uZW50LlxuICAgKlxuICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIGNvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogRGVmaW5pdGlvbiBvZiBjb250ZXh0IHR5cGVzIHRoaXMgY29tcG9uZW50IHNldHMgZm9yIGl0cyBjaGlsZHJlbi5cbiAgICpcbiAgICogQHR5cGUge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjaGlsZENvbnRleHRUeXBlczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IERlZmluaXRpb24gbWV0aG9kcyA9PT09XG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuIFZhbHVlcyBpbiB0aGUgbWFwcGluZyB3aWxsIGJlIHNldCBvblxuICAgKiBgdGhpcy5wcm9wc2AgaWYgdGhhdCBwcm9wIGlzIG5vdCBzcGVjaWZpZWQgKGkuZS4gdXNpbmcgYW4gYGluYCBjaGVjaykuXG4gICAqXG4gICAqIFRoaXMgbWV0aG9kIGlzIGludm9rZWQgYmVmb3JlIGBnZXRJbml0aWFsU3RhdGVgIGFuZCB0aGVyZWZvcmUgY2Fubm90IHJlbHlcbiAgICogb24gYHRoaXMuc3RhdGVgIG9yIHVzZSBgdGhpcy5zZXRTdGF0ZWAuXG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXREZWZhdWx0UHJvcHM6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIG9uY2UgYmVmb3JlIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC4gVGhlIHJldHVybiB2YWx1ZSB3aWxsIGJlIHVzZWRcbiAgICogYXMgdGhlIGluaXRpYWwgdmFsdWUgb2YgYHRoaXMuc3RhdGVgLlxuICAgKlxuICAgKiAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAqICAgICByZXR1cm4ge1xuICAgKiAgICAgICBpc09uOiBmYWxzZSxcbiAgICogICAgICAgZm9vQmF6OiBuZXcgQmF6Rm9vKClcbiAgICogICAgIH1cbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge29iamVjdH1cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBnZXRJbml0aWFsU3RhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTllfTUVSR0VELFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9XG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgZ2V0Q2hpbGRDb250ZXh0OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCxcblxuICAvKipcbiAgICogVXNlcyBwcm9wcyBmcm9tIGB0aGlzLnByb3BzYCBhbmQgc3RhdGUgZnJvbSBgdGhpcy5zdGF0ZWAgdG8gcmVuZGVyIHRoZVxuICAgKiBzdHJ1Y3R1cmUgb2YgdGhlIGNvbXBvbmVudC5cbiAgICpcbiAgICogTm8gZ3VhcmFudGVlcyBhcmUgbWFkZSBhYm91dCB3aGVuIG9yIGhvdyBvZnRlbiB0aGlzIG1ldGhvZCBpcyBpbnZva2VkLCBzb1xuICAgKiBpdCBtdXN0IG5vdCBoYXZlIHNpZGUgZWZmZWN0cy5cbiAgICpcbiAgICogICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgdmFyIG5hbWUgPSB0aGlzLnByb3BzLm5hbWU7XG4gICAqICAgICByZXR1cm4gPGRpdj5IZWxsbywge25hbWV9ITwvZGl2PjtcbiAgICogICB9XG4gICAqXG4gICAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fVxuICAgKiBAbm9zaWRlZWZmZWN0c1xuICAgKiBAcmVxdWlyZWRcbiAgICovXG4gIHJlbmRlcjogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvLyA9PT09IERlbGVnYXRlIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBpcyBpbml0aWFsbHkgY3JlYXRlZCBhbmQgYWJvdXQgdG8gYmUgbW91bnRlZC5cbiAgICogVGhpcyBtYXkgaGF2ZSBzaWRlIGVmZmVjdHMsIGJ1dCBhbnkgZXh0ZXJuYWwgc3Vic2NyaXB0aW9ucyBvciBkYXRhIGNyZWF0ZWRcbiAgICogYnkgdGhpcyBtZXRob2QgbXVzdCBiZSBjbGVhbmVkIHVwIGluIGBjb21wb25lbnRXaWxsVW5tb3VudGAuXG4gICAqXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbE1vdW50OiBTcGVjUG9saWN5LkRFRklORV9NQU5ZLFxuXG4gIC8qKlxuICAgKiBJbnZva2VkIHdoZW4gdGhlIGNvbXBvbmVudCBoYXMgYmVlbiBtb3VudGVkIGFuZCBoYXMgYSBET00gcmVwcmVzZW50YXRpb24uXG4gICAqIEhvd2V2ZXIsIHRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IHRoZSBET00gbm9kZSBpcyBpbiB0aGUgZG9jdW1lbnQuXG4gICAqXG4gICAqIFVzZSB0aGlzIGFzIGFuIG9wcG9ydHVuaXR5IHRvIG9wZXJhdGUgb24gdGhlIERPTSB3aGVuIHRoZSBjb21wb25lbnQgaGFzXG4gICAqIGJlZW4gbW91bnRlZCAoaW5pdGlhbGl6ZWQgYW5kIHJlbmRlcmVkKSBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RE9NRWxlbWVudH0gcm9vdE5vZGUgRE9NIGVsZW1lbnQgcmVwcmVzZW50aW5nIHRoZSBjb21wb25lbnQuXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50RGlkTW91bnQ6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgYmVmb3JlIHRoZSBjb21wb25lbnQgcmVjZWl2ZXMgbmV3IHByb3BzLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byByZWFjdCB0byBhIHByb3AgdHJhbnNpdGlvbiBieSB1cGRhdGluZyB0aGVcbiAgICogc3RhdGUgdXNpbmcgYHRoaXMuc2V0U3RhdGVgLiBDdXJyZW50IHByb3BzIGFyZSBhY2Nlc3NlZCB2aWEgYHRoaXMucHJvcHNgLlxuICAgKlxuICAgKiAgIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uKG5leHRQcm9wcywgbmV4dENvbnRleHQpIHtcbiAgICogICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgKiAgICAgICBsaWtlc0luY3JlYXNpbmc6IG5leHRQcm9wcy5saWtlQ291bnQgPiB0aGlzLnByb3BzLmxpa2VDb3VudFxuICAgKiAgICAgfSk7XG4gICAqICAgfVxuICAgKlxuICAgKiBOT1RFOiBUaGVyZSBpcyBubyBlcXVpdmFsZW50IGBjb21wb25lbnRXaWxsUmVjZWl2ZVN0YXRlYC4gQW4gaW5jb21pbmcgcHJvcFxuICAgKiB0cmFuc2l0aW9uIG1heSBjYXVzZSBhIHN0YXRlIGNoYW5nZSwgYnV0IHRoZSBvcHBvc2l0ZSBpcyBub3QgdHJ1ZS4gSWYgeW91XG4gICAqIG5lZWQgaXQsIHlvdSBhcmUgcHJvYmFibHkgbG9va2luZyBmb3IgYGNvbXBvbmVudFdpbGxVcGRhdGVgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmV4dFByb3BzXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wczogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGlsZSBkZWNpZGluZyBpZiB0aGUgY29tcG9uZW50IHNob3VsZCBiZSB1cGRhdGVkIGFzIGEgcmVzdWx0IG9mXG4gICAqIHJlY2VpdmluZyBuZXcgcHJvcHMsIHN0YXRlIGFuZC9vciBjb250ZXh0LlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBgcmV0dXJuIGZhbHNlYCB3aGVuIHlvdSdyZSBjZXJ0YWluIHRoYXQgdGhlXG4gICAqIHRyYW5zaXRpb24gdG8gdGhlIG5ldyBwcm9wcy9zdGF0ZS9jb250ZXh0IHdpbGwgbm90IHJlcXVpcmUgYSBjb21wb25lbnRcbiAgICogdXBkYXRlLlxuICAgKlxuICAgKiAgIHNob3VsZENvbXBvbmVudFVwZGF0ZTogZnVuY3Rpb24obmV4dFByb3BzLCBuZXh0U3RhdGUsIG5leHRDb250ZXh0KSB7XG4gICAqICAgICByZXR1cm4gIWVxdWFsKG5leHRQcm9wcywgdGhpcy5wcm9wcykgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRTdGF0ZSwgdGhpcy5zdGF0ZSkgfHxcbiAgICogICAgICAgIWVxdWFsKG5leHRDb250ZXh0LCB0aGlzLmNvbnRleHQpO1xuICAgKiAgIH1cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IG5leHRQcm9wc1xuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRTdGF0ZVxuICAgKiBAcGFyYW0gez9vYmplY3R9IG5leHRDb250ZXh0XG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdGhlIGNvbXBvbmVudCBzaG91bGQgdXBkYXRlLlxuICAgKiBAb3B0aW9uYWxcbiAgICovXG4gIHNob3VsZENvbXBvbmVudFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfT05DRSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQgaXMgYWJvdXQgdG8gdXBkYXRlIGR1ZSB0byBhIHRyYW5zaXRpb24gZnJvbVxuICAgKiBgdGhpcy5wcm9wc2AsIGB0aGlzLnN0YXRlYCBhbmQgYHRoaXMuY29udGV4dGAgdG8gYG5leHRQcm9wc2AsIGBuZXh0U3RhdGVgXG4gICAqIGFuZCBgbmV4dENvbnRleHRgLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBwZXJmb3JtIHByZXBhcmF0aW9uIGJlZm9yZSBhbiB1cGRhdGUgb2NjdXJzLlxuICAgKlxuICAgKiBOT1RFOiBZb3UgKipjYW5ub3QqKiB1c2UgYHRoaXMuc2V0U3RhdGUoKWAgaW4gdGhpcyBtZXRob2QuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXh0UHJvcHNcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0U3RhdGVcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBuZXh0Q29udGV4dFxuICAgKiBAcGFyYW0ge1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb259IHRyYW5zYWN0aW9uXG4gICAqIEBvcHRpb25hbFxuICAgKi9cbiAgY29tcG9uZW50V2lsbFVwZGF0ZTogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvKipcbiAgICogSW52b2tlZCB3aGVuIHRoZSBjb21wb25lbnQncyBET00gcmVwcmVzZW50YXRpb24gaGFzIGJlZW4gdXBkYXRlZC5cbiAgICpcbiAgICogVXNlIHRoaXMgYXMgYW4gb3Bwb3J0dW5pdHkgdG8gb3BlcmF0ZSBvbiB0aGUgRE9NIHdoZW4gdGhlIGNvbXBvbmVudCBoYXNcbiAgICogYmVlbiB1cGRhdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJldlByb3BzXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldlN0YXRlXG4gICAqIEBwYXJhbSB7P29iamVjdH0gcHJldkNvbnRleHRcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSByb290Tm9kZSBET00gZWxlbWVudCByZXByZXNlbnRpbmcgdGhlIGNvbXBvbmVudC5cbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnREaWRVcGRhdGU6IFNwZWNQb2xpY3kuREVGSU5FX01BTlksXG5cbiAgLyoqXG4gICAqIEludm9rZWQgd2hlbiB0aGUgY29tcG9uZW50IGlzIGFib3V0IHRvIGJlIHJlbW92ZWQgZnJvbSBpdHMgcGFyZW50IGFuZCBoYXZlXG4gICAqIGl0cyBET00gcmVwcmVzZW50YXRpb24gZGVzdHJveWVkLlxuICAgKlxuICAgKiBVc2UgdGhpcyBhcyBhbiBvcHBvcnR1bml0eSB0byBkZWFsbG9jYXRlIGFueSBleHRlcm5hbCByZXNvdXJjZXMuXG4gICAqXG4gICAqIE5PVEU6IFRoZXJlIGlzIG5vIGBjb21wb25lbnREaWRVbm1vdW50YCBzaW5jZSB5b3VyIGNvbXBvbmVudCB3aWxsIGhhdmUgYmVlblxuICAgKiBkZXN0cm95ZWQgYnkgdGhhdCBwb2ludC5cbiAgICpcbiAgICogQG9wdGlvbmFsXG4gICAqL1xuICBjb21wb25lbnRXaWxsVW5tb3VudDogU3BlY1BvbGljeS5ERUZJTkVfTUFOWSxcblxuICAvLyA9PT09IEFkdmFuY2VkIG1ldGhvZHMgPT09PVxuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQncyBjdXJyZW50bHkgbW91bnRlZCBET00gcmVwcmVzZW50YXRpb24uXG4gICAqXG4gICAqIEJ5IGRlZmF1bHQsIHRoaXMgaW1wbGVtZW50cyBSZWFjdCdzIHJlbmRlcmluZyBhbmQgcmVjb25jaWxpYXRpb24gYWxnb3JpdGhtLlxuICAgKiBTb3BoaXN0aWNhdGVkIGNsaWVudHMgbWF5IHdpc2ggdG8gb3ZlcnJpZGUgdGhpcy5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9ufSB0cmFuc2FjdGlvblxuICAgKiBAaW50ZXJuYWxcbiAgICogQG92ZXJyaWRhYmxlXG4gICAqL1xuICB1cGRhdGVDb21wb25lbnQ6IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRVxuXG59O1xuXG4vKipcbiAqIE1hcHBpbmcgZnJvbSBjbGFzcyBzcGVjaWZpY2F0aW9uIGtleXMgdG8gc3BlY2lhbCBwcm9jZXNzaW5nIGZ1bmN0aW9ucy5cbiAqXG4gKiBBbHRob3VnaCB0aGVzZSBhcmUgZGVjbGFyZWQgbGlrZSBpbnN0YW5jZSBwcm9wZXJ0aWVzIGluIHRoZSBzcGVjaWZpY2F0aW9uXG4gKiB3aGVuIGRlZmluaW5nIGNsYXNzZXMgdXNpbmcgYFJlYWN0LmNyZWF0ZUNsYXNzYCwgdGhleSBhcmUgYWN0dWFsbHkgc3RhdGljXG4gKiBhbmQgYXJlIGFjY2Vzc2libGUgb24gdGhlIGNvbnN0cnVjdG9yIGluc3RlYWQgb2YgdGhlIHByb3RvdHlwZS4gRGVzcGl0ZVxuICogYmVpbmcgc3RhdGljLCB0aGV5IG11c3QgYmUgZGVmaW5lZCBvdXRzaWRlIG9mIHRoZSBcInN0YXRpY3NcIiBrZXkgdW5kZXJcbiAqIHdoaWNoIGFsbCBvdGhlciBzdGF0aWMgbWV0aG9kcyBhcmUgZGVmaW5lZC5cbiAqL1xudmFyIFJFU0VSVkVEX1NQRUNfS0VZUyA9IHtcbiAgZGlzcGxheU5hbWU6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgZGlzcGxheU5hbWUpIHtcbiAgICBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSA9IGRpc3BsYXlOYW1lO1xuICB9LFxuICBtaXhpbnM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgbWl4aW5zKSB7XG4gICAgaWYgKG1peGlucykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaXhpbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbWl4U3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIG1peGluc1tpXSk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuICBjaGlsZENvbnRleHRUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBjaGlsZENvbnRleHRUeXBlcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIGNoaWxkQ29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNoaWxkQ29udGV4dCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLmNoaWxkQ29udGV4dFR5cGVzID0gYXNzaWduKHt9LCBDb25zdHJ1Y3Rvci5jaGlsZENvbnRleHRUeXBlcywgY2hpbGRDb250ZXh0VHlwZXMpO1xuICB9LFxuICBjb250ZXh0VHlwZXM6IGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhbGlkYXRlVHlwZURlZihDb25zdHJ1Y3RvciwgY29udGV4dFR5cGVzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLmNvbnRleHQpO1xuICAgIH1cbiAgICBDb25zdHJ1Y3Rvci5jb250ZXh0VHlwZXMgPSBhc3NpZ24oe30sIENvbnN0cnVjdG9yLmNvbnRleHRUeXBlcywgY29udGV4dFR5cGVzKTtcbiAgfSxcbiAgLyoqXG4gICAqIFNwZWNpYWwgY2FzZSBnZXREZWZhdWx0UHJvcHMgd2hpY2ggc2hvdWxkIG1vdmUgaW50byBzdGF0aWNzIGJ1dCByZXF1aXJlc1xuICAgKiBhdXRvbWF0aWMgbWVyZ2luZy5cbiAgICovXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBnZXREZWZhdWx0UHJvcHMpIHtcbiAgICBpZiAoQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzKSB7XG4gICAgICBDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMgPSBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMsIGdldERlZmF1bHRQcm9wcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcyA9IGdldERlZmF1bHRQcm9wcztcbiAgICB9XG4gIH0sXG4gIHByb3BUeXBlczogZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFsaWRhdGVUeXBlRGVmKENvbnN0cnVjdG9yLCBwcm9wVHlwZXMsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbnMucHJvcCk7XG4gICAgfVxuICAgIENvbnN0cnVjdG9yLnByb3BUeXBlcyA9IGFzc2lnbih7fSwgQ29uc3RydWN0b3IucHJvcFR5cGVzLCBwcm9wVHlwZXMpO1xuICB9LFxuICBzdGF0aWNzOiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgICBtaXhTdGF0aWNTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3RhdGljcyk7XG4gIH0sXG4gIGF1dG9iaW5kOiBmdW5jdGlvbiAoKSB7fSB9O1xuXG4vLyBub29wXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVEZWYoQ29uc3RydWN0b3IsIHR5cGVEZWYsIGxvY2F0aW9uKSB7XG4gIGZvciAodmFyIHByb3BOYW1lIGluIHR5cGVEZWYpIHtcbiAgICBpZiAodHlwZURlZi5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgIC8vIHVzZSBhIHdhcm5pbmcgaW5zdGVhZCBvZiBhbiBpbnZhcmlhbnQgc28gY29tcG9uZW50c1xuICAgICAgLy8gZG9uJ3Qgc2hvdyB1cCBpbiBwcm9kIGJ1dCBub3QgaW4gX19ERVZfX1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodHlwZW9mIHR5cGVEZWZbcHJvcE5hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ1JlYWN0LlByb3BUeXBlcy4nLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDbGFzcycsIFJlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzW2xvY2F0aW9uXSwgcHJvcE5hbWUpIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKSB7XG4gIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IFJlYWN0Q2xhc3NJbnRlcmZhY2VbbmFtZV0gOiBudWxsO1xuXG4gIC8vIERpc2FsbG93IG92ZXJyaWRpbmcgb2YgYmFzZSBjbGFzcyBtZXRob2RzIHVubGVzcyBleHBsaWNpdGx5IGFsbG93ZWQuXG4gIGlmIChSZWFjdENsYXNzTWl4aW4uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuT1ZFUlJJREVfQkFTRSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzc0ludGVyZmFjZTogWW91IGFyZSBhdHRlbXB0aW5nIHRvIG92ZXJyaWRlICcgKyAnYCVzYCBmcm9tIHlvdXIgY2xhc3Mgc3BlY2lmaWNhdGlvbi4gRW5zdXJlIHRoYXQgeW91ciBtZXRob2QgbmFtZXMgJyArICdkbyBub3Qgb3ZlcmxhcCB3aXRoIFJlYWN0IG1ldGhvZHMuJywgbmFtZSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLy8gRGlzYWxsb3cgZGVmaW5pbmcgbWV0aG9kcyBtb3JlIHRoYW4gb25jZSB1bmxlc3MgZXhwbGljaXRseSBhbGxvd2VkLlxuICBpZiAocHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAhKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkgfHwgc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3NJbnRlcmZhY2U6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgJyArICdgJXNgIG9uIHlvdXIgY29tcG9uZW50IG1vcmUgdGhhbiBvbmNlLiBUaGlzIGNvbmZsaWN0IG1heSBiZSBkdWUgJyArICd0byBhIG1peGluLicsIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIE1peGluIGhlbHBlciB3aGljaCBoYW5kbGVzIHBvbGljeSB2YWxpZGF0aW9uIGFuZCByZXNlcnZlZFxuICogc3BlY2lmaWNhdGlvbiBrZXlzIHdoZW4gYnVpbGRpbmcgUmVhY3QgY2xhc3NzZXMuXG4gKi9cbmZ1bmN0aW9uIG1peFNwZWNJbnRvQ29tcG9uZW50KENvbnN0cnVjdG9yLCBzcGVjKSB7XG4gIGlmICghc3BlYykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gICEodHlwZW9mIHNwZWMgIT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArICd1c2UgYSBjb21wb25lbnQgY2xhc3MgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICEhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHNwZWMpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdVxcJ3JlIGF0dGVtcHRpbmcgdG8gJyArICd1c2UgYSBjb21wb25lbnQgYXMgYSBtaXhpbi4gSW5zdGVhZCwganVzdCB1c2UgYSByZWd1bGFyIG9iamVjdC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHByb3RvID0gQ29uc3RydWN0b3IucHJvdG90eXBlO1xuXG4gIC8vIEJ5IGhhbmRsaW5nIG1peGlucyBiZWZvcmUgYW55IG90aGVyIHByb3BlcnRpZXMsIHdlIGVuc3VyZSB0aGUgc2FtZVxuICAvLyBjaGFpbmluZyBvcmRlciBpcyBhcHBsaWVkIHRvIG1ldGhvZHMgd2l0aCBERUZJTkVfTUFOWSBwb2xpY3ksIHdoZXRoZXJcbiAgLy8gbWl4aW5zIGFyZSBsaXN0ZWQgYmVmb3JlIG9yIGFmdGVyIHRoZXNlIG1ldGhvZHMgaW4gdGhlIHNwZWMuXG4gIGlmIChzcGVjLmhhc093blByb3BlcnR5KE1JWElOU19LRVkpKSB7XG4gICAgUkVTRVJWRURfU1BFQ19LRVlTLm1peGlucyhDb25zdHJ1Y3Rvciwgc3BlYy5taXhpbnMpO1xuICB9XG5cbiAgZm9yICh2YXIgbmFtZSBpbiBzcGVjKSB7XG4gICAgaWYgKCFzcGVjLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAobmFtZSA9PT0gTUlYSU5TX0tFWSkge1xuICAgICAgLy8gV2UgaGF2ZSBhbHJlYWR5IGhhbmRsZWQgbWl4aW5zIGluIGEgc3BlY2lhbCBjYXNlIGFib3ZlLlxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIHByb3BlcnR5ID0gc3BlY1tuYW1lXTtcbiAgICB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlKHByb3RvLCBuYW1lKTtcblxuICAgIGlmIChSRVNFUlZFRF9TUEVDX0tFWVMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIFJFU0VSVkVEX1NQRUNfS0VZU1tuYW1lXShDb25zdHJ1Y3RvciwgcHJvcGVydHkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBTZXR1cCBtZXRob2RzIG9uIHByb3RvdHlwZTpcbiAgICAgIC8vIFRoZSBmb2xsb3dpbmcgbWVtYmVyIG1ldGhvZHMgc2hvdWxkIG5vdCBiZSBhdXRvbWF0aWNhbGx5IGJvdW5kOlxuICAgICAgLy8gMS4gRXhwZWN0ZWQgUmVhY3RDbGFzcyBtZXRob2RzIChpbiB0aGUgXCJpbnRlcmZhY2VcIikuXG4gICAgICAvLyAyLiBPdmVycmlkZGVuIG1ldGhvZHMgKHRoYXQgd2VyZSBtaXhlZCBpbikuXG4gICAgICB2YXIgaXNSZWFjdENsYXNzTWV0aG9kID0gUmVhY3RDbGFzc0ludGVyZmFjZS5oYXNPd25Qcm9wZXJ0eShuYW1lKTtcbiAgICAgIHZhciBpc0FscmVhZHlEZWZpbmVkID0gcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSk7XG4gICAgICB2YXIgaXNGdW5jdGlvbiA9IHR5cGVvZiBwcm9wZXJ0eSA9PT0gJ2Z1bmN0aW9uJztcbiAgICAgIHZhciBzaG91bGRBdXRvQmluZCA9IGlzRnVuY3Rpb24gJiYgIWlzUmVhY3RDbGFzc01ldGhvZCAmJiAhaXNBbHJlYWR5RGVmaW5lZCAmJiBzcGVjLmF1dG9iaW5kICE9PSBmYWxzZTtcblxuICAgICAgaWYgKHNob3VsZEF1dG9CaW5kKSB7XG4gICAgICAgIGlmICghcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwKSB7XG4gICAgICAgICAgcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcHJvdG8uX19yZWFjdEF1dG9CaW5kTWFwW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoaXNBbHJlYWR5RGVmaW5lZCkge1xuICAgICAgICAgIHZhciBzcGVjUG9saWN5ID0gUmVhY3RDbGFzc0ludGVyZmFjZVtuYW1lXTtcblxuICAgICAgICAgIC8vIFRoZXNlIGNhc2VzIHNob3VsZCBhbHJlYWR5IGJlIGNhdWdodCBieSB2YWxpZGF0ZU1ldGhvZE92ZXJyaWRlLlxuICAgICAgICAgICEoaXNSZWFjdENsYXNzTWV0aG9kICYmIChzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZX01FUkdFRCB8fCBzcGVjUG9saWN5ID09PSBTcGVjUG9saWN5LkRFRklORV9NQU5ZKSkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnUmVhY3RDbGFzczogVW5leHBlY3RlZCBzcGVjIHBvbGljeSAlcyBmb3Iga2V5ICVzICcgKyAnd2hlbiBtaXhpbmcgaW4gY29tcG9uZW50IHNwZWNzLicsIHNwZWNQb2xpY3ksIG5hbWUpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIC8vIEZvciBtZXRob2RzIHdoaWNoIGFyZSBkZWZpbmVkIG1vcmUgdGhhbiBvbmNlLCBjYWxsIHRoZSBleGlzdGluZ1xuICAgICAgICAgIC8vIG1ldGhvZHMgYmVmb3JlIGNhbGxpbmcgdGhlIG5ldyBwcm9wZXJ0eSwgbWVyZ2luZyBpZiBhcHByb3ByaWF0ZS5cbiAgICAgICAgICBpZiAoc3BlY1BvbGljeSA9PT0gU3BlY1BvbGljeS5ERUZJTkVfTUFOWV9NRVJHRUQpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlTWVyZ2VkUmVzdWx0RnVuY3Rpb24ocHJvdG9bbmFtZV0sIHByb3BlcnR5KTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHNwZWNQb2xpY3kgPT09IFNwZWNQb2xpY3kuREVGSU5FX01BTlkpIHtcbiAgICAgICAgICAgIHByb3RvW25hbWVdID0gY3JlYXRlQ2hhaW5lZEZ1bmN0aW9uKHByb3RvW25hbWVdLCBwcm9wZXJ0eSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvW25hbWVdID0gcHJvcGVydHk7XG4gICAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAgIC8vIEFkZCB2ZXJib3NlIGRpc3BsYXlOYW1lIHRvIHRoZSBmdW5jdGlvbiwgd2hpY2ggaGVscHMgd2hlbiBsb29raW5nXG4gICAgICAgICAgICAvLyBhdCBwcm9maWxpbmcgdG9vbHMuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3BlcnR5ID09PSAnZnVuY3Rpb24nICYmIHNwZWMuZGlzcGxheU5hbWUpIHtcbiAgICAgICAgICAgICAgcHJvdG9bbmFtZV0uZGlzcGxheU5hbWUgPSBzcGVjLmRpc3BsYXlOYW1lICsgJ18nICsgbmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gbWl4U3RhdGljU3BlY0ludG9Db21wb25lbnQoQ29uc3RydWN0b3IsIHN0YXRpY3MpIHtcbiAgaWYgKCFzdGF0aWNzKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAodmFyIG5hbWUgaW4gc3RhdGljcykge1xuICAgIHZhciBwcm9wZXJ0eSA9IHN0YXRpY3NbbmFtZV07XG4gICAgaWYgKCFzdGF0aWNzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgaXNSZXNlcnZlZCA9IChuYW1lIGluIFJFU0VSVkVEX1NQRUNfS0VZUyk7XG4gICAgISFpc1Jlc2VydmVkID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ1JlYWN0Q2xhc3M6IFlvdSBhcmUgYXR0ZW1wdGluZyB0byBkZWZpbmUgYSByZXNlcnZlZCAnICsgJ3Byb3BlcnR5LCBgJXNgLCB0aGF0IHNob3VsZG5cXCd0IGJlIG9uIHRoZSBcInN0YXRpY3NcIiBrZXkuIERlZmluZSBpdCAnICsgJ2FzIGFuIGluc3RhbmNlIHByb3BlcnR5IGluc3RlYWQ7IGl0IHdpbGwgc3RpbGwgYmUgYWNjZXNzaWJsZSBvbiB0aGUgJyArICdjb25zdHJ1Y3Rvci4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgaXNJbmhlcml0ZWQgPSAobmFtZSBpbiBDb25zdHJ1Y3Rvcik7XG4gICAgISFpc0luaGVyaXRlZCA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdSZWFjdENsYXNzOiBZb3UgYXJlIGF0dGVtcHRpbmcgdG8gZGVmaW5lICcgKyAnYCVzYCBvbiB5b3VyIGNvbXBvbmVudCBtb3JlIHRoYW4gb25jZS4gVGhpcyBjb25mbGljdCBtYXkgYmUgJyArICdkdWUgdG8gYSBtaXhpbi4nLCBuYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgQ29uc3RydWN0b3JbbmFtZV0gPSBwcm9wZXJ0eTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvYmplY3RzLCBidXQgdGhyb3cgaWYgYm90aCBjb250YWluIHRoZSBzYW1lIGtleS5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gb25lIFRoZSBmaXJzdCBvYmplY3QsIHdoaWNoIGlzIG11dGF0ZWQuXG4gKiBAcGFyYW0ge29iamVjdH0gdHdvIFRoZSBzZWNvbmQgb2JqZWN0XG4gKiBAcmV0dXJuIHtvYmplY3R9IG9uZSBhZnRlciBpdCBoYXMgYmVlbiBtdXRhdGVkIHRvIGNvbnRhaW4gZXZlcnl0aGluZyBpbiB0d28uXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSW50b1dpdGhOb0R1cGxpY2F0ZUtleXMob25lLCB0d28pIHtcbiAgIShvbmUgJiYgdHdvICYmIHR5cGVvZiBvbmUgPT09ICdvYmplY3QnICYmIHR5cGVvZiB0d28gPT09ICdvYmplY3QnKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6IENhbm5vdCBtZXJnZSBub24tb2JqZWN0cy4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgZm9yICh2YXIga2V5IGluIHR3bykge1xuICAgIGlmICh0d28uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgIShvbmVba2V5XSA9PT0gdW5kZWZpbmVkKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKCk6ICcgKyAnVHJpZWQgdG8gbWVyZ2UgdHdvIG9iamVjdHMgd2l0aCB0aGUgc2FtZSBrZXk6IGAlc2AuIFRoaXMgY29uZmxpY3QgJyArICdtYXkgYmUgZHVlIHRvIGEgbWl4aW47IGluIHBhcnRpY3VsYXIsIHRoaXMgbWF5IGJlIGNhdXNlZCBieSB0d28gJyArICdnZXRJbml0aWFsU3RhdGUoKSBvciBnZXREZWZhdWx0UHJvcHMoKSBtZXRob2RzIHJldHVybmluZyBvYmplY3RzICcgKyAnd2l0aCBjbGFzaGluZyBrZXlzLicsIGtleSkgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICAgICAgb25lW2tleV0gPSB0d29ba2V5XTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9uZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHR3byBmdW5jdGlvbnMgYW5kIG1lcmdlcyB0aGVpciByZXR1cm4gdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IG9uZSBGdW5jdGlvbiB0byBpbnZva2UgZmlyc3QuXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSB0d28gRnVuY3Rpb24gdG8gaW52b2tlIHNlY29uZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBGdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIHR3byBhcmd1bWVudCBmdW5jdGlvbnMuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjcmVhdGVNZXJnZWRSZXN1bHRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkUmVzdWx0KCkge1xuICAgIHZhciBhID0gb25lLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgdmFyIGIgPSB0d28uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBpZiAoYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYjtcbiAgICB9IGVsc2UgaWYgKGIgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIHZhciBjID0ge307XG4gICAgbWVyZ2VJbnRvV2l0aE5vRHVwbGljYXRlS2V5cyhjLCBhKTtcbiAgICBtZXJnZUludG9XaXRoTm9EdXBsaWNhdGVLZXlzKGMsIGIpO1xuICAgIHJldHVybiBjO1xuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdHdvIGZ1bmN0aW9ucyBhbmQgaWdub3JlcyB0aGVpciByZXR1cm4gdmFsZXMuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbn0gb25lIEZ1bmN0aW9uIHRvIGludm9rZSBmaXJzdC5cbiAqIEBwYXJhbSB7ZnVuY3Rpb259IHR3byBGdW5jdGlvbiB0byBpbnZva2Ugc2Vjb25kLlxuICogQHJldHVybiB7ZnVuY3Rpb259IEZ1bmN0aW9uIHRoYXQgaW52b2tlcyB0aGUgdHdvIGFyZ3VtZW50IGZ1bmN0aW9ucy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNoYWluZWRGdW5jdGlvbihvbmUsIHR3bykge1xuICByZXR1cm4gZnVuY3Rpb24gY2hhaW5lZEZ1bmN0aW9uKCkge1xuICAgIG9uZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIHR3by5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICB9O1xufVxuXG4vKipcbiAqIEJpbmRzIGEgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbXBvbmVudCBDb21wb25lbnQgd2hvc2UgbWV0aG9kIGlzIGdvaW5nIHRvIGJlIGJvdW5kLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gbWV0aG9kIE1ldGhvZCB0byBiZSBib3VuZC5cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgYm91bmQgbWV0aG9kLlxuICovXG5mdW5jdGlvbiBiaW5kQXV0b0JpbmRNZXRob2QoY29tcG9uZW50LCBtZXRob2QpIHtcbiAgdmFyIGJvdW5kTWV0aG9kID0gbWV0aG9kLmJpbmQoY29tcG9uZW50KTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgIGJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZE1ldGhvZCA9IG1ldGhvZDtcbiAgICBib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRBcmd1bWVudHMgPSBudWxsO1xuICAgIHZhciBjb21wb25lbnROYW1lID0gY29tcG9uZW50LmNvbnN0cnVjdG9yLmRpc3BsYXlOYW1lO1xuICAgIHZhciBfYmluZCA9IGJvdW5kTWV0aG9kLmJpbmQ7XG4gICAgLyogZXNsaW50LWRpc2FibGUgYmxvY2stc2NvcGVkLXZhciwgbm8tdW5kZWYgKi9cbiAgICBib3VuZE1ldGhvZC5iaW5kID0gZnVuY3Rpb24gKG5ld1RoaXMpIHtcbiAgICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgICBhcmdzW19rZXkgLSAxXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgLy8gVXNlciBpcyB0cnlpbmcgdG8gYmluZCgpIGFuIGF1dG9ib3VuZCBtZXRob2Q7IHdlIGVmZmVjdGl2ZWx5IHdpbGxcbiAgICAgIC8vIGlnbm9yZSB0aGUgdmFsdWUgb2YgXCJ0aGlzXCIgdGhhdCB0aGUgdXNlciBpcyB0cnlpbmcgdG8gdXNlLCBzb1xuICAgICAgLy8gbGV0J3Mgd2Fybi5cbiAgICAgIGlmIChuZXdUaGlzICE9PSBjb21wb25lbnQgJiYgbmV3VGhpcyAhPT0gbnVsbCkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ2JpbmQoKTogUmVhY3QgY29tcG9uZW50IG1ldGhvZHMgbWF5IG9ubHkgYmUgYm91bmQgdG8gdGhlICcgKyAnY29tcG9uZW50IGluc3RhbmNlLiBTZWUgJXMnLCBjb21wb25lbnROYW1lKSA6IHVuZGVmaW5lZDtcbiAgICAgIH0gZWxzZSBpZiAoIWFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnYmluZCgpOiBZb3UgYXJlIGJpbmRpbmcgYSBjb21wb25lbnQgbWV0aG9kIHRvIHRoZSBjb21wb25lbnQuICcgKyAnUmVhY3QgZG9lcyB0aGlzIGZvciB5b3UgYXV0b21hdGljYWxseSBpbiBhIGhpZ2gtcGVyZm9ybWFuY2UgJyArICd3YXksIHNvIHlvdSBjYW4gc2FmZWx5IHJlbW92ZSB0aGlzIGNhbGwuIFNlZSAlcycsIGNvbXBvbmVudE5hbWUpIDogdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gYm91bmRNZXRob2Q7XG4gICAgICB9XG4gICAgICB2YXIgcmVib3VuZE1ldGhvZCA9IF9iaW5kLmFwcGx5KGJvdW5kTWV0aG9kLCBhcmd1bWVudHMpO1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRDb250ZXh0ID0gY29tcG9uZW50O1xuICAgICAgcmVib3VuZE1ldGhvZC5fX3JlYWN0Qm91bmRNZXRob2QgPSBtZXRob2Q7XG4gICAgICByZWJvdW5kTWV0aG9kLl9fcmVhY3RCb3VuZEFyZ3VtZW50cyA9IGFyZ3M7XG4gICAgICByZXR1cm4gcmVib3VuZE1ldGhvZDtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgKi9cbiAgICB9O1xuICB9XG4gIHJldHVybiBib3VuZE1ldGhvZDtcbn1cblxuLyoqXG4gKiBCaW5kcyBhbGwgYXV0by1ib3VuZCBtZXRob2RzIGluIGEgY29tcG9uZW50LlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb21wb25lbnQgQ29tcG9uZW50IHdob3NlIG1ldGhvZCBpcyBnb2luZyB0byBiZSBib3VuZC5cbiAqL1xuZnVuY3Rpb24gYmluZEF1dG9CaW5kTWV0aG9kcyhjb21wb25lbnQpIHtcbiAgZm9yICh2YXIgYXV0b0JpbmRLZXkgaW4gY29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgIGlmIChjb21wb25lbnQuX19yZWFjdEF1dG9CaW5kTWFwLmhhc093blByb3BlcnR5KGF1dG9CaW5kS2V5KSkge1xuICAgICAgdmFyIG1ldGhvZCA9IGNvbXBvbmVudC5fX3JlYWN0QXV0b0JpbmRNYXBbYXV0b0JpbmRLZXldO1xuICAgICAgY29tcG9uZW50W2F1dG9CaW5kS2V5XSA9IGJpbmRBdXRvQmluZE1ldGhvZChjb21wb25lbnQsIG1ldGhvZCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQWRkIG1vcmUgdG8gdGhlIFJlYWN0Q2xhc3MgYmFzZSBjbGFzcy4gVGhlc2UgYXJlIGFsbCBsZWdhY3kgZmVhdHVyZXMgYW5kXG4gKiB0aGVyZWZvcmUgbm90IGFscmVhZHkgcGFydCBvZiB0aGUgbW9kZXJuIFJlYWN0Q29tcG9uZW50LlxuICovXG52YXIgUmVhY3RDbGFzc01peGluID0ge1xuXG4gIC8qKlxuICAgKiBUT0RPOiBUaGlzIHdpbGwgYmUgZGVwcmVjYXRlZCBiZWNhdXNlIHN0YXRlIHNob3VsZCBhbHdheXMga2VlcCBhIGNvbnNpc3RlbnRcbiAgICogdHlwZSBzaWduYXR1cmUgYW5kIHRoZSBvbmx5IHVzZSBjYXNlIGZvciB0aGlzLCBpcyB0byBhdm9pZCB0aGF0LlxuICAgKi9cbiAgcmVwbGFjZVN0YXRlOiBmdW5jdGlvbiAobmV3U3RhdGUsIGNhbGxiYWNrKSB7XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVSZXBsYWNlU3RhdGUodGhpcywgbmV3U3RhdGUpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBDaGVja3Mgd2hldGhlciBvciBub3QgdGhpcyBjb21wb3NpdGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudXBkYXRlci5pc01vdW50ZWQodGhpcyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdWJzZXQgb2YgdGhlIHByb3BzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBwcm9wcyBhcmUgdXBkYXRlZC5cbiAgICogQGZpbmFsXG4gICAqIEBwdWJsaWNcbiAgICogQGRlcHJlY2F0ZWRcbiAgICovXG4gIHNldFByb3BzOiBmdW5jdGlvbiAocGFydGlhbFByb3BzLCBjYWxsYmFjaykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB3YXJuU2V0UHJvcHMoKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRQcm9wcyh0aGlzLCBwYXJ0aWFsUHJvcHMpO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgdGhpcy51cGRhdGVyLmVucXVldWVDYWxsYmFjayh0aGlzLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZXBsYWNlIGFsbCB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBuZXdQcm9wcyBTdWJzZXQgb2YgdGhlIG5leHQgcHJvcHMuXG4gICAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgcHJvcHMgYXJlIHVwZGF0ZWQuXG4gICAqIEBmaW5hbFxuICAgKiBAcHVibGljXG4gICAqIEBkZXByZWNhdGVkXG4gICAqL1xuICByZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChuZXdQcm9wcywgY2FsbGJhY2spIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgd2FyblNldFByb3BzKCk7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlUmVwbGFjZVByb3BzKHRoaXMsIG5ld1Byb3BzKTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHRoaXMudXBkYXRlci5lbnF1ZXVlQ2FsbGJhY2sodGhpcywgY2FsbGJhY2spO1xuICAgIH1cbiAgfVxufTtcblxudmFyIFJlYWN0Q2xhc3NDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7fTtcbmFzc2lnbihSZWFjdENsYXNzQ29tcG9uZW50LnByb3RvdHlwZSwgUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBSZWFjdENsYXNzTWl4aW4pO1xuXG4vKipcbiAqIE1vZHVsZSBmb3IgY3JlYXRpbmcgY29tcG9zaXRlIGNvbXBvbmVudHMuXG4gKlxuICogQGNsYXNzIFJlYWN0Q2xhc3NcbiAqL1xudmFyIFJlYWN0Q2xhc3MgPSB7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wb3NpdGUgY29tcG9uZW50IGNsYXNzIGdpdmVuIGEgY2xhc3Mgc3BlY2lmaWNhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtvYmplY3R9IHNwZWMgQ2xhc3Mgc3BlY2lmaWNhdGlvbiAod2hpY2ggbXVzdCBkZWZpbmUgYHJlbmRlcmApLlxuICAgKiBAcmV0dXJuIHtmdW5jdGlvbn0gQ29tcG9uZW50IGNvbnN0cnVjdG9yIGZ1bmN0aW9uLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjcmVhdGVDbGFzczogZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgICAgIC8vIFRoaXMgY29uc3RydWN0b3IgaXMgb3ZlcnJpZGRlbiBieSBtb2Nrcy4gVGhlIGFyZ3VtZW50IGlzIHVzZWRcbiAgICAgIC8vIGJ5IG1vY2tzIHRvIGFzc2VydCBvbiB3aGF0IGdldHMgbW91bnRlZC5cblxuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcodGhpcyBpbnN0YW5jZW9mIENvbnN0cnVjdG9yLCAnU29tZXRoaW5nIGlzIGNhbGxpbmcgYSBSZWFjdCBjb21wb25lbnQgZGlyZWN0bHkuIFVzZSBhIGZhY3Rvcnkgb3IgJyArICdKU1ggaW5zdGVhZC4gU2VlOiBodHRwczovL2ZiLm1lL3JlYWN0LWxlZ2FjeWZhY3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gV2lyZSB1cCBhdXRvLWJpbmRpbmdcbiAgICAgIGlmICh0aGlzLl9fcmVhY3RBdXRvQmluZE1hcCkge1xuICAgICAgICBiaW5kQXV0b0JpbmRNZXRob2RzKHRoaXMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgdGhpcy5yZWZzID0gZW1wdHlPYmplY3Q7XG4gICAgICB0aGlzLnVwZGF0ZXIgPSB1cGRhdGVyIHx8IFJlYWN0Tm9vcFVwZGF0ZVF1ZXVlO1xuXG4gICAgICB0aGlzLnN0YXRlID0gbnVsbDtcblxuICAgICAgLy8gUmVhY3RDbGFzc2VzIGRvZXNuJ3QgaGF2ZSBjb25zdHJ1Y3RvcnMuIEluc3RlYWQsIHRoZXkgdXNlIHRoZVxuICAgICAgLy8gZ2V0SW5pdGlhbFN0YXRlIGFuZCBjb21wb25lbnRXaWxsTW91bnQgbWV0aG9kcyBmb3IgaW5pdGlhbGl6YXRpb24uXG5cbiAgICAgIHZhciBpbml0aWFsU3RhdGUgPSB0aGlzLmdldEluaXRpYWxTdGF0ZSA/IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKCkgOiBudWxsO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgLy8gV2UgYWxsb3cgYXV0by1tb2NrcyB0byBwcm9jZWVkIGFzIGlmIHRoZXkncmUgcmV0dXJuaW5nIG51bGwuXG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAndW5kZWZpbmVkJyAmJiB0aGlzLmdldEluaXRpYWxTdGF0ZS5faXNNb2NrRnVuY3Rpb24pIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHByb2JhYmx5IGJhZCBwcmFjdGljZS4gQ29uc2lkZXIgd2FybmluZyBoZXJlIGFuZFxuICAgICAgICAgIC8vIGRlcHJlY2F0aW5nIHRoaXMgY29udmVuaWVuY2UuXG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgISh0eXBlb2YgaW5pdGlhbFN0YXRlID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShpbml0aWFsU3RhdGUpKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICclcy5nZXRJbml0aWFsU3RhdGUoKTogbXVzdCByZXR1cm4gYW4gb2JqZWN0IG9yIG51bGwnLCBDb25zdHJ1Y3Rvci5kaXNwbGF5TmFtZSB8fCAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHRoaXMuc3RhdGUgPSBpbml0aWFsU3RhdGU7XG4gICAgfTtcbiAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUgPSBuZXcgUmVhY3RDbGFzc0NvbXBvbmVudCgpO1xuICAgIENvbnN0cnVjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENvbnN0cnVjdG9yO1xuXG4gICAgaW5qZWN0ZWRNaXhpbnMuZm9yRWFjaChtaXhTcGVjSW50b0NvbXBvbmVudC5iaW5kKG51bGwsIENvbnN0cnVjdG9yKSk7XG5cbiAgICBtaXhTcGVjSW50b0NvbXBvbmVudChDb25zdHJ1Y3Rvciwgc3BlYyk7XG5cbiAgICAvLyBJbml0aWFsaXplIHRoZSBkZWZhdWx0UHJvcHMgcHJvcGVydHkgYWZ0ZXIgYWxsIG1peGlucyBoYXZlIGJlZW4gbWVyZ2VkLlxuICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgIENvbnN0cnVjdG9yLmRlZmF1bHRQcm9wcyA9IENvbnN0cnVjdG9yLmdldERlZmF1bHRQcm9wcygpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAvLyBUaGlzIGlzIGEgdGFnIHRvIGluZGljYXRlIHRoYXQgdGhlIHVzZSBvZiB0aGVzZSBtZXRob2QgbmFtZXMgaXMgb2ssXG4gICAgICAvLyBzaW5jZSBpdCdzIHVzZWQgd2l0aCBjcmVhdGVDbGFzcy4gSWYgaXQncyBub3QsIHRoZW4gaXQncyBsaWtlbHkgYVxuICAgICAgLy8gbWlzdGFrZSBzbyB3ZSdsbCB3YXJuIHlvdSB0byB1c2UgdGhlIHN0YXRpYyBwcm9wZXJ0eSwgcHJvcGVydHlcbiAgICAgIC8vIGluaXRpYWxpemVyIG9yIGNvbnN0cnVjdG9yIHJlc3BlY3RpdmVseS5cbiAgICAgIGlmIChDb25zdHJ1Y3Rvci5nZXREZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgQ29uc3RydWN0b3IuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgICBpZiAoQ29uc3RydWN0b3IucHJvdG90eXBlLmdldEluaXRpYWxTdGF0ZSkge1xuICAgICAgICBDb25zdHJ1Y3Rvci5wcm90b3R5cGUuZ2V0SW5pdGlhbFN0YXRlLmlzUmVhY3RDbGFzc0FwcHJvdmVkID0ge307XG4gICAgICB9XG4gICAgfVxuXG4gICAgIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5yZW5kZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAnY3JlYXRlQ2xhc3MoLi4uKTogQ2xhc3Mgc3BlY2lmaWNhdGlvbiBtdXN0IGltcGxlbWVudCBhIGByZW5kZXJgIG1ldGhvZC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRTaG91bGRVcGRhdGUsICclcyBoYXMgYSBtZXRob2QgY2FsbGVkICcgKyAnY29tcG9uZW50U2hvdWxkVXBkYXRlKCkuIERpZCB5b3UgbWVhbiBzaG91bGRDb21wb25lbnRVcGRhdGUoKT8gJyArICdUaGUgbmFtZSBpcyBwaHJhc2VkIGFzIGEgcXVlc3Rpb24gYmVjYXVzZSB0aGUgZnVuY3Rpb24gaXMgJyArICdleHBlY3RlZCB0byByZXR1cm4gYSB2YWx1ZS4nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoIUNvbnN0cnVjdG9yLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjaWV2ZVByb3BzLCAnJXMgaGFzIGEgbWV0aG9kIGNhbGxlZCAnICsgJ2NvbXBvbmVudFdpbGxSZWNpZXZlUHJvcHMoKS4gRGlkIHlvdSBtZWFuIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMoKT8nLCBzcGVjLmRpc3BsYXlOYW1lIHx8ICdBIGNvbXBvbmVudCcpIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8vIFJlZHVjZSB0aW1lIHNwZW50IGRvaW5nIGxvb2t1cHMgYnkgc2V0dGluZyB0aGVzZSBvbiB0aGUgcHJvdG90eXBlLlxuICAgIGZvciAodmFyIG1ldGhvZE5hbWUgaW4gUmVhY3RDbGFzc0ludGVyZmFjZSkge1xuICAgICAgaWYgKCFDb25zdHJ1Y3Rvci5wcm90b3R5cGVbbWV0aG9kTmFtZV0pIHtcbiAgICAgICAgQ29uc3RydWN0b3IucHJvdG90eXBlW21ldGhvZE5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH0sXG5cbiAgaW5qZWN0aW9uOiB7XG4gICAgaW5qZWN0TWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgICAgaW5qZWN0ZWRNaXhpbnMucHVzaChtaXhpbik7XG4gICAgfVxuICB9XG5cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RDbGFzcztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENsYXNzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0Q29tcG9uZW50XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3ROb29wVXBkYXRlUXVldWUgPSByZXF1aXJlKCcuL1JlYWN0Tm9vcFVwZGF0ZVF1ZXVlJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBlbXB0eU9iamVjdCA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5T2JqZWN0Jyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGhlbHBlcnMgZm9yIHRoZSB1cGRhdGluZyBzdGF0ZSBvZiBhIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gUmVhY3RDb21wb25lbnQocHJvcHMsIGNvbnRleHQsIHVwZGF0ZXIpIHtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICB0aGlzLnJlZnMgPSBlbXB0eU9iamVjdDtcbiAgLy8gV2UgaW5pdGlhbGl6ZSB0aGUgZGVmYXVsdCB1cGRhdGVyIGJ1dCB0aGUgcmVhbCBvbmUgZ2V0cyBpbmplY3RlZCBieSB0aGVcbiAgLy8gcmVuZGVyZXIuXG4gIHRoaXMudXBkYXRlciA9IHVwZGF0ZXIgfHwgUmVhY3ROb29wVXBkYXRlUXVldWU7XG59XG5cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50ID0ge307XG5cbi8qKlxuICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIEFsd2F5cyB1c2UgdGhpcyB0byBtdXRhdGVcbiAqIHN0YXRlLiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgYHRoaXMuc3RhdGVgIHdpbGwgYmUgaW1tZWRpYXRlbHkgdXBkYXRlZCwgc29cbiAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gKlxuICogVGhlcmUgaXMgbm8gZ3VhcmFudGVlIHRoYXQgY2FsbHMgdG8gYHNldFN0YXRlYCB3aWxsIHJ1biBzeW5jaHJvbm91c2x5LFxuICogYXMgdGhleSBtYXkgZXZlbnR1YWxseSBiZSBiYXRjaGVkIHRvZ2V0aGVyLiAgWW91IGNhbiBwcm92aWRlIGFuIG9wdGlvbmFsXG4gKiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiB0aGUgY2FsbCB0byBzZXRTdGF0ZSBpcyBhY3R1YWxseVxuICogY29tcGxldGVkLlxuICpcbiAqIFdoZW4gYSBmdW5jdGlvbiBpcyBwcm92aWRlZCB0byBzZXRTdGF0ZSwgaXQgd2lsbCBiZSBjYWxsZWQgYXQgc29tZSBwb2ludCBpblxuICogdGhlIGZ1dHVyZSAobm90IHN5bmNocm9ub3VzbHkpLiBJdCB3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB1cCB0byBkYXRlXG4gKiBjb21wb25lbnQgYXJndW1lbnRzIChzdGF0ZSwgcHJvcHMsIGNvbnRleHQpLiBUaGVzZSB2YWx1ZXMgY2FuIGJlIGRpZmZlcmVudFxuICogZnJvbSB0aGlzLiogYmVjYXVzZSB5b3VyIGZ1bmN0aW9uIG1heSBiZSBjYWxsZWQgYWZ0ZXIgcmVjZWl2ZVByb3BzIGJ1dCBiZWZvcmVcbiAqIHNob3VsZENvbXBvbmVudFVwZGF0ZSwgYW5kIHRoaXMgbmV3IHN0YXRlLCBwcm9wcywgYW5kIGNvbnRleHQgd2lsbCBub3QgeWV0IGJlXG4gKiBhc3NpZ25lZCB0byB0aGlzLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fGZ1bmN0aW9ufSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIG9yIGZ1bmN0aW9uIHRvXG4gKiAgICAgICAgcHJvZHVjZSBuZXh0IHBhcnRpYWwgc3RhdGUgdG8gYmUgbWVyZ2VkIHdpdGggY3VycmVudCBzdGF0ZS5cbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgc3RhdGUgaXMgdXBkYXRlZC5cbiAqIEBmaW5hbFxuICogQHByb3RlY3RlZFxuICovXG5SZWFjdENvbXBvbmVudC5wcm90b3R5cGUuc2V0U3RhdGUgPSBmdW5jdGlvbiAocGFydGlhbFN0YXRlLCBjYWxsYmFjaykge1xuICAhKHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBwYXJ0aWFsU3RhdGUgPT09ICdmdW5jdGlvbicgfHwgcGFydGlhbFN0YXRlID09IG51bGwpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3NldFN0YXRlKC4uLik6IHRha2VzIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMgdG8gdXBkYXRlIG9yIGEgJyArICdmdW5jdGlvbiB3aGljaCByZXR1cm5zIGFuIG9iamVjdCBvZiBzdGF0ZSB2YXJpYWJsZXMuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHBhcnRpYWxTdGF0ZSAhPSBudWxsLCAnc2V0U3RhdGUoLi4uKTogWW91IHBhc3NlZCBhbiB1bmRlZmluZWQgb3IgbnVsbCBzdGF0ZSBvYmplY3Q7ICcgKyAnaW5zdGVhZCwgdXNlIGZvcmNlVXBkYXRlKCkuJykgOiB1bmRlZmluZWQ7XG4gIH1cbiAgdGhpcy51cGRhdGVyLmVucXVldWVTZXRTdGF0ZSh0aGlzLCBwYXJ0aWFsU3RhdGUpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBGb3JjZXMgYW4gdXBkYXRlLiBUaGlzIHNob3VsZCBvbmx5IGJlIGludm9rZWQgd2hlbiBpdCBpcyBrbm93biB3aXRoXG4gKiBjZXJ0YWludHkgdGhhdCB3ZSBhcmUgKipub3QqKiBpbiBhIERPTSB0cmFuc2FjdGlvbi5cbiAqXG4gKiBZb3UgbWF5IHdhbnQgdG8gY2FsbCB0aGlzIHdoZW4geW91IGtub3cgdGhhdCBzb21lIGRlZXBlciBhc3BlY3Qgb2YgdGhlXG4gKiBjb21wb25lbnQncyBzdGF0ZSBoYXMgY2hhbmdlZCBidXQgYHNldFN0YXRlYCB3YXMgbm90IGNhbGxlZC5cbiAqXG4gKiBUaGlzIHdpbGwgbm90IGludm9rZSBgc2hvdWxkQ29tcG9uZW50VXBkYXRlYCwgYnV0IGl0IHdpbGwgaW52b2tlXG4gKiBgY29tcG9uZW50V2lsbFVwZGF0ZWAgYW5kIGBjb21wb25lbnREaWRVcGRhdGVgLlxuICpcbiAqIEBwYXJhbSB7P2Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsZWQgYWZ0ZXIgdXBkYXRlIGlzIGNvbXBsZXRlLlxuICogQGZpbmFsXG4gKiBAcHJvdGVjdGVkXG4gKi9cblJlYWN0Q29tcG9uZW50LnByb3RvdHlwZS5mb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUZvcmNlVXBkYXRlKHRoaXMpO1xuICBpZiAoY2FsbGJhY2spIHtcbiAgICB0aGlzLnVwZGF0ZXIuZW5xdWV1ZUNhbGxiYWNrKHRoaXMsIGNhbGxiYWNrKTtcbiAgfVxufTtcblxuLyoqXG4gKiBEZXByZWNhdGVkIEFQSXMuIFRoZXNlIEFQSXMgdXNlZCB0byBleGlzdCBvbiBjbGFzc2ljIFJlYWN0IGNsYXNzZXMgYnV0IHNpbmNlXG4gKiB3ZSB3b3VsZCBsaWtlIHRvIGRlcHJlY2F0ZSB0aGVtLCB3ZSdyZSBub3QgZ29pbmcgdG8gbW92ZSB0aGVtIG92ZXIgdG8gdGhpc1xuICogbW9kZXJuIGJhc2UgY2xhc3MuIEluc3RlYWQsIHdlIGRlZmluZSBhIGdldHRlciB0aGF0IHdhcm5zIGlmIGl0J3MgYWNjZXNzZWQuXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBkZXByZWNhdGVkQVBJcyA9IHtcbiAgICBnZXRET01Ob2RlOiBbJ2dldERPTU5vZGUnLCAnVXNlIFJlYWN0RE9NLmZpbmRET01Ob2RlKGNvbXBvbmVudCkgaW5zdGVhZC4nXSxcbiAgICBpc01vdW50ZWQ6IFsnaXNNb3VudGVkJywgJ0luc3RlYWQsIG1ha2Ugc3VyZSB0byBjbGVhbiB1cCBzdWJzY3JpcHRpb25zIGFuZCBwZW5kaW5nIHJlcXVlc3RzIGluICcgKyAnY29tcG9uZW50V2lsbFVubW91bnQgdG8gcHJldmVudCBtZW1vcnkgbGVha3MuJ10sXG4gICAgcmVwbGFjZVByb3BzOiBbJ3JlcGxhY2VQcm9wcycsICdJbnN0ZWFkLCBjYWxsIHJlbmRlciBhZ2FpbiBhdCB0aGUgdG9wIGxldmVsLiddLFxuICAgIHJlcGxhY2VTdGF0ZTogWydyZXBsYWNlU3RhdGUnLCAnUmVmYWN0b3IgeW91ciBjb2RlIHRvIHVzZSBzZXRTdGF0ZSBpbnN0ZWFkIChzZWUgJyArICdodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzMyMzYpLiddLFxuICAgIHNldFByb3BzOiBbJ3NldFByb3BzJywgJ0luc3RlYWQsIGNhbGwgcmVuZGVyIGFnYWluIGF0IHRoZSB0b3AgbGV2ZWwuJ11cbiAgfTtcbiAgdmFyIGRlZmluZURlcHJlY2F0aW9uV2FybmluZyA9IGZ1bmN0aW9uIChtZXRob2ROYW1lLCBpbmZvKSB7XG4gICAgaWYgKGNhbkRlZmluZVByb3BlcnR5KSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhY3RDb21wb25lbnQucHJvdG90eXBlLCBtZXRob2ROYW1lLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnJXMoLi4uKSBpcyBkZXByZWNhdGVkIGluIHBsYWluIEphdmFTY3JpcHQgUmVhY3QgY2xhc3Nlcy4gJXMnLCBpbmZvWzBdLCBpbmZvWzFdKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gIH07XG4gIGZvciAodmFyIGZuTmFtZSBpbiBkZXByZWNhdGVkQVBJcykge1xuICAgIGlmIChkZXByZWNhdGVkQVBJcy5oYXNPd25Qcm9wZXJ0eShmbk5hbWUpKSB7XG4gICAgICBkZWZpbmVEZXByZWNhdGlvbldhcm5pbmcoZm5OYW1lLCBkZXByZWNhdGVkQVBJc1tmbk5hbWVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdENvbXBvbmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdENvbXBvbmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3ROb29wVXBkYXRlUXVldWVcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciB3YXJuaW5nID0gcmVxdWlyZSgnZmJqcy9saWIvd2FybmluZycpO1xuXG5mdW5jdGlvbiB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCBjYWxsZXJOYW1lKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoZmFsc2UsICclcyguLi4pOiBDYW4gb25seSB1cGRhdGUgYSBtb3VudGVkIG9yIG1vdW50aW5nIGNvbXBvbmVudC4gJyArICdUaGlzIHVzdWFsbHkgbWVhbnMgeW91IGNhbGxlZCAlcygpIG9uIGFuIHVubW91bnRlZCBjb21wb25lbnQuICcgKyAnVGhpcyBpcyBhIG5vLW9wLiBQbGVhc2UgY2hlY2sgdGhlIGNvZGUgZm9yIHRoZSAlcyBjb21wb25lbnQuJywgY2FsbGVyTmFtZSwgY2FsbGVyTmFtZSwgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IgJiYgcHVibGljSW5zdGFuY2UuY29uc3RydWN0b3IuZGlzcGxheU5hbWUgfHwgJycpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogVGhpcyBpcyB0aGUgYWJzdHJhY3QgQVBJIGZvciBhbiB1cGRhdGUgcXVldWUuXG4gKi9cbnZhciBSZWFjdE5vb3BVcGRhdGVRdWV1ZSA9IHtcblxuICAvKipcbiAgICogQ2hlY2tzIHdoZXRoZXIgb3Igbm90IHRoaXMgY29tcG9zaXRlIGNvbXBvbmVudCBpcyBtb3VudGVkLlxuICAgKiBAcGFyYW0ge1JlYWN0Q2xhc3N9IHB1YmxpY0luc3RhbmNlIFRoZSBpbnN0YW5jZSB3ZSB3YW50IHRvIHRlc3QuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgbW91bnRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgKiBAcHJvdGVjdGVkXG4gICAqIEBmaW5hbFxuICAgKi9cbiAgaXNNb3VudGVkOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEVucXVldWUgYSBjYWxsYmFjayB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYWZ0ZXIgYWxsIHRoZSBwZW5kaW5nIHVwZGF0ZXNcbiAgICogaGF2ZSBwcm9jZXNzZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRvIHVzZSBhcyBgdGhpc2AgY29udGV4dC5cbiAgICogQHBhcmFtIHs/ZnVuY3Rpb259IGNhbGxiYWNrIENhbGxlZCBhZnRlciBzdGF0ZSBpcyB1cGRhdGVkLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVDYWxsYmFjazogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBjYWxsYmFjaykge30sXG5cbiAgLyoqXG4gICAqIEZvcmNlcyBhbiB1cGRhdGUuIFRoaXMgc2hvdWxkIG9ubHkgYmUgaW52b2tlZCB3aGVuIGl0IGlzIGtub3duIHdpdGhcbiAgICogY2VydGFpbnR5IHRoYXQgd2UgYXJlICoqbm90KiogaW4gYSBET00gdHJhbnNhY3Rpb24uXG4gICAqXG4gICAqIFlvdSBtYXkgd2FudCB0byBjYWxsIHRoaXMgd2hlbiB5b3Uga25vdyB0aGF0IHNvbWUgZGVlcGVyIGFzcGVjdCBvZiB0aGVcbiAgICogY29tcG9uZW50J3Mgc3RhdGUgaGFzIGNoYW5nZWQgYnV0IGBzZXRTdGF0ZWAgd2FzIG5vdCBjYWxsZWQuXG4gICAqXG4gICAqIFRoaXMgd2lsbCBub3QgaW52b2tlIGBzaG91bGRDb21wb25lbnRVcGRhdGVgLCBidXQgaXQgd2lsbCBpbnZva2VcbiAgICogYGNvbXBvbmVudFdpbGxVcGRhdGVgIGFuZCBgY29tcG9uZW50RGlkVXBkYXRlYC5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgZW5xdWV1ZUZvcmNlVXBkYXRlOiBmdW5jdGlvbiAocHVibGljSW5zdGFuY2UpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnZm9yY2VVcGRhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogUmVwbGFjZXMgYWxsIG9mIHRoZSBzdGF0ZS4gQWx3YXlzIHVzZSB0aGlzIG9yIGBzZXRTdGF0ZWAgdG8gbXV0YXRlIHN0YXRlLlxuICAgKiBZb3Ugc2hvdWxkIHRyZWF0IGB0aGlzLnN0YXRlYCBhcyBpbW11dGFibGUuXG4gICAqXG4gICAqIFRoZXJlIGlzIG5vIGd1YXJhbnRlZSB0aGF0IGB0aGlzLnN0YXRlYCB3aWxsIGJlIGltbWVkaWF0ZWx5IHVwZGF0ZWQsIHNvXG4gICAqIGFjY2Vzc2luZyBgdGhpcy5zdGF0ZWAgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCBtYXkgcmV0dXJuIHRoZSBvbGQgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gY29tcGxldGVTdGF0ZSBOZXh0IHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlU3RhdGU6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgY29tcGxldGVTdGF0ZSkge1xuICAgIHdhcm5URFoocHVibGljSW5zdGFuY2UsICdyZXBsYWNlU3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgc3RhdGUuIFRoaXMgb25seSBleGlzdHMgYmVjYXVzZSBfcGVuZGluZ1N0YXRlIGlzXG4gICAqIGludGVybmFsLiBUaGlzIHByb3ZpZGVzIGEgbWVyZ2luZyBzdHJhdGVneSB0aGF0IGlzIG5vdCBhdmFpbGFibGUgdG8gZGVlcFxuICAgKiBwcm9wZXJ0aWVzIHdoaWNoIGlzIGNvbmZ1c2luZy4gVE9ETzogRXhwb3NlIHBlbmRpbmdTdGF0ZSBvciBkb24ndCB1c2UgaXRcbiAgICogZHVyaW5nIHRoZSBtZXJnZS5cbiAgICpcbiAgICogQHBhcmFtIHtSZWFjdENsYXNzfSBwdWJsaWNJbnN0YW5jZSBUaGUgaW5zdGFuY2UgdGhhdCBzaG91bGQgcmVyZW5kZXIuXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBwYXJ0aWFsU3RhdGUgTmV4dCBwYXJ0aWFsIHN0YXRlIHRvIGJlIG1lcmdlZCB3aXRoIHN0YXRlLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVTZXRTdGF0ZTogZnVuY3Rpb24gKHB1YmxpY0luc3RhbmNlLCBwYXJ0aWFsU3RhdGUpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAnc2V0U3RhdGUnKTtcbiAgfSxcblxuICAvKipcbiAgICogU2V0cyBhIHN1YnNldCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGFydGlhbFByb3BzIFN1YnNldCBvZiB0aGUgbmV4dCBwcm9wcy5cbiAgICogQGludGVybmFsXG4gICAqL1xuICBlbnF1ZXVlU2V0UHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcGFydGlhbFByb3BzKSB7XG4gICAgd2FyblREWihwdWJsaWNJbnN0YW5jZSwgJ3NldFByb3BzJyk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBvZiB0aGUgcHJvcHMuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhY3RDbGFzc30gcHVibGljSW5zdGFuY2UgVGhlIGluc3RhbmNlIHRoYXQgc2hvdWxkIHJlcmVuZGVyLlxuICAgKiBAcGFyYW0ge29iamVjdH0gcHJvcHMgTmV3IHByb3BzLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIGVucXVldWVSZXBsYWNlUHJvcHM6IGZ1bmN0aW9uIChwdWJsaWNJbnN0YW5jZSwgcHJvcHMpIHtcbiAgICB3YXJuVERaKHB1YmxpY0luc3RhbmNlLCAncmVwbGFjZVByb3BzJyk7XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdE5vb3BVcGRhdGVRdWV1ZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdE5vb3BVcGRhdGVRdWV1ZS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIENhbGxiYWNrUXVldWUgPSByZXF1aXJlKCcuL0NhbGxiYWNrUXVldWUnKTtcbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCcuL1JlYWN0QnJvd3NlckV2ZW50RW1pdHRlcicpO1xudmFyIFJlYWN0RE9NRmVhdHVyZUZsYWdzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZlYXR1cmVGbGFncycpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBUcmFuc2FjdGlvbiA9IHJlcXVpcmUoJy4vVHJhbnNhY3Rpb24nKTtcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG4vKipcbiAqIEVuc3VyZXMgdGhhdCwgd2hlbiBwb3NzaWJsZSwgdGhlIHNlbGVjdGlvbiByYW5nZSAoY3VycmVudGx5IHNlbGVjdGVkIHRleHRcbiAqIGlucHV0KSBpcyBub3QgZGlzdHVyYmVkIGJ5IHBlcmZvcm1pbmcgdGhlIHRyYW5zYWN0aW9uLlxuICovXG52YXIgU0VMRUNUSU9OX1JFU1RPUkFUSU9OID0ge1xuICAvKipcbiAgICogQHJldHVybiB7U2VsZWN0aW9ufSBTZWxlY3Rpb24gaW5mb3JtYXRpb24uXG4gICAqL1xuICBpbml0aWFsaXplOiBSZWFjdElucHV0U2VsZWN0aW9uLmdldFNlbGVjdGlvbkluZm9ybWF0aW9uLFxuICAvKipcbiAgICogQHBhcmFtIHtTZWxlY3Rpb259IHNlbCBTZWxlY3Rpb24gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBgaW5pdGlhbGl6ZWAuXG4gICAqL1xuICBjbG9zZTogUmVhY3RJbnB1dFNlbGVjdGlvbi5yZXN0b3JlU2VsZWN0aW9uXG59O1xuXG4vKipcbiAqIFN1cHByZXNzZXMgZXZlbnRzIChibHVyL2ZvY3VzKSB0aGF0IGNvdWxkIGJlIGluYWR2ZXJ0ZW50bHkgZGlzcGF0Y2hlZCBkdWUgdG9cbiAqIGhpZ2ggbGV2ZWwgRE9NIG1hbmlwdWxhdGlvbnMgKGxpa2UgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgYSB0ZXh0IGlucHV0IGZyb20gdGhlXG4gKiBET00pLlxuICovXG52YXIgRVZFTlRfU1VQUFJFU1NJT04gPSB7XG4gIC8qKlxuICAgKiBAcmV0dXJuIHtib29sZWFufSBUaGUgZW5hYmxlZCBzdGF0dXMgb2YgYFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlcmAgYmVmb3JlXG4gICAqIHRoZSByZWNvbmNpbGlhdGlvbi5cbiAgICovXG4gIGluaXRpYWxpemU6IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY3VycmVudGx5RW5hYmxlZCA9IFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5pc0VuYWJsZWQoKTtcbiAgICBSZWFjdEJyb3dzZXJFdmVudEVtaXR0ZXIuc2V0RW5hYmxlZChmYWxzZSk7XG4gICAgcmV0dXJuIGN1cnJlbnRseUVuYWJsZWQ7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gcHJldmlvdXNseUVuYWJsZWQgRW5hYmxlZCBzdGF0dXMgb2ZcbiAgICogICBgUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyYCBiZWZvcmUgdGhlIHJlY29uY2lsaWF0aW9uIG9jY3VycmVkLiBgY2xvc2VgXG4gICAqICAgcmVzdG9yZXMgdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgKi9cbiAgY2xvc2U6IGZ1bmN0aW9uIChwcmV2aW91c2x5RW5hYmxlZCkge1xuICAgIFJlYWN0QnJvd3NlckV2ZW50RW1pdHRlci5zZXRFbmFibGVkKHByZXZpb3VzbHlFbmFibGVkKTtcbiAgfVxufTtcblxuLyoqXG4gKiBQcm92aWRlcyBhIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBjb21wb25lbnREaWRNb3VudGAgYW5kXG4gKiBgY29tcG9uZW50RGlkVXBkYXRlYCBjYWxsYmFja3MgZHVyaW5nIHRoZSB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEFmdGVyIERPTSBpcyBmbHVzaGVkLCBpbnZva2UgYWxsIHJlZ2lzdGVyZWQgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcy5cbiAgICovXG4gIGNsb3NlOiBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkubm90aWZ5QWxsKCk7XG4gIH1cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtTRUxFQ1RJT05fUkVTVE9SQVRJT04sIEVWRU5UX1NVUFBSRVNTSU9OLCBPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEN1cnJlbnRseTpcbiAqIC0gVGhlIG9yZGVyIHRoYXQgdGhlc2UgYXJlIGxpc3RlZCBpbiB0aGUgdHJhbnNhY3Rpb24gaXMgY3JpdGljYWw6XG4gKiAtIFN1cHByZXNzZXMgZXZlbnRzLlxuICogLSBSZXN0b3JlcyBzZWxlY3Rpb24gcmFuZ2UuXG4gKlxuICogRnV0dXJlOlxuICogLSBSZXN0b3JlIGRvY3VtZW50L292ZXJmbG93IHNjcm9sbCBwb3NpdGlvbnMgdGhhdCB3ZXJlIHVuaW50ZW50aW9uYWxseVxuICogICBtb2RpZmllZCB2aWEgRE9NIGluc2VydGlvbnMgYWJvdmUgdGhlIHRvcCB2aWV3cG9ydCBib3VuZGFyeS5cbiAqIC0gSW1wbGVtZW50L2ludGVncmF0ZSB3aXRoIGN1c3RvbWl6ZWQgY29uc3RyYWludCBiYXNlZCBsYXlvdXQgc3lzdGVtIGFuZCBrZWVwXG4gKiAgIHRyYWNrIG9mIHdoaWNoIGRpbWVuc2lvbnMgbXVzdCBiZSByZW1lYXN1cmVkLlxuICpcbiAqIEBjbGFzcyBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uXG4gKi9cbmZ1bmN0aW9uIFJlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24oZm9yY2VIVE1MKSB7XG4gIHRoaXMucmVpbml0aWFsaXplVHJhbnNhY3Rpb24oKTtcbiAgLy8gT25seSBzZXJ2ZXItc2lkZSByZW5kZXJpbmcgcmVhbGx5IG5lZWRzIHRoaXMgb3B0aW9uIChzZWVcbiAgLy8gYFJlYWN0U2VydmVyUmVuZGVyaW5nYCksIGJ1dCBzZXJ2ZXItc2lkZSB1c2VzXG4gIC8vIGBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uYCBpbnN0ZWFkLiBUaGlzIG9wdGlvbiBpcyBoZXJlIHNvIHRoYXQgaXQnc1xuICAvLyBhY2Nlc3NpYmxlIGFuZCBkZWZhdWx0cyB0byBmYWxzZSB3aGVuIGBSZWFjdERPTUNvbXBvbmVudGAgYW5kXG4gIC8vIGBSZWFjdFRleHRDb21wb25lbnRgIGNoZWNrcyBpdCBpbiBgbW91bnRDb21wb25lbnRgLmBcbiAgdGhpcy5yZW5kZXJUb1N0YXRpY01hcmt1cCA9IGZhbHNlO1xuICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IENhbGxiYWNrUXVldWUuZ2V0UG9vbGVkKG51bGwpO1xuICB0aGlzLnVzZUNyZWF0ZUVsZW1lbnQgPSAhZm9yY2VIVE1MICYmIFJlYWN0RE9NRmVhdHVyZUZsYWdzLnVzZUNyZWF0ZUVsZW1lbnQ7XG59XG5cbnZhciBNaXhpbiA9IHtcbiAgLyoqXG4gICAqIEBzZWUgVHJhbnNhY3Rpb25cbiAgICogQGFic3RyYWN0XG4gICAqIEBmaW5hbFxuICAgKiBAcmV0dXJuIHthcnJheTxvYmplY3Q+fSBMaXN0IG9mIG9wZXJhdGlvbiB3cmFwIHByb2NlZHVyZXMuXG4gICAqICAgVE9ETzogY29udmVydCB0byBhcnJheTxUcmFuc2FjdGlvbldyYXBwZXI+XG4gICAqL1xuICBnZXRUcmFuc2FjdGlvbldyYXBwZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFRSQU5TQUNUSU9OX1dSQVBQRVJTO1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmV0dXJuIHtvYmplY3R9IFRoZSBxdWV1ZSB0byBjb2xsZWN0IGBvbkRPTVJlYWR5YCBjYWxsYmFja3Mgd2l0aC5cbiAgICovXG4gIGdldFJlYWN0TW91bnRSZWFkeTogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnJlYWN0TW91bnRSZWFkeTtcbiAgfSxcblxuICAvKipcbiAgICogYFBvb2xlZENsYXNzYCBsb29rcyBmb3IgdGhpcywgYW5kIHdpbGwgaW52b2tlIHRoaXMgYmVmb3JlIGFsbG93aW5nIHRoaXNcbiAgICogaW5zdGFuY2UgdG8gYmUgcmV1c2VkLlxuICAgKi9cbiAgZGVzdHJ1Y3RvcjogZnVuY3Rpb24gKCkge1xuICAgIENhbGxiYWNrUXVldWUucmVsZWFzZSh0aGlzLnJlYWN0TW91bnRSZWFkeSk7XG4gICAgdGhpcy5yZWFjdE1vdW50UmVhZHkgPSBudWxsO1xuICB9XG59O1xuXG5hc3NpZ24oUmVhY3RSZWNvbmNpbGVUcmFuc2FjdGlvbi5wcm90b3R5cGUsIFRyYW5zYWN0aW9uLk1peGluLCBNaXhpbik7XG5cblBvb2xlZENsYXNzLmFkZFBvb2xpbmdUbyhSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uKTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFJlY29uY2lsZVRyYW5zYWN0aW9uO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0UmVjb25jaWxlVHJhbnNhY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RJbnB1dFNlbGVjdGlvblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0gcmVxdWlyZSgnLi9SZWFjdERPTVNlbGVjdGlvbicpO1xuXG52YXIgY29udGFpbnNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvY29udGFpbnNOb2RlJyk7XG52YXIgZm9jdXNOb2RlID0gcmVxdWlyZSgnZmJqcy9saWIvZm9jdXNOb2RlJyk7XG52YXIgZ2V0QWN0aXZlRWxlbWVudCA9IHJlcXVpcmUoJ2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQnKTtcblxuZnVuY3Rpb24gaXNJbkRvY3VtZW50KG5vZGUpIHtcbiAgcmV0dXJuIGNvbnRhaW5zTm9kZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIG5vZGUpO1xufVxuXG4vKipcbiAqIEBSZWFjdElucHV0U2VsZWN0aW9uOiBSZWFjdCBpbnB1dCBzZWxlY3Rpb24gbW9kdWxlLiBCYXNlZCBvbiBTZWxlY3Rpb24uanMsXG4gKiBidXQgbW9kaWZpZWQgdG8gYmUgc3VpdGFibGUgZm9yIHJlYWN0IGFuZCBoYXMgYSBjb3VwbGUgb2YgYnVnIGZpeGVzIChkb2Vzbid0XG4gKiBhc3N1bWUgYnV0dG9ucyBoYXZlIHJhbmdlIHNlbGVjdGlvbnMgYWxsb3dlZCkuXG4gKiBJbnB1dCBzZWxlY3Rpb24gbW9kdWxlIGZvciBSZWFjdC5cbiAqL1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSB7XG5cbiAgaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzOiBmdW5jdGlvbiAoZWxlbSkge1xuICAgIHZhciBub2RlTmFtZSA9IGVsZW0gJiYgZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgcmV0dXJuIG5vZGVOYW1lICYmIChub2RlTmFtZSA9PT0gJ2lucHV0JyAmJiBlbGVtLnR5cGUgPT09ICd0ZXh0JyB8fCBub2RlTmFtZSA9PT0gJ3RleHRhcmVhJyB8fCBlbGVtLmNvbnRlbnRFZGl0YWJsZSA9PT0gJ3RydWUnKTtcbiAgfSxcblxuICBnZXRTZWxlY3Rpb25JbmZvcm1hdGlvbjogZnVuY3Rpb24gKCkge1xuICAgIHZhciBmb2N1c2VkRWxlbSA9IGdldEFjdGl2ZUVsZW1lbnQoKTtcbiAgICByZXR1cm4ge1xuICAgICAgZm9jdXNlZEVsZW06IGZvY3VzZWRFbGVtLFxuICAgICAgc2VsZWN0aW9uUmFuZ2U6IFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKGZvY3VzZWRFbGVtKSA/IFJlYWN0SW5wdXRTZWxlY3Rpb24uZ2V0U2VsZWN0aW9uKGZvY3VzZWRFbGVtKSA6IG51bGxcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAcmVzdG9yZVNlbGVjdGlvbjogSWYgYW55IHNlbGVjdGlvbiBpbmZvcm1hdGlvbiB3YXMgcG90ZW50aWFsbHkgbG9zdCxcbiAgICogcmVzdG9yZSBpdC4gVGhpcyBpcyB1c2VmdWwgd2hlbiBwZXJmb3JtaW5nIG9wZXJhdGlvbnMgdGhhdCBjb3VsZCByZW1vdmUgZG9tXG4gICAqIG5vZGVzIGFuZCBwbGFjZSB0aGVtIGJhY2sgaW4sIHJlc3VsdGluZyBpbiBmb2N1cyBiZWluZyBsb3N0LlxuICAgKi9cbiAgcmVzdG9yZVNlbGVjdGlvbjogZnVuY3Rpb24gKHByaW9yU2VsZWN0aW9uSW5mb3JtYXRpb24pIHtcbiAgICB2YXIgY3VyRm9jdXNlZEVsZW0gPSBnZXRBY3RpdmVFbGVtZW50KCk7XG4gICAgdmFyIHByaW9yRm9jdXNlZEVsZW0gPSBwcmlvclNlbGVjdGlvbkluZm9ybWF0aW9uLmZvY3VzZWRFbGVtO1xuICAgIHZhciBwcmlvclNlbGVjdGlvblJhbmdlID0gcHJpb3JTZWxlY3Rpb25JbmZvcm1hdGlvbi5zZWxlY3Rpb25SYW5nZTtcbiAgICBpZiAoY3VyRm9jdXNlZEVsZW0gIT09IHByaW9yRm9jdXNlZEVsZW0gJiYgaXNJbkRvY3VtZW50KHByaW9yRm9jdXNlZEVsZW0pKSB7XG4gICAgICBpZiAoUmVhY3RJbnB1dFNlbGVjdGlvbi5oYXNTZWxlY3Rpb25DYXBhYmlsaXRpZXMocHJpb3JGb2N1c2VkRWxlbSkpIHtcbiAgICAgICAgUmVhY3RJbnB1dFNlbGVjdGlvbi5zZXRTZWxlY3Rpb24ocHJpb3JGb2N1c2VkRWxlbSwgcHJpb3JTZWxlY3Rpb25SYW5nZSk7XG4gICAgICB9XG4gICAgICBmb2N1c05vZGUocHJpb3JGb2N1c2VkRWxlbSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAZ2V0U2VsZWN0aW9uOiBHZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgZm9jdXNlZCB0ZXh0YXJlYSwgaW5wdXQgb3JcbiAgICogY29udGVudEVkaXRhYmxlIG5vZGUuXG4gICAqIC1AaW5wdXQ6IExvb2sgdXAgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0XG4gICAqIC1AcmV0dXJuIHtzdGFydDogc2VsZWN0aW9uU3RhcnQsIGVuZDogc2VsZWN0aW9uRW5kfVxuICAgKi9cbiAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgICB2YXIgc2VsZWN0aW9uO1xuXG4gICAgaWYgKCdzZWxlY3Rpb25TdGFydCcgaW4gaW5wdXQpIHtcbiAgICAgIC8vIE1vZGVybiBicm93c2VyIHdpdGggaW5wdXQgb3IgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSB7XG4gICAgICAgIHN0YXJ0OiBpbnB1dC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgZW5kOiBpbnB1dC5zZWxlY3Rpb25FbmRcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChkb2N1bWVudC5zZWxlY3Rpb24gJiYgKGlucHV0Lm5vZGVOYW1lICYmIGlucHV0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcpKSB7XG4gICAgICAvLyBJRTggaW5wdXQuXG4gICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKTtcbiAgICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzZWxlY3Rpb24gcGVyIGRvY3VtZW50IGluIElFLCBzbyBpdCBtdXN0XG4gICAgICAvLyBiZSBpbiBvdXIgZWxlbWVudC5cbiAgICAgIGlmIChyYW5nZS5wYXJlbnRFbGVtZW50KCkgPT09IGlucHV0KSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHtcbiAgICAgICAgICBzdGFydDogLXJhbmdlLm1vdmVTdGFydCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aCksXG4gICAgICAgICAgZW5kOiAtcmFuZ2UubW92ZUVuZCgnY2hhcmFjdGVyJywgLWlucHV0LnZhbHVlLmxlbmd0aClcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQ29udGVudCBlZGl0YWJsZSBvciBvbGQgSUUgdGV4dGFyZWEuXG4gICAgICBzZWxlY3Rpb24gPSBSZWFjdERPTVNlbGVjdGlvbi5nZXRPZmZzZXRzKGlucHV0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gc2VsZWN0aW9uIHx8IHsgc3RhcnQ6IDAsIGVuZDogMCB9O1xuICB9LFxuXG4gIC8qKlxuICAgKiBAc2V0U2VsZWN0aW9uOiBTZXRzIHRoZSBzZWxlY3Rpb24gYm91bmRzIG9mIGEgdGV4dGFyZWEgb3IgaW5wdXQgYW5kIGZvY3VzZXNcbiAgICogdGhlIGlucHV0LlxuICAgKiAtQGlucHV0ICAgICBTZXQgc2VsZWN0aW9uIGJvdW5kcyBvZiB0aGlzIGlucHV0IG9yIHRleHRhcmVhXG4gICAqIC1Ab2Zmc2V0cyAgIE9iamVjdCBvZiBzYW1lIGZvcm0gdGhhdCBpcyByZXR1cm5lZCBmcm9tIGdldCpcbiAgICovXG4gIHNldFNlbGVjdGlvbjogZnVuY3Rpb24gKGlucHV0LCBvZmZzZXRzKSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICB2YXIgZW5kID0gb2Zmc2V0cy5lbmQ7XG4gICAgaWYgKHR5cGVvZiBlbmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICB9XG5cbiAgICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBpbnB1dCkge1xuICAgICAgaW5wdXQuc2VsZWN0aW9uU3RhcnQgPSBzdGFydDtcbiAgICAgIGlucHV0LnNlbGVjdGlvbkVuZCA9IE1hdGgubWluKGVuZCwgaW5wdXQudmFsdWUubGVuZ3RoKTtcbiAgICB9IGVsc2UgaWYgKGRvY3VtZW50LnNlbGVjdGlvbiAmJiAoaW5wdXQubm9kZU5hbWUgJiYgaW5wdXQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2lucHV0JykpIHtcbiAgICAgIHZhciByYW5nZSA9IGlucHV0LmNyZWF0ZVRleHRSYW5nZSgpO1xuICAgICAgcmFuZ2UuY29sbGFwc2UodHJ1ZSk7XG4gICAgICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgICAgIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgICAgIHJhbmdlLnNlbGVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBSZWFjdERPTVNlbGVjdGlvbi5zZXRPZmZzZXRzKGlucHV0LCBvZmZzZXRzKTtcbiAgICB9XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RJbnB1dFNlbGVjdGlvbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdElucHV0U2VsZWN0aW9uLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RE9NU2VsZWN0aW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCA9IHJlcXVpcmUoJy4vZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldCcpO1xudmFyIGdldFRleHRDb250ZW50QWNjZXNzb3IgPSByZXF1aXJlKCcuL2dldFRleHRDb250ZW50QWNjZXNzb3InKTtcblxuLyoqXG4gKiBXaGlsZSBgaXNDb2xsYXBzZWRgIGlzIGF2YWlsYWJsZSBvbiB0aGUgU2VsZWN0aW9uIG9iamVjdCBhbmQgYGNvbGxhcHNlZGBcbiAqIGlzIGF2YWlsYWJsZSBvbiB0aGUgUmFuZ2Ugb2JqZWN0LCBJRTExIHNvbWV0aW1lcyBnZXRzIHRoZW0gd3JvbmcuXG4gKiBJZiB0aGUgYW5jaG9yL2ZvY3VzIG5vZGVzIGFuZCBvZmZzZXRzIGFyZSB0aGUgc2FtZSwgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZC5cbiAqL1xuZnVuY3Rpb24gaXNDb2xsYXBzZWQoYW5jaG9yTm9kZSwgYW5jaG9yT2Zmc2V0LCBmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KSB7XG4gIHJldHVybiBhbmNob3JOb2RlID09PSBmb2N1c05vZGUgJiYgYW5jaG9yT2Zmc2V0ID09PSBmb2N1c09mZnNldDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIGFwcHJvcHJpYXRlIGFuY2hvciBhbmQgZm9jdXMgbm9kZS9vZmZzZXQgcGFpcnMgZm9yIElFLlxuICpcbiAqIFRoZSBjYXRjaCBoZXJlIGlzIHRoYXQgSUUncyBzZWxlY3Rpb24gQVBJIGRvZXNuJ3QgcHJvdmlkZSBpbmZvcm1hdGlvblxuICogYWJvdXQgd2hldGhlciB0aGUgc2VsZWN0aW9uIGlzIGZvcndhcmQgb3IgYmFja3dhcmQsIHNvIHdlIGhhdmUgdG9cbiAqIGJlaGF2ZSBhcyB0aG91Z2ggaXQncyBhbHdheXMgZm9yd2FyZC5cbiAqXG4gKiBJRSB0ZXh0IGRpZmZlcnMgZnJvbSBtb2Rlcm4gc2VsZWN0aW9uIGluIHRoYXQgaXQgYmVoYXZlcyBhcyB0aG91Z2hcbiAqIGJsb2NrIGVsZW1lbnRzIGVuZCB3aXRoIGEgbmV3IGxpbmUuIFRoaXMgbWVhbnMgY2hhcmFjdGVyIG9mZnNldHMgd2lsbFxuICogZGlmZmVyIGJldHdlZW4gdGhlIHR3byBBUElzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRJRU9mZnNldHMobm9kZSkge1xuICB2YXIgc2VsZWN0aW9uID0gZG9jdW1lbnQuc2VsZWN0aW9uO1xuICB2YXIgc2VsZWN0ZWRSYW5nZSA9IHNlbGVjdGlvbi5jcmVhdGVSYW5nZSgpO1xuICB2YXIgc2VsZWN0ZWRMZW5ndGggPSBzZWxlY3RlZFJhbmdlLnRleHQubGVuZ3RoO1xuXG4gIC8vIER1cGxpY2F0ZSBzZWxlY3Rpb24gc28gd2UgY2FuIG1vdmUgcmFuZ2Ugd2l0aG91dCBicmVha2luZyB1c2VyIHNlbGVjdGlvbi5cbiAgdmFyIGZyb21TdGFydCA9IHNlbGVjdGVkUmFuZ2UuZHVwbGljYXRlKCk7XG4gIGZyb21TdGFydC5tb3ZlVG9FbGVtZW50VGV4dChub2RlKTtcbiAgZnJvbVN0YXJ0LnNldEVuZFBvaW50KCdFbmRUb1N0YXJ0Jywgc2VsZWN0ZWRSYW5nZSk7XG5cbiAgdmFyIHN0YXJ0T2Zmc2V0ID0gZnJvbVN0YXJ0LnRleHQubGVuZ3RoO1xuICB2YXIgZW5kT2Zmc2V0ID0gc3RhcnRPZmZzZXQgKyBzZWxlY3RlZExlbmd0aDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBzdGFydE9mZnNldCxcbiAgICBlbmQ6IGVuZE9mZnNldFxuICB9O1xufVxuXG4vKipcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0TW9kZXJuT2Zmc2V0cyhub2RlKSB7XG4gIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uICYmIHdpbmRvdy5nZXRTZWxlY3Rpb24oKTtcblxuICBpZiAoIXNlbGVjdGlvbiB8fCBzZWxlY3Rpb24ucmFuZ2VDb3VudCA9PT0gMCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGFuY2hvck5vZGUgPSBzZWxlY3Rpb24uYW5jaG9yTm9kZTtcbiAgdmFyIGFuY2hvck9mZnNldCA9IHNlbGVjdGlvbi5hbmNob3JPZmZzZXQ7XG4gIHZhciBmb2N1c05vZGUgPSBzZWxlY3Rpb24uZm9jdXNOb2RlO1xuICB2YXIgZm9jdXNPZmZzZXQgPSBzZWxlY3Rpb24uZm9jdXNPZmZzZXQ7XG5cbiAgdmFyIGN1cnJlbnRSYW5nZSA9IHNlbGVjdGlvbi5nZXRSYW5nZUF0KDApO1xuXG4gIC8vIEluIEZpcmVmb3gsIHJhbmdlLnN0YXJ0Q29udGFpbmVyIGFuZCByYW5nZS5lbmRDb250YWluZXIgY2FuIGJlIFwiYW5vbnltb3VzXG4gIC8vIGRpdnNcIiwgZS5nLiB0aGUgdXAvZG93biBidXR0b25zIG9uIGFuIDxpbnB1dCB0eXBlPVwibnVtYmVyXCI+LiBBbm9ueW1vdXNcbiAgLy8gZGl2cyBkbyBub3Qgc2VlbSB0byBleHBvc2UgcHJvcGVydGllcywgdHJpZ2dlcmluZyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcbiAgLy8gZXJyb3JcIiBpZiBhbnkgb2YgaXRzIHByb3BlcnRpZXMgYXJlIGFjY2Vzc2VkLiBUaGUgb25seSBzZWVtaW5nbHkgcG9zc2libGVcbiAgLy8gd2F5IHRvIGF2b2lkIGVycm9yaW5nIGlzIHRvIGFjY2VzcyBhIHByb3BlcnR5IHRoYXQgdHlwaWNhbGx5IHdvcmtzIGZvclxuICAvLyBub24tYW5vbnltb3VzIGRpdnMgYW5kIGNhdGNoIGFueSBlcnJvciB0aGF0IG1heSBvdGhlcndpc2UgYXJpc2UuIFNlZVxuICAvLyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0yMDg0MjdcbiAgdHJ5IHtcbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtZXhwcmVzc2lvbnMgKi9cbiAgICBjdXJyZW50UmFuZ2Uuc3RhcnRDb250YWluZXIubm9kZVR5cGU7XG4gICAgY3VycmVudFJhbmdlLmVuZENvbnRhaW5lci5ub2RlVHlwZTtcbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC1leHByZXNzaW9ucyAqL1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBJZiB0aGUgbm9kZSBhbmQgb2Zmc2V0IHZhbHVlcyBhcmUgdGhlIHNhbWUsIHRoZSBzZWxlY3Rpb24gaXMgY29sbGFwc2VkLlxuICAvLyBgU2VsZWN0aW9uLmlzQ29sbGFwc2VkYCBpcyBhdmFpbGFibGUgbmF0aXZlbHksIGJ1dCBJRSBzb21ldGltZXMgZ2V0c1xuICAvLyB0aGlzIHZhbHVlIHdyb25nLlxuICB2YXIgaXNTZWxlY3Rpb25Db2xsYXBzZWQgPSBpc0NvbGxhcHNlZChzZWxlY3Rpb24uYW5jaG9yTm9kZSwgc2VsZWN0aW9uLmFuY2hvck9mZnNldCwgc2VsZWN0aW9uLmZvY3VzTm9kZSwgc2VsZWN0aW9uLmZvY3VzT2Zmc2V0KTtcblxuICB2YXIgcmFuZ2VMZW5ndGggPSBpc1NlbGVjdGlvbkNvbGxhcHNlZCA/IDAgOiBjdXJyZW50UmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG5cbiAgdmFyIHRlbXBSYW5nZSA9IGN1cnJlbnRSYW5nZS5jbG9uZVJhbmdlKCk7XG4gIHRlbXBSYW5nZS5zZWxlY3ROb2RlQ29udGVudHMobm9kZSk7XG4gIHRlbXBSYW5nZS5zZXRFbmQoY3VycmVudFJhbmdlLnN0YXJ0Q29udGFpbmVyLCBjdXJyZW50UmFuZ2Uuc3RhcnRPZmZzZXQpO1xuXG4gIHZhciBpc1RlbXBSYW5nZUNvbGxhcHNlZCA9IGlzQ29sbGFwc2VkKHRlbXBSYW5nZS5zdGFydENvbnRhaW5lciwgdGVtcFJhbmdlLnN0YXJ0T2Zmc2V0LCB0ZW1wUmFuZ2UuZW5kQ29udGFpbmVyLCB0ZW1wUmFuZ2UuZW5kT2Zmc2V0KTtcblxuICB2YXIgc3RhcnQgPSBpc1RlbXBSYW5nZUNvbGxhcHNlZCA/IDAgOiB0ZW1wUmFuZ2UudG9TdHJpbmcoKS5sZW5ndGg7XG4gIHZhciBlbmQgPSBzdGFydCArIHJhbmdlTGVuZ3RoO1xuXG4gIC8vIERldGVjdCB3aGV0aGVyIHRoZSBzZWxlY3Rpb24gaXMgYmFja3dhcmQuXG4gIHZhciBkZXRlY3Rpb25SYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIGRldGVjdGlvblJhbmdlLnNldFN0YXJ0KGFuY2hvck5vZGUsIGFuY2hvck9mZnNldCk7XG4gIGRldGVjdGlvblJhbmdlLnNldEVuZChmb2N1c05vZGUsIGZvY3VzT2Zmc2V0KTtcbiAgdmFyIGlzQmFja3dhcmQgPSBkZXRlY3Rpb25SYW5nZS5jb2xsYXBzZWQ7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydDogaXNCYWNrd2FyZCA/IGVuZCA6IHN0YXJ0LFxuICAgIGVuZDogaXNCYWNrd2FyZCA/IHN0YXJ0IDogZW5kXG4gIH07XG59XG5cbi8qKlxuICogQHBhcmFtIHtET01FbGVtZW50fERPTVRleHROb2RlfSBub2RlXG4gKiBAcGFyYW0ge29iamVjdH0gb2Zmc2V0c1xuICovXG5mdW5jdGlvbiBzZXRJRU9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5zZWxlY3Rpb24uY3JlYXRlUmFuZ2UoKS5kdXBsaWNhdGUoKTtcbiAgdmFyIHN0YXJ0LCBlbmQ7XG5cbiAgaWYgKHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzdGFydCA9IG9mZnNldHMuc3RhcnQ7XG4gICAgZW5kID0gc3RhcnQ7XG4gIH0gZWxzZSBpZiAob2Zmc2V0cy5zdGFydCA+IG9mZnNldHMuZW5kKSB7XG4gICAgc3RhcnQgPSBvZmZzZXRzLmVuZDtcbiAgICBlbmQgPSBvZmZzZXRzLnN0YXJ0O1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0ID0gb2Zmc2V0cy5zdGFydDtcbiAgICBlbmQgPSBvZmZzZXRzLmVuZDtcbiAgfVxuXG4gIHJhbmdlLm1vdmVUb0VsZW1lbnRUZXh0KG5vZGUpO1xuICByYW5nZS5tb3ZlU3RhcnQoJ2NoYXJhY3RlcicsIHN0YXJ0KTtcbiAgcmFuZ2Uuc2V0RW5kUG9pbnQoJ0VuZFRvU3RhcnQnLCByYW5nZSk7XG4gIHJhbmdlLm1vdmVFbmQoJ2NoYXJhY3RlcicsIGVuZCAtIHN0YXJ0KTtcbiAgcmFuZ2Uuc2VsZWN0KCk7XG59XG5cbi8qKlxuICogSW4gbW9kZXJuIG5vbi1JRSBicm93c2Vycywgd2UgY2FuIHN1cHBvcnQgYm90aCBmb3J3YXJkIGFuZCBiYWNrd2FyZFxuICogc2VsZWN0aW9ucy5cbiAqXG4gKiBOb3RlOiBJRTEwKyBzdXBwb3J0cyB0aGUgU2VsZWN0aW9uIG9iamVjdCwgYnV0IGl0IGRvZXMgbm90IHN1cHBvcnRcbiAqIHRoZSBgZXh0ZW5kYCBtZXRob2QsIHdoaWNoIG1lYW5zIHRoYXQgZXZlbiBpbiBtb2Rlcm4gSUUsIGl0J3Mgbm90IHBvc3NpYmxlXG4gKiB0byBwcm9ncmFtYXRpY2FsbHkgY3JlYXRlIGEgYmFja3dhcmQgc2VsZWN0aW9uLiBUaHVzLCBmb3IgYWxsIElFXG4gKiB2ZXJzaW9ucywgd2UgdXNlIHRoZSBvbGQgSUUgQVBJIHRvIGNyZWF0ZSBvdXIgc2VsZWN0aW9ucy5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvZmZzZXRzXG4gKi9cbmZ1bmN0aW9uIHNldE1vZGVybk9mZnNldHMobm9kZSwgb2Zmc2V0cykge1xuICBpZiAoIXdpbmRvdy5nZXRTZWxlY3Rpb24pIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICB2YXIgbGVuZ3RoID0gbm9kZVtnZXRUZXh0Q29udGVudEFjY2Vzc29yKCldLmxlbmd0aDtcbiAgdmFyIHN0YXJ0ID0gTWF0aC5taW4ob2Zmc2V0cy5zdGFydCwgbGVuZ3RoKTtcbiAgdmFyIGVuZCA9IHR5cGVvZiBvZmZzZXRzLmVuZCA9PT0gJ3VuZGVmaW5lZCcgPyBzdGFydCA6IE1hdGgubWluKG9mZnNldHMuZW5kLCBsZW5ndGgpO1xuXG4gIC8vIElFIDExIHVzZXMgbW9kZXJuIHNlbGVjdGlvbiwgYnV0IGRvZXNuJ3Qgc3VwcG9ydCB0aGUgZXh0ZW5kIG1ldGhvZC5cbiAgLy8gRmxpcCBiYWNrd2FyZCBzZWxlY3Rpb25zLCBzbyB3ZSBjYW4gc2V0IHdpdGggYSBzaW5nbGUgcmFuZ2UuXG4gIGlmICghc2VsZWN0aW9uLmV4dGVuZCAmJiBzdGFydCA+IGVuZCkge1xuICAgIHZhciB0ZW1wID0gZW5kO1xuICAgIGVuZCA9IHN0YXJ0O1xuICAgIHN0YXJ0ID0gdGVtcDtcbiAgfVxuXG4gIHZhciBzdGFydE1hcmtlciA9IGdldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQobm9kZSwgc3RhcnQpO1xuICB2YXIgZW5kTWFya2VyID0gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChub2RlLCBlbmQpO1xuXG4gIGlmIChzdGFydE1hcmtlciAmJiBlbmRNYXJrZXIpIHtcbiAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuICAgIHJhbmdlLnNldFN0YXJ0KHN0YXJ0TWFya2VyLm5vZGUsIHN0YXJ0TWFya2VyLm9mZnNldCk7XG4gICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuXG4gICAgaWYgKHN0YXJ0ID4gZW5kKSB7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgICAgc2VsZWN0aW9uLmV4dGVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJhbmdlLnNldEVuZChlbmRNYXJrZXIubm9kZSwgZW5kTWFya2VyLm9mZnNldCk7XG4gICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgdXNlSUVPZmZzZXRzID0gRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NICYmICdzZWxlY3Rpb24nIGluIGRvY3VtZW50ICYmICEoJ2dldFNlbGVjdGlvbicgaW4gd2luZG93KTtcblxudmFyIFJlYWN0RE9NU2VsZWN0aW9uID0ge1xuICAvKipcbiAgICogQHBhcmFtIHtET01FbGVtZW50fSBub2RlXG4gICAqL1xuICBnZXRPZmZzZXRzOiB1c2VJRU9mZnNldHMgPyBnZXRJRU9mZnNldHMgOiBnZXRNb2Rlcm5PZmZzZXRzLFxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAgICogQHBhcmFtIHtvYmplY3R9IG9mZnNldHNcbiAgICovXG4gIHNldE9mZnNldHM6IHVzZUlFT2Zmc2V0cyA/IHNldElFT2Zmc2V0cyA6IHNldE1vZGVybk9mZnNldHNcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZWxlY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZWxlY3Rpb24uanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBHaXZlbiBhbnkgbm9kZSByZXR1cm4gdGhlIGZpcnN0IGxlYWYgbm9kZSB3aXRob3V0IGNoaWxkcmVuLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gbm9kZVxuICogQHJldHVybiB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX1cbiAqL1xuZnVuY3Rpb24gZ2V0TGVhZk5vZGUobm9kZSkge1xuICB3aGlsZSAobm9kZSAmJiBub2RlLmZpcnN0Q2hpbGQpIHtcbiAgICBub2RlID0gbm9kZS5maXJzdENoaWxkO1xuICB9XG4gIHJldHVybiBub2RlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbmV4dCBzaWJsaW5nIHdpdGhpbiBhIGNvbnRhaW5lci4gVGhpcyB3aWxsIHdhbGsgdXAgdGhlXG4gKiBET00gaWYgYSBub2RlJ3Mgc2libGluZ3MgaGF2ZSBiZWVuIGV4aGF1c3RlZC5cbiAqXG4gKiBAcGFyYW0ge0RPTUVsZW1lbnR8RE9NVGV4dE5vZGV9IG5vZGVcbiAqIEByZXR1cm4gez9ET01FbGVtZW50fERPTVRleHROb2RlfVxuICovXG5mdW5jdGlvbiBnZXRTaWJsaW5nTm9kZShub2RlKSB7XG4gIHdoaWxlIChub2RlKSB7XG4gICAgaWYgKG5vZGUubmV4dFNpYmxpbmcpIHtcbiAgICAgIHJldHVybiBub2RlLm5leHRTaWJsaW5nO1xuICAgIH1cbiAgICBub2RlID0gbm9kZS5wYXJlbnROb2RlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IG9iamVjdCBkZXNjcmliaW5nIHRoZSBub2RlcyB3aGljaCBjb250YWluIGNoYXJhY3RlcnMgYXQgb2Zmc2V0LlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudHxET01UZXh0Tm9kZX0gcm9vdFxuICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFxuICogQHJldHVybiB7P29iamVjdH1cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZUZvckNoYXJhY3Rlck9mZnNldChyb290LCBvZmZzZXQpIHtcbiAgdmFyIG5vZGUgPSBnZXRMZWFmTm9kZShyb290KTtcbiAgdmFyIG5vZGVTdGFydCA9IDA7XG4gIHZhciBub2RlRW5kID0gMDtcblxuICB3aGlsZSAobm9kZSkge1xuICAgIGlmIChub2RlLm5vZGVUeXBlID09PSAzKSB7XG4gICAgICBub2RlRW5kID0gbm9kZVN0YXJ0ICsgbm9kZS50ZXh0Q29udGVudC5sZW5ndGg7XG5cbiAgICAgIGlmIChub2RlU3RhcnQgPD0gb2Zmc2V0ICYmIG5vZGVFbmQgPj0gb2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICBvZmZzZXQ6IG9mZnNldCAtIG5vZGVTdGFydFxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBub2RlU3RhcnQgPSBub2RlRW5kO1xuICAgIH1cblxuICAgIG5vZGUgPSBnZXRMZWFmTm9kZShnZXRTaWJsaW5nTm9kZShub2RlKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXROb2RlRm9yQ2hhcmFjdGVyT2Zmc2V0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2dldE5vZGVGb3JDaGFyYWN0ZXJPZmZzZXQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZ2V0QWN0aXZlRWxlbWVudFxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBmYi13d3cvdHlwZW9mLXVuZGVmaW5lZCAqL1xuXG4vKipcbiAqIFNhbWUgYXMgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBidXQgd3JhcHMgaW4gYSB0cnktY2F0Y2ggYmxvY2suIEluIElFIGl0IGlzXG4gKiBub3Qgc2FmZSB0byBjYWxsIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgaWYgdGhlcmUgaXMgbm90aGluZyBmb2N1c2VkLlxuICpcbiAqIFRoZSBhY3RpdmVFbGVtZW50IHdpbGwgYmUgbnVsbCBvbmx5IGlmIHRoZSBkb2N1bWVudCBvciBkb2N1bWVudCBib2R5IGlzIG5vdFxuICogeWV0IGRlZmluZWQuXG4gKi9cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gZ2V0QWN0aXZlRWxlbWVudCgpIC8qP0RPTUVsZW1lbnQqL3tcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50IHx8IGRvY3VtZW50LmJvZHk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuYm9keTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGdldEFjdGl2ZUVsZW1lbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL2dldEFjdGl2ZUVsZW1lbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU2VsZWN0RXZlbnRQbHVnaW5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFdmVudENvbnN0YW50cyA9IHJlcXVpcmUoJy4vRXZlbnRDb25zdGFudHMnKTtcbnZhciBFdmVudFByb3BhZ2F0b3JzID0gcmVxdWlyZSgnLi9FdmVudFByb3BhZ2F0b3JzJyk7XG52YXIgRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xudmFyIFJlYWN0SW5wdXRTZWxlY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0SW5wdXRTZWxlY3Rpb24nKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxudmFyIGdldEFjdGl2ZUVsZW1lbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9nZXRBY3RpdmVFbGVtZW50Jyk7XG52YXIgaXNUZXh0SW5wdXRFbGVtZW50ID0gcmVxdWlyZSgnLi9pc1RleHRJbnB1dEVsZW1lbnQnKTtcbnZhciBrZXlPZiA9IHJlcXVpcmUoJ2ZianMvbGliL2tleU9mJyk7XG52YXIgc2hhbGxvd0VxdWFsID0gcmVxdWlyZSgnZmJqcy9saWIvc2hhbGxvd0VxdWFsJyk7XG5cbnZhciB0b3BMZXZlbFR5cGVzID0gRXZlbnRDb25zdGFudHMudG9wTGV2ZWxUeXBlcztcblxudmFyIHNraXBTZWxlY3Rpb25DaGFuZ2VFdmVudCA9IEV4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSAmJiAnZG9jdW1lbnRNb2RlJyBpbiBkb2N1bWVudCAmJiBkb2N1bWVudC5kb2N1bWVudE1vZGUgPD0gMTE7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBzZWxlY3Q6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU2VsZWN0Q2FwdHVyZTogbnVsbCB9KVxuICAgIH0sXG4gICAgZGVwZW5kZW5jaWVzOiBbdG9wTGV2ZWxUeXBlcy50b3BCbHVyLCB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51LCB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzLCB0b3BMZXZlbFR5cGVzLnRvcEtleURvd24sIHRvcExldmVsVHlwZXMudG9wTW91c2VEb3duLCB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXAsIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlXVxuICB9XG59O1xuXG52YXIgYWN0aXZlRWxlbWVudCA9IG51bGw7XG52YXIgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbnZhciBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbnZhciBtb3VzZURvd24gPSBmYWxzZTtcblxuLy8gVHJhY2sgd2hldGhlciBhIGxpc3RlbmVyIGV4aXN0cyBmb3IgdGhpcyBwbHVnaW4uIElmIG5vbmUgZXhpc3QsIHdlIGRvXG4vLyBub3QgZXh0cmFjdCBldmVudHMuXG52YXIgaGFzTGlzdGVuZXIgPSBmYWxzZTtcbnZhciBPTl9TRUxFQ1RfS0VZID0ga2V5T2YoeyBvblNlbGVjdDogbnVsbCB9KTtcblxuLyoqXG4gKiBHZXQgYW4gb2JqZWN0IHdoaWNoIGlzIGEgdW5pcXVlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cbiAqXG4gKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgbm90IGJlIGNvbnNpc3RlbnQgYWNyb3NzIG5vZGVzIG9yIGJyb3dzZXJzLCBidXRcbiAqIHR3byBpZGVudGljYWwgc2VsZWN0aW9ucyBvbiB0aGUgc2FtZSBub2RlIHdpbGwgcmV0dXJuIGlkZW50aWNhbCBvYmplY3RzLlxuICpcbiAqIEBwYXJhbSB7RE9NRWxlbWVudH0gbm9kZVxuICogQHJldHVybiB7b2JqZWN0fVxuICovXG5mdW5jdGlvbiBnZXRTZWxlY3Rpb24obm9kZSkge1xuICBpZiAoJ3NlbGVjdGlvblN0YXJ0JyBpbiBub2RlICYmIFJlYWN0SW5wdXRTZWxlY3Rpb24uaGFzU2VsZWN0aW9uQ2FwYWJpbGl0aWVzKG5vZGUpKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0YXJ0OiBub2RlLnNlbGVjdGlvblN0YXJ0LFxuICAgICAgZW5kOiBub2RlLnNlbGVjdGlvbkVuZFxuICAgIH07XG4gIH0gZWxzZSBpZiAod2luZG93LmdldFNlbGVjdGlvbikge1xuICAgIHZhciBzZWxlY3Rpb24gPSB3aW5kb3cuZ2V0U2VsZWN0aW9uKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvck5vZGU6IHNlbGVjdGlvbi5hbmNob3JOb2RlLFxuICAgICAgYW5jaG9yT2Zmc2V0OiBzZWxlY3Rpb24uYW5jaG9yT2Zmc2V0LFxuICAgICAgZm9jdXNOb2RlOiBzZWxlY3Rpb24uZm9jdXNOb2RlLFxuICAgICAgZm9jdXNPZmZzZXQ6IHNlbGVjdGlvbi5mb2N1c09mZnNldFxuICAgIH07XG4gIH0gZWxzZSBpZiAoZG9jdW1lbnQuc2VsZWN0aW9uKSB7XG4gICAgdmFyIHJhbmdlID0gZG9jdW1lbnQuc2VsZWN0aW9uLmNyZWF0ZVJhbmdlKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcmVudEVsZW1lbnQ6IHJhbmdlLnBhcmVudEVsZW1lbnQoKSxcbiAgICAgIHRleHQ6IHJhbmdlLnRleHQsXG4gICAgICB0b3A6IHJhbmdlLmJvdW5kaW5nVG9wLFxuICAgICAgbGVmdDogcmFuZ2UuYm91bmRpbmdMZWZ0XG4gICAgfTtcbiAgfVxufVxuXG4vKipcbiAqIFBvbGwgc2VsZWN0aW9uIHRvIHNlZSB3aGV0aGVyIGl0J3MgY2hhbmdlZC5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnRcbiAqIEByZXR1cm4gez9TeW50aGV0aWNFdmVudH1cbiAqL1xuZnVuY3Rpb24gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIC8vIEVuc3VyZSB3ZSBoYXZlIHRoZSByaWdodCBlbGVtZW50LCBhbmQgdGhhdCB0aGUgdXNlciBpcyBub3QgZHJhZ2dpbmcgYVxuICAvLyBzZWxlY3Rpb24gKHRoaXMgbWF0Y2hlcyBuYXRpdmUgYHNlbGVjdGAgZXZlbnQgYmVoYXZpb3IpLiBJbiBIVE1MNSwgc2VsZWN0XG4gIC8vIGZpcmVzIG9ubHkgb24gaW5wdXQgYW5kIHRleHRhcmVhIHRodXMgaWYgdGhlcmUncyBubyBmb2N1c2VkIGVsZW1lbnQgd2VcbiAgLy8gd29uJ3QgZGlzcGF0Y2guXG4gIGlmIChtb3VzZURvd24gfHwgYWN0aXZlRWxlbWVudCA9PSBudWxsIHx8IGFjdGl2ZUVsZW1lbnQgIT09IGdldEFjdGl2ZUVsZW1lbnQoKSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gT25seSBmaXJlIHdoZW4gc2VsZWN0aW9uIGhhcyBhY3R1YWxseSBjaGFuZ2VkLlxuICB2YXIgY3VycmVudFNlbGVjdGlvbiA9IGdldFNlbGVjdGlvbihhY3RpdmVFbGVtZW50KTtcbiAgaWYgKCFsYXN0U2VsZWN0aW9uIHx8ICFzaGFsbG93RXF1YWwobGFzdFNlbGVjdGlvbiwgY3VycmVudFNlbGVjdGlvbikpIHtcbiAgICBsYXN0U2VsZWN0aW9uID0gY3VycmVudFNlbGVjdGlvbjtcblxuICAgIHZhciBzeW50aGV0aWNFdmVudCA9IFN5bnRoZXRpY0V2ZW50LmdldFBvb2xlZChldmVudFR5cGVzLnNlbGVjdCwgYWN0aXZlRWxlbWVudElELCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgc3ludGhldGljRXZlbnQudHlwZSA9ICdzZWxlY3QnO1xuICAgIHN5bnRoZXRpY0V2ZW50LnRhcmdldCA9IGFjdGl2ZUVsZW1lbnQ7XG5cbiAgICBFdmVudFByb3BhZ2F0b3JzLmFjY3VtdWxhdGVUd29QaGFzZURpc3BhdGNoZXMoc3ludGhldGljRXZlbnQpO1xuXG4gICAgcmV0dXJuIHN5bnRoZXRpY0V2ZW50O1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY3JlYXRlcyBhbiBgb25TZWxlY3RgIGV2ZW50IHRoYXQgbm9ybWFsaXplcyBzZWxlY3QgZXZlbnRzXG4gKiBhY3Jvc3MgZm9ybSBlbGVtZW50cy5cbiAqXG4gKiBTdXBwb3J0ZWQgZWxlbWVudHMgYXJlOlxuICogLSBpbnB1dCAoc2VlIGBpc1RleHRJbnB1dEVsZW1lbnRgKVxuICogLSB0ZXh0YXJlYVxuICogLSBjb250ZW50RWRpdGFibGVcbiAqXG4gKiBUaGlzIGRpZmZlcnMgZnJvbSBuYXRpdmUgYnJvd3NlciBpbXBsZW1lbnRhdGlvbnMgaW4gdGhlIGZvbGxvd2luZyB3YXlzOlxuICogLSBGaXJlcyBvbiBjb250ZW50RWRpdGFibGUgZmllbGRzIGFzIHdlbGwgYXMgaW5wdXRzLlxuICogLSBGaXJlcyBmb3IgY29sbGFwc2VkIHNlbGVjdGlvbi5cbiAqIC0gRmlyZXMgYWZ0ZXIgdXNlciBpbnB1dC5cbiAqL1xudmFyIFNlbGVjdEV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIGlmICghaGFzTGlzdGVuZXIpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9wTGV2ZWxUeXBlKSB7XG4gICAgICAvLyBUcmFjayB0aGUgaW5wdXQgbm9kZSB0aGF0IGhhcyBmb2N1cy5cbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BGb2N1czpcbiAgICAgICAgaWYgKGlzVGV4dElucHV0RWxlbWVudCh0b3BMZXZlbFRhcmdldCkgfHwgdG9wTGV2ZWxUYXJnZXQuY29udGVudEVkaXRhYmxlID09PSAndHJ1ZScpIHtcbiAgICAgICAgICBhY3RpdmVFbGVtZW50ID0gdG9wTGV2ZWxUYXJnZXQ7XG4gICAgICAgICAgYWN0aXZlRWxlbWVudElEID0gdG9wTGV2ZWxUYXJnZXRJRDtcbiAgICAgICAgICBsYXN0U2VsZWN0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgICBhY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICAgICAgYWN0aXZlRWxlbWVudElEID0gbnVsbDtcbiAgICAgICAgbGFzdFNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICAvLyBEb24ndCBmaXJlIHRoZSBldmVudCB3aGlsZSB0aGUgdXNlciBpcyBkcmFnZ2luZy4gVGhpcyBtYXRjaGVzIHRoZVxuICAgICAgLy8gc2VtYW50aWNzIG9mIHRoZSBuYXRpdmUgc2VsZWN0IGV2ZW50LlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgICAgbW91c2VEb3duID0gdHJ1ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ29udGV4dE1lbnU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VVcDpcbiAgICAgICAgbW91c2VEb3duID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBjb25zdHJ1Y3RTZWxlY3RFdmVudChuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xuXG4gICAgICAvLyBDaHJvbWUgYW5kIElFIGZpcmUgbm9uLXN0YW5kYXJkIGV2ZW50IHdoZW4gc2VsZWN0aW9uIGlzIGNoYW5nZWQgKGFuZFxuICAgICAgLy8gc29tZXRpbWVzIHdoZW4gaXQgaGFzbid0KS4gSUUncyBldmVudCBmaXJlcyBvdXQgb2Ygb3JkZXIgd2l0aCByZXNwZWN0XG4gICAgICAvLyB0byBrZXkgYW5kIGlucHV0IGV2ZW50cyBvbiBkZWxldGlvbiwgc28gd2UgZGlzY2FyZCBpdC5cbiAgICAgIC8vXG4gICAgICAvLyBGaXJlZm94IGRvZXNuJ3Qgc3VwcG9ydCBzZWxlY3Rpb25jaGFuZ2UsIHNvIGNoZWNrIHNlbGVjdGlvbiBzdGF0dXNcbiAgICAgIC8vIGFmdGVyIGVhY2gga2V5IGVudHJ5LiBUaGUgc2VsZWN0aW9uIGNoYW5nZXMgYWZ0ZXIga2V5ZG93biBhbmQgYmVmb3JlXG4gICAgICAvLyBrZXl1cCwgYnV0IHdlIGNoZWNrIG9uIGtleWRvd24gYXMgd2VsbCBpbiB0aGUgY2FzZSBvZiBob2xkaW5nIGRvd24gYVxuICAgICAgLy8ga2V5LCB3aGVuIG11bHRpcGxlIGtleWRvd24gZXZlbnRzIGFyZSBmaXJlZCBidXQgb25seSBvbmUga2V5dXAgaXMuXG4gICAgICAvLyBUaGlzIGlzIGFsc28gb3VyIGFwcHJvYWNoIGZvciBJRSBoYW5kbGluZywgZm9yIHRoZSByZWFzb24gYWJvdmUuXG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2VsZWN0aW9uQ2hhbmdlOlxuICAgICAgICBpZiAoc2tpcFNlbGVjdGlvbkNoYW5nZUV2ZW50KSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIC8vIGZhbGxzIHRocm91Z2hcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BLZXlEb3duOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVVwOlxuICAgICAgICByZXR1cm4gY29uc3RydWN0U2VsZWN0RXZlbnQobmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfSxcblxuICBkaWRQdXRMaXN0ZW5lcjogZnVuY3Rpb24gKGlkLCByZWdpc3RyYXRpb25OYW1lLCBsaXN0ZW5lcikge1xuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9TRUxFQ1RfS0VZKSB7XG4gICAgICBoYXNMaXN0ZW5lciA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdEV2ZW50UGx1Z2luO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1NlbGVjdEV2ZW50UGx1Z2luLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFNlcnZlclJlYWN0Um9vdEluZGV4XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaXplIG9mIHRoZSByZWFjdFJvb3QgSUQgc3BhY2UuIFdlIGdlbmVyYXRlIHJhbmRvbSBudW1iZXJzIGZvciBSZWFjdCByb290XG4gKiBJRHMgYW5kIGlmIHRoZXJlJ3MgYSBjb2xsaXNpb24gdGhlIGV2ZW50cyBhbmQgRE9NIHVwZGF0ZSBzeXN0ZW0gd2lsbFxuICogZ2V0IGNvbmZ1c2VkLiBJbiB0aGUgZnV0dXJlIHdlIG5lZWQgYSB3YXkgdG8gZ2VuZXJhdGUgR1VJRHMgYnV0IGZvclxuICogbm93IHRoaXMgd2lsbCB3b3JrIG9uIGEgc21hbGxlciBzY2FsZS5cbiAqL1xudmFyIEdMT0JBTF9NT1VOVF9QT0lOVF9NQVggPSBNYXRoLnBvdygyLCA1Myk7XG5cbnZhciBTZXJ2ZXJSZWFjdFJvb3RJbmRleCA9IHtcbiAgY3JlYXRlUmVhY3RSb290SW5kZXg6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKE1hdGgucmFuZG9tKCkgKiBHTE9CQUxfTU9VTlRfUE9JTlRfTUFYKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTZXJ2ZXJSZWFjdFJvb3RJbmRleDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TZXJ2ZXJSZWFjdFJvb3RJbmRleC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTaW1wbGVFdmVudFBsdWdpblxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50Q29uc3RhbnRzID0gcmVxdWlyZSgnLi9FdmVudENvbnN0YW50cycpO1xudmFyIEV2ZW50TGlzdGVuZXIgPSByZXF1aXJlKCdmYmpzL2xpYi9FdmVudExpc3RlbmVyJyk7XG52YXIgRXZlbnRQcm9wYWdhdG9ycyA9IHJlcXVpcmUoJy4vRXZlbnRQcm9wYWdhdG9ycycpO1xudmFyIFJlYWN0TW91bnQgPSByZXF1aXJlKCcuL1JlYWN0TW91bnQnKTtcbnZhciBTeW50aGV0aWNDbGlwYm9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljQ2xpcGJvYXJkRXZlbnQnKTtcbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcbnZhciBTeW50aGV0aWNGb2N1c0V2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNGb2N1c0V2ZW50Jyk7XG52YXIgU3ludGhldGljS2V5Ym9hcmRFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljS2V5Ym9hcmRFdmVudCcpO1xudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcbnZhciBTeW50aGV0aWNEcmFnRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY0RyYWdFdmVudCcpO1xudmFyIFN5bnRoZXRpY1RvdWNoRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1RvdWNoRXZlbnQnKTtcbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG52YXIgU3ludGhldGljV2hlZWxFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljV2hlZWxFdmVudCcpO1xuXG52YXIgZW1wdHlGdW5jdGlvbiA9IHJlcXVpcmUoJ2ZianMvbGliL2VtcHR5RnVuY3Rpb24nKTtcbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIga2V5T2YgPSByZXF1aXJlKCdmYmpzL2xpYi9rZXlPZicpO1xuXG52YXIgdG9wTGV2ZWxUeXBlcyA9IEV2ZW50Q29uc3RhbnRzLnRvcExldmVsVHlwZXM7XG5cbnZhciBldmVudFR5cGVzID0ge1xuICBhYm9ydDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQWJvcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkFib3J0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgYmx1cjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQmx1cjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQmx1ckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNhblBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNhblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjYW5QbGF5VGhyb3VnaDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uQ2FuUGxheVRocm91Z2g6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkNhblBsYXlUaHJvdWdoQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY2xpY2s6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkNsaWNrOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25DbGlja0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGNvbnRleHRNZW51OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db250ZXh0TWVudTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uQ29udGV4dE1lbnVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBjb3B5OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Db3B5OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Db3B5Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgY3V0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25DdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkN1dENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRvdWJsZUNsaWNrOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Eb3VibGVDbGljazogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRG91YmxlQ2xpY2tDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0VuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VuZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ0VuZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdFbnRlcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0VudGVyOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25EcmFnRW50ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnRXhpdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJhZ0V4aXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdFeGl0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJhZ0xlYXZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnTGVhdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkRyYWdMZWF2ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGRyYWdPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EcmFnT3ZlcjogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ092ZXJDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBkcmFnU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkRyYWdTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJhZ1N0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZHJvcDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRHJvcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHJvcENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGR1cmF0aW9uQ2hhbmdlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25EdXJhdGlvbkNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRHVyYXRpb25DaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlbXB0aWVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbXB0aWVkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25FbXB0aWVkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZW5jcnlwdGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmNyeXB0ZWQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVuY3J5cHRlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGVuZGVkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25FbmRlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uRW5kZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBlcnJvcjoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uRXJyb3I6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbkVycm9yQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgZm9jdXM6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkZvY3VzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Gb2N1c0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGlucHV0OiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25JbnB1dDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uSW5wdXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBrZXlEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlEb3duOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlEb3duQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAga2V5UHJlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbktleVByZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25LZXlQcmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGtleVVwOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25LZXlVcDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uS2V5VXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Mb2FkQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbG9hZGVkRGF0YToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkRGF0YUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIGxvYWRlZE1ldGFkYXRhOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Mb2FkZWRNZXRhZGF0YTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZGVkTWV0YWRhdGFDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBsb2FkU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbkxvYWRTdGFydDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uTG9hZFN0YXJ0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgLy8gTm90ZTogV2UgZG8gbm90IGFsbG93IGxpc3RlbmluZyB0byBtb3VzZU92ZXIgZXZlbnRzLiBJbnN0ZWFkLCB1c2UgdGhlXG4gIC8vIG9uTW91c2VFbnRlci9vbk1vdXNlTGVhdmUgY3JlYXRlZCBieSBgRW50ZXJMZWF2ZUV2ZW50UGx1Z2luYC5cbiAgbW91c2VEb3duOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZURvd246IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlRG93bkNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlTW92ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VNb3ZlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Nb3VzZU1vdmVDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBtb3VzZU91dDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uTW91c2VPdXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgbW91c2VPdmVyOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Nb3VzZU92ZXI6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlT3ZlckNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIG1vdXNlVXA6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvbk1vdXNlVXA6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvbk1vdXNlVXBDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwYXN0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUGFzdGU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBhc3RlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcGF1c2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBhdXNlOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QYXVzZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHBsYXk6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblBsYXk6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblBsYXlDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBwbGF5aW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25QbGF5aW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25QbGF5aW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgcHJvZ3Jlc3M6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblByb2dyZXNzOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25Qcm9ncmVzc0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHJhdGVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2U6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJhdGVDaGFuZ2VDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICByZXNldDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uUmVzZXQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblJlc2V0Q2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc2Nyb2xsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TY3JvbGw6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblNjcm9sbENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHNlZWtlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU2Vla2VkOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVrZWRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzZWVraW5nOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TZWVraW5nOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TZWVraW5nQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgc3RhbGxlZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3RhbGxlZDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uU3RhbGxlZENhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHN1Ym1pdDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uU3VibWl0OiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdWJtaXRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICBzdXNwZW5kOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25TdXNwZW5kOiB0cnVlIH0pLFxuICAgICAgY2FwdHVyZWQ6IGtleU9mKHsgb25TdXNwZW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdGltZVVwZGF0ZToge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVGltZVVwZGF0ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoQ2FuY2VsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaENhbmNlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVG91Y2hDYW5jZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB0b3VjaEVuZDoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uVG91Y2hFbmQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoRW5kQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgdG91Y2hNb3ZlOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25Ub3VjaE1vdmU6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoTW92ZUNhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHRvdWNoU3RhcnQ6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblRvdWNoU3RhcnQ6IHRydWUgfSksXG4gICAgICBjYXB0dXJlZDoga2V5T2YoeyBvblRvdWNoU3RhcnRDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9LFxuICB2b2x1bWVDaGFuZ2U6IHtcbiAgICBwaGFzZWRSZWdpc3RyYXRpb25OYW1lczoge1xuICAgICAgYnViYmxlZDoga2V5T2YoeyBvblZvbHVtZUNoYW5nZTogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uVm9sdW1lQ2hhbmdlQ2FwdHVyZTogdHJ1ZSB9KVxuICAgIH1cbiAgfSxcbiAgd2FpdGluZzoge1xuICAgIHBoYXNlZFJlZ2lzdHJhdGlvbk5hbWVzOiB7XG4gICAgICBidWJibGVkOiBrZXlPZih7IG9uV2FpdGluZzogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2FpdGluZ0NhcHR1cmU6IHRydWUgfSlcbiAgICB9XG4gIH0sXG4gIHdoZWVsOiB7XG4gICAgcGhhc2VkUmVnaXN0cmF0aW9uTmFtZXM6IHtcbiAgICAgIGJ1YmJsZWQ6IGtleU9mKHsgb25XaGVlbDogdHJ1ZSB9KSxcbiAgICAgIGNhcHR1cmVkOiBrZXlPZih7IG9uV2hlZWxDYXB0dXJlOiB0cnVlIH0pXG4gICAgfVxuICB9XG59O1xuXG52YXIgdG9wTGV2ZWxFdmVudHNUb0Rpc3BhdGNoQ29uZmlnID0ge1xuICB0b3BBYm9ydDogZXZlbnRUeXBlcy5hYm9ydCxcbiAgdG9wQmx1cjogZXZlbnRUeXBlcy5ibHVyLFxuICB0b3BDYW5QbGF5OiBldmVudFR5cGVzLmNhblBsYXksXG4gIHRvcENhblBsYXlUaHJvdWdoOiBldmVudFR5cGVzLmNhblBsYXlUaHJvdWdoLFxuICB0b3BDbGljazogZXZlbnRUeXBlcy5jbGljayxcbiAgdG9wQ29udGV4dE1lbnU6IGV2ZW50VHlwZXMuY29udGV4dE1lbnUsXG4gIHRvcENvcHk6IGV2ZW50VHlwZXMuY29weSxcbiAgdG9wQ3V0OiBldmVudFR5cGVzLmN1dCxcbiAgdG9wRG91YmxlQ2xpY2s6IGV2ZW50VHlwZXMuZG91YmxlQ2xpY2ssXG4gIHRvcERyYWc6IGV2ZW50VHlwZXMuZHJhZyxcbiAgdG9wRHJhZ0VuZDogZXZlbnRUeXBlcy5kcmFnRW5kLFxuICB0b3BEcmFnRW50ZXI6IGV2ZW50VHlwZXMuZHJhZ0VudGVyLFxuICB0b3BEcmFnRXhpdDogZXZlbnRUeXBlcy5kcmFnRXhpdCxcbiAgdG9wRHJhZ0xlYXZlOiBldmVudFR5cGVzLmRyYWdMZWF2ZSxcbiAgdG9wRHJhZ092ZXI6IGV2ZW50VHlwZXMuZHJhZ092ZXIsXG4gIHRvcERyYWdTdGFydDogZXZlbnRUeXBlcy5kcmFnU3RhcnQsXG4gIHRvcERyb3A6IGV2ZW50VHlwZXMuZHJvcCxcbiAgdG9wRHVyYXRpb25DaGFuZ2U6IGV2ZW50VHlwZXMuZHVyYXRpb25DaGFuZ2UsXG4gIHRvcEVtcHRpZWQ6IGV2ZW50VHlwZXMuZW1wdGllZCxcbiAgdG9wRW5jcnlwdGVkOiBldmVudFR5cGVzLmVuY3J5cHRlZCxcbiAgdG9wRW5kZWQ6IGV2ZW50VHlwZXMuZW5kZWQsXG4gIHRvcEVycm9yOiBldmVudFR5cGVzLmVycm9yLFxuICB0b3BGb2N1czogZXZlbnRUeXBlcy5mb2N1cyxcbiAgdG9wSW5wdXQ6IGV2ZW50VHlwZXMuaW5wdXQsXG4gIHRvcEtleURvd246IGV2ZW50VHlwZXMua2V5RG93bixcbiAgdG9wS2V5UHJlc3M6IGV2ZW50VHlwZXMua2V5UHJlc3MsXG4gIHRvcEtleVVwOiBldmVudFR5cGVzLmtleVVwLFxuICB0b3BMb2FkOiBldmVudFR5cGVzLmxvYWQsXG4gIHRvcExvYWRlZERhdGE6IGV2ZW50VHlwZXMubG9hZGVkRGF0YSxcbiAgdG9wTG9hZGVkTWV0YWRhdGE6IGV2ZW50VHlwZXMubG9hZGVkTWV0YWRhdGEsXG4gIHRvcExvYWRTdGFydDogZXZlbnRUeXBlcy5sb2FkU3RhcnQsXG4gIHRvcE1vdXNlRG93bjogZXZlbnRUeXBlcy5tb3VzZURvd24sXG4gIHRvcE1vdXNlTW92ZTogZXZlbnRUeXBlcy5tb3VzZU1vdmUsXG4gIHRvcE1vdXNlT3V0OiBldmVudFR5cGVzLm1vdXNlT3V0LFxuICB0b3BNb3VzZU92ZXI6IGV2ZW50VHlwZXMubW91c2VPdmVyLFxuICB0b3BNb3VzZVVwOiBldmVudFR5cGVzLm1vdXNlVXAsXG4gIHRvcFBhc3RlOiBldmVudFR5cGVzLnBhc3RlLFxuICB0b3BQYXVzZTogZXZlbnRUeXBlcy5wYXVzZSxcbiAgdG9wUGxheTogZXZlbnRUeXBlcy5wbGF5LFxuICB0b3BQbGF5aW5nOiBldmVudFR5cGVzLnBsYXlpbmcsXG4gIHRvcFByb2dyZXNzOiBldmVudFR5cGVzLnByb2dyZXNzLFxuICB0b3BSYXRlQ2hhbmdlOiBldmVudFR5cGVzLnJhdGVDaGFuZ2UsXG4gIHRvcFJlc2V0OiBldmVudFR5cGVzLnJlc2V0LFxuICB0b3BTY3JvbGw6IGV2ZW50VHlwZXMuc2Nyb2xsLFxuICB0b3BTZWVrZWQ6IGV2ZW50VHlwZXMuc2Vla2VkLFxuICB0b3BTZWVraW5nOiBldmVudFR5cGVzLnNlZWtpbmcsXG4gIHRvcFN0YWxsZWQ6IGV2ZW50VHlwZXMuc3RhbGxlZCxcbiAgdG9wU3VibWl0OiBldmVudFR5cGVzLnN1Ym1pdCxcbiAgdG9wU3VzcGVuZDogZXZlbnRUeXBlcy5zdXNwZW5kLFxuICB0b3BUaW1lVXBkYXRlOiBldmVudFR5cGVzLnRpbWVVcGRhdGUsXG4gIHRvcFRvdWNoQ2FuY2VsOiBldmVudFR5cGVzLnRvdWNoQ2FuY2VsLFxuICB0b3BUb3VjaEVuZDogZXZlbnRUeXBlcy50b3VjaEVuZCxcbiAgdG9wVG91Y2hNb3ZlOiBldmVudFR5cGVzLnRvdWNoTW92ZSxcbiAgdG9wVG91Y2hTdGFydDogZXZlbnRUeXBlcy50b3VjaFN0YXJ0LFxuICB0b3BWb2x1bWVDaGFuZ2U6IGV2ZW50VHlwZXMudm9sdW1lQ2hhbmdlLFxuICB0b3BXYWl0aW5nOiBldmVudFR5cGVzLndhaXRpbmcsXG4gIHRvcFdoZWVsOiBldmVudFR5cGVzLndoZWVsXG59O1xuXG5mb3IgKHZhciB0eXBlIGluIHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZykge1xuICB0b3BMZXZlbEV2ZW50c1RvRGlzcGF0Y2hDb25maWdbdHlwZV0uZGVwZW5kZW5jaWVzID0gW3R5cGVdO1xufVxuXG52YXIgT05fQ0xJQ0tfS0VZID0ga2V5T2YoeyBvbkNsaWNrOiBudWxsIH0pO1xudmFyIG9uQ2xpY2tMaXN0ZW5lcnMgPSB7fTtcblxudmFyIFNpbXBsZUV2ZW50UGx1Z2luID0ge1xuXG4gIGV2ZW50VHlwZXM6IGV2ZW50VHlwZXMsXG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0b3BMZXZlbFR5cGUgUmVjb3JkIGZyb20gYEV2ZW50Q29uc3RhbnRzYC5cbiAgICogQHBhcmFtIHtET01FdmVudFRhcmdldH0gdG9wTGV2ZWxUYXJnZXQgVGhlIGxpc3RlbmluZyBjb21wb25lbnQgcm9vdCBub2RlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdG9wTGV2ZWxUYXJnZXRJRCBJRCBvZiBgdG9wTGV2ZWxUYXJnZXRgLlxuICAgKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gICAqIEByZXR1cm4geyp9IEFuIGFjY3VtdWxhdGlvbiBvZiBzeW50aGV0aWMgZXZlbnRzLlxuICAgKiBAc2VlIHtFdmVudFBsdWdpbkh1Yi5leHRyYWN0RXZlbnRzfVxuICAgKi9cbiAgZXh0cmFjdEV2ZW50czogZnVuY3Rpb24gKHRvcExldmVsVHlwZSwgdG9wTGV2ZWxUYXJnZXQsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICAgIHZhciBkaXNwYXRjaENvbmZpZyA9IHRvcExldmVsRXZlbnRzVG9EaXNwYXRjaENvbmZpZ1t0b3BMZXZlbFR5cGVdO1xuICAgIGlmICghZGlzcGF0Y2hDb25maWcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgRXZlbnRDb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKHRvcExldmVsVHlwZSkge1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEFib3J0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENhblBsYXk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2FuUGxheVRocm91Z2g6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHVyYXRpb25DaGFuZ2U6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW1wdGllZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BFbmNyeXB0ZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRW5kZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRXJyb3I6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wSW5wdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTG9hZDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BMb2FkZWREYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRlZE1ldGFkYXRhOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcExvYWRTdGFydDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQYXVzZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BQbGF5OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBsYXlpbmc6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUHJvZ3Jlc3M6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wUmF0ZUNoYW5nZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BSZXNldDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTZWVrZWQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wU2Vla2luZzpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdGFsbGVkOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFN1Ym1pdDpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTdXNwZW5kOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRpbWVVcGRhdGU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVm9sdW1lQ2hhbmdlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFdhaXRpbmc6XG4gICAgICAgIC8vIEhUTUwgRXZlbnRzXG4gICAgICAgIC8vIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvaHRtbDUvaW5kZXguaHRtbCNldmVudHMtMFxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleVByZXNzOlxuICAgICAgICAvLyBGaXJlRm94IGNyZWF0ZXMgYSBrZXlwcmVzcyBldmVudCBmb3IgZnVuY3Rpb24ga2V5cyB0b28uIFRoaXMgcmVtb3Zlc1xuICAgICAgICAvLyB0aGUgdW53YW50ZWQga2V5cHJlc3MgZXZlbnRzLiBFbnRlciBpcyBob3dldmVyIGJvdGggcHJpbnRhYmxlIGFuZFxuICAgICAgICAvLyBub24tcHJpbnRhYmxlLiBPbmUgd291bGQgZXhwZWN0IFRhYiB0byBiZSBhcyB3ZWxsIChidXQgaXQgaXNuJ3QpLlxuICAgICAgICBpZiAoZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEtleURvd246XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wS2V5VXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNLZXlib2FyZEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BCbHVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcEZvY3VzOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljRm9jdXNFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ2xpY2s6XG4gICAgICAgIC8vIEZpcmVmb3ggY3JlYXRlcyBhIGNsaWNrIGV2ZW50IG9uIHJpZ2h0IG1vdXNlIGNsaWNrcy4gVGhpcyByZW1vdmVzIHRoZVxuICAgICAgICAvLyB1bndhbnRlZCBjbGljayBldmVudHMuXG4gICAgICAgIGlmIChuYXRpdmVFdmVudC5idXR0b24gPT09IDIpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvbnRleHRNZW51OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERvdWJsZUNsaWNrOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlRG93bjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BNb3VzZU1vdmU6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdXQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wTW91c2VPdmVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcE1vdXNlVXA6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNNb3VzZUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJhZ0VudGVyOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdFeGl0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcERyYWdMZWF2ZTpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnT3ZlcjpcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BEcmFnU3RhcnQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wRHJvcDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY0RyYWdFdmVudDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hDYW5jZWw6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hFbmQ6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wVG91Y2hNb3ZlOlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFRvdWNoU3RhcnQ6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNUb3VjaEV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BTY3JvbGw6XG4gICAgICAgIEV2ZW50Q29uc3RydWN0b3IgPSBTeW50aGV0aWNVSUV2ZW50O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgdG9wTGV2ZWxUeXBlcy50b3BXaGVlbDpcbiAgICAgICAgRXZlbnRDb25zdHJ1Y3RvciA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcENvcHk6XG4gICAgICBjYXNlIHRvcExldmVsVHlwZXMudG9wQ3V0OlxuICAgICAgY2FzZSB0b3BMZXZlbFR5cGVzLnRvcFBhc3RlOlxuICAgICAgICBFdmVudENvbnN0cnVjdG9yID0gU3ludGhldGljQ2xpcGJvYXJkRXZlbnQ7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICAhRXZlbnRDb25zdHJ1Y3RvciA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdTaW1wbGVFdmVudFBsdWdpbjogVW5oYW5kbGVkIGV2ZW50IHR5cGUsIGAlc2AuJywgdG9wTGV2ZWxUeXBlKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGV2ZW50ID0gRXZlbnRDb25zdHJ1Y3Rvci5nZXRQb29sZWQoZGlzcGF0Y2hDb25maWcsIHRvcExldmVsVGFyZ2V0SUQsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG4gICAgRXZlbnRQcm9wYWdhdG9ycy5hY2N1bXVsYXRlVHdvUGhhc2VEaXNwYXRjaGVzKGV2ZW50KTtcbiAgICByZXR1cm4gZXZlbnQ7XG4gIH0sXG5cbiAgZGlkUHV0TGlzdGVuZXI6IGZ1bmN0aW9uIChpZCwgcmVnaXN0cmF0aW9uTmFtZSwgbGlzdGVuZXIpIHtcbiAgICAvLyBNb2JpbGUgU2FmYXJpIGRvZXMgbm90IGZpcmUgcHJvcGVybHkgYnViYmxlIGNsaWNrIGV2ZW50cyBvblxuICAgIC8vIG5vbi1pbnRlcmFjdGl2ZSBlbGVtZW50cywgd2hpY2ggbWVhbnMgZGVsZWdhdGVkIGNsaWNrIGxpc3RlbmVycyBkbyBub3RcbiAgICAvLyBmaXJlLiBUaGUgd29ya2Fyb3VuZCBmb3IgdGhpcyBidWcgaW52b2x2ZXMgYXR0YWNoaW5nIGFuIGVtcHR5IGNsaWNrXG4gICAgLy8gbGlzdGVuZXIgb24gdGhlIHRhcmdldCBub2RlLlxuICAgIGlmIChyZWdpc3RyYXRpb25OYW1lID09PSBPTl9DTElDS19LRVkpIHtcbiAgICAgIHZhciBub2RlID0gUmVhY3RNb3VudC5nZXROb2RlKGlkKTtcbiAgICAgIGlmICghb25DbGlja0xpc3RlbmVyc1tpZF0pIHtcbiAgICAgICAgb25DbGlja0xpc3RlbmVyc1tpZF0gPSBFdmVudExpc3RlbmVyLmxpc3Rlbihub2RlLCAnY2xpY2snLCBlbXB0eUZ1bmN0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgd2lsbERlbGV0ZUxpc3RlbmVyOiBmdW5jdGlvbiAoaWQsIHJlZ2lzdHJhdGlvbk5hbWUpIHtcbiAgICBpZiAocmVnaXN0cmF0aW9uTmFtZSA9PT0gT05fQ0xJQ0tfS0VZKSB7XG4gICAgICBvbkNsaWNrTGlzdGVuZXJzW2lkXS5yZW1vdmUoKTtcbiAgICAgIGRlbGV0ZSBvbkNsaWNrTGlzdGVuZXJzW2lkXTtcbiAgICB9XG4gIH1cblxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGVFdmVudFBsdWdpbjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TaW1wbGVFdmVudFBsdWdpbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEV2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL2NsaXBib2FyZC1hcGlzL1xuICovXG52YXIgQ2xpcGJvYXJkRXZlbnRJbnRlcmZhY2UgPSB7XG4gIGNsaXBib2FyZERhdGE6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHJldHVybiAnY2xpcGJvYXJkRGF0YScgaW4gZXZlbnQgPyBldmVudC5jbGlwYm9hcmREYXRhIDogd2luZG93LmNsaXBib2FyZERhdGE7XG4gIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IGRpc3BhdGNoQ29uZmlnIENvbmZpZ3VyYXRpb24gdXNlZCB0byBkaXNwYXRjaCB0aGlzIGV2ZW50LlxuICogQHBhcmFtIHtzdHJpbmd9IGRpc3BhdGNoTWFya2VyIE1hcmtlciBpZGVudGlmeWluZyB0aGUgZXZlbnQgdGFyZ2V0LlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQGV4dGVuZHMge1N5bnRoZXRpY1VJRXZlbnR9XG4gKi9cbmZ1bmN0aW9uIFN5bnRoZXRpY0NsaXBib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY0V2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljQ2xpcGJvYXJkRXZlbnQsIENsaXBib2FyZEV2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNDbGlwYm9hcmRFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNDbGlwYm9hcmRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNGb2N1c0V2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY1VJRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY1VJRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEZvY3VzRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgRm9jdXNFdmVudEludGVyZmFjZSA9IHtcbiAgcmVsYXRlZFRhcmdldDogbnVsbFxufTtcblxuLyoqXG4gKiBAcGFyYW0ge29iamVjdH0gZGlzcGF0Y2hDb25maWcgQ29uZmlndXJhdGlvbiB1c2VkIHRvIGRpc3BhdGNoIHRoaXMgZXZlbnQuXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlzcGF0Y2hNYXJrZXIgTWFya2VyIGlkZW50aWZ5aW5nIHRoZSBldmVudCB0YXJnZXQuXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAZXh0ZW5kcyB7U3ludGhldGljVUlFdmVudH1cbiAqL1xuZnVuY3Rpb24gU3ludGhldGljRm9jdXNFdmVudChkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCkge1xuICBTeW50aGV0aWNVSUV2ZW50LmNhbGwodGhpcywgZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpO1xufVxuXG5TeW50aGV0aWNVSUV2ZW50LmF1Z21lbnRDbGFzcyhTeW50aGV0aWNGb2N1c0V2ZW50LCBGb2N1c0V2ZW50SW50ZXJmYWNlKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTeW50aGV0aWNGb2N1c0V2ZW50O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1N5bnRoZXRpY0ZvY3VzRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljS2V5Ym9hcmRFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudENoYXJDb2RlID0gcmVxdWlyZSgnLi9nZXRFdmVudENoYXJDb2RlJyk7XG52YXIgZ2V0RXZlbnRLZXkgPSByZXF1aXJlKCcuL2dldEV2ZW50S2V5Jyk7XG52YXIgZ2V0RXZlbnRNb2RpZmllclN0YXRlID0gcmVxdWlyZSgnLi9nZXRFdmVudE1vZGlmaWVyU3RhdGUnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIEtleWJvYXJkRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgS2V5Ym9hcmRFdmVudEludGVyZmFjZSA9IHtcbiAga2V5OiBnZXRFdmVudEtleSxcbiAgbG9jYXRpb246IG51bGwsXG4gIGN0cmxLZXk6IG51bGwsXG4gIHNoaWZ0S2V5OiBudWxsLFxuICBhbHRLZXk6IG51bGwsXG4gIG1ldGFLZXk6IG51bGwsXG4gIHJlcGVhdDogbnVsbCxcbiAgbG9jYWxlOiBudWxsLFxuICBnZXRNb2RpZmllclN0YXRlOiBnZXRFdmVudE1vZGlmaWVyU3RhdGUsXG4gIC8vIExlZ2FjeSBJbnRlcmZhY2VcbiAgY2hhckNvZGU6IGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIGBjaGFyQ29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleVByZXNzIGV2ZW50IGFuZCByZXByZXNlbnRzIHRoZSB2YWx1ZSBvZlxuICAgIC8vIHRoZSBhY3R1YWwgcHJpbnRhYmxlIGNoYXJhY3Rlci5cblxuICAgIC8vIEtleVByZXNzIGlzIGRlcHJlY2F0ZWQsIGJ1dCBpdHMgcmVwbGFjZW1lbnQgaXMgbm90IHlldCBmaW5hbCBhbmQgbm90XG4gICAgLy8gaW1wbGVtZW50ZWQgaW4gYW55IG1ham9yIGJyb3dzZXIuIE9ubHkgS2V5UHJlc3MgaGFzIGNoYXJDb2RlLlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9LFxuICBrZXlDb2RlOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBga2V5Q29kZWAgaXMgdGhlIHJlc3VsdCBvZiBhIEtleURvd24vVXAgZXZlbnQgYW5kIHJlcHJlc2VudHMgdGhlIHZhbHVlIG9mXG4gICAgLy8gcGh5c2ljYWwga2V5Ym9hcmQga2V5LlxuXG4gICAgLy8gVGhlIGFjdHVhbCBtZWFuaW5nIG9mIHRoZSB2YWx1ZSBkZXBlbmRzIG9uIHRoZSB1c2Vycycga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gd2hpY2ggY2Fubm90IGJlIGRldGVjdGVkLiBBc3N1bWluZyB0aGF0IGl0IGlzIGEgVVMga2V5Ym9hcmQgbGF5b3V0XG4gICAgLy8gcHJvdmlkZXMgYSBzdXJwcmlzaW5nbHkgYWNjdXJhdGUgbWFwcGluZyBmb3IgVVMgYW5kIEV1cm9wZWFuIHVzZXJzLlxuICAgIC8vIER1ZSB0byB0aGlzLCBpdCBpcyBsZWZ0IHRvIHRoZSB1c2VyIHRvIGltcGxlbWVudCBhdCB0aGlzIHRpbWUuXG4gICAgaWYgKGV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBldmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgICByZXR1cm4gZXZlbnQua2V5Q29kZTtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG4gIH0sXG4gIHdoaWNoOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAvLyBgd2hpY2hgIGlzIGFuIGFsaWFzIGZvciBlaXRoZXIgYGtleUNvZGVgIG9yIGBjaGFyQ29kZWAgZGVwZW5kaW5nIG9uIHRoZVxuICAgIC8vIHR5cGUgb2YgdGhlIGV2ZW50LlxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5cHJlc3MnKSB7XG4gICAgICByZXR1cm4gZ2V0RXZlbnRDaGFyQ29kZShldmVudCk7XG4gICAgfVxuICAgIGlmIChldmVudC50eXBlID09PSAna2V5ZG93bicgfHwgZXZlbnQudHlwZSA9PT0gJ2tleXVwJykge1xuICAgICAgcmV0dXJuIGV2ZW50LmtleUNvZGU7XG4gICAgfVxuICAgIHJldHVybiAwO1xuICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNLZXlib2FyZEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY0tleWJvYXJkRXZlbnQsIEtleWJvYXJkRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0tleWJvYXJkRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvU3ludGhldGljS2V5Ym9hcmRFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBnZXRFdmVudENoYXJDb2RlXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBgY2hhckNvZGVgIHJlcHJlc2VudHMgdGhlIGFjdHVhbCBcImNoYXJhY3RlciBjb2RlXCIgYW5kIGlzIHNhZmUgdG8gdXNlIHdpdGhcbiAqIGBTdHJpbmcuZnJvbUNoYXJDb2RlYC4gQXMgc3VjaCwgb25seSBrZXlzIHRoYXQgY29ycmVzcG9uZCB0byBwcmludGFibGVcbiAqIGNoYXJhY3RlcnMgcHJvZHVjZSBhIHZhbGlkIGBjaGFyQ29kZWAsIHRoZSBvbmx5IGV4Y2VwdGlvbiB0byB0aGlzIGlzIEVudGVyLlxuICogVGhlIFRhYi1rZXkgaXMgY29uc2lkZXJlZCBub24tcHJpbnRhYmxlIGFuZCBkb2VzIG5vdCBoYXZlIGEgYGNoYXJDb2RlYCxcbiAqIHByZXN1bWFibHkgYmVjYXVzZSBpdCBkb2VzIG5vdCBwcm9kdWNlIGEgdGFiLWNoYXJhY3RlciBpbiBicm93c2Vycy5cbiAqXG4gKiBAcGFyYW0ge29iamVjdH0gbmF0aXZlRXZlbnQgTmF0aXZlIGJyb3dzZXIgZXZlbnQuXG4gKiBAcmV0dXJuIHtudW1iZXJ9IE5vcm1hbGl6ZWQgYGNoYXJDb2RlYCBwcm9wZXJ0eS5cbiAqL1xuZnVuY3Rpb24gZ2V0RXZlbnRDaGFyQ29kZShuYXRpdmVFdmVudCkge1xuICB2YXIgY2hhckNvZGU7XG4gIHZhciBrZXlDb2RlID0gbmF0aXZlRXZlbnQua2V5Q29kZTtcblxuICBpZiAoJ2NoYXJDb2RlJyBpbiBuYXRpdmVFdmVudCkge1xuICAgIGNoYXJDb2RlID0gbmF0aXZlRXZlbnQuY2hhckNvZGU7XG5cbiAgICAvLyBGRiBkb2VzIG5vdCBzZXQgYGNoYXJDb2RlYCBmb3IgdGhlIEVudGVyLWtleSwgY2hlY2sgYWdhaW5zdCBga2V5Q29kZWAuXG4gICAgaWYgKGNoYXJDb2RlID09PSAwICYmIGtleUNvZGUgPT09IDEzKSB7XG4gICAgICBjaGFyQ29kZSA9IDEzO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBJRTggZG9lcyBub3QgaW1wbGVtZW50IGBjaGFyQ29kZWAsIGJ1dCBga2V5Q29kZWAgaGFzIHRoZSBjb3JyZWN0IHZhbHVlLlxuICAgIGNoYXJDb2RlID0ga2V5Q29kZTtcbiAgfVxuXG4gIC8vIFNvbWUgbm9uLXByaW50YWJsZSBrZXlzIGFyZSByZXBvcnRlZCBpbiBgY2hhckNvZGVgL2BrZXlDb2RlYCwgZGlzY2FyZCB0aGVtLlxuICAvLyBNdXN0IG5vdCBkaXNjYXJkIHRoZSAobm9uLSlwcmludGFibGUgRW50ZXIta2V5LlxuICBpZiAoY2hhckNvZGUgPj0gMzIgfHwgY2hhckNvZGUgPT09IDEzKSB7XG4gICAgcmV0dXJuIGNoYXJDb2RlO1xuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZ2V0RXZlbnRDaGFyQ29kZTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9nZXRFdmVudENoYXJDb2RlLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIGdldEV2ZW50S2V5XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGdldEV2ZW50Q2hhckNvZGUgPSByZXF1aXJlKCcuL2dldEV2ZW50Q2hhckNvZGUnKTtcblxuLyoqXG4gKiBOb3JtYWxpemF0aW9uIG9mIGRlcHJlY2F0ZWQgSFRNTDUgYGtleWAgdmFsdWVzXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgbm9ybWFsaXplS2V5ID0ge1xuICAnRXNjJzogJ0VzY2FwZScsXG4gICdTcGFjZWJhcic6ICcgJyxcbiAgJ0xlZnQnOiAnQXJyb3dMZWZ0JyxcbiAgJ1VwJzogJ0Fycm93VXAnLFxuICAnUmlnaHQnOiAnQXJyb3dSaWdodCcsXG4gICdEb3duJzogJ0Fycm93RG93bicsXG4gICdEZWwnOiAnRGVsZXRlJyxcbiAgJ1dpbic6ICdPUycsXG4gICdNZW51JzogJ0NvbnRleHRNZW51JyxcbiAgJ0FwcHMnOiAnQ29udGV4dE1lbnUnLFxuICAnU2Nyb2xsJzogJ1Njcm9sbExvY2snLFxuICAnTW96UHJpbnRhYmxlS2V5JzogJ1VuaWRlbnRpZmllZCdcbn07XG5cbi8qKlxuICogVHJhbnNsYXRpb24gZnJvbSBsZWdhY3kgYGtleUNvZGVgIHRvIEhUTUw1IGBrZXlgXG4gKiBPbmx5IHNwZWNpYWwga2V5cyBzdXBwb3J0ZWQsIGFsbCBvdGhlcnMgZGVwZW5kIG9uIGtleWJvYXJkIGxheW91dCBvciBicm93c2VyXG4gKiBAc2VlIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9LZXlib2FyZEV2ZW50I0tleV9uYW1lc1xuICovXG52YXIgdHJhbnNsYXRlVG9LZXkgPSB7XG4gIDg6ICdCYWNrc3BhY2UnLFxuICA5OiAnVGFiJyxcbiAgMTI6ICdDbGVhcicsXG4gIDEzOiAnRW50ZXInLFxuICAxNjogJ1NoaWZ0JyxcbiAgMTc6ICdDb250cm9sJyxcbiAgMTg6ICdBbHQnLFxuICAxOTogJ1BhdXNlJyxcbiAgMjA6ICdDYXBzTG9jaycsXG4gIDI3OiAnRXNjYXBlJyxcbiAgMzI6ICcgJyxcbiAgMzM6ICdQYWdlVXAnLFxuICAzNDogJ1BhZ2VEb3duJyxcbiAgMzU6ICdFbmQnLFxuICAzNjogJ0hvbWUnLFxuICAzNzogJ0Fycm93TGVmdCcsXG4gIDM4OiAnQXJyb3dVcCcsXG4gIDM5OiAnQXJyb3dSaWdodCcsXG4gIDQwOiAnQXJyb3dEb3duJyxcbiAgNDU6ICdJbnNlcnQnLFxuICA0NjogJ0RlbGV0ZScsXG4gIDExMjogJ0YxJywgMTEzOiAnRjInLCAxMTQ6ICdGMycsIDExNTogJ0Y0JywgMTE2OiAnRjUnLCAxMTc6ICdGNicsXG4gIDExODogJ0Y3JywgMTE5OiAnRjgnLCAxMjA6ICdGOScsIDEyMTogJ0YxMCcsIDEyMjogJ0YxMScsIDEyMzogJ0YxMicsXG4gIDE0NDogJ051bUxvY2snLFxuICAxNDU6ICdTY3JvbGxMb2NrJyxcbiAgMjI0OiAnTWV0YSdcbn07XG5cbi8qKlxuICogQHBhcmFtIHtvYmplY3R9IG5hdGl2ZUV2ZW50IE5hdGl2ZSBicm93c2VyIGV2ZW50LlxuICogQHJldHVybiB7c3RyaW5nfSBOb3JtYWxpemVkIGBrZXlgIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBnZXRFdmVudEtleShuYXRpdmVFdmVudCkge1xuICBpZiAobmF0aXZlRXZlbnQua2V5KSB7XG4gICAgLy8gTm9ybWFsaXplIGluY29uc2lzdGVudCB2YWx1ZXMgcmVwb3J0ZWQgYnkgYnJvd3NlcnMgZHVlIHRvXG4gICAgLy8gaW1wbGVtZW50YXRpb25zIG9mIGEgd29ya2luZyBkcmFmdCBzcGVjaWZpY2F0aW9uLlxuXG4gICAgLy8gRmlyZUZveCBpbXBsZW1lbnRzIGBrZXlgIGJ1dCByZXR1cm5zIGBNb3pQcmludGFibGVLZXlgIGZvciBhbGxcbiAgICAvLyBwcmludGFibGUgY2hhcmFjdGVycyAobm9ybWFsaXplZCB0byBgVW5pZGVudGlmaWVkYCksIGlnbm9yZSBpdC5cbiAgICB2YXIga2V5ID0gbm9ybWFsaXplS2V5W25hdGl2ZUV2ZW50LmtleV0gfHwgbmF0aXZlRXZlbnQua2V5O1xuICAgIGlmIChrZXkgIT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICByZXR1cm4ga2V5O1xuICAgIH1cbiAgfVxuXG4gIC8vIEJyb3dzZXIgZG9lcyBub3QgaW1wbGVtZW50IGBrZXlgLCBwb2x5ZmlsbCBhcyBtdWNoIG9mIGl0IGFzIHdlIGNhbi5cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlwcmVzcycpIHtcbiAgICB2YXIgY2hhckNvZGUgPSBnZXRFdmVudENoYXJDb2RlKG5hdGl2ZUV2ZW50KTtcblxuICAgIC8vIFRoZSBlbnRlci1rZXkgaXMgdGVjaG5pY2FsbHkgYm90aCBwcmludGFibGUgYW5kIG5vbi1wcmludGFibGUgYW5kIGNhblxuICAgIC8vIHRodXMgYmUgY2FwdHVyZWQgYnkgYGtleXByZXNzYCwgbm8gb3RoZXIgbm9uLXByaW50YWJsZSBrZXkgc2hvdWxkLlxuICAgIHJldHVybiBjaGFyQ29kZSA9PT0gMTMgPyAnRW50ZXInIDogU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSk7XG4gIH1cbiAgaWYgKG5hdGl2ZUV2ZW50LnR5cGUgPT09ICdrZXlkb3duJyB8fCBuYXRpdmVFdmVudC50eXBlID09PSAna2V5dXAnKSB7XG4gICAgLy8gV2hpbGUgdXNlciBrZXlib2FyZCBsYXlvdXQgZGV0ZXJtaW5lcyB0aGUgYWN0dWFsIG1lYW5pbmcgb2YgZWFjaFxuICAgIC8vIGBrZXlDb2RlYCB2YWx1ZSwgYWxtb3N0IGFsbCBmdW5jdGlvbiBrZXlzIGhhdmUgYSB1bml2ZXJzYWwgdmFsdWUuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZVRvS2V5W25hdGl2ZUV2ZW50LmtleUNvZGVdIHx8ICdVbmlkZW50aWZpZWQnO1xuICB9XG4gIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZXRFdmVudEtleTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9nZXRFdmVudEtleS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNEcmFnRXZlbnRcbiAqIEB0eXBlY2hlY2tzIHN0YXRpYy1vbmx5XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgU3ludGhldGljTW91c2VFdmVudCA9IHJlcXVpcmUoJy4vU3ludGhldGljTW91c2VFdmVudCcpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgRHJhZ0V2ZW50XG4gKiBAc2VlIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy9cbiAqL1xudmFyIERyYWdFdmVudEludGVyZmFjZSA9IHtcbiAgZGF0YVRyYW5zZmVyOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNEcmFnRXZlbnQoZGlzcGF0Y2hDb25maWcsIGRpc3BhdGNoTWFya2VyLCBuYXRpdmVFdmVudCwgbmF0aXZlRXZlbnRUYXJnZXQpIHtcbiAgU3ludGhldGljTW91c2VFdmVudC5jYWxsKHRoaXMsIGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KTtcbn1cblxuU3ludGhldGljTW91c2VFdmVudC5hdWdtZW50Q2xhc3MoU3ludGhldGljRHJhZ0V2ZW50LCBEcmFnRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY0RyYWdFdmVudDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TeW50aGV0aWNEcmFnRXZlbnQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgU3ludGhldGljVG91Y2hFdmVudFxuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBTeW50aGV0aWNVSUV2ZW50ID0gcmVxdWlyZSgnLi9TeW50aGV0aWNVSUV2ZW50Jyk7XG5cbnZhciBnZXRFdmVudE1vZGlmaWVyU3RhdGUgPSByZXF1aXJlKCcuL2dldEV2ZW50TW9kaWZpZXJTdGF0ZScpO1xuXG4vKipcbiAqIEBpbnRlcmZhY2UgVG91Y2hFdmVudFxuICogQHNlZSBodHRwOi8vd3d3LnczLm9yZy9UUi90b3VjaC1ldmVudHMvXG4gKi9cbnZhciBUb3VjaEV2ZW50SW50ZXJmYWNlID0ge1xuICB0b3VjaGVzOiBudWxsLFxuICB0YXJnZXRUb3VjaGVzOiBudWxsLFxuICBjaGFuZ2VkVG91Y2hlczogbnVsbCxcbiAgYWx0S2V5OiBudWxsLFxuICBtZXRhS2V5OiBudWxsLFxuICBjdHJsS2V5OiBudWxsLFxuICBzaGlmdEtleTogbnVsbCxcbiAgZ2V0TW9kaWZpZXJTdGF0ZTogZ2V0RXZlbnRNb2RpZmllclN0YXRlXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNVSUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNUb3VjaEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY1VJRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY1VJRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1RvdWNoRXZlbnQsIFRvdWNoRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1RvdWNoRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvU3ludGhldGljVG91Y2hFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTeW50aGV0aWNXaGVlbEV2ZW50XG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFN5bnRoZXRpY01vdXNlRXZlbnQgPSByZXF1aXJlKCcuL1N5bnRoZXRpY01vdXNlRXZlbnQnKTtcblxuLyoqXG4gKiBAaW50ZXJmYWNlIFdoZWVsRXZlbnRcbiAqIEBzZWUgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzL1xuICovXG52YXIgV2hlZWxFdmVudEludGVyZmFjZSA9IHtcbiAgZGVsdGFYOiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICByZXR1cm4gJ2RlbHRhWCcgaW4gZXZlbnQgPyBldmVudC5kZWx0YVggOlxuICAgIC8vIEZhbGxiYWNrIHRvIGB3aGVlbERlbHRhWGAgZm9yIFdlYmtpdCBhbmQgbm9ybWFsaXplIChyaWdodCBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFYJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWCA6IDA7XG4gIH0sXG4gIGRlbHRhWTogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgcmV0dXJuICdkZWx0YVknIGluIGV2ZW50ID8gZXZlbnQuZGVsdGFZIDpcbiAgICAvLyBGYWxsYmFjayB0byBgd2hlZWxEZWx0YVlgIGZvciBXZWJraXQgYW5kIG5vcm1hbGl6ZSAoZG93biBpcyBwb3NpdGl2ZSkuXG4gICAgJ3doZWVsRGVsdGFZJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhWSA6XG4gICAgLy8gRmFsbGJhY2sgdG8gYHdoZWVsRGVsdGFgIGZvciBJRTw5IGFuZCBub3JtYWxpemUgKGRvd24gaXMgcG9zaXRpdmUpLlxuICAgICd3aGVlbERlbHRhJyBpbiBldmVudCA/IC1ldmVudC53aGVlbERlbHRhIDogMDtcbiAgfSxcbiAgZGVsdGFaOiBudWxsLFxuXG4gIC8vIEJyb3dzZXJzIHdpdGhvdXQgXCJkZWx0YU1vZGVcIiBpcyByZXBvcnRpbmcgaW4gcmF3IHdoZWVsIGRlbHRhIHdoZXJlIG9uZVxuICAvLyBub3RjaCBvbiB0aGUgc2Nyb2xsIGlzIGFsd2F5cyArLy0gMTIwLCByb3VnaGx5IGVxdWl2YWxlbnQgdG8gcGl4ZWxzLlxuICAvLyBBIGdvb2QgYXBwcm94aW1hdGlvbiBvZiBET01fREVMVEFfTElORSAoMSkgaXMgNSUgb2Ygdmlld3BvcnQgc2l6ZSBvclxuICAvLyB+NDAgcGl4ZWxzLCBmb3IgRE9NX0RFTFRBX1NDUkVFTiAoMikgaXQgaXMgODcuNSUgb2Ygdmlld3BvcnQgc2l6ZS5cbiAgZGVsdGFNb2RlOiBudWxsXG59O1xuXG4vKipcbiAqIEBwYXJhbSB7b2JqZWN0fSBkaXNwYXRjaENvbmZpZyBDb25maWd1cmF0aW9uIHVzZWQgdG8gZGlzcGF0Y2ggdGhpcyBldmVudC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBkaXNwYXRjaE1hcmtlciBNYXJrZXIgaWRlbnRpZnlpbmcgdGhlIGV2ZW50IHRhcmdldC5cbiAqIEBwYXJhbSB7b2JqZWN0fSBuYXRpdmVFdmVudCBOYXRpdmUgYnJvd3NlciBldmVudC5cbiAqIEBleHRlbmRzIHtTeW50aGV0aWNNb3VzZUV2ZW50fVxuICovXG5mdW5jdGlvbiBTeW50aGV0aWNXaGVlbEV2ZW50KGRpc3BhdGNoQ29uZmlnLCBkaXNwYXRjaE1hcmtlciwgbmF0aXZlRXZlbnQsIG5hdGl2ZUV2ZW50VGFyZ2V0KSB7XG4gIFN5bnRoZXRpY01vdXNlRXZlbnQuY2FsbCh0aGlzLCBkaXNwYXRjaENvbmZpZywgZGlzcGF0Y2hNYXJrZXIsIG5hdGl2ZUV2ZW50LCBuYXRpdmVFdmVudFRhcmdldCk7XG59XG5cblN5bnRoZXRpY01vdXNlRXZlbnQuYXVnbWVudENsYXNzKFN5bnRoZXRpY1doZWVsRXZlbnQsIFdoZWVsRXZlbnRJbnRlcmZhY2UpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFN5bnRoZXRpY1doZWVsRXZlbnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvU3ludGhldGljV2hlZWxFdmVudC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBTVkdET01Qcm9wZXJ0eUNvbmZpZ1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xuXG52YXIgTVVTVF9VU0VfQVRUUklCVVRFID0gRE9NUHJvcGVydHkuaW5qZWN0aW9uLk1VU1RfVVNFX0FUVFJJQlVURTtcblxudmFyIE5TID0ge1xuICB4bGluazogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLFxuICB4bWw6ICdodHRwOi8vd3d3LnczLm9yZy9YTUwvMTk5OC9uYW1lc3BhY2UnXG59O1xuXG52YXIgU1ZHRE9NUHJvcGVydHlDb25maWcgPSB7XG4gIFByb3BlcnRpZXM6IHtcbiAgICBjbGlwUGF0aDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGN4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgY3k6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBkeTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZpbGw6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmaWxsT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZvbnRGYW1pbHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBmb250U2l6ZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGZ4OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgZnk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBncmFkaWVudFRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIGdyYWRpZW50VW5pdHM6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJFbmQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJNaWQ6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBtYXJrZXJTdGFydDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9mZnNldDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIG9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcGF0dGVyblVuaXRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcG9pbnRzOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgcHJlc2VydmVBc3BlY3RSYXRpbzogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICByeDogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHJ5OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3ByZWFkTWV0aG9kOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcENvbG9yOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3RvcE9wYWNpdHk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2U6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VEYXNoYXJyYXk6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICBzdHJva2VMaW5lY2FwOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgc3Ryb2tlT3BhY2l0eTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHN0cm9rZVdpZHRoOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgdGV4dEFuY2hvcjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHRyYW5zZm9ybTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHZlcnNpb246IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB2aWV3Qm94OiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeDE6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4MjogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHg6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FjdHVhdGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0FyY3JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua0hyZWY6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1JvbGU6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1Nob3c6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bGlua1RpdGxlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeGxpbmtUeXBlOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeG1sQmFzZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHhtbExhbmc6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB4bWxTcGFjZTogTVVTVF9VU0VfQVRUUklCVVRFLFxuICAgIHkxOiBNVVNUX1VTRV9BVFRSSUJVVEUsXG4gICAgeTI6IE1VU1RfVVNFX0FUVFJJQlVURSxcbiAgICB5OiBNVVNUX1VTRV9BVFRSSUJVVEVcbiAgfSxcbiAgRE9NQXR0cmlidXRlTmFtZXNwYWNlczoge1xuICAgIHhsaW5rQWN0dWF0ZTogTlMueGxpbmssXG4gICAgeGxpbmtBcmNyb2xlOiBOUy54bGluayxcbiAgICB4bGlua0hyZWY6IE5TLnhsaW5rLFxuICAgIHhsaW5rUm9sZTogTlMueGxpbmssXG4gICAgeGxpbmtTaG93OiBOUy54bGluayxcbiAgICB4bGlua1RpdGxlOiBOUy54bGluayxcbiAgICB4bGlua1R5cGU6IE5TLnhsaW5rLFxuICAgIHhtbEJhc2U6IE5TLnhtbCxcbiAgICB4bWxMYW5nOiBOUy54bWwsXG4gICAgeG1sU3BhY2U6IE5TLnhtbFxuICB9LFxuICBET01BdHRyaWJ1dGVOYW1lczoge1xuICAgIGNsaXBQYXRoOiAnY2xpcC1wYXRoJyxcbiAgICBmaWxsT3BhY2l0eTogJ2ZpbGwtb3BhY2l0eScsXG4gICAgZm9udEZhbWlseTogJ2ZvbnQtZmFtaWx5JyxcbiAgICBmb250U2l6ZTogJ2ZvbnQtc2l6ZScsXG4gICAgZ3JhZGllbnRUcmFuc2Zvcm06ICdncmFkaWVudFRyYW5zZm9ybScsXG4gICAgZ3JhZGllbnRVbml0czogJ2dyYWRpZW50VW5pdHMnLFxuICAgIG1hcmtlckVuZDogJ21hcmtlci1lbmQnLFxuICAgIG1hcmtlck1pZDogJ21hcmtlci1taWQnLFxuICAgIG1hcmtlclN0YXJ0OiAnbWFya2VyLXN0YXJ0JyxcbiAgICBwYXR0ZXJuQ29udGVudFVuaXRzOiAncGF0dGVybkNvbnRlbnRVbml0cycsXG4gICAgcGF0dGVyblVuaXRzOiAncGF0dGVyblVuaXRzJyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAncHJlc2VydmVBc3BlY3RSYXRpbycsXG4gICAgc3ByZWFkTWV0aG9kOiAnc3ByZWFkTWV0aG9kJyxcbiAgICBzdG9wQ29sb3I6ICdzdG9wLWNvbG9yJyxcbiAgICBzdG9wT3BhY2l0eTogJ3N0b3Atb3BhY2l0eScsXG4gICAgc3Ryb2tlRGFzaGFycmF5OiAnc3Ryb2tlLWRhc2hhcnJheScsXG4gICAgc3Ryb2tlTGluZWNhcDogJ3N0cm9rZS1saW5lY2FwJyxcbiAgICBzdHJva2VPcGFjaXR5OiAnc3Ryb2tlLW9wYWNpdHknLFxuICAgIHN0cm9rZVdpZHRoOiAnc3Ryb2tlLXdpZHRoJyxcbiAgICB0ZXh0QW5jaG9yOiAndGV4dC1hbmNob3InLFxuICAgIHZpZXdCb3g6ICd2aWV3Qm94JyxcbiAgICB4bGlua0FjdHVhdGU6ICd4bGluazphY3R1YXRlJyxcbiAgICB4bGlua0FyY3JvbGU6ICd4bGluazphcmNyb2xlJyxcbiAgICB4bGlua0hyZWY6ICd4bGluazpocmVmJyxcbiAgICB4bGlua1JvbGU6ICd4bGluazpyb2xlJyxcbiAgICB4bGlua1Nob3c6ICd4bGluazpzaG93JyxcbiAgICB4bGlua1RpdGxlOiAneGxpbms6dGl0bGUnLFxuICAgIHhsaW5rVHlwZTogJ3hsaW5rOnR5cGUnLFxuICAgIHhtbEJhc2U6ICd4bWw6YmFzZScsXG4gICAgeG1sTGFuZzogJ3htbDpsYW5nJyxcbiAgICB4bWxTcGFjZTogJ3htbDpzcGFjZSdcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBTVkdET01Qcm9wZXJ0eUNvbmZpZztcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9TVkdET01Qcm9wZXJ0eUNvbmZpZy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERlZmF1bHRQZXJmXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIERPTVByb3BlcnR5ID0gcmVxdWlyZSgnLi9ET01Qcm9wZXJ0eScpO1xudmFyIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcyA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzJyk7XG52YXIgUmVhY3RNb3VudCA9IHJlcXVpcmUoJy4vUmVhY3RNb3VudCcpO1xudmFyIFJlYWN0UGVyZiA9IHJlcXVpcmUoJy4vUmVhY3RQZXJmJyk7XG5cbnZhciBwZXJmb3JtYW5jZU5vdyA9IHJlcXVpcmUoJ2ZianMvbGliL3BlcmZvcm1hbmNlTm93Jyk7XG5cbmZ1bmN0aW9uIHJvdW5kRmxvYXQodmFsKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKHZhbCAqIDEwMCkgLyAxMDA7XG59XG5cbmZ1bmN0aW9uIGFkZFZhbHVlKG9iaiwga2V5LCB2YWwpIHtcbiAgb2JqW2tleV0gPSAob2JqW2tleV0gfHwgMCkgKyB2YWw7XG59XG5cbnZhciBSZWFjdERlZmF1bHRQZXJmID0ge1xuICBfYWxsTWVhc3VyZW1lbnRzOiBbXSwgLy8gbGFzdCBpdGVtIGluIHRoZSBsaXN0IGlzIHRoZSBjdXJyZW50IG9uZVxuICBfbW91bnRTdGFjazogWzBdLFxuICBfaW5qZWN0ZWQ6IGZhbHNlLFxuXG4gIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFSZWFjdERlZmF1bHRQZXJmLl9pbmplY3RlZCkge1xuICAgICAgUmVhY3RQZXJmLmluamVjdGlvbi5pbmplY3RNZWFzdXJlKFJlYWN0RGVmYXVsdFBlcmYubWVhc3VyZSk7XG4gICAgfVxuXG4gICAgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgUmVhY3RQZXJmLmVuYWJsZU1lYXN1cmUgPSB0cnVlO1xuICB9LFxuXG4gIHN0b3A6IGZ1bmN0aW9uICgpIHtcbiAgICBSZWFjdFBlcmYuZW5hYmxlTWVhc3VyZSA9IGZhbHNlO1xuICB9LFxuXG4gIGdldExhc3RNZWFzdXJlbWVudHM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICB9LFxuXG4gIHByaW50RXhjbHVzaXZlOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICB2YXIgc3VtbWFyeSA9IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRFeGNsdXNpdmVTdW1tYXJ5KG1lYXN1cmVtZW50cyk7XG4gICAgY29uc29sZS50YWJsZShzdW1tYXJ5Lm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ0NvbXBvbmVudCBjbGFzcyBuYW1lJzogaXRlbS5jb21wb25lbnROYW1lLFxuICAgICAgICAnVG90YWwgaW5jbHVzaXZlIHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5pbmNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIG1vdW50IHRpbWUgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5leGNsdXNpdmUpLFxuICAgICAgICAnRXhjbHVzaXZlIHJlbmRlciB0aW1lIChtcyknOiByb3VuZEZsb2F0KGl0ZW0ucmVuZGVyKSxcbiAgICAgICAgJ01vdW50IHRpbWUgcGVyIGluc3RhbmNlIChtcyknOiByb3VuZEZsb2F0KGl0ZW0uZXhjbHVzaXZlIC8gaXRlbS5jb3VudCksXG4gICAgICAgICdSZW5kZXIgdGltZSBwZXIgaW5zdGFuY2UgKG1zKSc6IHJvdW5kRmxvYXQoaXRlbS5yZW5kZXIgLyBpdGVtLmNvdW50KSxcbiAgICAgICAgJ0luc3RhbmNlcyc6IGl0ZW0uY291bnRcbiAgICAgIH07XG4gICAgfSkpO1xuICAgIC8vIFRPRE86IFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpcy5nZXRUb3RhbFRpbWUoKSBkb2VzIG5vdCByZXR1cm4gdGhlIGNvcnJlY3RcbiAgICAvLyBudW1iZXIuXG4gIH0sXG5cbiAgcHJpbnRJbmNsdXNpdmU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudHMpIHtcbiAgICBtZWFzdXJlbWVudHMgPSBtZWFzdXJlbWVudHMgfHwgUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzO1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKTtcbiAgICBjb25zb2xlLnRhYmxlKHN1bW1hcnkubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnT3duZXIgPiBjb21wb25lbnQnOiBpdGVtLmNvbXBvbmVudE5hbWUsXG4gICAgICAgICdJbmNsdXNpdmUgdGltZSAobXMpJzogcm91bmRGbG9hdChpdGVtLnRpbWUpLFxuICAgICAgICAnSW5zdGFuY2VzJzogaXRlbS5jb3VudFxuICAgICAgfTtcbiAgICB9KSk7XG4gICAgY29uc29sZS5sb2coJ1RvdGFsIHRpbWU6JywgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldFRvdGFsVGltZShtZWFzdXJlbWVudHMpLnRvRml4ZWQoMikgKyAnIG1zJyk7XG4gIH0sXG5cbiAgZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcDogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIHZhciBzdW1tYXJ5ID0gUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCB0cnVlKTtcbiAgICByZXR1cm4gc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgICdPd25lciA+IGNvbXBvbmVudCc6IGl0ZW0uY29tcG9uZW50TmFtZSxcbiAgICAgICAgJ1dhc3RlZCB0aW1lIChtcyknOiBpdGVtLnRpbWUsXG4gICAgICAgICdJbnN0YW5jZXMnOiBpdGVtLmNvdW50XG4gICAgICB9O1xuICAgIH0pO1xuICB9LFxuXG4gIHByaW50V2FzdGVkOiBmdW5jdGlvbiAobWVhc3VyZW1lbnRzKSB7XG4gICAgbWVhc3VyZW1lbnRzID0gbWVhc3VyZW1lbnRzIHx8IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cztcbiAgICBjb25zb2xlLnRhYmxlKFJlYWN0RGVmYXVsdFBlcmYuZ2V0TWVhc3VyZW1lbnRzU3VtbWFyeU1hcChtZWFzdXJlbWVudHMpKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBwcmludERPTTogZnVuY3Rpb24gKG1lYXN1cmVtZW50cykge1xuICAgIG1lYXN1cmVtZW50cyA9IG1lYXN1cmVtZW50cyB8fCBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHM7XG4gICAgdmFyIHN1bW1hcnkgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpO1xuICAgIGNvbnNvbGUudGFibGUoc3VtbWFyeS5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIHJlc3VsdFtET01Qcm9wZXJ0eS5JRF9BVFRSSUJVVEVfTkFNRV0gPSBpdGVtLmlkO1xuICAgICAgcmVzdWx0LnR5cGUgPSBpdGVtLnR5cGU7XG4gICAgICByZXN1bHQuYXJncyA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uYXJncyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pKTtcbiAgICBjb25zb2xlLmxvZygnVG90YWwgdGltZTonLCBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXMuZ2V0VG90YWxUaW1lKG1lYXN1cmVtZW50cykudG9GaXhlZCgyKSArICcgbXMnKTtcbiAgfSxcblxuICBfcmVjb3JkV3JpdGU6IGZ1bmN0aW9uIChpZCwgZm5OYW1lLCB0b3RhbFRpbWUsIGFyZ3MpIHtcbiAgICAvLyBUT0RPOiB0b3RhbFRpbWUgaXNuJ3QgdGhhdCB1c2VmdWwgc2luY2UgaXQgZG9lc24ndCBjb3VudCBwYWludHMvcmVmbG93c1xuICAgIHZhciB3cml0ZXMgPSBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLndyaXRlcztcbiAgICB3cml0ZXNbaWRdID0gd3JpdGVzW2lkXSB8fCBbXTtcbiAgICB3cml0ZXNbaWRdLnB1c2goe1xuICAgICAgdHlwZTogZm5OYW1lLFxuICAgICAgdGltZTogdG90YWxUaW1lLFxuICAgICAgYXJnczogYXJnc1xuICAgIH0pO1xuICB9LFxuXG4gIG1lYXN1cmU6IGZ1bmN0aW9uIChtb2R1bGVOYW1lLCBmbk5hbWUsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvdGFsVGltZTtcbiAgICAgIHZhciBydjtcbiAgICAgIHZhciBzdGFydDtcblxuICAgICAgaWYgKGZuTmFtZSA9PT0gJ19yZW5kZXJOZXdSb290Q29tcG9uZW50JyB8fCBmbk5hbWUgPT09ICdmbHVzaEJhdGNoZWRVcGRhdGVzJykge1xuICAgICAgICAvLyBBIFwibWVhc3VyZW1lbnRcIiBpcyBhIHNldCBvZiBtZXRyaWNzIHJlY29yZGVkIGZvciBlYWNoIGZsdXNoLiBXZSB3YW50XG4gICAgICAgIC8vIHRvIGdyb3VwIHRoZSBtZXRyaWNzIGZvciBhIGdpdmVuIGZsdXNoIHRvZ2V0aGVyIHNvIHdlIGNhbiBsb29rIGF0IHRoZVxuICAgICAgICAvLyBjb21wb25lbnRzIHRoYXQgcmVuZGVyZWQgYW5kIHRoZSBET00gb3BlcmF0aW9ucyB0aGF0IGFjdHVhbGx5XG4gICAgICAgIC8vIGhhcHBlbmVkIHRvIGRldGVybWluZSB0aGUgYW1vdW50IG9mIFwid2FzdGVkIHdvcmtcIiBwZXJmb3JtZWQuXG4gICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50cy5wdXNoKHtcbiAgICAgICAgICBleGNsdXNpdmU6IHt9LFxuICAgICAgICAgIGluY2x1c2l2ZToge30sXG4gICAgICAgICAgcmVuZGVyOiB7fSxcbiAgICAgICAgICBjb3VudHM6IHt9LFxuICAgICAgICAgIHdyaXRlczoge30sXG4gICAgICAgICAgZGlzcGxheU5hbWVzOiB7fSxcbiAgICAgICAgICB0b3RhbFRpbWU6IDAsXG4gICAgICAgICAgY3JlYXRlZDoge31cbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICBSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHNbUmVhY3REZWZhdWx0UGVyZi5fYWxsTWVhc3VyZW1lbnRzLmxlbmd0aCAtIDFdLnRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdfbW91bnRJbWFnZUludG9Ob2RlJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RCcm93c2VyRXZlbnRFbWl0dGVyJyB8fCBtb2R1bGVOYW1lID09PSAnUmVhY3RET01JRE9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdDU1NQcm9wZXJ0eU9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01DaGlsZHJlbk9wZXJhdGlvbnMnIHx8IG1vZHVsZU5hbWUgPT09ICdET01Qcm9wZXJ0eU9wZXJhdGlvbnMnKSB7XG4gICAgICAgIHN0YXJ0ID0gcGVyZm9ybWFuY2VOb3coKTtcbiAgICAgICAgcnYgPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB0b3RhbFRpbWUgPSBwZXJmb3JtYW5jZU5vdygpIC0gc3RhcnQ7XG5cbiAgICAgICAgaWYgKGZuTmFtZSA9PT0gJ19tb3VudEltYWdlSW50b05vZGUnKSB7XG4gICAgICAgICAgdmFyIG1vdW50SUQgPSBSZWFjdE1vdW50LmdldElEKGFyZ3NbMV0pO1xuICAgICAgICAgIFJlYWN0RGVmYXVsdFBlcmYuX3JlY29yZFdyaXRlKG1vdW50SUQsIGZuTmFtZSwgdG90YWxUaW1lLCBhcmdzWzBdKTtcbiAgICAgICAgfSBlbHNlIGlmIChmbk5hbWUgPT09ICdkYW5nZXJvdXNseVByb2Nlc3NDaGlsZHJlblVwZGF0ZXMnKSB7XG4gICAgICAgICAgLy8gc3BlY2lhbCBmb3JtYXRcbiAgICAgICAgICBhcmdzWzBdLmZvckVhY2goZnVuY3Rpb24gKHVwZGF0ZSkge1xuICAgICAgICAgICAgdmFyIHdyaXRlQXJncyA9IHt9O1xuICAgICAgICAgICAgaWYgKHVwZGF0ZS5mcm9tSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLmZyb21JbmRleCA9IHVwZGF0ZS5mcm9tSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodXBkYXRlLnRvSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRvSW5kZXggPSB1cGRhdGUudG9JbmRleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1cGRhdGUudGV4dENvbnRlbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgd3JpdGVBcmdzLnRleHRDb250ZW50ID0gdXBkYXRlLnRleHRDb250ZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHVwZGF0ZS5tYXJrdXBJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICB3cml0ZUFyZ3MubWFya3VwID0gYXJnc1sxXVt1cGRhdGUubWFya3VwSW5kZXhdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUodXBkYXRlLnBhcmVudElELCB1cGRhdGUudHlwZSwgdG90YWxUaW1lLCB3cml0ZUFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGJhc2ljIGZvcm1hdFxuICAgICAgICAgIHZhciBpZCA9IGFyZ3NbMF07XG4gICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGlkID0gUmVhY3RNb3VudC5nZXRJRChhcmdzWzBdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgUmVhY3REZWZhdWx0UGVyZi5fcmVjb3JkV3JpdGUoaWQsIGZuTmFtZSwgdG90YWxUaW1lLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ2O1xuICAgICAgfSBlbHNlIGlmIChtb2R1bGVOYW1lID09PSAnUmVhY3RDb21wb3NpdGVDb21wb25lbnQnICYmIChmbk5hbWUgPT09ICdtb3VudENvbXBvbmVudCcgfHwgZm5OYW1lID09PSAndXBkYXRlQ29tcG9uZW50JyB8fCAvLyBUT0RPOiByZWNlaXZlQ29tcG9uZW50KCk/XG4gICAgICBmbk5hbWUgPT09ICdfcmVuZGVyVmFsaWRhdGVkQ29tcG9uZW50JykpIHtcblxuICAgICAgICBpZiAodGhpcy5fY3VycmVudEVsZW1lbnQudHlwZSA9PT0gUmVhY3RNb3VudC5Ub3BMZXZlbFdyYXBwZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb290Tm9kZUlEID0gZm5OYW1lID09PSAnbW91bnRDb21wb25lbnQnID8gYXJnc1swXSA6IHRoaXMuX3Jvb3ROb2RlSUQ7XG4gICAgICAgIHZhciBpc1JlbmRlciA9IGZuTmFtZSA9PT0gJ19yZW5kZXJWYWxpZGF0ZWRDb21wb25lbnQnO1xuICAgICAgICB2YXIgaXNNb3VudCA9IGZuTmFtZSA9PT0gJ21vdW50Q29tcG9uZW50JztcblxuICAgICAgICB2YXIgbW91bnRTdGFjayA9IFJlYWN0RGVmYXVsdFBlcmYuX21vdW50U3RhY2s7XG4gICAgICAgIHZhciBlbnRyeSA9IFJlYWN0RGVmYXVsdFBlcmYuX2FsbE1lYXN1cmVtZW50c1tSZWFjdERlZmF1bHRQZXJmLl9hbGxNZWFzdXJlbWVudHMubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKGlzUmVuZGVyKSB7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuY291bnRzLCByb290Tm9kZUlELCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc01vdW50KSB7XG4gICAgICAgICAgZW50cnkuY3JlYXRlZFtyb290Tm9kZUlEXSA9IHRydWU7XG4gICAgICAgICAgbW91bnRTdGFjay5wdXNoKDApO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBwZXJmb3JtYW5jZU5vdygpO1xuICAgICAgICBydiA9IGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIHRvdGFsVGltZSA9IHBlcmZvcm1hbmNlTm93KCkgLSBzdGFydDtcblxuICAgICAgICBpZiAoaXNSZW5kZXIpIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5yZW5kZXIsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNNb3VudCkge1xuICAgICAgICAgIHZhciBzdWJNb3VudFRpbWUgPSBtb3VudFN0YWNrLnBvcCgpO1xuICAgICAgICAgIG1vdW50U3RhY2tbbW91bnRTdGFjay5sZW5ndGggLSAxXSArPSB0b3RhbFRpbWU7XG4gICAgICAgICAgYWRkVmFsdWUoZW50cnkuZXhjbHVzaXZlLCByb290Tm9kZUlELCB0b3RhbFRpbWUgLSBzdWJNb3VudFRpbWUpO1xuICAgICAgICAgIGFkZFZhbHVlKGVudHJ5LmluY2x1c2l2ZSwgcm9vdE5vZGVJRCwgdG90YWxUaW1lKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRWYWx1ZShlbnRyeS5pbmNsdXNpdmUsIHJvb3ROb2RlSUQsIHRvdGFsVGltZSk7XG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeS5kaXNwbGF5TmFtZXNbcm9vdE5vZGVJRF0gPSB7XG4gICAgICAgICAgY3VycmVudDogdGhpcy5nZXROYW1lKCksXG4gICAgICAgICAgb3duZXI6IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lciA/IHRoaXMuX2N1cnJlbnRFbGVtZW50Ll9vd25lci5nZXROYW1lKCkgOiAnPHJvb3Q+J1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBydjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfVxuICAgIH07XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3REZWZhdWx0UGVyZjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdERlZmF1bHRQZXJmLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0RGVmYXVsdFBlcmZBbmFseXNpc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xuXG4vLyBEb24ndCB0cnkgdG8gc2F2ZSB1c2VycyBsZXNzIHRoYW4gMS4ybXMgKGEgbnVtYmVyIEkgbWFkZSB1cClcbnZhciBET05UX0NBUkVfVEhSRVNIT0xEID0gMS4yO1xudmFyIERPTV9PUEVSQVRJT05fVFlQRVMgPSB7XG4gICdfbW91bnRJbWFnZUludG9Ob2RlJzogJ3NldCBpbm5lckhUTUwnLFxuICBJTlNFUlRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIE1PVkVfRVhJU1RJTkc6ICdtb3ZlJyxcbiAgUkVNT1ZFX05PREU6ICdyZW1vdmUnLFxuICBTRVRfTUFSS1VQOiAnc2V0IGlubmVySFRNTCcsXG4gIFRFWFRfQ09OVEVOVDogJ3NldCB0ZXh0Q29udGVudCcsXG4gICdzZXRWYWx1ZUZvclByb3BlcnR5JzogJ3VwZGF0ZSBhdHRyaWJ1dGUnLFxuICAnc2V0VmFsdWVGb3JBdHRyaWJ1dGUnOiAndXBkYXRlIGF0dHJpYnV0ZScsXG4gICdkZWxldGVWYWx1ZUZvclByb3BlcnR5JzogJ3JlbW92ZSBhdHRyaWJ1dGUnLFxuICAnc2V0VmFsdWVGb3JTdHlsZXMnOiAndXBkYXRlIHN0eWxlcycsXG4gICdyZXBsYWNlTm9kZVdpdGhNYXJrdXAnOiAncmVwbGFjZScsXG4gICd1cGRhdGVUZXh0Q29udGVudCc6ICdzZXQgdGV4dENvbnRlbnQnXG59O1xuXG5mdW5jdGlvbiBnZXRUb3RhbFRpbWUobWVhc3VyZW1lbnRzKSB7XG4gIC8vIFRPRE86IHJldHVybiBudW1iZXIgb2YgRE9NIG9wcz8gY291bGQgYmUgbWlzbGVhZGluZy5cbiAgLy8gVE9ETzogbWVhc3VyZSBkcm9wcGVkIGZyYW1lcyBhZnRlciByZWNvbmNpbGU/XG4gIC8vIFRPRE86IGxvZyB0b3RhbCB0aW1lIG9mIGVhY2ggcmVjb25jaWxlIGFuZCB0aGUgdG9wLWxldmVsIGNvbXBvbmVudFxuICAvLyBjbGFzcyB0aGF0IHRyaWdnZXJlZCBpdC5cbiAgdmFyIHRvdGFsVGltZSA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWVhc3VyZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1lYXN1cmVtZW50ID0gbWVhc3VyZW1lbnRzW2ldO1xuICAgIHRvdGFsVGltZSArPSBtZWFzdXJlbWVudC50b3RhbFRpbWU7XG4gIH1cbiAgcmV0dXJuIHRvdGFsVGltZTtcbn1cblxuZnVuY3Rpb24gZ2V0RE9NU3VtbWFyeShtZWFzdXJlbWVudHMpIHtcbiAgdmFyIGl0ZW1zID0gW107XG4gIG1lYXN1cmVtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChtZWFzdXJlbWVudCkge1xuICAgIE9iamVjdC5rZXlzKG1lYXN1cmVtZW50LndyaXRlcykuZm9yRWFjaChmdW5jdGlvbiAoaWQpIHtcbiAgICAgIG1lYXN1cmVtZW50LndyaXRlc1tpZF0uZm9yRWFjaChmdW5jdGlvbiAod3JpdGUpIHtcbiAgICAgICAgaXRlbXMucHVzaCh7XG4gICAgICAgICAgaWQ6IGlkLFxuICAgICAgICAgIHR5cGU6IERPTV9PUEVSQVRJT05fVFlQRVNbd3JpdGUudHlwZV0gfHwgd3JpdGUudHlwZSxcbiAgICAgICAgICBhcmdzOiB3cml0ZS5hcmdzXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gaXRlbXM7XG59XG5cbmZ1bmN0aW9uIGdldEV4Y2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzKSB7XG4gIHZhciBjYW5kaWRhdGVzID0ge307XG4gIHZhciBkaXNwbGF5TmFtZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG5cbiAgICBmb3IgKHZhciBpZCBpbiBhbGxJRHMpIHtcbiAgICAgIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXSA9IGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdIHx8IHtcbiAgICAgICAgY29tcG9uZW50TmFtZTogZGlzcGxheU5hbWUsXG4gICAgICAgIGluY2x1c2l2ZTogMCxcbiAgICAgICAgZXhjbHVzaXZlOiAwLFxuICAgICAgICByZW5kZXI6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuICAgICAgaWYgKG1lYXN1cmVtZW50LnJlbmRlcltpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0ucmVuZGVyICs9IG1lYXN1cmVtZW50LnJlbmRlcltpZF07XG4gICAgICB9XG4gICAgICBpZiAobWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgKz0gbWVhc3VyZW1lbnQuZXhjbHVzaXZlW2lkXTtcbiAgICAgIH1cbiAgICAgIGlmIChtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdKSB7XG4gICAgICAgIGNhbmRpZGF0ZXNbZGlzcGxheU5hbWVdLmluY2x1c2l2ZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0uY291bnQgKz0gbWVhc3VyZW1lbnQuY291bnRzW2lkXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBOb3cgbWFrZSBhIHNvcnRlZCBhcnJheSB3aXRoIHRoZSByZXN1bHRzLlxuICB2YXIgYXJyID0gW107XG4gIGZvciAoZGlzcGxheU5hbWUgaW4gY2FuZGlkYXRlcykge1xuICAgIGlmIChjYW5kaWRhdGVzW2Rpc3BsYXlOYW1lXS5leGNsdXNpdmUgPj0gRE9OVF9DQVJFX1RIUkVTSE9MRCkge1xuICAgICAgYXJyLnB1c2goY2FuZGlkYXRlc1tkaXNwbGF5TmFtZV0pO1xuICAgIH1cbiAgfVxuXG4gIGFyci5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgcmV0dXJuIGIuZXhjbHVzaXZlIC0gYS5leGNsdXNpdmU7XG4gIH0pO1xuXG4gIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIGdldEluY2x1c2l2ZVN1bW1hcnkobWVhc3VyZW1lbnRzLCBvbmx5Q2xlYW4pIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSB7fTtcbiAgdmFyIGluY2x1c2l2ZUtleTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG1lYXN1cmVtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWFzdXJlbWVudCA9IG1lYXN1cmVtZW50c1tpXTtcbiAgICB2YXIgYWxsSURzID0gYXNzaWduKHt9LCBtZWFzdXJlbWVudC5leGNsdXNpdmUsIG1lYXN1cmVtZW50LmluY2x1c2l2ZSk7XG4gICAgdmFyIGNsZWFuQ29tcG9uZW50cztcblxuICAgIGlmIChvbmx5Q2xlYW4pIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50cyA9IGdldFVuY2hhbmdlZENvbXBvbmVudHMobWVhc3VyZW1lbnQpO1xuICAgIH1cblxuICAgIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgICAgaWYgKG9ubHlDbGVhbiAmJiAhY2xlYW5Db21wb25lbnRzW2lkXSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIGRpc3BsYXlOYW1lID0gbWVhc3VyZW1lbnQuZGlzcGxheU5hbWVzW2lkXTtcblxuICAgICAgLy8gSW5jbHVzaXZlIHRpbWUgaXMgbm90IHVzZWZ1bCBmb3IgbWFueSBjb21wb25lbnRzIHdpdGhvdXQga25vd2luZyB3aGVyZVxuICAgICAgLy8gdGhleSBhcmUgaW5zdGFudGlhdGVkLiBTbyB3ZSBhZ2dyZWdhdGUgaW5jbHVzaXZlIHRpbWUgd2l0aCBib3RoIHRoZVxuICAgICAgLy8gb3duZXIgYW5kIGN1cnJlbnQgZGlzcGxheU5hbWUgYXMgdGhlIGtleS5cbiAgICAgIGluY2x1c2l2ZUtleSA9IGRpc3BsYXlOYW1lLm93bmVyICsgJyA+ICcgKyBkaXNwbGF5TmFtZS5jdXJyZW50O1xuXG4gICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gPSBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0gfHwge1xuICAgICAgICBjb21wb25lbnROYW1lOiBpbmNsdXNpdmVLZXksXG4gICAgICAgIHRpbWU6IDAsXG4gICAgICAgIGNvdW50OiAwXG4gICAgICB9O1xuXG4gICAgICBpZiAobWVhc3VyZW1lbnQuaW5jbHVzaXZlW2lkXSkge1xuICAgICAgICBjYW5kaWRhdGVzW2luY2x1c2l2ZUtleV0udGltZSArPSBtZWFzdXJlbWVudC5pbmNsdXNpdmVbaWRdO1xuICAgICAgfVxuICAgICAgaWYgKG1lYXN1cmVtZW50LmNvdW50c1tpZF0pIHtcbiAgICAgICAgY2FuZGlkYXRlc1tpbmNsdXNpdmVLZXldLmNvdW50ICs9IG1lYXN1cmVtZW50LmNvdW50c1tpZF07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gTm93IG1ha2UgYSBzb3J0ZWQgYXJyYXkgd2l0aCB0aGUgcmVzdWx0cy5cbiAgdmFyIGFyciA9IFtdO1xuICBmb3IgKGluY2x1c2l2ZUtleSBpbiBjYW5kaWRhdGVzKSB7XG4gICAgaWYgKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XS50aW1lID49IERPTlRfQ0FSRV9USFJFU0hPTEQpIHtcbiAgICAgIGFyci5wdXNoKGNhbmRpZGF0ZXNbaW5jbHVzaXZlS2V5XSk7XG4gICAgfVxuICB9XG5cbiAgYXJyLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICByZXR1cm4gYi50aW1lIC0gYS50aW1lO1xuICB9KTtcblxuICByZXR1cm4gYXJyO1xufVxuXG5mdW5jdGlvbiBnZXRVbmNoYW5nZWRDb21wb25lbnRzKG1lYXN1cmVtZW50KSB7XG4gIC8vIEZvciBhIGdpdmVuIHJlY29uY2lsZSwgbG9vayBhdCB3aGljaCBjb21wb25lbnRzIGRpZCBub3QgYWN0dWFsbHlcbiAgLy8gcmVuZGVyIGFueXRoaW5nIHRvIHRoZSBET00gYW5kIHJldHVybiBhIG1hcHBpbmcgb2YgdGhlaXIgSUQgdG9cbiAgLy8gdGhlIGFtb3VudCBvZiB0aW1lIGl0IHRvb2sgdG8gcmVuZGVyIHRoZSBlbnRpcmUgc3VidHJlZS5cbiAgdmFyIGNsZWFuQ29tcG9uZW50cyA9IHt9O1xuICB2YXIgZGlydHlMZWFmSURzID0gT2JqZWN0LmtleXMobWVhc3VyZW1lbnQud3JpdGVzKTtcbiAgdmFyIGFsbElEcyA9IGFzc2lnbih7fSwgbWVhc3VyZW1lbnQuZXhjbHVzaXZlLCBtZWFzdXJlbWVudC5pbmNsdXNpdmUpO1xuXG4gIGZvciAodmFyIGlkIGluIGFsbElEcykge1xuICAgIHZhciBpc0RpcnR5ID0gZmFsc2U7XG4gICAgLy8gRm9yIGVhY2ggY29tcG9uZW50IHRoYXQgcmVuZGVyZWQsIHNlZSBpZiBhIGNvbXBvbmVudCB0aGF0IHRyaWdnZXJlZFxuICAgIC8vIGEgRE9NIG9wIGlzIGluIGl0cyBzdWJ0cmVlLlxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlydHlMZWFmSURzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoZGlydHlMZWFmSURzW2ldLmluZGV4T2YoaWQpID09PSAwKSB7XG4gICAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gY2hlY2sgaWYgY29tcG9uZW50IG5ld2x5IGNyZWF0ZWRcbiAgICBpZiAobWVhc3VyZW1lbnQuY3JlYXRlZFtpZF0pIHtcbiAgICAgIGlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAoIWlzRGlydHkgJiYgbWVhc3VyZW1lbnQuY291bnRzW2lkXSA+IDApIHtcbiAgICAgIGNsZWFuQ29tcG9uZW50c1tpZF0gPSB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xlYW5Db21wb25lbnRzO1xufVxuXG52YXIgUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzID0ge1xuICBnZXRFeGNsdXNpdmVTdW1tYXJ5OiBnZXRFeGNsdXNpdmVTdW1tYXJ5LFxuICBnZXRJbmNsdXNpdmVTdW1tYXJ5OiBnZXRJbmNsdXNpdmVTdW1tYXJ5LFxuICBnZXRET01TdW1tYXJ5OiBnZXRET01TdW1tYXJ5LFxuICBnZXRUb3RhbFRpbWU6IGdldFRvdGFsVGltZVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdERlZmF1bHRQZXJmQW5hbHlzaXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3REZWZhdWx0UGVyZkFuYWx5c2lzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIHBlcmZvcm1hbmNlTm93XG4gKiBAdHlwZWNoZWNrc1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHBlcmZvcm1hbmNlID0gcmVxdWlyZSgnLi9wZXJmb3JtYW5jZScpO1xuXG52YXIgcGVyZm9ybWFuY2VOb3c7XG5cbi8qKlxuICogRGV0ZWN0IGlmIHdlIGNhbiB1c2UgYHdpbmRvdy5wZXJmb3JtYW5jZS5ub3coKWAgYW5kIGdyYWNlZnVsbHkgZmFsbGJhY2sgdG9cbiAqIGBEYXRlLm5vdygpYCBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBuZWVkIHRvIHN1cHBvcnQgRmlyZWZveCA8IDE1IGZvciBub3dcbiAqIGJlY2F1c2Ugb2YgRmFjZWJvb2sncyB0ZXN0aW5nIGluZnJhc3RydWN0dXJlLlxuICovXG5pZiAocGVyZm9ybWFuY2Uubm93KSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwZXJmb3JtYW5jZS5ub3coKTtcbiAgfTtcbn0gZWxzZSB7XG4gIHBlcmZvcm1hbmNlTm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBEYXRlLm5vdygpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBlcmZvcm1hbmNlTm93O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qvfi9mYmpzL2xpYi9wZXJmb3JtYW5jZU5vdy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBwZXJmb3JtYW5jZVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIHBlcmZvcm1hbmNlO1xuXG5pZiAoRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NKSB7XG4gIHBlcmZvcm1hbmNlID0gd2luZG93LnBlcmZvcm1hbmNlIHx8IHdpbmRvdy5tc1BlcmZvcm1hbmNlIHx8IHdpbmRvdy53ZWJraXRQZXJmb3JtYW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwZXJmb3JtYW5jZSB8fCB7fTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L34vZmJqcy9saWIvcGVyZm9ybWFuY2UuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RWZXJzaW9uXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICcwLjE0LjgnO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0VmVyc2lvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiogQHByb3ZpZGVzTW9kdWxlIHJlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdE1vdW50ID0gcmVxdWlyZSgnLi9SZWFjdE1vdW50Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RNb3VudC5yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9yZW5kZXJTdWJ0cmVlSW50b0NvbnRhaW5lci5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTVNlcnZlclxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEluamVjdGlvbiA9IHJlcXVpcmUoJy4vUmVhY3REZWZhdWx0SW5qZWN0aW9uJyk7XG52YXIgUmVhY3RTZXJ2ZXJSZW5kZXJpbmcgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nJyk7XG52YXIgUmVhY3RWZXJzaW9uID0gcmVxdWlyZSgnLi9SZWFjdFZlcnNpb24nKTtcblxuUmVhY3REZWZhdWx0SW5qZWN0aW9uLmluamVjdCgpO1xuXG52YXIgUmVhY3RET01TZXJ2ZXIgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiBSZWFjdFNlcnZlclJlbmRlcmluZy5yZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IFJlYWN0U2VydmVyUmVuZGVyaW5nLnJlbmRlclRvU3RhdGljTWFya3VwLFxuICB2ZXJzaW9uOiBSZWFjdFZlcnNpb25cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01TZXJ2ZXI7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01TZXJ2ZXIuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAdHlwZWNoZWNrcyBzdGF0aWMtb25seVxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyUmVuZGVyaW5nXG4gKi9cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0RGVmYXVsdEJhdGNoaW5nU3RyYXRlZ3knKTtcbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0SW5zdGFuY2VIYW5kbGVzID0gcmVxdWlyZSgnLi9SZWFjdEluc3RhbmNlSGFuZGxlcycpO1xudmFyIFJlYWN0TWFya3VwQ2hlY2tzdW0gPSByZXF1aXJlKCcuL1JlYWN0TWFya3VwQ2hlY2tzdW0nKTtcbnZhciBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kgPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneScpO1xudmFyIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1JlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24nKTtcbnZhciBSZWFjdFVwZGF0ZXMgPSByZXF1aXJlKCcuL1JlYWN0VXBkYXRlcycpO1xuXG52YXIgZW1wdHlPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eU9iamVjdCcpO1xudmFyIGluc3RhbnRpYXRlUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL2luc3RhbnRpYXRlUmVhY3RDb21wb25lbnQnKTtcbnZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCdmYmpzL2xpYi9pbnZhcmlhbnQnKTtcblxuLyoqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgSFRNTCBtYXJrdXBcbiAqL1xuZnVuY3Rpb24gcmVuZGVyVG9TdHJpbmcoZWxlbWVudCkge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGVsZW1lbnQpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJ3JlbmRlclRvU3RyaW5nKCk6IFlvdSBtdXN0IHBhc3MgYSB2YWxpZCBSZWFjdEVsZW1lbnQuJykgOiBpbnZhcmlhbnQoZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciB0cmFuc2FjdGlvbjtcbiAgdHJ5IHtcbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3RTZXJ2ZXJCYXRjaGluZ1N0cmF0ZWd5KTtcblxuICAgIHZhciBpZCA9IFJlYWN0SW5zdGFuY2VIYW5kbGVzLmNyZWF0ZVJlYWN0Um9vdElEKCk7XG4gICAgdHJhbnNhY3Rpb24gPSBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLmdldFBvb2xlZChmYWxzZSk7XG5cbiAgICByZXR1cm4gdHJhbnNhY3Rpb24ucGVyZm9ybShmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgY29tcG9uZW50SW5zdGFuY2UgPSBpbnN0YW50aWF0ZVJlYWN0Q29tcG9uZW50KGVsZW1lbnQsIG51bGwpO1xuICAgICAgdmFyIG1hcmt1cCA9IGNvbXBvbmVudEluc3RhbmNlLm1vdW50Q29tcG9uZW50KGlkLCB0cmFuc2FjdGlvbiwgZW1wdHlPYmplY3QpO1xuICAgICAgcmV0dXJuIFJlYWN0TWFya3VwQ2hlY2tzdW0uYWRkQ2hlY2tzdW1Ub01hcmt1cChtYXJrdXApO1xuICAgIH0sIG51bGwpO1xuICB9IGZpbmFsbHkge1xuICAgIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ucmVsZWFzZSh0cmFuc2FjdGlvbik7XG4gICAgLy8gUmV2ZXJ0IHRvIHRoZSBET00gYmF0Y2hpbmcgc3RyYXRlZ3kgc2luY2UgdGhlc2UgdHdvIHJlbmRlcmVyc1xuICAgIC8vIGN1cnJlbnRseSBzaGFyZSB0aGVzZSBzdGF0ZWZ1bCBtb2R1bGVzLlxuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdERlZmF1bHRCYXRjaGluZ1N0cmF0ZWd5KTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50XG4gKiBAcmV0dXJuIHtzdHJpbmd9IHRoZSBIVE1MIG1hcmt1cCwgd2l0aG91dCB0aGUgZXh0cmEgUmVhY3QgSUQgYW5kIGNoZWNrc3VtXG4gKiAoZm9yIGdlbmVyYXRpbmcgc3RhdGljIHBhZ2VzKVxuICovXG5mdW5jdGlvbiByZW5kZXJUb1N0YXRpY01hcmt1cChlbGVtZW50KSB7XG4gICFSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gaW52YXJpYW50KGZhbHNlLCAncmVuZGVyVG9TdGF0aWNNYXJrdXAoKTogWW91IG11c3QgcGFzcyBhIHZhbGlkIFJlYWN0RWxlbWVudC4nKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG5cbiAgdmFyIHRyYW5zYWN0aW9uO1xuICB0cnkge1xuICAgIFJlYWN0VXBkYXRlcy5pbmplY3Rpb24uaW5qZWN0QmF0Y2hpbmdTdHJhdGVneShSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kpO1xuXG4gICAgdmFyIGlkID0gUmVhY3RJbnN0YW5jZUhhbmRsZXMuY3JlYXRlUmVhY3RSb290SUQoKTtcbiAgICB0cmFuc2FjdGlvbiA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24uZ2V0UG9vbGVkKHRydWUpO1xuXG4gICAgcmV0dXJuIHRyYW5zYWN0aW9uLnBlcmZvcm0oZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gaW5zdGFudGlhdGVSZWFjdENvbXBvbmVudChlbGVtZW50LCBudWxsKTtcbiAgICAgIHJldHVybiBjb21wb25lbnRJbnN0YW5jZS5tb3VudENvbXBvbmVudChpZCwgdHJhbnNhY3Rpb24sIGVtcHR5T2JqZWN0KTtcbiAgICB9LCBudWxsKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnJlbGVhc2UodHJhbnNhY3Rpb24pO1xuICAgIC8vIFJldmVydCB0byB0aGUgRE9NIGJhdGNoaW5nIHN0cmF0ZWd5IHNpbmNlIHRoZXNlIHR3byByZW5kZXJlcnNcbiAgICAvLyBjdXJyZW50bHkgc2hhcmUgdGhlc2Ugc3RhdGVmdWwgbW9kdWxlcy5cbiAgICBSZWFjdFVwZGF0ZXMuaW5qZWN0aW9uLmluamVjdEJhdGNoaW5nU3RyYXRlZ3koUmVhY3REZWZhdWx0QmF0Y2hpbmdTdHJhdGVneSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIHJlbmRlclRvU3RyaW5nOiByZW5kZXJUb1N0cmluZyxcbiAgcmVuZGVyVG9TdGF0aWNNYXJrdXA6IHJlbmRlclRvU3RhdGljTWFya3VwXG59O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0U2VydmVyUmVuZGVyaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKlxuICogQHByb3ZpZGVzTW9kdWxlIFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneVxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kgPSB7XG4gIGlzQmF0Y2hpbmdVcGRhdGVzOiBmYWxzZSxcbiAgYmF0Y2hlZFVwZGF0ZXM6IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIERvbid0IGRvIGFueXRoaW5nIGhlcmUuIER1cmluZyB0aGUgc2VydmVyIHJlbmRlcmluZyB3ZSBkb24ndCB3YW50IHRvXG4gICAgLy8gc2NoZWR1bGUgYW55IHVwZGF0ZXMuIFdlIHdpbGwgc2ltcGx5IGlnbm9yZSB0aGVtLlxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyQmF0Y2hpbmdTdHJhdGVneTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdFNlcnZlckJhdGNoaW5nU3RyYXRlZ3kuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvblxuICogQHR5cGVjaGVja3NcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBQb29sZWRDbGFzcyA9IHJlcXVpcmUoJy4vUG9vbGVkQ2xhc3MnKTtcbnZhciBDYWxsYmFja1F1ZXVlID0gcmVxdWlyZSgnLi9DYWxsYmFja1F1ZXVlJyk7XG52YXIgVHJhbnNhY3Rpb24gPSByZXF1aXJlKCcuL1RyYW5zYWN0aW9uJyk7XG5cbnZhciBhc3NpZ24gPSByZXF1aXJlKCcuL09iamVjdC5hc3NpZ24nKTtcbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xuXG4vKipcbiAqIFByb3ZpZGVzIGEgYENhbGxiYWNrUXVldWVgIHF1ZXVlIGZvciBjb2xsZWN0aW5nIGBvbkRPTVJlYWR5YCBjYWxsYmFja3NcbiAqIGR1cmluZyB0aGUgcGVyZm9ybWluZyBvZiB0aGUgdHJhbnNhY3Rpb24uXG4gKi9cbnZhciBPTl9ET01fUkVBRFlfUVVFVUVJTkcgPSB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgaW50ZXJuYWwgYG9uRE9NUmVhZHlgIHF1ZXVlLlxuICAgKi9cbiAgaW5pdGlhbGl6ZTogZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVhY3RNb3VudFJlYWR5LnJlc2V0KCk7XG4gIH0sXG5cbiAgY2xvc2U6IGVtcHR5RnVuY3Rpb25cbn07XG5cbi8qKlxuICogRXhlY3V0ZWQgd2l0aGluIHRoZSBzY29wZSBvZiB0aGUgYFRyYW5zYWN0aW9uYCBpbnN0YW5jZS4gQ29uc2lkZXIgdGhlc2UgYXNcbiAqIGJlaW5nIG1lbWJlciBtZXRob2RzLCBidXQgd2l0aCBhbiBpbXBsaWVkIG9yZGVyaW5nIHdoaWxlIGJlaW5nIGlzb2xhdGVkIGZyb21cbiAqIGVhY2ggb3RoZXIuXG4gKi9cbnZhciBUUkFOU0FDVElPTl9XUkFQUEVSUyA9IFtPTl9ET01fUkVBRFlfUVVFVUVJTkddO1xuXG4vKipcbiAqIEBjbGFzcyBSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHJlbmRlclRvU3RhdGljTWFya3VwXG4gKi9cbmZ1bmN0aW9uIFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24ocmVuZGVyVG9TdGF0aWNNYXJrdXApIHtcbiAgdGhpcy5yZWluaXRpYWxpemVUcmFuc2FjdGlvbigpO1xuICB0aGlzLnJlbmRlclRvU3RhdGljTWFya3VwID0gcmVuZGVyVG9TdGF0aWNNYXJrdXA7XG4gIHRoaXMucmVhY3RNb3VudFJlYWR5ID0gQ2FsbGJhY2tRdWV1ZS5nZXRQb29sZWQobnVsbCk7XG4gIHRoaXMudXNlQ3JlYXRlRWxlbWVudCA9IGZhbHNlO1xufVxuXG52YXIgTWl4aW4gPSB7XG4gIC8qKlxuICAgKiBAc2VlIFRyYW5zYWN0aW9uXG4gICAqIEBhYnN0cmFjdFxuICAgKiBAZmluYWxcbiAgICogQHJldHVybiB7YXJyYXl9IEVtcHR5IGxpc3Qgb2Ygb3BlcmF0aW9uIHdyYXAgcHJvY2VkdXJlcy5cbiAgICovXG4gIGdldFRyYW5zYWN0aW9uV3JhcHBlcnM6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gVFJBTlNBQ1RJT05fV1JBUFBFUlM7XG4gIH0sXG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge29iamVjdH0gVGhlIHF1ZXVlIHRvIGNvbGxlY3QgYG9uRE9NUmVhZHlgIGNhbGxiYWNrcyB3aXRoLlxuICAgKi9cbiAgZ2V0UmVhY3RNb3VudFJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVhY3RNb3VudFJlYWR5O1xuICB9LFxuXG4gIC8qKlxuICAgKiBgUG9vbGVkQ2xhc3NgIGxvb2tzIGZvciB0aGlzLCBhbmQgd2lsbCBpbnZva2UgdGhpcyBiZWZvcmUgYWxsb3dpbmcgdGhpc1xuICAgKiBpbnN0YW5jZSB0byBiZSByZXVzZWQuXG4gICAqL1xuICBkZXN0cnVjdG9yOiBmdW5jdGlvbiAoKSB7XG4gICAgQ2FsbGJhY2tRdWV1ZS5yZWxlYXNlKHRoaXMucmVhY3RNb3VudFJlYWR5KTtcbiAgICB0aGlzLnJlYWN0TW91bnRSZWFkeSA9IG51bGw7XG4gIH1cbn07XG5cbmFzc2lnbihSZWFjdFNlcnZlclJlbmRlcmluZ1RyYW5zYWN0aW9uLnByb3RvdHlwZSwgVHJhbnNhY3Rpb24uTWl4aW4sIE1peGluKTtcblxuUG9vbGVkQ2xhc3MuYWRkUG9vbGluZ1RvKFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb24pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0U2VydmVyUmVuZGVyaW5nVHJhbnNhY3Rpb247XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RTZXJ2ZXJSZW5kZXJpbmdUcmFuc2FjdGlvbi5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdElzb21vcnBoaWNcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdENoaWxkcmVuID0gcmVxdWlyZSgnLi9SZWFjdENoaWxkcmVuJyk7XG52YXIgUmVhY3RDb21wb25lbnQgPSByZXF1aXJlKCcuL1JlYWN0Q29tcG9uZW50Jyk7XG52YXIgUmVhY3RDbGFzcyA9IHJlcXVpcmUoJy4vUmVhY3RDbGFzcycpO1xudmFyIFJlYWN0RE9NRmFjdG9yaWVzID0gcmVxdWlyZSgnLi9SZWFjdERPTUZhY3RvcmllcycpO1xudmFyIFJlYWN0RWxlbWVudCA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50Jyk7XG52YXIgUmVhY3RFbGVtZW50VmFsaWRhdG9yID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnRWYWxpZGF0b3InKTtcbnZhciBSZWFjdFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vUmVhY3RQcm9wVHlwZXMnKTtcbnZhciBSZWFjdFZlcnNpb24gPSByZXF1aXJlKCcuL1JlYWN0VmVyc2lvbicpO1xuXG52YXIgYXNzaWduID0gcmVxdWlyZSgnLi9PYmplY3QuYXNzaWduJyk7XG52YXIgb25seUNoaWxkID0gcmVxdWlyZSgnLi9vbmx5Q2hpbGQnKTtcblxudmFyIGNyZWF0ZUVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudDtcbnZhciBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50LmNyZWF0ZUZhY3Rvcnk7XG52YXIgY2xvbmVFbGVtZW50ID0gUmVhY3RFbGVtZW50LmNsb25lRWxlbWVudDtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgY3JlYXRlRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVFbGVtZW50O1xuICBjcmVhdGVGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUZhY3Rvcnk7XG4gIGNsb25lRWxlbWVudCA9IFJlYWN0RWxlbWVudFZhbGlkYXRvci5jbG9uZUVsZW1lbnQ7XG59XG5cbnZhciBSZWFjdCA9IHtcblxuICAvLyBNb2Rlcm5cblxuICBDaGlsZHJlbjoge1xuICAgIG1hcDogUmVhY3RDaGlsZHJlbi5tYXAsXG4gICAgZm9yRWFjaDogUmVhY3RDaGlsZHJlbi5mb3JFYWNoLFxuICAgIGNvdW50OiBSZWFjdENoaWxkcmVuLmNvdW50LFxuICAgIHRvQXJyYXk6IFJlYWN0Q2hpbGRyZW4udG9BcnJheSxcbiAgICBvbmx5OiBvbmx5Q2hpbGRcbiAgfSxcblxuICBDb21wb25lbnQ6IFJlYWN0Q29tcG9uZW50LFxuXG4gIGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGNsb25lRWxlbWVudDogY2xvbmVFbGVtZW50LFxuICBpc1ZhbGlkRWxlbWVudDogUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50LFxuXG4gIC8vIENsYXNzaWNcblxuICBQcm9wVHlwZXM6IFJlYWN0UHJvcFR5cGVzLFxuICBjcmVhdGVDbGFzczogUmVhY3RDbGFzcy5jcmVhdGVDbGFzcyxcbiAgY3JlYXRlRmFjdG9yeTogY3JlYXRlRmFjdG9yeSxcbiAgY3JlYXRlTWl4aW46IGZ1bmN0aW9uIChtaXhpbikge1xuICAgIC8vIEN1cnJlbnRseSBhIG5vb3AuIFdpbGwgYmUgdXNlZCB0byB2YWxpZGF0ZSBhbmQgdHJhY2UgbWl4aW5zLlxuICAgIHJldHVybiBtaXhpbjtcbiAgfSxcblxuICAvLyBUaGlzIGxvb2tzIERPTSBzcGVjaWZpYyBidXQgdGhlc2UgYXJlIGFjdHVhbGx5IGlzb21vcnBoaWMgaGVscGVyc1xuICAvLyBzaW5jZSB0aGV5IGFyZSBqdXN0IGdlbmVyYXRpbmcgRE9NIHN0cmluZ3MuXG4gIERPTTogUmVhY3RET01GYWN0b3JpZXMsXG5cbiAgdmVyc2lvbjogUmVhY3RWZXJzaW9uLFxuXG4gIC8vIEhvb2sgZm9yIEpTWCBzcHJlYWQsIGRvbid0IHVzZSB0aGlzIGZvciBhbnl0aGluZyBlbHNlLlxuICBfX3NwcmVhZDogYXNzaWduXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0O1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL1JlYWN0SXNvbW9ycGhpYy5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBSZWFjdERPTUZhY3Rvcmllc1xuICogQHR5cGVjaGVja3Mgc3RhdGljLW9ubHlcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdEVsZW1lbnQgPSByZXF1aXJlKCcuL1JlYWN0RWxlbWVudCcpO1xudmFyIFJlYWN0RWxlbWVudFZhbGlkYXRvciA9IHJlcXVpcmUoJy4vUmVhY3RFbGVtZW50VmFsaWRhdG9yJyk7XG5cbnZhciBtYXBPYmplY3QgPSByZXF1aXJlKCdmYmpzL2xpYi9tYXBPYmplY3QnKTtcblxuLyoqXG4gKiBDcmVhdGUgYSBmYWN0b3J5IHRoYXQgY3JlYXRlcyBIVE1MIHRhZyBlbGVtZW50cy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdGFnIFRhZyBuYW1lIChlLmcuIGBkaXZgKS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZURPTUZhY3RvcnkodGFnKSB7XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudFZhbGlkYXRvci5jcmVhdGVGYWN0b3J5KHRhZyk7XG4gIH1cbiAgcmV0dXJuIFJlYWN0RWxlbWVudC5jcmVhdGVGYWN0b3J5KHRhZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG1hcHBpbmcgZnJvbSBzdXBwb3J0ZWQgSFRNTCB0YWdzIHRvIGBSZWFjdERPTUNvbXBvbmVudGAgY2xhc3Nlcy5cbiAqIFRoaXMgaXMgYWxzbyBhY2Nlc3NpYmxlIHZpYSBgUmVhY3QuRE9NYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbnZhciBSZWFjdERPTUZhY3RvcmllcyA9IG1hcE9iamVjdCh7XG4gIGE6ICdhJyxcbiAgYWJicjogJ2FiYnInLFxuICBhZGRyZXNzOiAnYWRkcmVzcycsXG4gIGFyZWE6ICdhcmVhJyxcbiAgYXJ0aWNsZTogJ2FydGljbGUnLFxuICBhc2lkZTogJ2FzaWRlJyxcbiAgYXVkaW86ICdhdWRpbycsXG4gIGI6ICdiJyxcbiAgYmFzZTogJ2Jhc2UnLFxuICBiZGk6ICdiZGknLFxuICBiZG86ICdiZG8nLFxuICBiaWc6ICdiaWcnLFxuICBibG9ja3F1b3RlOiAnYmxvY2txdW90ZScsXG4gIGJvZHk6ICdib2R5JyxcbiAgYnI6ICdicicsXG4gIGJ1dHRvbjogJ2J1dHRvbicsXG4gIGNhbnZhczogJ2NhbnZhcycsXG4gIGNhcHRpb246ICdjYXB0aW9uJyxcbiAgY2l0ZTogJ2NpdGUnLFxuICBjb2RlOiAnY29kZScsXG4gIGNvbDogJ2NvbCcsXG4gIGNvbGdyb3VwOiAnY29sZ3JvdXAnLFxuICBkYXRhOiAnZGF0YScsXG4gIGRhdGFsaXN0OiAnZGF0YWxpc3QnLFxuICBkZDogJ2RkJyxcbiAgZGVsOiAnZGVsJyxcbiAgZGV0YWlsczogJ2RldGFpbHMnLFxuICBkZm46ICdkZm4nLFxuICBkaWFsb2c6ICdkaWFsb2cnLFxuICBkaXY6ICdkaXYnLFxuICBkbDogJ2RsJyxcbiAgZHQ6ICdkdCcsXG4gIGVtOiAnZW0nLFxuICBlbWJlZDogJ2VtYmVkJyxcbiAgZmllbGRzZXQ6ICdmaWVsZHNldCcsXG4gIGZpZ2NhcHRpb246ICdmaWdjYXB0aW9uJyxcbiAgZmlndXJlOiAnZmlndXJlJyxcbiAgZm9vdGVyOiAnZm9vdGVyJyxcbiAgZm9ybTogJ2Zvcm0nLFxuICBoMTogJ2gxJyxcbiAgaDI6ICdoMicsXG4gIGgzOiAnaDMnLFxuICBoNDogJ2g0JyxcbiAgaDU6ICdoNScsXG4gIGg2OiAnaDYnLFxuICBoZWFkOiAnaGVhZCcsXG4gIGhlYWRlcjogJ2hlYWRlcicsXG4gIGhncm91cDogJ2hncm91cCcsXG4gIGhyOiAnaHInLFxuICBodG1sOiAnaHRtbCcsXG4gIGk6ICdpJyxcbiAgaWZyYW1lOiAnaWZyYW1lJyxcbiAgaW1nOiAnaW1nJyxcbiAgaW5wdXQ6ICdpbnB1dCcsXG4gIGluczogJ2lucycsXG4gIGtiZDogJ2tiZCcsXG4gIGtleWdlbjogJ2tleWdlbicsXG4gIGxhYmVsOiAnbGFiZWwnLFxuICBsZWdlbmQ6ICdsZWdlbmQnLFxuICBsaTogJ2xpJyxcbiAgbGluazogJ2xpbmsnLFxuICBtYWluOiAnbWFpbicsXG4gIG1hcDogJ21hcCcsXG4gIG1hcms6ICdtYXJrJyxcbiAgbWVudTogJ21lbnUnLFxuICBtZW51aXRlbTogJ21lbnVpdGVtJyxcbiAgbWV0YTogJ21ldGEnLFxuICBtZXRlcjogJ21ldGVyJyxcbiAgbmF2OiAnbmF2JyxcbiAgbm9zY3JpcHQ6ICdub3NjcmlwdCcsXG4gIG9iamVjdDogJ29iamVjdCcsXG4gIG9sOiAnb2wnLFxuICBvcHRncm91cDogJ29wdGdyb3VwJyxcbiAgb3B0aW9uOiAnb3B0aW9uJyxcbiAgb3V0cHV0OiAnb3V0cHV0JyxcbiAgcDogJ3AnLFxuICBwYXJhbTogJ3BhcmFtJyxcbiAgcGljdHVyZTogJ3BpY3R1cmUnLFxuICBwcmU6ICdwcmUnLFxuICBwcm9ncmVzczogJ3Byb2dyZXNzJyxcbiAgcTogJ3EnLFxuICBycDogJ3JwJyxcbiAgcnQ6ICdydCcsXG4gIHJ1Ynk6ICdydWJ5JyxcbiAgczogJ3MnLFxuICBzYW1wOiAnc2FtcCcsXG4gIHNjcmlwdDogJ3NjcmlwdCcsXG4gIHNlY3Rpb246ICdzZWN0aW9uJyxcbiAgc2VsZWN0OiAnc2VsZWN0JyxcbiAgc21hbGw6ICdzbWFsbCcsXG4gIHNvdXJjZTogJ3NvdXJjZScsXG4gIHNwYW46ICdzcGFuJyxcbiAgc3Ryb25nOiAnc3Ryb25nJyxcbiAgc3R5bGU6ICdzdHlsZScsXG4gIHN1YjogJ3N1YicsXG4gIHN1bW1hcnk6ICdzdW1tYXJ5JyxcbiAgc3VwOiAnc3VwJyxcbiAgdGFibGU6ICd0YWJsZScsXG4gIHRib2R5OiAndGJvZHknLFxuICB0ZDogJ3RkJyxcbiAgdGV4dGFyZWE6ICd0ZXh0YXJlYScsXG4gIHRmb290OiAndGZvb3QnLFxuICB0aDogJ3RoJyxcbiAgdGhlYWQ6ICd0aGVhZCcsXG4gIHRpbWU6ICd0aW1lJyxcbiAgdGl0bGU6ICd0aXRsZScsXG4gIHRyOiAndHInLFxuICB0cmFjazogJ3RyYWNrJyxcbiAgdTogJ3UnLFxuICB1bDogJ3VsJyxcbiAgJ3Zhcic6ICd2YXInLFxuICB2aWRlbzogJ3ZpZGVvJyxcbiAgd2JyOiAnd2JyJyxcblxuICAvLyBTVkdcbiAgY2lyY2xlOiAnY2lyY2xlJyxcbiAgY2xpcFBhdGg6ICdjbGlwUGF0aCcsXG4gIGRlZnM6ICdkZWZzJyxcbiAgZWxsaXBzZTogJ2VsbGlwc2UnLFxuICBnOiAnZycsXG4gIGltYWdlOiAnaW1hZ2UnLFxuICBsaW5lOiAnbGluZScsXG4gIGxpbmVhckdyYWRpZW50OiAnbGluZWFyR3JhZGllbnQnLFxuICBtYXNrOiAnbWFzaycsXG4gIHBhdGg6ICdwYXRoJyxcbiAgcGF0dGVybjogJ3BhdHRlcm4nLFxuICBwb2x5Z29uOiAncG9seWdvbicsXG4gIHBvbHlsaW5lOiAncG9seWxpbmUnLFxuICByYWRpYWxHcmFkaWVudDogJ3JhZGlhbEdyYWRpZW50JyxcbiAgcmVjdDogJ3JlY3QnLFxuICBzdG9wOiAnc3RvcCcsXG4gIHN2ZzogJ3N2ZycsXG4gIHRleHQ6ICd0ZXh0JyxcbiAgdHNwYW46ICd0c3BhbidcblxufSwgY3JlYXRlRE9NRmFjdG9yeSk7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhY3RET01GYWN0b3JpZXM7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9saWIvUmVhY3RET01GYWN0b3JpZXMuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDE0LTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgUmVhY3RFbGVtZW50VmFsaWRhdG9yXG4gKi9cblxuLyoqXG4gKiBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgcHJvdmlkZXMgYSB3cmFwcGVyIGFyb3VuZCBhIGVsZW1lbnQgZmFjdG9yeVxuICogd2hpY2ggdmFsaWRhdGVzIHRoZSBwcm9wcyBwYXNzZWQgdG8gdGhlIGVsZW1lbnQuIFRoaXMgaXMgaW50ZW5kZWQgdG8gYmVcbiAqIHVzZWQgb25seSBpbiBERVYgYW5kIGNvdWxkIGJlIHJlcGxhY2VkIGJ5IGEgc3RhdGljIHR5cGUgY2hlY2tlciBmb3IgbGFuZ3VhZ2VzXG4gKiB0aGF0IHN1cHBvcnQgaXQuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcbnZhciBSZWFjdFByb3BUeXBlTG9jYXRpb25zID0gcmVxdWlyZSgnLi9SZWFjdFByb3BUeXBlTG9jYXRpb25zJyk7XG52YXIgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXMgPSByZXF1aXJlKCcuL1JlYWN0UHJvcFR5cGVMb2NhdGlvbk5hbWVzJyk7XG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSByZXF1aXJlKCcuL1JlYWN0Q3VycmVudE93bmVyJyk7XG5cbnZhciBjYW5EZWZpbmVQcm9wZXJ0eSA9IHJlcXVpcmUoJy4vY2FuRGVmaW5lUHJvcGVydHknKTtcbnZhciBnZXRJdGVyYXRvckZuID0gcmVxdWlyZSgnLi9nZXRJdGVyYXRvckZuJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcblxuZnVuY3Rpb24gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkge1xuICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgIHZhciBuYW1lID0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC5nZXROYW1lKCk7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiAnIENoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgfVxuICB9XG4gIHJldHVybiAnJztcbn1cblxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxudmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xuXG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIGlmICghZWxlbWVudC5fc3RvcmUgfHwgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkIHx8IGVsZW1lbnQua2V5ICE9IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcblxuICB2YXIgYWRkZW5kYSA9IGdldEFkZGVuZGFGb3JLZXlVc2UoJ3VuaXF1ZUtleScsIGVsZW1lbnQsIHBhcmVudFR5cGUpO1xuICBpZiAoYWRkZW5kYSA9PT0gbnVsbCkge1xuICAgIC8vIHdlIGFscmVhZHkgc2hvd2VkIHRoZSB3YXJuaW5nXG4gICAgcmV0dXJuO1xuICB9XG4gIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnRWFjaCBjaGlsZCBpbiBhbiBhcnJheSBvciBpdGVyYXRvciBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzJXMnLCBhZGRlbmRhLnBhcmVudE9yT3duZXIgfHwgJycsIGFkZGVuZGEuY2hpbGRPd25lciB8fCAnJywgYWRkZW5kYS51cmwgfHwgJycpIDogdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIFNoYXJlZCB3YXJuaW5nIGFuZCBtb25pdG9yaW5nIGNvZGUgZm9yIHRoZSBrZXkgd2FybmluZ3MuXG4gKlxuICogQGludGVybmFsXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZVR5cGUgQSBrZXkgdXNlZCBmb3IgZGUtZHVwaW5nIHdhcm5pbmdzLlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgQ29tcG9uZW50IHRoYXQgcmVxdWlyZXMgYSBrZXkuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgZWxlbWVudCdzIHBhcmVudCdzIHR5cGUuXG4gKiBAcmV0dXJucyB7P29iamVjdH0gQSBzZXQgb2YgYWRkZW5kYSB0byB1c2UgaW4gdGhlIHdhcm5pbmcgbWVzc2FnZSwgb3IgbnVsbFxuICogaWYgdGhlIHdhcm5pbmcgaGFzIGFscmVhZHkgYmVlbiBzaG93biBiZWZvcmUgKGFuZCBzaG91bGRuJ3QgYmUgc2hvd24gYWdhaW4pLlxuICovXG5mdW5jdGlvbiBnZXRBZGRlbmRhRm9yS2V5VXNlKG1lc3NhZ2VUeXBlLCBlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICBpZiAoIWFkZGVuZHVtKSB7XG4gICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG4gICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgIGFkZGVuZHVtID0gJyBDaGVjayB0aGUgdG9wLWxldmVsIHJlbmRlciBjYWxsIHVzaW5nIDwnICsgcGFyZW50TmFtZSArICc+Lic7XG4gICAgfVxuICB9XG5cbiAgdmFyIG1lbW9pemVyID0gb3duZXJIYXNLZXlVc2VXYXJuaW5nW21lc3NhZ2VUeXBlXSB8fCAob3duZXJIYXNLZXlVc2VXYXJuaW5nW21lc3NhZ2VUeXBlXSA9IHt9KTtcbiAgaWYgKG1lbW9pemVyW2FkZGVuZHVtXSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIG1lbW9pemVyW2FkZGVuZHVtXSA9IHRydWU7XG5cbiAgdmFyIGFkZGVuZGEgPSB7XG4gICAgcGFyZW50T3JPd25lcjogYWRkZW5kdW0sXG4gICAgdXJsOiAnIFNlZSBodHRwczovL2ZiLm1lL3JlYWN0LXdhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLFxuICAgIGNoaWxkT3duZXI6IG51bGxcbiAgfTtcblxuICAvLyBVc3VhbGx5IHRoZSBjdXJyZW50IG93bmVyIGlzIHRoZSBvZmZlbmRlciwgYnV0IGlmIGl0IGFjY2VwdHMgY2hpbGRyZW4gYXMgYVxuICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cbiAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5fb3duZXIgJiYgZWxlbWVudC5fb3duZXIgIT09IFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQpIHtcbiAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICBhZGRlbmRhLmNoaWxkT3duZXIgPSAnIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tICcgKyBlbGVtZW50Ll9vd25lci5nZXROYW1lKCkgKyAnLic7XG4gIH1cblxuICByZXR1cm4gYWRkZW5kYTtcbn1cblxuLyoqXG4gKiBFbnN1cmUgdGhhdCBldmVyeSBlbGVtZW50IGVpdGhlciBpcyBwYXNzZWQgaW4gYSBzdGF0aWMgbG9jYXRpb24sIGluIGFuXG4gKiBhcnJheSB3aXRoIGFuIGV4cGxpY2l0IGtleXMgcHJvcGVydHkgZGVmaW5lZCwgb3IgaW4gYW4gb2JqZWN0IGxpdGVyYWxcbiAqIHdpdGggdmFsaWQga2V5IHByb3BlcnR5LlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdE5vZGV9IG5vZGUgU3RhdGljYWxseSBwYXNzZWQgY2hpbGQgb2YgYW55IHR5cGUuXG4gKiBAcGFyYW0geyp9IHBhcmVudFR5cGUgbm9kZSdzIHBhcmVudCdzIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2hpbGRLZXlzKG5vZGUsIHBhcmVudFR5cGUpIHtcbiAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcbiAgICAgIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoY2hpbGQsIHBhcmVudFR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChSZWFjdEVsZW1lbnQuaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgIGlmIChub2RlLl9zdG9yZSkge1xuICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gIH0gZWxzZSBpZiAobm9kZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihub2RlKTtcbiAgICAvLyBFbnRyeSBpdGVyYXRvcnMgcHJvdmlkZSBpbXBsaWNpdCBrZXlzLlxuICAgIGlmIChpdGVyYXRvckZuKSB7XG4gICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgdmFyIHN0ZXA7XG4gICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICBpZiAoUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSBwcm9wcyBhcmUgdmFsaWRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29tcG9uZW50TmFtZSBOYW1lIG9mIHRoZSBjb21wb25lbnQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICogQHBhcmFtIHtvYmplY3R9IHByb3BUeXBlcyBNYXAgb2YgcHJvcCBuYW1lIHRvIGEgUmVhY3RQcm9wVHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30gbG9jYXRpb24gZS5nLiBcInByb3BcIiwgXCJjb250ZXh0XCIsIFwiY2hpbGQgY29udGV4dFwiXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyhjb21wb25lbnROYW1lLCBwcm9wVHlwZXMsIHByb3BzLCBsb2NhdGlvbikge1xuICBmb3IgKHZhciBwcm9wTmFtZSBpbiBwcm9wVHlwZXMpIHtcbiAgICBpZiAocHJvcFR5cGVzLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xuICAgICAgdmFyIGVycm9yO1xuICAgICAgLy8gUHJvcCB0eXBlIHZhbGlkYXRpb24gbWF5IHRocm93LiBJbiBjYXNlIHRoZXkgZG8sIHdlIGRvbid0IHdhbnQgdG9cbiAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAvLyBiZWhhdmlvciBhcyB3aXRob3V0IHRoaXMgc3RhdGVtZW50IGV4Y2VwdCB3aXRoIGEgYmV0dGVyIG1lc3NhZ2UuXG4gICAgICAgICEodHlwZW9mIHByb3BUeXBlc1twcm9wTmFtZV0gPT09ICdmdW5jdGlvbicpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IGludmFyaWFudChmYWxzZSwgJyVzOiAlcyB0eXBlIGAlc2AgaXMgaW52YWxpZDsgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gJyArICdSZWFjdC5Qcm9wVHlwZXMuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBSZWFjdFByb3BUeXBlTG9jYXRpb25OYW1lc1tsb2NhdGlvbl0sIHByb3BOYW1lKSA6IGludmFyaWFudChmYWxzZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgIGVycm9yID0gcHJvcFR5cGVzW3Byb3BOYW1lXShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uKTtcbiAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgIGVycm9yID0gZXg7XG4gICAgICB9XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyghZXJyb3IgfHwgZXJyb3IgaW5zdGFuY2VvZiBFcnJvciwgJyVzOiB0eXBlIHNwZWNpZmljYXRpb24gb2YgJXMgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgUmVhY3RQcm9wVHlwZUxvY2F0aW9uTmFtZXNbbG9jYXRpb25dLCBwcm9wTmFtZSwgdHlwZW9mIGVycm9yKSA6IHVuZGVmaW5lZDtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IubWVzc2FnZV0gPSB0cnVlO1xuXG4gICAgICAgIHZhciBhZGRlbmR1bSA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCBwcm9wVHlwZTogJXMlcycsIGVycm9yLm1lc3NhZ2UsIGFkZGVuZHVtKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB2YXIgY29tcG9uZW50Q2xhc3MgPSBlbGVtZW50LnR5cGU7XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MgIT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG5hbWUgPSBjb21wb25lbnRDbGFzcy5kaXNwbGF5TmFtZSB8fCBjb21wb25lbnRDbGFzcy5uYW1lO1xuICBpZiAoY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzKSB7XG4gICAgY2hlY2tQcm9wVHlwZXMobmFtZSwgY29tcG9uZW50Q2xhc3MucHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCBSZWFjdFByb3BUeXBlTG9jYXRpb25zLnByb3ApO1xuICB9XG4gIGlmICh0eXBlb2YgY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IHdhcm5pbmcoY29tcG9uZW50Q2xhc3MuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkLCAnZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbnZhciBSZWFjdEVsZW1lbnRWYWxpZGF0b3IgPSB7XG5cbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gKHR5cGUsIHByb3BzLCBjaGlsZHJlbikge1xuICAgIHZhciB2YWxpZFR5cGUgPSB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbic7XG4gICAgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHZhbGlkVHlwZSwgJ1JlYWN0LmNyZWF0ZUVsZW1lbnQ6IHR5cGUgc2hvdWxkIG5vdCBiZSBudWxsLCB1bmRlZmluZWQsIGJvb2xlYW4sIG9yICcgKyAnbnVtYmVyLiBJdCBzaG91bGQgYmUgYSBzdHJpbmcgKGZvciBET00gZWxlbWVudHMpIG9yIGEgUmVhY3RDbGFzcyAnICsgJyhmb3IgY29tcG9zaXRlIGNvbXBvbmVudHMpLiVzJywgZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCkpIDogdW5kZWZpbmVkO1xuXG4gICAgdmFyIGVsZW1lbnQgPSBSZWFjdEVsZW1lbnQuY3JlYXRlRWxlbWVudC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gVGhlIHJlc3VsdCBjYW4gYmUgbnVsbGlzaCBpZiBhIG1vY2sgb3IgYSBjdXN0b20gZnVuY3Rpb24gaXMgdXNlZC5cbiAgICAvLyBUT0RPOiBEcm9wIHRoaXMgd2hlbiB0aGVzZSBhcmUgbm8gbG9uZ2VyIGFsbG93ZWQgYXMgdGhlIHR5cGUgYXJndW1lbnQuXG4gICAgaWYgKGVsZW1lbnQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuXG4gICAgLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuICAgIGlmICh2YWxpZFR5cGUpIHtcbiAgICAgIGZvciAodmFyIGkgPSAyOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGFyZ3VtZW50c1tpXSwgdHlwZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfSxcblxuICBjcmVhdGVGYWN0b3J5OiBmdW5jdGlvbiAodHlwZSkge1xuICAgIHZhciB2YWxpZGF0ZWRGYWN0b3J5ID0gUmVhY3RFbGVtZW50VmFsaWRhdG9yLmNyZWF0ZUVsZW1lbnQuYmluZChudWxsLCB0eXBlKTtcbiAgICAvLyBMZWdhY3kgaG9vayBUT0RPOiBXYXJuIGlmIHRoaXMgaXMgYWNjZXNzZWRcbiAgICB2YWxpZGF0ZWRGYWN0b3J5LnR5cGUgPSB0eXBlO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmIChjYW5EZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsaWRhdGVkRmFjdG9yeSwgJ3R5cGUnLCB7XG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ZhY3RvcnkudHlwZSBpcyBkZXByZWNhdGVkLiBBY2Nlc3MgdGhlIGNsYXNzIGRpcmVjdGx5ICcgKyAnYmVmb3JlIHBhc3NpbmcgaXQgdG8gY3JlYXRlRmFjdG9yeS4nKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAndHlwZScsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IHR5cGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHR5cGU7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdmFsaWRhdGVkRmFjdG9yeTtcbiAgfSxcblxuICBjbG9uZUVsZW1lbnQ6IGZ1bmN0aW9uIChlbGVtZW50LCBwcm9wcywgY2hpbGRyZW4pIHtcbiAgICB2YXIgbmV3RWxlbWVudCA9IFJlYWN0RWxlbWVudC5jbG9uZUVsZW1lbnQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICBmb3IgKHZhciBpID0gMjsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFsaWRhdGVDaGlsZEtleXMoYXJndW1lbnRzW2ldLCBuZXdFbGVtZW50LnR5cGUpO1xuICAgIH1cbiAgICB2YWxpZGF0ZVByb3BUeXBlcyhuZXdFbGVtZW50KTtcbiAgICByZXR1cm4gbmV3RWxlbWVudDtcbiAgfVxuXG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWN0RWxlbWVudFZhbGlkYXRvcjtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9SZWFjdEVsZW1lbnRWYWxpZGF0b3IuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgbWFwT2JqZWN0XG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG4vKipcbiAqIEV4ZWN1dGVzIHRoZSBwcm92aWRlZCBgY2FsbGJhY2tgIG9uY2UgZm9yIGVhY2ggZW51bWVyYWJsZSBvd24gcHJvcGVydHkgaW4gdGhlXG4gKiBvYmplY3QgYW5kIGNvbnN0cnVjdHMgYSBuZXcgb2JqZWN0IGZyb20gdGhlIHJlc3VsdHMuIFRoZSBgY2FsbGJhY2tgIGlzXG4gKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOlxuICpcbiAqICAtIHRoZSBwcm9wZXJ0eSB2YWx1ZVxuICogIC0gdGhlIHByb3BlcnR5IG5hbWVcbiAqICAtIHRoZSBvYmplY3QgYmVpbmcgdHJhdmVyc2VkXG4gKlxuICogUHJvcGVydGllcyB0aGF0IGFyZSBhZGRlZCBhZnRlciB0aGUgY2FsbCB0byBgbWFwT2JqZWN0YCB3aWxsIG5vdCBiZSB2aXNpdGVkXG4gKiBieSBgY2FsbGJhY2tgLiBJZiB0aGUgdmFsdWVzIG9mIGV4aXN0aW5nIHByb3BlcnRpZXMgYXJlIGNoYW5nZWQsIHRoZSB2YWx1ZVxuICogcGFzc2VkIHRvIGBjYWxsYmFja2Agd2lsbCBiZSB0aGUgdmFsdWUgYXQgdGhlIHRpbWUgYG1hcE9iamVjdGAgdmlzaXRzIHRoZW0uXG4gKiBQcm9wZXJ0aWVzIHRoYXQgYXJlIGRlbGV0ZWQgYmVmb3JlIGJlaW5nIHZpc2l0ZWQgYXJlIG5vdCB2aXNpdGVkLlxuICpcbiAqIEBncmVwIGZ1bmN0aW9uIG9iamVjdE1hcCgpXG4gKiBAZ3JlcCBmdW5jdGlvbiBvYmpNYXAoKVxuICpcbiAqIEBwYXJhbSB7P29iamVjdH0gb2JqZWN0XG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHsqfSBjb250ZXh0XG4gKiBAcmV0dXJuIHs/b2JqZWN0fVxuICovXG5mdW5jdGlvbiBtYXBPYmplY3Qob2JqZWN0LCBjYWxsYmFjaywgY29udGV4dCkge1xuICBpZiAoIW9iamVjdCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciByZXN1bHQgPSB7fTtcbiAgZm9yICh2YXIgbmFtZSBpbiBvYmplY3QpIHtcbiAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIG5hbWUpKSB7XG4gICAgICByZXN1bHRbbmFtZV0gPSBjYWxsYmFjay5jYWxsKGNvbnRleHQsIG9iamVjdFtuYW1lXSwgbmFtZSwgb2JqZWN0KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBtYXBPYmplY3Q7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC9+L2ZianMvbGliL21hcE9iamVjdC5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTMtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICpcbiAqIEBwcm92aWRlc01vZHVsZSBvbmx5Q2hpbGRcbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3RFbGVtZW50ID0gcmVxdWlyZSgnLi9SZWFjdEVsZW1lbnQnKTtcblxudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGZpcnN0IGNoaWxkIGluIGEgY29sbGVjdGlvbiBvZiBjaGlsZHJlbiBhbmQgdmVyaWZpZXMgdGhhdCB0aGVyZVxuICogaXMgb25seSBvbmUgY2hpbGQgaW4gdGhlIGNvbGxlY3Rpb24uIFRoZSBjdXJyZW50IGltcGxlbWVudGF0aW9uIG9mIHRoaXNcbiAqIGZ1bmN0aW9uIGFzc3VtZXMgdGhhdCBhIHNpbmdsZSBjaGlsZCBnZXRzIHBhc3NlZCB3aXRob3V0IGEgd3JhcHBlciwgYnV0IHRoZVxuICogcHVycG9zZSBvZiB0aGlzIGhlbHBlciBmdW5jdGlvbiBpcyB0byBhYnN0cmFjdCBhd2F5IHRoZSBwYXJ0aWN1bGFyIHN0cnVjdHVyZVxuICogb2YgY2hpbGRyZW4uXG4gKlxuICogQHBhcmFtIHs/b2JqZWN0fSBjaGlsZHJlbiBDaGlsZCBjb2xsZWN0aW9uIHN0cnVjdHVyZS5cbiAqIEByZXR1cm4ge1JlYWN0Q29tcG9uZW50fSBUaGUgZmlyc3QgYW5kIG9ubHkgYFJlYWN0Q29tcG9uZW50YCBjb250YWluZWQgaW4gdGhlXG4gKiBzdHJ1Y3R1cmUuXG4gKi9cbmZ1bmN0aW9uIG9ubHlDaGlsZChjaGlsZHJlbikge1xuICAhUmVhY3RFbGVtZW50LmlzVmFsaWRFbGVtZW50KGNoaWxkcmVuKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBpbnZhcmlhbnQoZmFsc2UsICdvbmx5Q2hpbGQgbXVzdCBiZSBwYXNzZWQgYSBjaGlsZHJlbiB3aXRoIGV4YWN0bHkgb25lIGNoaWxkLicpIDogaW52YXJpYW50KGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIGNoaWxkcmVuO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG9ubHlDaGlsZDtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0L2xpYi9vbmx5Q2hpbGQuanMiLCIvKipcbiAqIENvcHlyaWdodCAyMDEzLTIwMTUsIEZhY2Vib29rLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIEJTRC1zdHlsZSBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLiBBbiBhZGRpdGlvbmFsIGdyYW50XG4gKiBvZiBwYXRlbnQgcmlnaHRzIGNhbiBiZSBmb3VuZCBpbiB0aGUgUEFURU5UUyBmaWxlIGluIHRoZSBzYW1lIGRpcmVjdG9yeS5cbiAqXG4gKiBAcHJvdmlkZXNNb2R1bGUgZGVwcmVjYXRlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGFzc2lnbiA9IHJlcXVpcmUoJy4vT2JqZWN0LmFzc2lnbicpO1xudmFyIHdhcm5pbmcgPSByZXF1aXJlKCdmYmpzL2xpYi93YXJuaW5nJyk7XG5cbi8qKlxuICogVGhpcyB3aWxsIGxvZyBhIHNpbmdsZSBkZXByZWNhdGlvbiBub3RpY2UgcGVyIGZ1bmN0aW9uIGFuZCBmb3J3YXJkIHRoZSBjYWxsXG4gKiBvbiB0byB0aGUgbmV3IEFQSS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gZm5OYW1lIFRoZSBuYW1lIG9mIHRoZSBmdW5jdGlvblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld01vZHVsZSBUaGUgbW9kdWxlIHRoYXQgZm4gd2lsbCBleGlzdCBpblxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1BhY2thZ2UgVGhlIG1vZHVsZSB0aGF0IGZuIHdpbGwgZXhpc3QgaW5cbiAqIEBwYXJhbSB7Kn0gY3R4IFRoZSBjb250ZXh0IHRoaXMgZm9yd2FyZGVkIGNhbGwgc2hvdWxkIHJ1biBpblxuICogQHBhcmFtIHtmdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIGZvcndhcmQgb24gdG9cbiAqIEByZXR1cm4ge2Z1bmN0aW9ufSBUaGUgZnVuY3Rpb24gdGhhdCB3aWxsIHdhcm4gb25jZSBhbmQgdGhlbiBjYWxsIGZuXG4gKi9cbmZ1bmN0aW9uIGRlcHJlY2F0ZWQoZm5OYW1lLCBuZXdNb2R1bGUsIG5ld1BhY2thZ2UsIGN0eCwgZm4pIHtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIHZhciBuZXdGbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKHdhcm5lZCxcbiAgICAgIC8vIFJlcXVpcmUgZXhhbXBsZXMgaW4gdGhpcyBzdHJpbmcgbXVzdCBiZSBzcGxpdCB0byBwcmV2ZW50IFJlYWN0J3NcbiAgICAgIC8vIGJ1aWxkIHRvb2xzIGZyb20gbWlzdGFraW5nIHRoZW0gZm9yIHJlYWwgcmVxdWlyZXMuXG4gICAgICAvLyBPdGhlcndpc2UgdGhlIGJ1aWxkIHRvb2xzIHdpbGwgYXR0ZW1wdCB0byBidWlsZCBhICclcycgbW9kdWxlLlxuICAgICAgJ1JlYWN0LiVzIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgJXMuJXMgZnJvbSByZXF1aXJlJyArICcoXFwnJXNcXCcpICcgKyAnaW5zdGVhZC4nLCBmbk5hbWUsIG5ld01vZHVsZSwgZm5OYW1lLCBuZXdQYWNrYWdlKSA6IHVuZGVmaW5lZDtcbiAgICAgIHdhcm5lZCA9IHRydWU7XG4gICAgICByZXR1cm4gZm4uYXBwbHkoY3R4LCBhcmd1bWVudHMpO1xuICAgIH07XG4gICAgLy8gV2UgbmVlZCB0byBtYWtlIHN1cmUgYWxsIHByb3BlcnRpZXMgb2YgdGhlIG9yaWdpbmFsIGZuIGFyZSBjb3BpZWQgb3Zlci5cbiAgICAvLyBJbiBwYXJ0aWN1bGFyLCB0aGlzIGlzIG5lZWRlZCB0byBzdXBwb3J0IFByb3BUeXBlc1xuICAgIHJldHVybiBhc3NpZ24obmV3Rm4sIGZuKTtcbiAgfVxuXG4gIHJldHVybiBmbjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGVkO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3QvbGliL2RlcHJlY2F0ZWQuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgncmVhY3QvbGliL1JlYWN0RE9NJyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LWRvbS9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY3JlYXRlTWVtb3J5SGlzdG9yeSA9IGV4cG9ydHMuaGFzaEhpc3RvcnkgPSBleHBvcnRzLmJyb3dzZXJIaXN0b3J5ID0gZXhwb3J0cy5hcHBseVJvdXRlck1pZGRsZXdhcmUgPSBleHBvcnRzLmZvcm1hdFBhdHRlcm4gPSBleHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBleHBvcnRzLm1hdGNoID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IGV4cG9ydHMuUHJvcFR5cGVzID0gZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IGV4cG9ydHMuUm91dGVyQ29udGV4dCA9IGV4cG9ydHMuY3JlYXRlUm91dGVzID0gZXhwb3J0cy51c2VSb3V0ZXMgPSBleHBvcnRzLlJvdXRlQ29udGV4dCA9IGV4cG9ydHMuTGlmZWN5Y2xlID0gZXhwb3J0cy5IaXN0b3J5ID0gZXhwb3J0cy5Sb3V0ZSA9IGV4cG9ydHMuUmVkaXJlY3QgPSBleHBvcnRzLkluZGV4Um91dGUgPSBleHBvcnRzLkluZGV4UmVkaXJlY3QgPSBleHBvcnRzLndpdGhSb3V0ZXIgPSBleHBvcnRzLkluZGV4TGluayA9IGV4cG9ydHMuTGluayA9IGV4cG9ydHMuUm91dGVyID0gdW5kZWZpbmVkO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdjcmVhdGVSb3V0ZXMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZXM7XG4gIH1cbn0pO1xuXG52YXIgX1Byb3BUeXBlczIgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ2xvY2F0aW9uU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5sb2NhdGlvblNoYXBlO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAncm91dGVyU2hhcGUnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBfUHJvcFR5cGVzMi5yb3V0ZXJTaGFwZTtcbiAgfVxufSk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdmb3JtYXRQYXR0ZXJuJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gX1BhdHRlcm5VdGlscy5mb3JtYXRQYXR0ZXJuO1xuICB9XG59KTtcblxudmFyIF9Sb3V0ZXIyID0gcmVxdWlyZSgnLi9Sb3V0ZXInKTtcblxudmFyIF9Sb3V0ZXIzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyMik7XG5cbnZhciBfTGluazIgPSByZXF1aXJlKCcuL0xpbmsnKTtcblxudmFyIF9MaW5rMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0xpbmsyKTtcblxudmFyIF9JbmRleExpbmsyID0gcmVxdWlyZSgnLi9JbmRleExpbmsnKTtcblxudmFyIF9JbmRleExpbmszID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhMaW5rMik7XG5cbnZhciBfd2l0aFJvdXRlcjIgPSByZXF1aXJlKCcuL3dpdGhSb3V0ZXInKTtcblxudmFyIF93aXRoUm91dGVyMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dpdGhSb3V0ZXIyKTtcblxudmFyIF9JbmRleFJlZGlyZWN0MiA9IHJlcXVpcmUoJy4vSW5kZXhSZWRpcmVjdCcpO1xuXG52YXIgX0luZGV4UmVkaXJlY3QzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfSW5kZXhSZWRpcmVjdDIpO1xuXG52YXIgX0luZGV4Um91dGUyID0gcmVxdWlyZSgnLi9JbmRleFJvdXRlJyk7XG5cbnZhciBfSW5kZXhSb3V0ZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9JbmRleFJvdXRlMik7XG5cbnZhciBfUmVkaXJlY3QyID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0Mik7XG5cbnZhciBfUm91dGUyID0gcmVxdWlyZSgnLi9Sb3V0ZScpO1xuXG52YXIgX1JvdXRlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlMik7XG5cbnZhciBfSGlzdG9yeTIgPSByZXF1aXJlKCcuL0hpc3RvcnknKTtcblxudmFyIF9IaXN0b3J5MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX0hpc3RvcnkyKTtcblxudmFyIF9MaWZlY3ljbGUyID0gcmVxdWlyZSgnLi9MaWZlY3ljbGUnKTtcblxudmFyIF9MaWZlY3ljbGUzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGlmZWN5Y2xlMik7XG5cbnZhciBfUm91dGVDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVDb250ZXh0MyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JvdXRlQ29udGV4dDIpO1xuXG52YXIgX3VzZVJvdXRlczIgPSByZXF1aXJlKCcuL3VzZVJvdXRlcycpO1xuXG52YXIgX3VzZVJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXMyKTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dDIpO1xuXG52YXIgX1JvdXRpbmdDb250ZXh0MiA9IHJlcXVpcmUoJy4vUm91dGluZ0NvbnRleHQnKTtcblxudmFyIF9Sb3V0aW5nQ29udGV4dDMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0aW5nQ29udGV4dDIpO1xuXG52YXIgX1Byb3BUeXBlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Qcm9wVHlwZXMyKTtcblxudmFyIF9tYXRjaDIgPSByZXF1aXJlKCcuL21hdGNoJyk7XG5cbnZhciBfbWF0Y2gzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2gyKTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5MiA9IHJlcXVpcmUoJy4vdXNlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX3VzZVJvdXRlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUm91dGVySGlzdG9yeTIpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTIgPSByZXF1aXJlKCcuL2FwcGx5Um91dGVyTWlkZGxld2FyZScpO1xuXG52YXIgX2FwcGx5Um91dGVyTWlkZGxld2FyZTMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9hcHBseVJvdXRlck1pZGRsZXdhcmUyKTtcblxudmFyIF9icm93c2VySGlzdG9yeTIgPSByZXF1aXJlKCcuL2Jyb3dzZXJIaXN0b3J5Jyk7XG5cbnZhciBfYnJvd3Nlckhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYnJvd3Nlckhpc3RvcnkyKTtcblxudmFyIF9oYXNoSGlzdG9yeTIgPSByZXF1aXJlKCcuL2hhc2hIaXN0b3J5Jyk7XG5cbnZhciBfaGFzaEhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaGFzaEhpc3RvcnkyKTtcblxudmFyIF9jcmVhdGVNZW1vcnlIaXN0b3J5MiA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeTIpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5leHBvcnRzLlJvdXRlciA9IF9Sb3V0ZXIzLmRlZmF1bHQ7IC8qIGNvbXBvbmVudHMgKi9cblxuZXhwb3J0cy5MaW5rID0gX0xpbmszLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4TGluayA9IF9JbmRleExpbmszLmRlZmF1bHQ7XG5leHBvcnRzLndpdGhSb3V0ZXIgPSBfd2l0aFJvdXRlcjMuZGVmYXVsdDtcblxuLyogY29tcG9uZW50cyAoY29uZmlndXJhdGlvbikgKi9cblxuZXhwb3J0cy5JbmRleFJlZGlyZWN0ID0gX0luZGV4UmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLkluZGV4Um91dGUgPSBfSW5kZXhSb3V0ZTMuZGVmYXVsdDtcbmV4cG9ydHMuUmVkaXJlY3QgPSBfUmVkaXJlY3QzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlID0gX1JvdXRlMy5kZWZhdWx0O1xuXG4vKiBtaXhpbnMgKi9cblxuZXhwb3J0cy5IaXN0b3J5ID0gX0hpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLkxpZmVjeWNsZSA9IF9MaWZlY3ljbGUzLmRlZmF1bHQ7XG5leHBvcnRzLlJvdXRlQ29udGV4dCA9IF9Sb3V0ZUNvbnRleHQzLmRlZmF1bHQ7XG5cbi8qIHV0aWxzICovXG5cbmV4cG9ydHMudXNlUm91dGVzID0gX3VzZVJvdXRlczMuZGVmYXVsdDtcbmV4cG9ydHMuUm91dGVyQ29udGV4dCA9IF9Sb3V0ZXJDb250ZXh0My5kZWZhdWx0O1xuZXhwb3J0cy5Sb3V0aW5nQ29udGV4dCA9IF9Sb3V0aW5nQ29udGV4dDMuZGVmYXVsdDtcbmV4cG9ydHMuUHJvcFR5cGVzID0gX1Byb3BUeXBlczMuZGVmYXVsdDtcbmV4cG9ydHMubWF0Y2ggPSBfbWF0Y2gzLmRlZmF1bHQ7XG5leHBvcnRzLnVzZVJvdXRlckhpc3RvcnkgPSBfdXNlUm91dGVySGlzdG9yeTMuZGVmYXVsdDtcbmV4cG9ydHMuYXBwbHlSb3V0ZXJNaWRkbGV3YXJlID0gX2FwcGx5Um91dGVyTWlkZGxld2FyZTMuZGVmYXVsdDtcblxuLyogaGlzdG9yaWVzICovXG5cbmV4cG9ydHMuYnJvd3Nlckhpc3RvcnkgPSBfYnJvd3Nlckhpc3RvcnkzLmRlZmF1bHQ7XG5leHBvcnRzLmhhc2hIaXN0b3J5ID0gX2hhc2hIaXN0b3J5My5kZWZhdWx0O1xuZXhwb3J0cy5jcmVhdGVNZW1vcnlIaXN0b3J5ID0gX2NyZWF0ZU1lbW9yeUhpc3RvcnkzLmRlZmF1bHQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmlzUmVhY3RDaGlsZHJlbiA9IGlzUmVhY3RDaGlsZHJlbjtcbmV4cG9ydHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50ID0gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50O1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbiA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuO1xuZXhwb3J0cy5jcmVhdGVSb3V0ZXMgPSBjcmVhdGVSb3V0ZXM7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gaXNWYWxpZENoaWxkKG9iamVjdCkge1xuICByZXR1cm4gb2JqZWN0ID09IG51bGwgfHwgX3JlYWN0Mi5kZWZhdWx0LmlzVmFsaWRFbGVtZW50KG9iamVjdCk7XG59XG5cbmZ1bmN0aW9uIGlzUmVhY3RDaGlsZHJlbihvYmplY3QpIHtcbiAgcmV0dXJuIGlzVmFsaWRDaGlsZChvYmplY3QpIHx8IEFycmF5LmlzQXJyYXkob2JqZWN0KSAmJiBvYmplY3QuZXZlcnkoaXNWYWxpZENoaWxkKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUm91dGUoZGVmYXVsdFByb3BzLCBwcm9wcykge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGRlZmF1bHRQcm9wcywgcHJvcHMpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkge1xuICB2YXIgdHlwZSA9IGVsZW1lbnQudHlwZTtcbiAgdmFyIHJvdXRlID0gY3JlYXRlUm91dGUodHlwZS5kZWZhdWx0UHJvcHMsIGVsZW1lbnQucHJvcHMpO1xuXG4gIGlmIChyb3V0ZS5jaGlsZHJlbikge1xuICAgIHZhciBjaGlsZFJvdXRlcyA9IGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuKHJvdXRlLmNoaWxkcmVuLCByb3V0ZSk7XG5cbiAgICBpZiAoY2hpbGRSb3V0ZXMubGVuZ3RoKSByb3V0ZS5jaGlsZFJvdXRlcyA9IGNoaWxkUm91dGVzO1xuXG4gICAgZGVsZXRlIHJvdXRlLmNoaWxkcmVuO1xuICB9XG5cbiAgcmV0dXJuIHJvdXRlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW5kIHJldHVybnMgYSByb3V0ZXMgb2JqZWN0IGZyb20gdGhlIGdpdmVuIFJlYWN0Q2hpbGRyZW4uIEpTWFxuICogcHJvdmlkZXMgYSBjb252ZW5pZW50IHdheSB0byB2aXN1YWxpemUgaG93IHJvdXRlcyBpbiB0aGUgaGllcmFyY2h5IGFyZVxuICogbmVzdGVkLlxuICpcbiAqICAgaW1wb3J0IHsgUm91dGUsIGNyZWF0ZVJvdXRlc0Zyb21SZWFjdENoaWxkcmVuIH0gZnJvbSAncmVhY3Qtcm91dGVyJ1xuICpcbiAqICAgY29uc3Qgcm91dGVzID0gY3JlYXRlUm91dGVzRnJvbVJlYWN0Q2hpbGRyZW4oXG4gKiAgICAgPFJvdXRlIGNvbXBvbmVudD17QXBwfT5cbiAqICAgICAgIDxSb3V0ZSBwYXRoPVwiaG9tZVwiIGNvbXBvbmVudD17RGFzaGJvYXJkfS8+XG4gKiAgICAgICA8Um91dGUgcGF0aD1cIm5ld3NcIiBjb21wb25lbnQ9e05ld3NGZWVkfS8+XG4gKiAgICAgPC9Sb3V0ZT5cbiAqICAgKVxuICpcbiAqIE5vdGU6IFRoaXMgbWV0aG9kIGlzIGF1dG9tYXRpY2FsbHkgdXNlZCB3aGVuIHlvdSBwcm92aWRlIDxSb3V0ZT4gY2hpbGRyZW5cbiAqIHRvIGEgPFJvdXRlcj4gY29tcG9uZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihjaGlsZHJlbiwgcGFyZW50Um91dGUpIHtcbiAgdmFyIHJvdXRlcyA9IFtdO1xuXG4gIF9yZWFjdDIuZGVmYXVsdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCBmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgIGlmIChfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIENvbXBvbmVudCBjbGFzc2VzIG1heSBoYXZlIGEgc3RhdGljIGNyZWF0ZSogbWV0aG9kLlxuICAgICAgaWYgKGVsZW1lbnQudHlwZS5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpIHtcbiAgICAgICAgdmFyIHJvdXRlID0gZWxlbWVudC50eXBlLmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSk7XG5cbiAgICAgICAgaWYgKHJvdXRlKSByb3V0ZXMucHVzaChyb3V0ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByb3V0ZXMucHVzaChjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlcztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHJvdXRlcyBmcm9tIHRoZSBnaXZlbiBvYmplY3Qgd2hpY2hcbiAqIG1heSBiZSBhIEpTWCByb3V0ZSwgYSBwbGFpbiBvYmplY3Qgcm91dGUsIG9yIGFuIGFycmF5IG9mIGVpdGhlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUm91dGVzKHJvdXRlcykge1xuICBpZiAoaXNSZWFjdENoaWxkcmVuKHJvdXRlcykpIHtcbiAgICByb3V0ZXMgPSBjcmVhdGVSb3V0ZXNGcm9tUmVhY3RDaGlsZHJlbihyb3V0ZXMpO1xuICB9IGVsc2UgaWYgKHJvdXRlcyAmJiAhQXJyYXkuaXNBcnJheShyb3V0ZXMpKSB7XG4gICAgcm91dGVzID0gW3JvdXRlc107XG4gIH1cblxuICByZXR1cm4gcm91dGVzO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZVV0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5yb3V0ZXIgPSBleHBvcnRzLnJvdXRlcyA9IGV4cG9ydHMucm91dGUgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudCA9IGV4cG9ydHMubG9jYXRpb24gPSBleHBvcnRzLmhpc3RvcnkgPSBleHBvcnRzLmZhbHN5ID0gZXhwb3J0cy5sb2NhdGlvblNoYXBlID0gZXhwb3J0cy5yb3V0ZXJTaGFwZSA9IHVuZGVmaW5lZDtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbnZhciBJbnRlcm5hbFByb3BUeXBlcyA9IF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKF9JbnRlcm5hbFByb3BUeXBlcyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkKG9iaikgeyBpZiAob2JqICYmIG9iai5fX2VzTW9kdWxlKSB7IHJldHVybiBvYmo7IH0gZWxzZSB7IHZhciBuZXdPYmogPSB7fTsgaWYgKG9iaiAhPSBudWxsKSB7IGZvciAodmFyIGtleSBpbiBvYmopIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIG5ld09ialtrZXldID0gb2JqW2tleV07IH0gfSBuZXdPYmouZGVmYXVsdCA9IG9iajsgcmV0dXJuIG5ld09iajsgfSB9XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmdW5jID0gX3JlYWN0LlByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9yZWFjdC5Qcm9wVHlwZXMub2JqZWN0O1xudmFyIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZTtcbnZhciBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbnZhciByb3V0ZXJTaGFwZSA9IGV4cG9ydHMucm91dGVyU2hhcGUgPSBzaGFwZSh7XG4gIHB1c2g6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcmVwbGFjZTogZnVuYy5pc1JlcXVpcmVkLFxuICBnbzogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0JhY2s6IGZ1bmMuaXNSZXF1aXJlZCxcbiAgZ29Gb3J3YXJkOiBmdW5jLmlzUmVxdWlyZWQsXG4gIHNldFJvdXRlTGVhdmVIb29rOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGlzQWN0aXZlOiBmdW5jLmlzUmVxdWlyZWRcbn0pO1xuXG52YXIgbG9jYXRpb25TaGFwZSA9IGV4cG9ydHMubG9jYXRpb25TaGFwZSA9IHNoYXBlKHtcbiAgcGF0aG5hbWU6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzZWFyY2g6IHN0cmluZy5pc1JlcXVpcmVkLFxuICBzdGF0ZTogb2JqZWN0LFxuICBhY3Rpb246IHN0cmluZy5pc1JlcXVpcmVkLFxuICBrZXk6IHN0cmluZ1xufSk7XG5cbi8vIERlcHJlY2F0ZWQgc3R1ZmYgYmVsb3c6XG5cbnZhciBmYWxzeSA9IGV4cG9ydHMuZmFsc3kgPSBJbnRlcm5hbFByb3BUeXBlcy5mYWxzeTtcbnZhciBoaXN0b3J5ID0gZXhwb3J0cy5oaXN0b3J5ID0gSW50ZXJuYWxQcm9wVHlwZXMuaGlzdG9yeTtcbnZhciBsb2NhdGlvbiA9IGV4cG9ydHMubG9jYXRpb24gPSBsb2NhdGlvblNoYXBlO1xudmFyIGNvbXBvbmVudCA9IGV4cG9ydHMuY29tcG9uZW50ID0gSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50O1xudmFyIGNvbXBvbmVudHMgPSBleHBvcnRzLmNvbXBvbmVudHMgPSBJbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzO1xudmFyIHJvdXRlID0gZXhwb3J0cy5yb3V0ZSA9IEludGVybmFsUHJvcFR5cGVzLnJvdXRlO1xudmFyIHJvdXRlcyA9IGV4cG9ydHMucm91dGVzID0gSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzO1xudmFyIHJvdXRlciA9IGV4cG9ydHMucm91dGVyID0gcm91dGVyU2hhcGU7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlcHJlY2F0ZVByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsIG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgcmV0dXJuIHByb3BUeXBlLmFwcGx5KHVuZGVmaW5lZCwgYXJndW1lbnRzKTtcbiAgICAgIH07XG4gICAgfTtcblxuICAgIHZhciBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlcHJlY2F0ZVByb3BUeXBlKHByb3BUeXBlLCAnVGhpcyBwcm9wIHR5cGUgaXMgbm90IGludGVuZGVkIGZvciBleHRlcm5hbCB1c2UsIGFuZCB3YXMgcHJldmlvdXNseSBleHBvcnRlZCBieSBtaXN0YWtlLiBUaGVzZSBpbnRlcm5hbCBwcm9wIHR5cGVzIGFyZSBkZXByZWNhdGVkIGZvciBleHRlcm5hbCB1c2UsIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLicpO1xuICAgIH07XG5cbiAgICB2YXIgZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlID0gZnVuY3Rpb24gZGVwcmVjYXRlUmVuYW1lZFByb3BUeXBlKHByb3BUeXBlLCBuYW1lKSB7XG4gICAgICByZXR1cm4gZGVwcmVjYXRlUHJvcFR5cGUocHJvcFR5cGUsICdUaGUgYCcgKyBuYW1lICsgJ2AgcHJvcCB0eXBlIGlzIG5vdyBleHBvcnRlZCBhcyBgJyArIG5hbWUgKyAnU2hhcGVgIHRvIGF2b2lkIG5hbWUgY29uZmxpY3RzLiBUaGlzIGV4cG9ydCBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgaW4gYSBsYXRlciB2ZXJzaW9uLicpO1xuICAgIH07XG5cbiAgICBleHBvcnRzLmZhbHN5ID0gZmFsc3kgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKGZhbHN5KTtcbiAgICBleHBvcnRzLmhpc3RvcnkgPSBoaXN0b3J5ID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShoaXN0b3J5KTtcbiAgICBleHBvcnRzLmNvbXBvbmVudCA9IGNvbXBvbmVudCA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUoY29tcG9uZW50KTtcbiAgICBleHBvcnRzLmNvbXBvbmVudHMgPSBjb21wb25lbnRzID0gZGVwcmVjYXRlSW50ZXJuYWxQcm9wVHlwZShjb21wb25lbnRzKTtcbiAgICBleHBvcnRzLnJvdXRlID0gcm91dGUgPSBkZXByZWNhdGVJbnRlcm5hbFByb3BUeXBlKHJvdXRlKTtcbiAgICBleHBvcnRzLnJvdXRlcyA9IHJvdXRlcyA9IGRlcHJlY2F0ZUludGVybmFsUHJvcFR5cGUocm91dGVzKTtcblxuICAgIGV4cG9ydHMubG9jYXRpb24gPSBsb2NhdGlvbiA9IGRlcHJlY2F0ZVJlbmFtZWRQcm9wVHlwZShsb2NhdGlvbiwgJ2xvY2F0aW9uJyk7XG4gICAgZXhwb3J0cy5yb3V0ZXIgPSByb3V0ZXIgPSBkZXByZWNhdGVSZW5hbWVkUHJvcFR5cGUocm91dGVyLCAncm91dGVyJyk7XG4gIH0pKCk7XG59XG5cbnZhciBkZWZhdWx0RXhwb3J0ID0ge1xuICBmYWxzeTogZmFsc3ksXG4gIGhpc3Rvcnk6IGhpc3RvcnksXG4gIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgY29tcG9uZW50OiBjb21wb25lbnQsXG4gIGNvbXBvbmVudHM6IGNvbXBvbmVudHMsXG4gIHJvdXRlOiByb3V0ZSxcbiAgLy8gRm9yIHNvbWUgcmVhc29uLCByb3V0ZXMgd2FzIG5ldmVyIGhlcmUuXG4gIHJvdXRlcjogcm91dGVyXG59O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICBkZWZhdWx0RXhwb3J0ID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShkZWZhdWx0RXhwb3J0LCAnVGhlIGRlZmF1bHQgZXhwb3J0IGZyb20gYHJlYWN0LXJvdXRlci9saWIvUHJvcFR5cGVzYCBpcyBkZXByZWNhdGVkLiBQbGVhc2UgdXNlIHRoZSBuYW1lZCBleHBvcnRzIGluc3RlYWQuJyk7XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRFeHBvcnQ7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1Byb3BUeXBlcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSB1bmRlZmluZWQ7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBjYW5Vc2VNZW1icmFuZSA9IGV4cG9ydHMuY2FuVXNlTWVtYnJhbmUgPSBmYWxzZTtcblxuLy8gTm8tb3AgYnkgZGVmYXVsdC5cbnZhciBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gZnVuY3Rpb24gZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyhvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdDtcbn07XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHRyeSB7XG4gICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ3gnLCB7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSkueCkge1xuICAgICAgZXhwb3J0cy5jYW5Vc2VNZW1icmFuZSA9IGNhblVzZU1lbWJyYW5lID0gdHJ1ZTtcbiAgICB9XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cbiAgfSBjYXRjaCAoZSkge31cbiAgLyogZXNsaW50LWVuYWJsZSBuby1lbXB0eSAqL1xuXG4gIGlmIChjYW5Vc2VNZW1icmFuZSkge1xuICAgIGRlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSBmdW5jdGlvbiBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzKG9iamVjdCwgbWVzc2FnZSkge1xuICAgICAgLy8gV3JhcCB0aGUgZGVwcmVjYXRlZCBvYmplY3QgaW4gYSBtZW1icmFuZSB0byB3YXJuIG9uIHByb3BlcnR5IGFjY2Vzcy5cbiAgICAgIHZhciBtZW1icmFuZSA9IHt9O1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwcm9wKSB7XG4gICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcCkpIHtcbiAgICAgICAgICByZXR1cm4gJ2NvbnRpbnVlJztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqZWN0W3Byb3BdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgLy8gQ2FuJ3QgdXNlIGZhdCBhcnJvdyBoZXJlIGJlY2F1c2Ugb2YgdXNlIG9mIGFyZ3VtZW50cyBiZWxvdy5cbiAgICAgICAgICBtZW1icmFuZVtwcm9wXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF0uYXBwbHkob2JqZWN0LCBhcmd1bWVudHMpO1xuICAgICAgICAgIH07XG4gICAgICAgICAgcmV0dXJuICdjb250aW51ZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGVzZSBwcm9wZXJ0aWVzIGFyZSBub24tZW51bWVyYWJsZSB0byBwcmV2ZW50IFJlYWN0IGRldiB0b29scyBmcm9tXG4gICAgICAgIC8vIHNlZWluZyB0aGVtIGFuZCBjYXVzaW5nIHNwdXJpb3VzIHdhcm5pbmdzIHdoZW4gYWNjZXNzaW5nIHRoZW0uIEluXG4gICAgICAgIC8vIHByaW5jaXBsZSB0aGlzIGNvdWxkIGJlIGRvbmUgd2l0aCBhIHByb3h5LCBidXQgc3VwcG9ydCBmb3IgdGhlXG4gICAgICAgIC8vIG93bktleXMgdHJhcCBvbiBwcm94aWVzIGlzIG5vdCB1bml2ZXJzYWwsIGV2ZW4gYW1vbmcgYnJvd3NlcnMgdGhhdFxuICAgICAgICAvLyBvdGhlcndpc2Ugc3VwcG9ydCBwcm94aWVzLlxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobWVtYnJhbmUsIHByb3AsIHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCBtZXNzYWdlKSA6IHZvaWQgMDtcbiAgICAgICAgICAgIHJldHVybiBvYmplY3RbcHJvcF07XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIGZvciAodmFyIHByb3AgaW4gb2JqZWN0KSB7XG4gICAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09ICdjb250aW51ZScpIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVtYnJhbmU7XG4gICAgfTtcbiAgfVxufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBkZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5kZWZhdWx0ID0gcm91dGVyV2FybmluZztcbmV4cG9ydHMuX3Jlc2V0V2FybmVkID0gX3Jlc2V0V2FybmVkO1xuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIHdhcm5lZCA9IHt9O1xuXG5mdW5jdGlvbiByb3V0ZXJXYXJuaW5nKGZhbHNlVG9XYXJuLCBtZXNzYWdlKSB7XG4gIC8vIE9ubHkgaXNzdWUgZGVwcmVjYXRpb24gd2FybmluZ3Mgb25jZS5cbiAgaWYgKG1lc3NhZ2UuaW5kZXhPZignZGVwcmVjYXRlZCcpICE9PSAtMSkge1xuICAgIGlmICh3YXJuZWRbbWVzc2FnZV0pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YXJuZWRbbWVzc2FnZV0gPSB0cnVlO1xuICB9XG5cbiAgbWVzc2FnZSA9ICdbcmVhY3Qtcm91dGVyXSAnICsgbWVzc2FnZTtcblxuICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAyID8gX2xlbiAtIDIgOiAwKSwgX2tleSA9IDI7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICBhcmdzW19rZXkgLSAyXSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIF93YXJuaW5nMi5kZWZhdWx0LmFwcGx5KHVuZGVmaW5lZCwgW2ZhbHNlVG9XYXJuLCBtZXNzYWdlXS5jb25jYXQoYXJncykpO1xufVxuXG5mdW5jdGlvbiBfcmVzZXRXYXJuZWQoKSB7XG4gIHdhcm5lZCA9IHt9O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9yb3V0ZXJXYXJuaW5nLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNC0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFNpbWlsYXIgdG8gaW52YXJpYW50IGJ1dCBvbmx5IGxvZ3MgYSB3YXJuaW5nIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gbG9nIGlzc3VlcyBpbiBkZXZlbG9wbWVudCBlbnZpcm9ubWVudHMgaW4gY3JpdGljYWxcbiAqIHBhdGhzLiBSZW1vdmluZyB0aGUgbG9nZ2luZyBjb2RlIGZvciBwcm9kdWN0aW9uIGVudmlyb25tZW50cyB3aWxsIGtlZXAgdGhlXG4gKiBzYW1lIGxvZ2ljIGFuZCBmb2xsb3cgdGhlIHNhbWUgY29kZSBwYXRocy5cbiAqL1xuXG52YXIgd2FybmluZyA9IGZ1bmN0aW9uKCkge307XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHdhcm5pbmcgPSBmdW5jdGlvbihjb25kaXRpb24sIGZvcm1hdCwgYXJncykge1xuICAgIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuID4gMiA/IGxlbiAtIDIgOiAwKTtcbiAgICBmb3IgKHZhciBrZXkgPSAyOyBrZXkgPCBsZW47IGtleSsrKSB7XG4gICAgICBhcmdzW2tleSAtIDJdID0gYXJndW1lbnRzW2tleV07XG4gICAgfVxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArXG4gICAgICAgICdtZXNzYWdlIGFyZ3VtZW50J1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoZm9ybWF0Lmxlbmd0aCA8IDEwIHx8ICgvXltzXFxXXSokLykudGVzdChmb3JtYXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUaGUgd2FybmluZyBmb3JtYXQgc2hvdWxkIGJlIGFibGUgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyAnICtcbiAgICAgICAgJ3dhcm5pbmcuIFBsZWFzZSwgdXNlIGEgbW9yZSBkZXNjcmlwdGl2ZSBmb3JtYXQgdGhhbjogJyArIGZvcm1hdFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAoIWNvbmRpdGlvbikge1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIHZhciBtZXNzYWdlID0gJ1dhcm5pbmc6ICcgK1xuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIGFyZ3NbYXJnSW5kZXgrK107XG4gICAgICAgIH0pO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zb2xlLmVycm9yKG1lc3NhZ2UpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgLy8gVGhpcyBlcnJvciB3YXMgdGhyb3duIGFzIGEgY29udmVuaWVuY2Ugc28gdGhhdCB5b3UgY2FuIHVzZSB0aGlzIHN0YWNrXG4gICAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoKHgpIHt9XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9+L3dhcm5pbmcvYnJvd3Nlci5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbmV4cG9ydHMucm91dGVzID0gZXhwb3J0cy5yb3V0ZSA9IGV4cG9ydHMuY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50ID0gZXhwb3J0cy5oaXN0b3J5ID0gdW5kZWZpbmVkO1xuZXhwb3J0cy5mYWxzeSA9IGZhbHN5O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIGZ1bmMgPSBfcmVhY3QuUHJvcFR5cGVzLmZ1bmM7XG52YXIgb2JqZWN0ID0gX3JlYWN0LlByb3BUeXBlcy5vYmplY3Q7XG52YXIgYXJyYXlPZiA9IF9yZWFjdC5Qcm9wVHlwZXMuYXJyYXlPZjtcbnZhciBvbmVPZlR5cGUgPSBfcmVhY3QuUHJvcFR5cGVzLm9uZU9mVHlwZTtcbnZhciBlbGVtZW50ID0gX3JlYWN0LlByb3BUeXBlcy5lbGVtZW50O1xudmFyIHNoYXBlID0gX3JlYWN0LlByb3BUeXBlcy5zaGFwZTtcbnZhciBzdHJpbmcgPSBfcmVhY3QuUHJvcFR5cGVzLnN0cmluZztcbmZ1bmN0aW9uIGZhbHN5KHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSkge1xuICBpZiAocHJvcHNbcHJvcE5hbWVdKSByZXR1cm4gbmV3IEVycm9yKCc8JyArIGNvbXBvbmVudE5hbWUgKyAnPiBzaG91bGQgbm90IGhhdmUgYSBcIicgKyBwcm9wTmFtZSArICdcIiBwcm9wJyk7XG59XG5cbnZhciBoaXN0b3J5ID0gZXhwb3J0cy5oaXN0b3J5ID0gc2hhcGUoe1xuICBsaXN0ZW46IGZ1bmMuaXNSZXF1aXJlZCxcbiAgcHVzaDogZnVuYy5pc1JlcXVpcmVkLFxuICByZXBsYWNlOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvOiBmdW5jLmlzUmVxdWlyZWQsXG4gIGdvQmFjazogZnVuYy5pc1JlcXVpcmVkLFxuICBnb0ZvcndhcmQ6IGZ1bmMuaXNSZXF1aXJlZFxufSk7XG5cbnZhciBjb21wb25lbnQgPSBleHBvcnRzLmNvbXBvbmVudCA9IG9uZU9mVHlwZShbZnVuYywgc3RyaW5nXSk7XG52YXIgY29tcG9uZW50cyA9IGV4cG9ydHMuY29tcG9uZW50cyA9IG9uZU9mVHlwZShbY29tcG9uZW50LCBvYmplY3RdKTtcbnZhciByb3V0ZSA9IGV4cG9ydHMucm91dGUgPSBvbmVPZlR5cGUoW29iamVjdCwgZWxlbWVudF0pO1xudmFyIHJvdXRlcyA9IGV4cG9ydHMucm91dGVzID0gb25lT2ZUeXBlKFtyb3V0ZSwgYXJyYXlPZihyb3V0ZSldKTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvSW50ZXJuYWxQcm9wVHlwZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmNvbXBpbGVQYXR0ZXJuID0gY29tcGlsZVBhdHRlcm47XG5leHBvcnRzLm1hdGNoUGF0dGVybiA9IG1hdGNoUGF0dGVybjtcbmV4cG9ydHMuZ2V0UGFyYW1OYW1lcyA9IGdldFBhcmFtTmFtZXM7XG5leHBvcnRzLmdldFBhcmFtcyA9IGdldFBhcmFtcztcbmV4cG9ydHMuZm9ybWF0UGF0dGVybiA9IGZvcm1hdFBhdHRlcm47XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGVzY2FwZVJlZ0V4cChzdHJpbmcpIHtcbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bLiorP14ke30oKXxbXFxdXFxcXF0vZywgJ1xcXFwkJicpO1xufVxuXG5mdW5jdGlvbiBfY29tcGlsZVBhdHRlcm4ocGF0dGVybikge1xuICB2YXIgcmVnZXhwU291cmNlID0gJyc7XG4gIHZhciBwYXJhbU5hbWVzID0gW107XG4gIHZhciB0b2tlbnMgPSBbXTtcblxuICB2YXIgbWF0Y2ggPSB2b2lkIDAsXG4gICAgICBsYXN0SW5kZXggPSAwLFxuICAgICAgbWF0Y2hlciA9IC86KFthLXpBLVpfJF1bYS16QS1aMC05XyRdKil8XFwqXFwqfFxcKnxcXCh8XFwpL2c7XG4gIHdoaWxlIChtYXRjaCA9IG1hdGNoZXIuZXhlYyhwYXR0ZXJuKSkge1xuICAgIGlmIChtYXRjaC5pbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICB0b2tlbnMucHVzaChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgbWF0Y2guaW5kZXgpKTtcbiAgICAgIHJlZ2V4cFNvdXJjZSArPSBlc2NhcGVSZWdFeHAocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIG1hdGNoLmluZGV4KSk7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoWzFdKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyhbXi9dKyknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKG1hdGNoWzFdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoWzBdID09PSAnKionKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyguKiknO1xuICAgICAgcGFyYW1OYW1lcy5wdXNoKCdzcGxhdCcpO1xuICAgIH0gZWxzZSBpZiAobWF0Y2hbMF0gPT09ICcqJykge1xuICAgICAgcmVnZXhwU291cmNlICs9ICcoLio/KSc7XG4gICAgICBwYXJhbU5hbWVzLnB1c2goJ3NwbGF0Jyk7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyg/Oic7XG4gICAgfSBlbHNlIGlmIChtYXRjaFswXSA9PT0gJyknKSB7XG4gICAgICByZWdleHBTb3VyY2UgKz0gJyk/JztcbiAgICB9XG5cbiAgICB0b2tlbnMucHVzaChtYXRjaFswXSk7XG5cbiAgICBsYXN0SW5kZXggPSBtYXRjaGVyLmxhc3RJbmRleDtcbiAgfVxuXG4gIGlmIChsYXN0SW5kZXggIT09IHBhdHRlcm4ubGVuZ3RoKSB7XG4gICAgdG9rZW5zLnB1c2gocGF0dGVybi5zbGljZShsYXN0SW5kZXgsIHBhdHRlcm4ubGVuZ3RoKSk7XG4gICAgcmVnZXhwU291cmNlICs9IGVzY2FwZVJlZ0V4cChwYXR0ZXJuLnNsaWNlKGxhc3RJbmRleCwgcGF0dGVybi5sZW5ndGgpKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgcGF0dGVybjogcGF0dGVybixcbiAgICByZWdleHBTb3VyY2U6IHJlZ2V4cFNvdXJjZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHRva2VuczogdG9rZW5zXG4gIH07XG59XG5cbnZhciBDb21waWxlZFBhdHRlcm5zQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG5mdW5jdGlvbiBjb21waWxlUGF0dGVybihwYXR0ZXJuKSB7XG4gIGlmICghQ29tcGlsZWRQYXR0ZXJuc0NhY2hlW3BhdHRlcm5dKSBDb21waWxlZFBhdHRlcm5zQ2FjaGVbcGF0dGVybl0gPSBfY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgcmV0dXJuIENvbXBpbGVkUGF0dGVybnNDYWNoZVtwYXR0ZXJuXTtcbn1cblxuLyoqXG4gKiBBdHRlbXB0cyB0byBtYXRjaCBhIHBhdHRlcm4gb24gdGhlIGdpdmVuIHBhdGhuYW1lLiBQYXR0ZXJucyBtYXkgdXNlXG4gKiB0aGUgZm9sbG93aW5nIHNwZWNpYWwgY2hhcmFjdGVyczpcbiAqXG4gKiAtIDpwYXJhbU5hbWUgICAgIE1hdGNoZXMgYSBVUkwgc2VnbWVudCB1cCB0byB0aGUgbmV4dCAvLCA/LCBvciAjLiBUaGVcbiAqICAgICAgICAgICAgICAgICAgY2FwdHVyZWQgc3RyaW5nIGlzIGNvbnNpZGVyZWQgYSBcInBhcmFtXCJcbiAqIC0gKCkgICAgICAgICAgICAgV3JhcHMgYSBzZWdtZW50IG9mIHRoZSBVUkwgdGhhdCBpcyBvcHRpb25hbFxuICogLSAqICAgICAgICAgICAgICBDb25zdW1lcyAobm9uLWdyZWVkeSkgYWxsIGNoYXJhY3RlcnMgdXAgdG8gdGhlIG5leHRcbiAqICAgICAgICAgICAgICAgICAgY2hhcmFjdGVyIGluIHRoZSBwYXR0ZXJuLCBvciB0byB0aGUgZW5kIG9mIHRoZSBVUkwgaWZcbiAqICAgICAgICAgICAgICAgICAgdGhlcmUgaXMgbm9uZVxuICogLSAqKiAgICAgICAgICAgICBDb25zdW1lcyAoZ3JlZWR5KSBhbGwgY2hhcmFjdGVycyB1cCB0byB0aGUgbmV4dCBjaGFyYWN0ZXJcbiAqICAgICAgICAgICAgICAgICAgaW4gdGhlIHBhdHRlcm4sIG9yIHRvIHRoZSBlbmQgb2YgdGhlIFVSTCBpZiB0aGVyZSBpcyBub25lXG4gKlxuICogIFRoZSBmdW5jdGlvbiBjYWxscyBjYWxsYmFjayhlcnJvciwgbWF0Y2hlZCkgd2hlbiBmaW5pc2hlZC5cbiAqIFRoZSByZXR1cm4gdmFsdWUgaXMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuICpcbiAqIC0gcmVtYWluaW5nUGF0aG5hbWVcbiAqIC0gcGFyYW1OYW1lc1xuICogLSBwYXJhbVZhbHVlc1xuICovXG5mdW5jdGlvbiBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpIHtcbiAgLy8gRW5zdXJlIHBhdHRlcm4gc3RhcnRzIHdpdGggbGVhZGluZyBzbGFzaCBmb3IgY29uc2lzdGVuY3kgd2l0aCBwYXRobmFtZS5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApICE9PSAnLycpIHtcbiAgICBwYXR0ZXJuID0gJy8nICsgcGF0dGVybjtcbiAgfVxuXG4gIHZhciBfY29tcGlsZVBhdHRlcm4yID0gY29tcGlsZVBhdHRlcm4ocGF0dGVybik7XG5cbiAgdmFyIHJlZ2V4cFNvdXJjZSA9IF9jb21waWxlUGF0dGVybjIucmVnZXhwU291cmNlO1xuICB2YXIgcGFyYW1OYW1lcyA9IF9jb21waWxlUGF0dGVybjIucGFyYW1OYW1lcztcbiAgdmFyIHRva2VucyA9IF9jb21waWxlUGF0dGVybjIudG9rZW5zO1xuXG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KHBhdHRlcm4ubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHJlZ2V4cFNvdXJjZSArPSAnLz8nOyAvLyBBbGxvdyBvcHRpb25hbCBwYXRoIHNlcGFyYXRvciBhdCBlbmQuXG4gIH1cblxuICAvLyBTcGVjaWFsLWNhc2UgcGF0dGVybnMgbGlrZSAnKicgZm9yIGNhdGNoLWFsbCByb3V0ZXMuXG4gIGlmICh0b2tlbnNbdG9rZW5zLmxlbmd0aCAtIDFdID09PSAnKicpIHtcbiAgICByZWdleHBTb3VyY2UgKz0gJyQnO1xuICB9XG5cbiAgdmFyIG1hdGNoID0gcGF0aG5hbWUubWF0Y2gobmV3IFJlZ0V4cCgnXicgKyByZWdleHBTb3VyY2UsICdpJykpO1xuICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1hdGNoZWRQYXRoID0gbWF0Y2hbMF07XG4gIHZhciByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cihtYXRjaGVkUGF0aC5sZW5ndGgpO1xuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSkge1xuICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggZW5kcyBhdCBhIHBhdGggc2VwYXJhdG9yLCBpZiB3ZSBkaWRuJ3QgbWF0Y2hcbiAgICAvLyB0aGUgZnVsbCBwYXRoLCBzbyBhbnkgcmVtYWluaW5nIHBhdGhuYW1lIGlzIGEgbmV3IHBhdGggc2VnbWVudC5cbiAgICBpZiAobWF0Y2hlZFBhdGguY2hhckF0KG1hdGNoZWRQYXRoLmxlbmd0aCAtIDEpICE9PSAnLycpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIHBhdGhuYW1lLCB0cmVhdCB0aGUgcGF0aCBzZXBhcmF0b3IgYXMgcGFydCBvZlxuICAgIC8vIHRoZSByZW1haW5pbmcgcGF0aG5hbWUgZm9yIHByb3Blcmx5IGNvbnRpbnVpbmcgdGhlIG1hdGNoLlxuICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gJy8nICsgcmVtYWluaW5nUGF0aG5hbWU7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHJlbWFpbmluZ1BhdGhuYW1lOiByZW1haW5pbmdQYXRobmFtZSxcbiAgICBwYXJhbU5hbWVzOiBwYXJhbU5hbWVzLFxuICAgIHBhcmFtVmFsdWVzOiBtYXRjaC5zbGljZSgxKS5tYXAoZnVuY3Rpb24gKHYpIHtcbiAgICAgIHJldHVybiB2ICYmIGRlY29kZVVSSUNvbXBvbmVudCh2KTtcbiAgICB9KVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRQYXJhbU5hbWVzKHBhdHRlcm4pIHtcbiAgcmV0dXJuIGNvbXBpbGVQYXR0ZXJuKHBhdHRlcm4pLnBhcmFtTmFtZXM7XG59XG5cbmZ1bmN0aW9uIGdldFBhcmFtcyhwYXR0ZXJuLCBwYXRobmFtZSkge1xuICB2YXIgbWF0Y2ggPSBtYXRjaFBhdHRlcm4ocGF0dGVybiwgcGF0aG5hbWUpO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgcGFyYW1OYW1lcyA9IG1hdGNoLnBhcmFtTmFtZXM7XG4gIHZhciBwYXJhbVZhbHVlcyA9IG1hdGNoLnBhcmFtVmFsdWVzO1xuXG4gIHZhciBwYXJhbXMgPSB7fTtcblxuICBwYXJhbU5hbWVzLmZvckVhY2goZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICBwYXJhbXNbcGFyYW1OYW1lXSA9IHBhcmFtVmFsdWVzW2luZGV4XTtcbiAgfSk7XG5cbiAgcmV0dXJuIHBhcmFtcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgdmVyc2lvbiBvZiB0aGUgZ2l2ZW4gcGF0dGVybiB3aXRoIHBhcmFtcyBpbnRlcnBvbGF0ZWQuIFRocm93c1xuICogaWYgdGhlcmUgaXMgYSBkeW5hbWljIHNlZ21lbnQgb2YgdGhlIHBhdHRlcm4gZm9yIHdoaWNoIHRoZXJlIGlzIG5vIHBhcmFtLlxuICovXG5mdW5jdGlvbiBmb3JtYXRQYXR0ZXJuKHBhdHRlcm4sIHBhcmFtcykge1xuICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG5cbiAgdmFyIF9jb21waWxlUGF0dGVybjMgPSBjb21waWxlUGF0dGVybihwYXR0ZXJuKTtcblxuICB2YXIgdG9rZW5zID0gX2NvbXBpbGVQYXR0ZXJuMy50b2tlbnM7XG5cbiAgdmFyIHBhcmVuQ291bnQgPSAwLFxuICAgICAgcGF0aG5hbWUgPSAnJyxcbiAgICAgIHNwbGF0SW5kZXggPSAwO1xuXG4gIHZhciB0b2tlbiA9IHZvaWQgMCxcbiAgICAgIHBhcmFtTmFtZSA9IHZvaWQgMCxcbiAgICAgIHBhcmFtVmFsdWUgPSB2b2lkIDA7XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgIGlmICh0b2tlbiA9PT0gJyonIHx8IHRva2VuID09PSAnKionKSB7XG4gICAgICBwYXJhbVZhbHVlID0gQXJyYXkuaXNBcnJheShwYXJhbXMuc3BsYXQpID8gcGFyYW1zLnNwbGF0W3NwbGF0SW5kZXgrK10gOiBwYXJhbXMuc3BsYXQ7XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIHNwbGF0ICMlcyBmb3IgcGF0aCBcIiVzXCInLCBzcGxhdEluZGV4LCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSShwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKCcpIHtcbiAgICAgIHBhcmVuQ291bnQgKz0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuID09PSAnKScpIHtcbiAgICAgIHBhcmVuQ291bnQgLT0gMTtcbiAgICB9IGVsc2UgaWYgKHRva2VuLmNoYXJBdCgwKSA9PT0gJzonKSB7XG4gICAgICBwYXJhbU5hbWUgPSB0b2tlbi5zdWJzdHJpbmcoMSk7XG4gICAgICBwYXJhbVZhbHVlID0gcGFyYW1zW3BhcmFtTmFtZV07XG5cbiAgICAgICEocGFyYW1WYWx1ZSAhPSBudWxsIHx8IHBhcmVuQ291bnQgPiAwKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdNaXNzaW5nIFwiJXNcIiBwYXJhbWV0ZXIgZm9yIHBhdGggXCIlc1wiJywgcGFyYW1OYW1lLCBwYXR0ZXJuKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICAgIGlmIChwYXJhbVZhbHVlICE9IG51bGwpIHBhdGhuYW1lICs9IGVuY29kZVVSSUNvbXBvbmVudChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0aG5hbWUgKz0gdG9rZW47XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhdGhuYW1lLnJlcGxhY2UoL1xcLysvZywgJy8nKTtcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvUGF0dGVyblV0aWxzLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxMy0yMDE1LCBGYWNlYm9vaywgSW5jLlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBCU0Qtc3R5bGUgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS4gQW4gYWRkaXRpb25hbCBncmFudFxuICogb2YgcGF0ZW50IHJpZ2h0cyBjYW4gYmUgZm91bmQgaW4gdGhlIFBBVEVOVFMgZmlsZSBpbiB0aGUgc2FtZSBkaXJlY3RvcnkuXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgaW52YXJpYW50ID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YXJpYW50IHJlcXVpcmVzIGFuIGVycm9yIG1lc3NhZ2UgYXJndW1lbnQnKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWNvbmRpdGlvbikge1xuICAgIHZhciBlcnJvcjtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICAnTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArXG4gICAgICAgICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLidcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBhcmdzID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICAgIGVycm9yID0gbmV3IEVycm9yKFxuICAgICAgICBmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24oKSB7IHJldHVybiBhcmdzW2FyZ0luZGV4KytdOyB9KVxuICAgICAgKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGludmFyaWFudDtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL34vaW52YXJpYW50L2Jyb3dzZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfY3JlYXRlSGFzaEhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUhhc2hIaXN0b3J5KTtcblxudmFyIF91c2VRdWVyaWVzID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvdXNlUXVlcmllcycpO1xuXG52YXIgX3VzZVF1ZXJpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlUXVlcmllcyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlciA9IHJlcXVpcmUoJy4vY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXInKTtcblxudmFyIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcik7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfUm91dGVVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVVdGlscycpO1xuXG52YXIgX1JvdXRlclV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZXJVdGlscycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMob2JqLCBrZXlzKSB7IHZhciB0YXJnZXQgPSB7fTsgZm9yICh2YXIgaSBpbiBvYmopIHsgaWYgKGtleXMuaW5kZXhPZihpKSA+PSAwKSBjb250aW51ZTsgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBpKSkgY29udGludWU7IHRhcmdldFtpXSA9IG9ialtpXTsgfSByZXR1cm4gdGFyZ2V0OyB9XG5cbmZ1bmN0aW9uIGlzRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICByZXR1cm4gIWhpc3RvcnkgfHwgIWhpc3RvcnkuX192Ml9jb21wYXRpYmxlX187XG59XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbmZ1bmN0aW9uIGlzVW5zdXBwb3J0ZWRIaXN0b3J5KGhpc3RvcnkpIHtcbiAgLy8gdjMgaGlzdG9yaWVzIGV4cG9zZSBnZXRDdXJyZW50TG9jYXRpb24sIGJ1dCBhcmVuJ3QgY3VycmVudGx5IHN1cHBvcnRlZC5cbiAgcmV0dXJuIGhpc3RvcnkgJiYgaGlzdG9yeS5nZXRDdXJyZW50TG9jYXRpb247XG59XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJvdXRlcj4gaXMgYSBoaWdoLWxldmVsIEFQSSBmb3IgYXV0b21hdGljYWxseSBzZXR0aW5nIHVwXG4gKiBhIHJvdXRlciB0aGF0IHJlbmRlcnMgYSA8Um91dGVyQ29udGV4dD4gd2l0aCBhbGwgdGhlIHByb3BzXG4gKiBpdCBuZWVkcyBlYWNoIHRpbWUgdGhlIFVSTCBjaGFuZ2VzLlxuICovXG5cbnZhciBSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ1JvdXRlcicsXG5cblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5yb3V0ZXMsXG4gICAgcm91dGVzOiBfSW50ZXJuYWxQcm9wVHlwZXMucm91dGVzLCAvLyBhbGlhcyBmb3IgY2hpbGRyZW5cbiAgICByZW5kZXI6IGZ1bmMsXG4gICAgY3JlYXRlRWxlbWVudDogZnVuYyxcbiAgICBvbkVycm9yOiBmdW5jLFxuICAgIG9uVXBkYXRlOiBmdW5jLFxuXG4gICAgLy8gRGVwcmVjYXRlZDpcbiAgICBwYXJzZVF1ZXJ5U3RyaW5nOiBmdW5jLFxuICAgIHN0cmluZ2lmeVF1ZXJ5OiBmdW5jLFxuXG4gICAgLy8gUFJJVkFURTogRm9yIGNsaWVudC1zaWRlIHJlaHlkcmF0aW9uIG9mIHNlcnZlciBtYXRjaC5cbiAgICBtYXRjaENvbnRleHQ6IG9iamVjdFxuICB9LFxuXG4gIGdldERlZmF1bHRQcm9wczogZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3BzKCkge1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcihwcm9wcykge1xuICAgICAgICByZXR1cm4gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnQoX1JvdXRlckNvbnRleHQyLmRlZmF1bHQsIHByb3BzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9LFxuICBnZXRJbml0aWFsU3RhdGU6IGZ1bmN0aW9uIGdldEluaXRpYWxTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9jYXRpb246IG51bGwsXG4gICAgICByb3V0ZXM6IG51bGwsXG4gICAgICBwYXJhbXM6IG51bGwsXG4gICAgICBjb21wb25lbnRzOiBudWxsXG4gICAgfTtcbiAgfSxcbiAgaGFuZGxlRXJyb3I6IGZ1bmN0aW9uIGhhbmRsZUVycm9yKGVycm9yKSB7XG4gICAgaWYgKHRoaXMucHJvcHMub25FcnJvcikge1xuICAgICAgdGhpcy5wcm9wcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUaHJvdyBlcnJvcnMgYnkgZGVmYXVsdCBzbyB3ZSBkb24ndCBzaWxlbnRseSBzd2FsbG93IHRoZW0hXG4gICAgICB0aHJvdyBlcnJvcjsgLy8gVGhpcyBlcnJvciBwcm9iYWJseSBvY2N1cnJlZCBpbiBnZXRDaGlsZFJvdXRlcyBvciBnZXRDb21wb25lbnRzLlxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50V2lsbE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnRXaWxsTW91bnQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciBwYXJzZVF1ZXJ5U3RyaW5nID0gX3Byb3BzLnBhcnNlUXVlcnlTdHJpbmc7XG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gX3Byb3BzLnN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIShwYXJzZVF1ZXJ5U3RyaW5nIHx8IHN0cmluZ2lmeVF1ZXJ5KSwgJ2BwYXJzZVF1ZXJ5U3RyaW5nYCBhbmQgYHN0cmluZ2lmeVF1ZXJ5YCBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIGNyZWF0ZSBhIGN1c3RvbSBoaXN0b3J5LiBodHRwOi8vdGlueS5jYy9yb3V0ZXItY3VzdG9tcXVlcnlzdHJpbmcnKSA6IHZvaWQgMDtcblxuICAgIHZhciBfY3JlYXRlUm91dGVyT2JqZWN0cyA9IHRoaXMuY3JlYXRlUm91dGVyT2JqZWN0cygpO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy5oaXN0b3J5O1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9IF9jcmVhdGVSb3V0ZXJPYmplY3RzLnRyYW5zaXRpb25NYW5hZ2VyO1xuICAgIHZhciByb3V0ZXIgPSBfY3JlYXRlUm91dGVyT2JqZWN0cy5yb3V0ZXI7XG5cblxuICAgIHRoaXMuX3VubGlzdGVuID0gdHJhbnNpdGlvbk1hbmFnZXIubGlzdGVuKGZ1bmN0aW9uIChlcnJvciwgc3RhdGUpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBfdGhpcy5oYW5kbGVFcnJvcihlcnJvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBfdGhpcy5zZXRTdGF0ZShzdGF0ZSwgX3RoaXMucHJvcHMub25VcGRhdGUpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5oaXN0b3J5ID0gaGlzdG9yeTtcbiAgICB0aGlzLnJvdXRlciA9IHJvdXRlcjtcbiAgfSxcbiAgY3JlYXRlUm91dGVyT2JqZWN0czogZnVuY3Rpb24gY3JlYXRlUm91dGVyT2JqZWN0cygpIHtcbiAgICB2YXIgbWF0Y2hDb250ZXh0ID0gdGhpcy5wcm9wcy5tYXRjaENvbnRleHQ7XG5cbiAgICBpZiAobWF0Y2hDb250ZXh0KSB7XG4gICAgICByZXR1cm4gbWF0Y2hDb250ZXh0O1xuICAgIH1cblxuICAgIHZhciBoaXN0b3J5ID0gdGhpcy5wcm9wcy5oaXN0b3J5O1xuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcm91dGVzID0gX3Byb3BzMi5yb3V0ZXM7XG4gICAgdmFyIGNoaWxkcmVuID0gX3Byb3BzMi5jaGlsZHJlbjtcblxuXG4gICAgISFpc1Vuc3VwcG9ydGVkSGlzdG9yeShoaXN0b3J5KSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdZb3UgaGF2ZSBwcm92aWRlZCBhIGhpc3Rvcnkgb2JqZWN0IGNyZWF0ZWQgd2l0aCBoaXN0b3J5IHYzLnguICcgKyAnVGhpcyB2ZXJzaW9uIG9mIFJlYWN0IFJvdXRlciBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHYzIGhpc3RvcnkgJyArICdvYmplY3RzLiBQbGVhc2UgdXNlIGhpc3RvcnkgdjIueCBpbnN0ZWFkLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChpc0RlcHJlY2F0ZWRIaXN0b3J5KGhpc3RvcnkpKSB7XG4gICAgICBoaXN0b3J5ID0gdGhpcy53cmFwRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSk7XG4gICAgfVxuXG4gICAgdmFyIHRyYW5zaXRpb25NYW5hZ2VyID0gKDAsIF9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcjIuZGVmYXVsdCkoaGlzdG9yeSwgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykocm91dGVzIHx8IGNoaWxkcmVuKSk7XG4gICAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gICAgdmFyIHJvdXRpbmdIaXN0b3J5ID0gKDAsIF9Sb3V0ZXJVdGlscy5jcmVhdGVSb3V0aW5nSGlzdG9yeSkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpO1xuXG4gICAgcmV0dXJuIHsgaGlzdG9yeTogcm91dGluZ0hpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfTtcbiAgfSxcbiAgd3JhcERlcHJlY2F0ZWRIaXN0b3J5OiBmdW5jdGlvbiB3cmFwRGVwcmVjYXRlZEhpc3RvcnkoaGlzdG9yeSkge1xuICAgIHZhciBfcHJvcHMzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IF9wcm9wczMucGFyc2VRdWVyeVN0cmluZztcbiAgICB2YXIgc3RyaW5naWZ5UXVlcnkgPSBfcHJvcHMzLnN0cmluZ2lmeVF1ZXJ5O1xuXG5cbiAgICB2YXIgY3JlYXRlSGlzdG9yeSA9IHZvaWQgMDtcbiAgICBpZiAoaGlzdG9yeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdJdCBhcHBlYXJzIHlvdSBoYXZlIHByb3ZpZGVkIGEgZGVwcmVjYXRlZCBoaXN0b3J5IG9iamVjdCB0byBgPFJvdXRlci8+YCwgcGxlYXNlIHVzZSBhIGhpc3RvcnkgcHJvdmlkZWQgYnkgJyArICdSZWFjdCBSb3V0ZXIgd2l0aCBgaW1wb3J0IHsgYnJvd3Nlckhpc3RvcnkgfSBmcm9tIFxcJ3JlYWN0LXJvdXRlclxcJ2Agb3IgYGltcG9ydCB7IGhhc2hIaXN0b3J5IH0gZnJvbSBcXCdyZWFjdC1yb3V0ZXJcXCdgLiAnICsgJ0lmIHlvdSBhcmUgdXNpbmcgYSBjdXN0b20gaGlzdG9yeSBwbGVhc2UgY3JlYXRlIGl0IHdpdGggYHVzZVJvdXRlckhpc3RvcnlgLCBzZWUgaHR0cDovL3RpbnkuY2Mvcm91dGVyLXVzaW5naGlzdG9yeSBmb3IgZGV0YWlscy4nKSA6IHZvaWQgMDtcbiAgICAgIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgICAgICByZXR1cm4gaGlzdG9yeTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYFJvdXRlcmAgbm8gbG9uZ2VyIGRlZmF1bHRzIHRoZSBoaXN0b3J5IHByb3AgdG8gaGFzaCBoaXN0b3J5LiBQbGVhc2UgdXNlIHRoZSBgaGFzaEhpc3RvcnlgIHNpbmdsZXRvbiBpbnN0ZWFkLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItZGVmYXVsdGhpc3RvcnknKSA6IHZvaWQgMDtcbiAgICAgIGNyZWF0ZUhpc3RvcnkgPSBfY3JlYXRlSGFzaEhpc3RvcnkyLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkoeyBwYXJzZVF1ZXJ5U3RyaW5nOiBwYXJzZVF1ZXJ5U3RyaW5nLCBzdHJpbmdpZnlRdWVyeTogc3RyaW5naWZ5UXVlcnkgfSk7XG4gIH0sXG5cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogc2FuaXR5IGNoZWNrICovXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHM6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMobmV4dFByb3BzKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkobmV4dFByb3BzLmhpc3RvcnkgPT09IHRoaXMucHJvcHMuaGlzdG9yeSwgJ1lvdSBjYW5ub3QgY2hhbmdlIDxSb3V0ZXIgaGlzdG9yeT47IGl0IHdpbGwgYmUgaWdub3JlZCcpIDogdm9pZCAwO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoKG5leHRQcm9wcy5yb3V0ZXMgfHwgbmV4dFByb3BzLmNoaWxkcmVuKSA9PT0gKHRoaXMucHJvcHMucm91dGVzIHx8IHRoaXMucHJvcHMuY2hpbGRyZW4pLCAnWW91IGNhbm5vdCBjaGFuZ2UgPFJvdXRlciByb3V0ZXM+OyBpdCB3aWxsIGJlIGlnbm9yZWQnKSA6IHZvaWQgMDtcbiAgfSxcbiAgY29tcG9uZW50V2lsbFVubW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIGlmICh0aGlzLl91bmxpc3RlbikgdGhpcy5fdW5saXN0ZW4oKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF9zdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgdmFyIGxvY2F0aW9uID0gX3N0YXRlLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZXMgPSBfc3RhdGUucm91dGVzO1xuICAgIHZhciBwYXJhbXMgPSBfc3RhdGUucGFyYW1zO1xuICAgIHZhciBjb21wb25lbnRzID0gX3N0YXRlLmNvbXBvbmVudHM7XG4gICAgdmFyIF9wcm9wczQgPSB0aGlzLnByb3BzO1xuICAgIHZhciBjcmVhdGVFbGVtZW50ID0gX3Byb3BzNC5jcmVhdGVFbGVtZW50O1xuICAgIHZhciByZW5kZXIgPSBfcHJvcHM0LnJlbmRlcjtcblxuICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHM0LCBbJ2NyZWF0ZUVsZW1lbnQnLCAncmVuZGVyJ10pO1xuXG4gICAgaWYgKGxvY2F0aW9uID09IG51bGwpIHJldHVybiBudWxsOyAvLyBBc3luYyBtYXRjaFxuXG4gICAgLy8gT25seSBmb3J3YXJkIG5vbi1Sb3V0ZXItc3BlY2lmaWMgcHJvcHMgdG8gcm91dGluZyBjb250ZXh0LCBhcyB0aG9zZSBhcmVcbiAgICAvLyB0aGUgb25seSBvbmVzIHRoYXQgbWlnaHQgYmUgY3VzdG9tIHJvdXRpbmcgY29udGV4dCBwcm9wcy5cbiAgICBPYmplY3Qua2V5cyhSb3V0ZXIucHJvcFR5cGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChwcm9wVHlwZSkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBwcm9wc1twcm9wVHlwZV07XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVuZGVyKF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgICAgaGlzdG9yeTogdGhpcy5oaXN0b3J5LFxuICAgICAgcm91dGVyOiB0aGlzLnJvdXRlcixcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHJvdXRlczogcm91dGVzLFxuICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICBjb21wb25lbnRzOiBjb21wb25lbnRzLFxuICAgICAgY3JlYXRlRWxlbWVudDogY3JlYXRlRWxlbWVudFxuICAgIH0pKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlcjtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfQWN0aW9ucyA9IHJlcXVpcmUoJy4vQWN0aW9ucycpO1xuXG52YXIgX1BhdGhVdGlscyA9IHJlcXVpcmUoJy4vUGF0aFV0aWxzJyk7XG5cbnZhciBfRXhlY3V0aW9uRW52aXJvbm1lbnQgPSByZXF1aXJlKCcuL0V4ZWN1dGlvbkVudmlyb25tZW50Jyk7XG5cbnZhciBfRE9NVXRpbHMgPSByZXF1aXJlKCcuL0RPTVV0aWxzJyk7XG5cbnZhciBfRE9NU3RhdGVTdG9yYWdlID0gcmVxdWlyZSgnLi9ET01TdGF0ZVN0b3JhZ2UnKTtcblxudmFyIF9jcmVhdGVET01IaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVET01IaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVET01IaXN0b3J5KTtcblxuZnVuY3Rpb24gaXNBYnNvbHV0ZVBhdGgocGF0aCkge1xuICByZXR1cm4gdHlwZW9mIHBhdGggPT09ICdzdHJpbmcnICYmIHBhdGguY2hhckF0KDApID09PSAnLyc7XG59XG5cbmZ1bmN0aW9uIGVuc3VyZVNsYXNoKCkge1xuICB2YXIgcGF0aCA9IF9ET01VdGlscy5nZXRIYXNoUGF0aCgpO1xuXG4gIGlmIChpc0Fic29sdXRlUGF0aChwYXRoKSkgcmV0dXJuIHRydWU7XG5cbiAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aCgnLycgKyBwYXRoKTtcblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGFkZFF1ZXJ5U3RyaW5nVmFsdWVUb1BhdGgocGF0aCwga2V5LCB2YWx1ZSkge1xuICByZXR1cm4gcGF0aCArIChwYXRoLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgKGtleSArICc9JyArIHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHJldHVybiBwYXRoLnJlcGxhY2UobmV3IFJlZ0V4cCgnWz8mXT8nICsga2V5ICsgJz1bYS16QS1aMC05XSsnKSwgJycpO1xufVxuXG5mdW5jdGlvbiBnZXRRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwga2V5KSB7XG4gIHZhciBtYXRjaCA9IHBhdGgubWF0Y2gobmV3IFJlZ0V4cCgnXFxcXD8uKj9cXFxcYicgKyBrZXkgKyAnPSguKz8pXFxcXGInKSk7XG4gIHJldHVybiBtYXRjaCAmJiBtYXRjaFsxXTtcbn1cblxudmFyIERlZmF1bHRRdWVyeUtleSA9ICdfayc7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhhc2hIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICFfRXhlY3V0aW9uRW52aXJvbm1lbnQuY2FuVXNlRE9NID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UsICdIYXNoIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gIHZhciBxdWVyeUtleSA9IG9wdGlvbnMucXVlcnlLZXk7XG5cbiAgaWYgKHF1ZXJ5S2V5ID09PSB1bmRlZmluZWQgfHwgISFxdWVyeUtleSkgcXVlcnlLZXkgPSB0eXBlb2YgcXVlcnlLZXkgPT09ICdzdHJpbmcnID8gcXVlcnlLZXkgOiBEZWZhdWx0UXVlcnlLZXk7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBwYXRoID0gX0RPTVV0aWxzLmdldEhhc2hQYXRoKCk7XG5cbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAocXVlcnlLZXkpIHtcbiAgICAgIGtleSA9IGdldFF1ZXJ5U3RyaW5nVmFsdWVGcm9tUGF0aChwYXRoLCBxdWVyeUtleSk7XG4gICAgICBwYXRoID0gc3RyaXBRdWVyeVN0cmluZ1ZhbHVlRnJvbVBhdGgocGF0aCwgcXVlcnlLZXkpO1xuXG4gICAgICBpZiAoa2V5KSB7XG4gICAgICAgIHN0YXRlID0gX0RPTVN0YXRlU3RvcmFnZS5yZWFkU3RhdGUoa2V5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgICAga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcbiAgICAgICAgX0RPTVV0aWxzLnJlcGxhY2VIYXNoUGF0aChhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIHF1ZXJ5S2V5LCBrZXkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gc3RhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRIYXNoQ2hhbmdlTGlzdGVuZXIoX3JlZikge1xuICAgIHZhciB0cmFuc2l0aW9uVG8gPSBfcmVmLnRyYW5zaXRpb25UbztcblxuICAgIGZ1bmN0aW9uIGhhc2hDaGFuZ2VMaXN0ZW5lcigpIHtcbiAgICAgIGlmICghZW5zdXJlU2xhc2goKSkgcmV0dXJuOyAvLyBBbHdheXMgbWFrZSBzdXJlIGhhc2hlcyBhcmUgcHJlY2VlZGVkIHdpdGggYSAvLlxuXG4gICAgICB0cmFuc2l0aW9uVG8oZ2V0Q3VycmVudExvY2F0aW9uKCkpO1xuICAgIH1cblxuICAgIGVuc3VyZVNsYXNoKCk7XG4gICAgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIGhhc2hDaGFuZ2VMaXN0ZW5lcik7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgX0RPTVV0aWxzLnJlbW92ZUV2ZW50TGlzdGVuZXIod2luZG93LCAnaGFzaGNoYW5nZScsIGhhc2hDaGFuZ2VMaXN0ZW5lcik7XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICB2YXIgYmFzZW5hbWUgPSBsb2NhdGlvbi5iYXNlbmFtZTtcbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBzdGF0ZSA9IGxvY2F0aW9uLnN0YXRlO1xuICAgIHZhciBhY3Rpb24gPSBsb2NhdGlvbi5hY3Rpb247XG4gICAgdmFyIGtleSA9IGxvY2F0aW9uLmtleTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkgcmV0dXJuOyAvLyBOb3RoaW5nIHRvIGRvLlxuXG4gICAgdmFyIHBhdGggPSAoYmFzZW5hbWUgfHwgJycpICsgcGF0aG5hbWUgKyBzZWFyY2g7XG5cbiAgICBpZiAocXVlcnlLZXkpIHtcbiAgICAgIHBhdGggPSBhZGRRdWVyeVN0cmluZ1ZhbHVlVG9QYXRoKHBhdGgsIHF1ZXJ5S2V5LCBrZXkpO1xuICAgICAgX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGUoa2V5LCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERyb3Aga2V5IGFuZCBzdGF0ZS5cbiAgICAgIGxvY2F0aW9uLmtleSA9IGxvY2F0aW9uLnN0YXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY3VycmVudEhhc2ggPSBfRE9NVXRpbHMuZ2V0SGFzaFBhdGgoKTtcblxuICAgIGlmIChhY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgIGlmIChjdXJyZW50SGFzaCAhPT0gcGF0aCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9IHBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdZb3UgY2Fubm90IFBVU0ggdGhlIHNhbWUgcGF0aCB1c2luZyBoYXNoIGhpc3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGN1cnJlbnRIYXNoICE9PSBwYXRoKSB7XG4gICAgICAvLyBSRVBMQUNFXG4gICAgICBfRE9NVXRpbHMucmVwbGFjZUhhc2hQYXRoKHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZURPTUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe30sIG9wdGlvbnMsIHtcbiAgICBnZXRDdXJyZW50TG9jYXRpb246IGdldEN1cnJlbnRMb2NhdGlvbixcbiAgICBmaW5pc2hUcmFuc2l0aW9uOiBmaW5pc2hUcmFuc2l0aW9uLFxuICAgIHNhdmVTdGF0ZTogX0RPTVN0YXRlU3RvcmFnZS5zYXZlU3RhdGVcbiAgfSkpO1xuXG4gIHZhciBsaXN0ZW5lckNvdW50ID0gMCxcbiAgICAgIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gbGlzdGVuQmVmb3JlKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW5CZWZvcmUobGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgdmFyIHVubGlzdGVuID0gaGlzdG9yeS5saXN0ZW4obGlzdGVuZXIpO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIHVubGlzdGVuKCk7XG5cbiAgICAgIGlmICgtLWxpc3RlbmVyQ291bnQgPT09IDApIHN0b3BIYXNoQ2hhbmdlTGlzdGVuZXIoKTtcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShxdWVyeUtleSB8fCBsb2NhdGlvbi5zdGF0ZSA9PSBudWxsLCAnWW91IGNhbm5vdCB1c2Ugc3RhdGUgd2l0aG91dCBhIHF1ZXJ5S2V5IGl0IHdpbGwgYmUgZHJvcHBlZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgaGlzdG9yeS5wdXNoKGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgbG9jYXRpb24uc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucmVwbGFjZShsb2NhdGlvbik7XG4gIH1cblxuICB2YXIgZ29Jc1N1cHBvcnRlZFdpdGhvdXRSZWxvYWQgPSBfRE9NVXRpbHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKTtcblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGdvSXNTdXBwb3J0ZWRXaXRob3V0UmVsb2FkLCAnSGFzaCBoaXN0b3J5IGdvKG4pIGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQgaW4gdGhpcyBicm93c2VyJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LmdvKG4pO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihwYXRoKSB7XG4gICAgcmV0dXJuICcjJyArIGhpc3RvcnkuY3JlYXRlSHJlZihwYXRoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVnaXN0ZXJUcmFuc2l0aW9uSG9vayhob29rKSB7XG4gICAgaWYgKCsrbGlzdGVuZXJDb3VudCA9PT0gMSkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lciA9IHN0YXJ0SGFzaENoYW5nZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgaGlzdG9yeS5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGhpc3RvcnkudW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuXG4gICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcEhhc2hDaGFuZ2VMaXN0ZW5lcigpO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocXVlcnlLZXkgfHwgc3RhdGUgPT0gbnVsbCwgJ1lvdSBjYW5ub3QgdXNlIHN0YXRlIHdpdGhvdXQgYSBxdWVyeUtleSBpdCB3aWxsIGJlIGRyb3BwZWQnKSA6IHVuZGVmaW5lZDtcblxuICAgIGhpc3RvcnkucHVzaFN0YXRlKHN0YXRlLCBwYXRoKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHF1ZXJ5S2V5IHx8IHN0YXRlID09IG51bGwsICdZb3UgY2Fubm90IHVzZSBzdGF0ZSB3aXRob3V0IGEgcXVlcnlLZXkgaXQgd2lsbCBiZSBkcm9wcGVkJykgOiB1bmRlZmluZWQ7XG5cbiAgICBoaXN0b3J5LnJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCk7XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICBsaXN0ZW46IGxpc3RlbixcbiAgICBwdXNoOiBwdXNoLFxuICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgZ286IGdvLFxuICAgIGNyZWF0ZUhyZWY6IGNyZWF0ZUhyZWYsXG5cbiAgICByZWdpc3RlclRyYW5zaXRpb25Ib29rOiByZWdpc3RlclRyYW5zaXRpb25Ib29rLCAvLyBkZXByZWNhdGVkIC0gd2FybmluZyBpcyBpbiBjcmVhdGVIaXN0b3J5XG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgICBwdXNoU3RhdGU6IHB1c2hTdGF0ZSwgLy8gZGVwcmVjYXRlZCAtIHdhcm5pbmcgaXMgaW4gY3JlYXRlSGlzdG9yeVxuICAgIHJlcGxhY2VTdGF0ZTogcmVwbGFjZVN0YXRlIC8vIGRlcHJlY2F0ZWQgLSB3YXJuaW5nIGlzIGluIGNyZWF0ZUhpc3RvcnlcbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUhhc2hIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVIYXNoSGlzdG9yeS5qcyIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTQtMjAxNSwgRmFjZWJvb2ssIEluYy5cbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgQlNELXN0eWxlIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuIEFuIGFkZGl0aW9uYWwgZ3JhbnRcbiAqIG9mIHBhdGVudCByaWdodHMgY2FuIGJlIGZvdW5kIGluIHRoZSBQQVRFTlRTIGZpbGUgaW4gdGhlIHNhbWUgZGlyZWN0b3J5LlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBmdW5jdGlvbigpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB3YXJuaW5nID0gZnVuY3Rpb24oY29uZGl0aW9uLCBmb3JtYXQsIGFyZ3MpIHtcbiAgICB2YXIgbGVuID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiA+IDIgPyBsZW4gLSAyIDogMCk7XG4gICAgZm9yICh2YXIga2V5ID0gMjsga2V5IDwgbGVuOyBrZXkrKykge1xuICAgICAgYXJnc1trZXkgLSAyXSA9IGFyZ3VtZW50c1trZXldO1xuICAgIH1cbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ2B3YXJuaW5nKGNvbmRpdGlvbiwgZm9ybWF0LCAuLi5hcmdzKWAgcmVxdWlyZXMgYSB3YXJuaW5nICcgK1xuICAgICAgICAnbWVzc2FnZSBhcmd1bWVudCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5sZW5ndGggPCAxMCB8fCAoL15bc1xcV10qJC8pLnRlc3QoZm9ybWF0KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIHdhcm5pbmcgZm9ybWF0IHNob3VsZCBiZSBhYmxlIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgJyArXG4gICAgICAgICd3YXJuaW5nLiBQbGVhc2UsIHVzZSBhIG1vcmUgZGVzY3JpcHRpdmUgZm9ybWF0IHRoYW46ICcgKyBmb3JtYXRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICtcbiAgICAgICAgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgICAgICB9KTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgZXJyb3Igd2FzIHRocm93biBhcyBhIGNvbnZlbmllbmNlIHNvIHRoYXQgeW91IGNhbiB1c2UgdGhpcyBzdGFja1xuICAgICAgICAvLyB0byBmaW5kIHRoZSBjYWxsc2l0ZSB0aGF0IGNhdXNlZCB0aGlzIHdhcm5pbmcgdG8gZmlyZS5cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgfSBjYXRjaCh4KSB7fVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB3YXJuaW5nO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vd2FybmluZy9icm93c2VyLmpzIiwiLyoqXG4gKiBJbmRpY2F0ZXMgdGhhdCBuYXZpZ2F0aW9uIHdhcyBjYXVzZWQgYnkgYSBjYWxsIHRvIGhpc3RvcnkucHVzaC5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xudmFyIFBVU0ggPSAnUFVTSCc7XG5cbmV4cG9ydHMuUFVTSCA9IFBVU0g7XG4vKipcbiAqIEluZGljYXRlcyB0aGF0IG5hdmlnYXRpb24gd2FzIGNhdXNlZCBieSBhIGNhbGwgdG8gaGlzdG9yeS5yZXBsYWNlLlxuICovXG52YXIgUkVQTEFDRSA9ICdSRVBMQUNFJztcblxuZXhwb3J0cy5SRVBMQUNFID0gUkVQTEFDRTtcbi8qKlxuICogSW5kaWNhdGVzIHRoYXQgbmF2aWdhdGlvbiB3YXMgY2F1c2VkIGJ5IHNvbWUgb3RoZXIgYWN0aW9uIHN1Y2hcbiAqIGFzIHVzaW5nIGEgYnJvd3NlcidzIGJhY2svZm9yd2FyZCBidXR0b25zIGFuZC9vciBtYW51YWxseSBtYW5pcHVsYXRpbmdcbiAqIHRoZSBVUkwgaW4gYSBicm93c2VyJ3MgbG9jYXRpb24gYmFyLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICpcbiAqIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93RXZlbnRIYW5kbGVycy9vbnBvcHN0YXRlXG4gKiBmb3IgbW9yZSBpbmZvcm1hdGlvbi5cbiAqL1xudmFyIFBPUCA9ICdQT1AnO1xuXG5leHBvcnRzLlBPUCA9IFBPUDtcbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHtcbiAgUFVTSDogUFVTSCxcbiAgUkVQTEFDRTogUkVQTEFDRSxcbiAgUE9QOiBQT1Bcbn07XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9BY3Rpb25zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuZXhwb3J0cy5leHRyYWN0UGF0aCA9IGV4dHJhY3RQYXRoO1xuZXhwb3J0cy5wYXJzZVBhdGggPSBwYXJzZVBhdGg7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbmZ1bmN0aW9uIGV4dHJhY3RQYXRoKHN0cmluZykge1xuICB2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL15odHRwcz86XFwvXFwvW15cXC9dKi8pO1xuXG4gIGlmIChtYXRjaCA9PSBudWxsKSByZXR1cm4gc3RyaW5nO1xuXG4gIHJldHVybiBzdHJpbmcuc3Vic3RyaW5nKG1hdGNoWzBdLmxlbmd0aCk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlUGF0aChwYXRoKSB7XG4gIHZhciBwYXRobmFtZSA9IGV4dHJhY3RQYXRoKHBhdGgpO1xuICB2YXIgc2VhcmNoID0gJyc7XG4gIHZhciBoYXNoID0gJyc7XG5cbiAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKHBhdGggPT09IHBhdGhuYW1lLCAnQSBwYXRoIG11c3QgYmUgcGF0aG5hbWUgKyBzZWFyY2ggKyBoYXNoIG9ubHksIG5vdCBhIGZ1bGx5IHF1YWxpZmllZCBVUkwgbGlrZSBcIiVzXCInLCBwYXRoKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgaGFzaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignIycpO1xuICBpZiAoaGFzaEluZGV4ICE9PSAtMSkge1xuICAgIGhhc2ggPSBwYXRobmFtZS5zdWJzdHJpbmcoaGFzaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBoYXNoSW5kZXgpO1xuICB9XG5cbiAgdmFyIHNlYXJjaEluZGV4ID0gcGF0aG5hbWUuaW5kZXhPZignPycpO1xuICBpZiAoc2VhcmNoSW5kZXggIT09IC0xKSB7XG4gICAgc2VhcmNoID0gcGF0aG5hbWUuc3Vic3RyaW5nKHNlYXJjaEluZGV4KTtcbiAgICBwYXRobmFtZSA9IHBhdGhuYW1lLnN1YnN0cmluZygwLCBzZWFyY2hJbmRleCk7XG4gIH1cblxuICBpZiAocGF0aG5hbWUgPT09ICcnKSBwYXRobmFtZSA9ICcvJztcblxuICByZXR1cm4ge1xuICAgIHBhdGhuYW1lOiBwYXRobmFtZSxcbiAgICBzZWFyY2g6IHNlYXJjaCxcbiAgICBoYXNoOiBoYXNoXG4gIH07XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9QYXRoVXRpbHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgY2FuVXNlRE9NID0gISEodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmRvY3VtZW50ICYmIHdpbmRvdy5kb2N1bWVudC5jcmVhdGVFbGVtZW50KTtcbmV4cG9ydHMuY2FuVXNlRE9NID0gY2FuVXNlRE9NO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRXhlY3V0aW9uRW52aXJvbm1lbnQuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuZXhwb3J0cy5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMuZ2V0SGFzaFBhdGggPSBnZXRIYXNoUGF0aDtcbmV4cG9ydHMucmVwbGFjZUhhc2hQYXRoID0gcmVwbGFjZUhhc2hQYXRoO1xuZXhwb3J0cy5nZXRXaW5kb3dQYXRoID0gZ2V0V2luZG93UGF0aDtcbmV4cG9ydHMuZ28gPSBnbztcbmV4cG9ydHMuZ2V0VXNlckNvbmZpcm1hdGlvbiA9IGdldFVzZXJDb25maXJtYXRpb247XG5leHBvcnRzLnN1cHBvcnRzSGlzdG9yeSA9IHN1cHBvcnRzSGlzdG9yeTtcbmV4cG9ydHMuc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2ggPSBzdXBwb3J0c0dvV2l0aG91dFJlbG9hZFVzaW5nSGFzaDtcblxuZnVuY3Rpb24gYWRkRXZlbnRMaXN0ZW5lcihub2RlLCBldmVudCwgbGlzdGVuZXIpIHtcbiAgaWYgKG5vZGUuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmF0dGFjaEV2ZW50KCdvbicgKyBldmVudCwgbGlzdGVuZXIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIobm9kZSwgZXZlbnQsIGxpc3RlbmVyKSB7XG4gIGlmIChub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcbiAgICBub2RlLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gIH0gZWxzZSB7XG4gICAgbm9kZS5kZXRhY2hFdmVudCgnb24nICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRIYXNoUGF0aCgpIHtcbiAgLy8gV2UgY2FuJ3QgdXNlIHdpbmRvdy5sb2NhdGlvbi5oYXNoIGhlcmUgYmVjYXVzZSBpdCdzIG5vdFxuICAvLyBjb25zaXN0ZW50IGFjcm9zcyBicm93c2VycyAtIEZpcmVmb3ggd2lsbCBwcmUtZGVjb2RlIGl0IVxuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLmhyZWYuc3BsaXQoJyMnKVsxXSB8fCAnJztcbn1cblxuZnVuY3Rpb24gcmVwbGFjZUhhc2hQYXRoKHBhdGgpIHtcbiAgd2luZG93LmxvY2F0aW9uLnJlcGxhY2Uod2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArICcjJyArIHBhdGgpO1xufVxuXG5mdW5jdGlvbiBnZXRXaW5kb3dQYXRoKCkge1xuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgd2luZG93LmxvY2F0aW9uLnNlYXJjaCArIHdpbmRvdy5sb2NhdGlvbi5oYXNoO1xufVxuXG5mdW5jdGlvbiBnbyhuKSB7XG4gIGlmIChuKSB3aW5kb3cuaGlzdG9yeS5nbyhuKTtcbn1cblxuZnVuY3Rpb24gZ2V0VXNlckNvbmZpcm1hdGlvbihtZXNzYWdlLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayh3aW5kb3cuY29uZmlybShtZXNzYWdlKSk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBIVE1MNSBoaXN0b3J5IEFQSSBpcyBzdXBwb3J0ZWQuIFRha2VuIGZyb20gTW9kZXJuaXpyLlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9Nb2Rlcm5penIvTW9kZXJuaXpyL2Jsb2IvbWFzdGVyL2ZlYXR1cmUtZGV0ZWN0cy9oaXN0b3J5LmpzXG4gKiBjaGFuZ2VkIHRvIGF2b2lkIGZhbHNlIG5lZ2F0aXZlcyBmb3IgV2luZG93cyBQaG9uZXM6IGh0dHBzOi8vZ2l0aHViLmNvbS9yYWNrdC9yZWFjdC1yb3V0ZXIvaXNzdWVzLzU4NlxuICovXG5cbmZ1bmN0aW9uIHN1cHBvcnRzSGlzdG9yeSgpIHtcbiAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgaWYgKCh1YS5pbmRleE9mKCdBbmRyb2lkIDIuJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0FuZHJvaWQgNC4wJykgIT09IC0xKSAmJiB1YS5pbmRleE9mKCdNb2JpbGUgU2FmYXJpJykgIT09IC0xICYmIHVhLmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSAmJiB1YS5pbmRleE9mKCdXaW5kb3dzIFBob25lJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB3aW5kb3cuaGlzdG9yeSAmJiAncHVzaFN0YXRlJyBpbiB3aW5kb3cuaGlzdG9yeTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHVzaW5nIGdvKG4pIHdpdGggaGFzaCBoaXN0b3J5IGNhdXNlcyBhIGZ1bGwgcGFnZSByZWxvYWQuXG4gKi9cblxuZnVuY3Rpb24gc3VwcG9ydHNHb1dpdGhvdXRSZWxvYWRVc2luZ0hhc2goKSB7XG4gIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIHJldHVybiB1YS5pbmRleE9mKCdGaXJlZm94JykgPT09IC0xO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvRE9NVXRpbHMuanMiLCIvKmVzbGludC1kaXNhYmxlIG5vLWVtcHR5ICovXG4ndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnNhdmVTdGF0ZSA9IHNhdmVTdGF0ZTtcbmV4cG9ydHMucmVhZFN0YXRlID0gcmVhZFN0YXRlO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgS2V5UHJlZml4ID0gJ0BASGlzdG9yeS8nO1xudmFyIFF1b3RhRXhjZWVkZWRFcnJvcnMgPSBbJ1F1b3RhRXhjZWVkZWRFcnJvcicsICdRVU9UQV9FWENFRURFRF9FUlInXTtcblxudmFyIFNlY3VyaXR5RXJyb3IgPSAnU2VjdXJpdHlFcnJvcic7XG5cbmZ1bmN0aW9uIGNyZWF0ZUtleShrZXkpIHtcbiAgcmV0dXJuIEtleVByZWZpeCArIGtleTtcbn1cblxuZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgdHJ5IHtcbiAgICBpZiAoc3RhdGUgPT0gbnVsbCkge1xuICAgICAgd2luZG93LnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aW5kb3cuc2Vzc2lvblN0b3JhZ2Uuc2V0SXRlbShjcmVhdGVLZXkoa2V5KSwgSlNPTi5zdHJpbmdpZnkoc3RhdGUpKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGVycm9yLm5hbWUgPT09IFNlY3VyaXR5RXJyb3IpIHtcbiAgICAgIC8vIEJsb2NraW5nIGNvb2tpZXMgaW4gQ2hyb21lL0ZpcmVmb3gvU2FmYXJpIHRocm93cyBTZWN1cml0eUVycm9yIG9uIGFueVxuICAgICAgLy8gYXR0ZW1wdCB0byBhY2Nlc3Mgd2luZG93LnNlc3Npb25TdG9yYWdlLlxuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldIFVuYWJsZSB0byBzYXZlIHN0YXRlOyBzZXNzaW9uU3RvcmFnZSBpcyBub3QgYXZhaWxhYmxlIGR1ZSB0byBzZWN1cml0eSBzZXR0aW5ncycpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFF1b3RhRXhjZWVkZWRFcnJvcnMuaW5kZXhPZihlcnJvci5uYW1lKSA+PSAwICYmIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5sZW5ndGggPT09IDApIHtcbiAgICAgIC8vIFNhZmFyaSBcInByaXZhdGUgbW9kZVwiIHRocm93cyBRdW90YUV4Y2VlZGVkRXJyb3IuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oZmFsc2UsICdbaGlzdG9yeV0gVW5hYmxlIHRvIHNhdmUgc3RhdGU7IHNlc3Npb25TdG9yYWdlIGlzIG5vdCBhdmFpbGFibGUgaW4gU2FmYXJpIHByaXZhdGUgbW9kZScpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVhZFN0YXRlKGtleSkge1xuICB2YXIganNvbiA9IHVuZGVmaW5lZDtcbiAgdHJ5IHtcbiAgICBqc29uID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oY3JlYXRlS2V5KGtleSkpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5uYW1lID09PSBTZWN1cml0eUVycm9yKSB7XG4gICAgICAvLyBCbG9ja2luZyBjb29raWVzIGluIENocm9tZS9GaXJlZm94L1NhZmFyaSB0aHJvd3MgU2VjdXJpdHlFcnJvciBvbiBhbnlcbiAgICAgIC8vIGF0dGVtcHQgdG8gYWNjZXNzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5cbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1toaXN0b3J5XSBVbmFibGUgdG8gcmVhZCBzdGF0ZTsgc2Vzc2lvblN0b3JhZ2UgaXMgbm90IGF2YWlsYWJsZSBkdWUgdG8gc2VjdXJpdHkgc2V0dGluZ3MnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgaWYgKGpzb24pIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEpTT04ucGFyc2UoanNvbik7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIElnbm9yZSBpbnZhbGlkIEpTT04uXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ET01TdGF0ZVN0b3JhZ2UuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9ET01VdGlscyA9IHJlcXVpcmUoJy4vRE9NVXRpbHMnKTtcblxudmFyIF9jcmVhdGVIaXN0b3J5ID0gcmVxdWlyZSgnLi9jcmVhdGVIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIaXN0b3J5KTtcblxuZnVuY3Rpb24gY3JlYXRlRE9NSGlzdG9yeShvcHRpb25zKSB7XG4gIHZhciBoaXN0b3J5ID0gX2NyZWF0ZUhpc3RvcnkyWydkZWZhdWx0J10oX2V4dGVuZHMoe1xuICAgIGdldFVzZXJDb25maXJtYXRpb246IF9ET01VdGlscy5nZXRVc2VyQ29uZmlybWF0aW9uXG4gIH0sIG9wdGlvbnMsIHtcbiAgICBnbzogX0RPTVV0aWxzLmdvXG4gIH0pKTtcblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnRE9NIGhpc3RvcnkgbmVlZHMgYSBET00nKSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbjogbGlzdGVuXG4gIH0pO1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSBjcmVhdGVET01IaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVET01IaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX2RlZXBFcXVhbCA9IHJlcXVpcmUoJ2RlZXAtZXF1YWwnKTtcblxudmFyIF9kZWVwRXF1YWwyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVlcEVxdWFsKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0FzeW5jVXRpbHMgPSByZXF1aXJlKCcuL0FzeW5jVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfY3JlYXRlTG9jYXRpb24yID0gcmVxdWlyZSgnLi9jcmVhdGVMb2NhdGlvbicpO1xuXG52YXIgX2NyZWF0ZUxvY2F0aW9uMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZUxvY2F0aW9uMik7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2sgPSByZXF1aXJlKCcuL3J1blRyYW5zaXRpb25Ib29rJyk7XG5cbnZhciBfcnVuVHJhbnNpdGlvbkhvb2syID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcnVuVHJhbnNpdGlvbkhvb2spO1xuXG52YXIgX2RlcHJlY2F0ZSA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlJyk7XG5cbnZhciBfZGVwcmVjYXRlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVJhbmRvbUtleShsZW5ndGgpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkudG9TdHJpbmcoMzYpLnN1YnN0cigyLCBsZW5ndGgpO1xufVxuXG5mdW5jdGlvbiBsb2NhdGlvbnNBcmVFcXVhbChhLCBiKSB7XG4gIHJldHVybiBhLnBhdGhuYW1lID09PSBiLnBhdGhuYW1lICYmIGEuc2VhcmNoID09PSBiLnNlYXJjaCAmJlxuICAvL2EuYWN0aW9uID09PSBiLmFjdGlvbiAmJiAvLyBEaWZmZXJlbnQgYWN0aW9uICE9PSBsb2NhdGlvbiBjaGFuZ2UuXG4gIGEua2V5ID09PSBiLmtleSAmJiBfZGVlcEVxdWFsMlsnZGVmYXVsdCddKGEuc3RhdGUsIGIuc3RhdGUpO1xufVxuXG52YXIgRGVmYXVsdEtleUxlbmd0aCA9IDY7XG5cbmZ1bmN0aW9uIGNyZWF0ZUhpc3RvcnkoKSB7XG4gIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8ge30gOiBhcmd1bWVudHNbMF07XG4gIHZhciBnZXRDdXJyZW50TG9jYXRpb24gPSBvcHRpb25zLmdldEN1cnJlbnRMb2NhdGlvbjtcbiAgdmFyIGZpbmlzaFRyYW5zaXRpb24gPSBvcHRpb25zLmZpbmlzaFRyYW5zaXRpb247XG4gIHZhciBzYXZlU3RhdGUgPSBvcHRpb25zLnNhdmVTdGF0ZTtcbiAgdmFyIGdvID0gb3B0aW9ucy5nbztcbiAgdmFyIGdldFVzZXJDb25maXJtYXRpb24gPSBvcHRpb25zLmdldFVzZXJDb25maXJtYXRpb247XG4gIHZhciBrZXlMZW5ndGggPSBvcHRpb25zLmtleUxlbmd0aDtcblxuICBpZiAodHlwZW9mIGtleUxlbmd0aCAhPT0gJ251bWJlcicpIGtleUxlbmd0aCA9IERlZmF1bHRLZXlMZW5ndGg7XG5cbiAgdmFyIHRyYW5zaXRpb25Ib29rcyA9IFtdO1xuXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZShob29rKSB7XG4gICAgdHJhbnNpdGlvbkhvb2tzLnB1c2goaG9vayk7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdHJhbnNpdGlvbkhvb2tzID0gdHJhbnNpdGlvbkhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbSAhPT0gaG9vaztcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICB2YXIgYWxsS2V5cyA9IFtdO1xuICB2YXIgY2hhbmdlTGlzdGVuZXJzID0gW107XG4gIHZhciBsb2NhdGlvbiA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBnZXRDdXJyZW50KCkge1xuICAgIGlmIChwZW5kaW5nTG9jYXRpb24gJiYgcGVuZGluZ0xvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSB7XG4gICAgICByZXR1cm4gYWxsS2V5cy5pbmRleE9mKHBlbmRpbmdMb2NhdGlvbi5rZXkpO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24pIHtcbiAgICAgIHJldHVybiBhbGxLZXlzLmluZGV4T2YobG9jYXRpb24ua2V5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uKG5ld0xvY2F0aW9uKSB7XG4gICAgdmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50KCk7XG5cbiAgICBsb2NhdGlvbiA9IG5ld0xvY2F0aW9uO1xuXG4gICAgaWYgKGxvY2F0aW9uLmFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgYWxsS2V5cyA9IFtdLmNvbmNhdChhbGxLZXlzLnNsaWNlKDAsIGN1cnJlbnQgKyAxKSwgW2xvY2F0aW9uLmtleV0pO1xuICAgIH0gZWxzZSBpZiAobG9jYXRpb24uYWN0aW9uID09PSBfQWN0aW9ucy5SRVBMQUNFKSB7XG4gICAgICBhbGxLZXlzW2N1cnJlbnRdID0gbG9jYXRpb24ua2V5O1xuICAgIH1cblxuICAgIGNoYW5nZUxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgbGlzdGVuZXIobG9jYXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgY2hhbmdlTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuXG4gICAgaWYgKGxvY2F0aW9uKSB7XG4gICAgICBsaXN0ZW5lcihsb2NhdGlvbik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBfbG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcbiAgICAgIGFsbEtleXMgPSBbX2xvY2F0aW9uLmtleV07XG4gICAgICB1cGRhdGVMb2NhdGlvbihfbG9jYXRpb24pO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFuZ2VMaXN0ZW5lcnMgPSBjaGFuZ2VMaXN0ZW5lcnMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtICE9PSBsaXN0ZW5lcjtcbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb25maXJtVHJhbnNpdGlvblRvKGxvY2F0aW9uLCBjYWxsYmFjaykge1xuICAgIF9Bc3luY1V0aWxzLmxvb3BBc3luYyh0cmFuc2l0aW9uSG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIG5leHQsIGRvbmUpIHtcbiAgICAgIF9ydW5UcmFuc2l0aW9uSG9vazJbJ2RlZmF1bHQnXSh0cmFuc2l0aW9uSG9va3NbaW5kZXhdLCBsb2NhdGlvbiwgZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICBkb25lKHJlc3VsdCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgaWYgKGdldFVzZXJDb25maXJtYXRpb24gJiYgdHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGdldFVzZXJDb25maXJtYXRpb24obWVzc2FnZSwgZnVuY3Rpb24gKG9rKSB7XG4gICAgICAgICAgY2FsbGJhY2sob2sgIT09IGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjayhtZXNzYWdlICE9PSBmYWxzZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgcGVuZGluZ0xvY2F0aW9uID0gdW5kZWZpbmVkO1xuXG4gIGZ1bmN0aW9uIHRyYW5zaXRpb25UbyhuZXh0TG9jYXRpb24pIHtcbiAgICBpZiAobG9jYXRpb24gJiYgbG9jYXRpb25zQXJlRXF1YWwobG9jYXRpb24sIG5leHRMb2NhdGlvbikpIHJldHVybjsgLy8gTm90aGluZyB0byBkby5cblxuICAgIHBlbmRpbmdMb2NhdGlvbiA9IG5leHRMb2NhdGlvbjtcblxuICAgIGNvbmZpcm1UcmFuc2l0aW9uVG8obmV4dExvY2F0aW9uLCBmdW5jdGlvbiAob2spIHtcbiAgICAgIGlmIChwZW5kaW5nTG9jYXRpb24gIT09IG5leHRMb2NhdGlvbikgcmV0dXJuOyAvLyBUcmFuc2l0aW9uIHdhcyBpbnRlcnJ1cHRlZC5cblxuICAgICAgaWYgKG9rKSB7XG4gICAgICAgIC8vIHRyZWF0IFBVU0ggdG8gY3VycmVudCBwYXRoIGxpa2UgUkVQTEFDRSB0byBiZSBjb25zaXN0ZW50IHdpdGggYnJvd3NlcnNcbiAgICAgICAgaWYgKG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBVU0gpIHtcbiAgICAgICAgICB2YXIgcHJldlBhdGggPSBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgICAgICAgICB2YXIgbmV4dFBhdGggPSBjcmVhdGVQYXRoKG5leHRMb2NhdGlvbik7XG5cbiAgICAgICAgICBpZiAobmV4dFBhdGggPT09IHByZXZQYXRoICYmIF9kZWVwRXF1YWwyWydkZWZhdWx0J10obG9jYXRpb24uc3RhdGUsIG5leHRMb2NhdGlvbi5zdGF0ZSkpIG5leHRMb2NhdGlvbi5hY3Rpb24gPSBfQWN0aW9ucy5SRVBMQUNFO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGZpbmlzaFRyYW5zaXRpb24obmV4dExvY2F0aW9uKSAhPT0gZmFsc2UpIHVwZGF0ZUxvY2F0aW9uKG5leHRMb2NhdGlvbik7XG4gICAgICB9IGVsc2UgaWYgKGxvY2F0aW9uICYmIG5leHRMb2NhdGlvbi5hY3Rpb24gPT09IF9BY3Rpb25zLlBPUCkge1xuICAgICAgICB2YXIgcHJldkluZGV4ID0gYWxsS2V5cy5pbmRleE9mKGxvY2F0aW9uLmtleSk7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSBhbGxLZXlzLmluZGV4T2YobmV4dExvY2F0aW9uLmtleSk7XG5cbiAgICAgICAgaWYgKHByZXZJbmRleCAhPT0gLTEgJiYgbmV4dEluZGV4ICE9PSAtMSkgZ28ocHJldkluZGV4IC0gbmV4dEluZGV4KTsgLy8gUmVzdG9yZSB0aGUgVVJMLlxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcHVzaChsb2NhdGlvbikge1xuICAgIHRyYW5zaXRpb25UbyhjcmVhdGVMb2NhdGlvbihsb2NhdGlvbiwgX0FjdGlvbnMuUFVTSCwgY3JlYXRlS2V5KCkpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24pIHtcbiAgICB0cmFuc2l0aW9uVG8oY3JlYXRlTG9jYXRpb24obG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UsIGNyZWF0ZUtleSgpKSk7XG4gIH1cblxuICBmdW5jdGlvbiBnb0JhY2soKSB7XG4gICAgZ28oLTEpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ29Gb3J3YXJkKCkge1xuICAgIGdvKDEpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlS2V5KCkge1xuICAgIHJldHVybiBjcmVhdGVSYW5kb21LZXkoa2V5TGVuZ3RoKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVBhdGgobG9jYXRpb24pIHtcbiAgICBpZiAobG9jYXRpb24gPT0gbnVsbCB8fCB0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICB2YXIgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICB2YXIgc2VhcmNoID0gbG9jYXRpb24uc2VhcmNoO1xuICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaDtcblxuICAgIHZhciByZXN1bHQgPSBwYXRobmFtZTtcblxuICAgIGlmIChzZWFyY2gpIHJlc3VsdCArPSBzZWFyY2g7XG5cbiAgICBpZiAoaGFzaCkgcmVzdWx0ICs9IGhhc2g7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlSHJlZihsb2NhdGlvbikge1xuICAgIHJldHVybiBjcmVhdGVQYXRoKGxvY2F0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uLCBhY3Rpb24pIHtcbiAgICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gY3JlYXRlS2V5KCkgOiBhcmd1bWVudHNbMl07XG5cbiAgICBpZiAodHlwZW9mIGFjdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1RoZSBzdGF0ZSAoMm5kKSBhcmd1bWVudCB0byBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhICcgKyAnbG9jYXRpb24gZGVzY3JpcHRvciBpbnN0ZWFkJykgOiB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKGxvY2F0aW9uKTtcblxuICAgICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IGFjdGlvbiB9KTtcblxuICAgICAgYWN0aW9uID0ga2V5O1xuICAgICAga2V5ID0gYXJndW1lbnRzWzNdIHx8IGNyZWF0ZUtleSgpO1xuICAgIH1cblxuICAgIHJldHVybiBfY3JlYXRlTG9jYXRpb24zWydkZWZhdWx0J10obG9jYXRpb24sIGFjdGlvbiwga2V5KTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gc2V0U3RhdGUoc3RhdGUpIHtcbiAgICBpZiAobG9jYXRpb24pIHtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uU3RhdGUobG9jYXRpb24sIHN0YXRlKTtcbiAgICAgIHVwZGF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdXBkYXRlTG9jYXRpb25TdGF0ZShnZXRDdXJyZW50TG9jYXRpb24oKSwgc3RhdGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZUxvY2F0aW9uU3RhdGUobG9jYXRpb24sIHN0YXRlKSB7XG4gICAgbG9jYXRpb24uc3RhdGUgPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24uc3RhdGUsIHN0YXRlKTtcbiAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICh0cmFuc2l0aW9uSG9va3MuaW5kZXhPZihob29rKSA9PT0gLTEpIHRyYW5zaXRpb25Ib29rcy5wdXNoKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIHRyYW5zaXRpb25Ib29rcyA9IHRyYW5zaXRpb25Ib29rcy5maWx0ZXIoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiBwdXNoU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICBwdXNoKF9leHRlbmRzKHsgc3RhdGU6IHN0YXRlIH0sIHBhdGgpKTtcbiAgfVxuXG4gIC8vIGRlcHJlY2F0ZWRcbiAgZnVuY3Rpb24gcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgaWYgKHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJykgcGF0aCA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmVwbGFjZShfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHRyYW5zaXRpb25UbzogdHJhbnNpdGlvblRvLFxuICAgIHB1c2g6IHB1c2gsXG4gICAgcmVwbGFjZTogcmVwbGFjZSxcbiAgICBnbzogZ28sXG4gICAgZ29CYWNrOiBnb0JhY2ssXG4gICAgZ29Gb3J3YXJkOiBnb0ZvcndhcmQsXG4gICAgY3JlYXRlS2V5OiBjcmVhdGVLZXksXG4gICAgY3JlYXRlUGF0aDogY3JlYXRlUGF0aCxcbiAgICBjcmVhdGVIcmVmOiBjcmVhdGVIcmVmLFxuICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbixcblxuICAgIHNldFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHNldFN0YXRlLCAnc2V0U3RhdGUgaXMgZGVwcmVjYXRlZDsgdXNlIGxvY2F0aW9uLmtleSB0byBzYXZlIHN0YXRlIGluc3RlYWQnKSxcbiAgICByZWdpc3RlclRyYW5zaXRpb25Ib29rOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssICdyZWdpc3RlclRyYW5zaXRpb25Ib29rIGlzIGRlcHJlY2F0ZWQ7IHVzZSBsaXN0ZW5CZWZvcmUgaW5zdGVhZCcpLFxuICAgIHVucmVnaXN0ZXJUcmFuc2l0aW9uSG9vazogX2RlcHJlY2F0ZTJbJ2RlZmF1bHQnXSh1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssICd1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2sgaXMgZGVwcmVjYXRlZDsgdXNlIHRoZSBjYWxsYmFjayByZXR1cm5lZCBmcm9tIGxpc3RlbkJlZm9yZSBpbnN0ZWFkJyksXG4gICAgcHVzaFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHB1c2hTdGF0ZSwgJ3B1c2hTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcHVzaCBpbnN0ZWFkJyksXG4gICAgcmVwbGFjZVN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHJlcGxhY2VTdGF0ZSwgJ3JlcGxhY2VTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcmVwbGFjZSBpbnN0ZWFkJylcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gY3JlYXRlSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvY3JlYXRlSGlzdG9yeS5qcyIsInZhciBwU2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2U7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMuanMnKTtcbnZhciBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoJy4vbGliL2lzX2FyZ3VtZW50cy5qcycpO1xuXG52YXIgZGVlcEVxdWFsID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYWN0dWFsLCBleHBlY3RlZCwgb3B0cykge1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgLy8gNy4xLiBBbGwgaWRlbnRpY2FsIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgYXMgZGV0ZXJtaW5lZCBieSA9PT0uXG4gIGlmIChhY3R1YWwgPT09IGV4cGVjdGVkKSB7XG4gICAgcmV0dXJuIHRydWU7XG5cbiAgfSBlbHNlIGlmIChhY3R1YWwgaW5zdGFuY2VvZiBEYXRlICYmIGV4cGVjdGVkIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBhY3R1YWwuZ2V0VGltZSgpID09PSBleHBlY3RlZC5nZXRUaW1lKCk7XG5cbiAgLy8gNy4zLiBPdGhlciBwYWlycyB0aGF0IGRvIG5vdCBib3RoIHBhc3MgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnLFxuICAvLyBlcXVpdmFsZW5jZSBpcyBkZXRlcm1pbmVkIGJ5ID09LlxuICB9IGVsc2UgaWYgKCFhY3R1YWwgfHwgIWV4cGVjdGVkIHx8IHR5cGVvZiBhY3R1YWwgIT0gJ29iamVjdCcgJiYgdHlwZW9mIGV4cGVjdGVkICE9ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIG9wdHMuc3RyaWN0ID8gYWN0dWFsID09PSBleHBlY3RlZCA6IGFjdHVhbCA9PSBleHBlY3RlZDtcblxuICAvLyA3LjQuIEZvciBhbGwgb3RoZXIgT2JqZWN0IHBhaXJzLCBpbmNsdWRpbmcgQXJyYXkgb2JqZWN0cywgZXF1aXZhbGVuY2UgaXNcbiAgLy8gZGV0ZXJtaW5lZCBieSBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGFzIHZlcmlmaWVkXG4gIC8vIHdpdGggT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKSwgdGhlIHNhbWUgc2V0IG9mIGtleXNcbiAgLy8gKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksIGVxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeVxuICAvLyBjb3JyZXNwb25kaW5nIGtleSwgYW5kIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS4gTm90ZTogdGhpc1xuICAvLyBhY2NvdW50cyBmb3IgYm90aCBuYW1lZCBhbmQgaW5kZXhlZCBwcm9wZXJ0aWVzIG9uIEFycmF5cy5cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gb2JqRXF1aXYoYWN0dWFsLCBleHBlY3RlZCwgb3B0cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWRPck51bGwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyICh4KSB7XG4gIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHgubGVuZ3RoICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIHguY29weSAhPT0gJ2Z1bmN0aW9uJyB8fCB0eXBlb2YgeC5zbGljZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoeC5sZW5ndGggPiAwICYmIHR5cGVvZiB4WzBdICE9PSAnbnVtYmVyJykgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb2JqRXF1aXYoYSwgYiwgb3B0cykge1xuICB2YXIgaSwga2V5O1xuICBpZiAoaXNVbmRlZmluZWRPck51bGwoYSkgfHwgaXNVbmRlZmluZWRPck51bGwoYikpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvLyBhbiBpZGVudGljYWwgJ3Byb3RvdHlwZScgcHJvcGVydHkuXG4gIGlmIChhLnByb3RvdHlwZSAhPT0gYi5wcm90b3R5cGUpIHJldHVybiBmYWxzZTtcbiAgLy9+fn5JJ3ZlIG1hbmFnZWQgdG8gYnJlYWsgT2JqZWN0LmtleXMgdGhyb3VnaCBzY3Jld3kgYXJndW1lbnRzIHBhc3NpbmcuXG4gIC8vICAgQ29udmVydGluZyB0byBhcnJheSBzb2x2ZXMgdGhlIHByb2JsZW0uXG4gIGlmIChpc0FyZ3VtZW50cyhhKSkge1xuICAgIGlmICghaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgYSA9IHBTbGljZS5jYWxsKGEpO1xuICAgIGIgPSBwU2xpY2UuY2FsbChiKTtcbiAgICByZXR1cm4gZGVlcEVxdWFsKGEsIGIsIG9wdHMpO1xuICB9XG4gIGlmIChpc0J1ZmZlcihhKSkge1xuICAgIGlmICghaXNCdWZmZXIoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICB0cnkge1xuICAgIHZhciBrYSA9IG9iamVjdEtleXMoYSksXG4gICAgICAgIGtiID0gb2JqZWN0S2V5cyhiKTtcbiAgfSBjYXRjaCAoZSkgey8vaGFwcGVucyB3aGVuIG9uZSBpcyBhIHN0cmluZyBsaXRlcmFsIGFuZCB0aGUgb3RoZXIgaXNuJ3RcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLy8gaGF2aW5nIHRoZSBzYW1lIG51bWJlciBvZiBvd25lZCBwcm9wZXJ0aWVzIChrZXlzIGluY29ycG9yYXRlc1xuICAvLyBoYXNPd25Qcm9wZXJ0eSlcbiAgaWYgKGthLmxlbmd0aCAhPSBrYi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICAvL3RoZSBzYW1lIHNldCBvZiBrZXlzIChhbHRob3VnaCBub3QgbmVjZXNzYXJpbHkgdGhlIHNhbWUgb3JkZXIpLFxuICBrYS5zb3J0KCk7XG4gIGtiLnNvcnQoKTtcbiAgLy9+fn5jaGVhcCBrZXkgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGlmIChrYVtpXSAhPSBrYltpXSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvL2VxdWl2YWxlbnQgdmFsdWVzIGZvciBldmVyeSBjb3JyZXNwb25kaW5nIGtleSwgYW5kXG4gIC8vfn5+cG9zc2libHkgZXhwZW5zaXZlIGRlZXAgdGVzdFxuICBmb3IgKGkgPSBrYS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGtleSA9IGthW2ldO1xuICAgIGlmICghZGVlcEVxdWFsKGFba2V5XSwgYltrZXldLCBvcHRzKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0eXBlb2YgYSA9PT0gdHlwZW9mIGI7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9+L2hpc3Rvcnkvfi9kZWVwLWVxdWFsL2luZGV4LmpzIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gdHlwZW9mIE9iamVjdC5rZXlzID09PSAnZnVuY3Rpb24nXG4gID8gT2JqZWN0LmtleXMgOiBzaGltO1xuXG5leHBvcnRzLnNoaW0gPSBzaGltO1xuZnVuY3Rpb24gc2hpbSAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICByZXR1cm4ga2V5cztcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9+L2RlZXAtZXF1YWwvbGliL2tleXMuanMiLCJ2YXIgc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA9IChmdW5jdGlvbigpe1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50cylcbn0pKCkgPT0gJ1tvYmplY3QgQXJndW1lbnRzXSc7XG5cbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHN1cHBvcnRzQXJndW1lbnRzQ2xhc3MgPyBzdXBwb3J0ZWQgOiB1bnN1cHBvcnRlZDtcblxuZXhwb3J0cy5zdXBwb3J0ZWQgPSBzdXBwb3J0ZWQ7XG5mdW5jdGlvbiBzdXBwb3J0ZWQob2JqZWN0KSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcbn07XG5cbmV4cG9ydHMudW5zdXBwb3J0ZWQgPSB1bnN1cHBvcnRlZDtcbmZ1bmN0aW9uIHVuc3VwcG9ydGVkKG9iamVjdCl7XG4gIHJldHVybiBvYmplY3QgJiZcbiAgICB0eXBlb2Ygb2JqZWN0ID09ICdvYmplY3QnICYmXG4gICAgdHlwZW9mIG9iamVjdC5sZW5ndGggPT0gJ251bWJlcicgJiZcbiAgICBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCAnY2FsbGVlJykgJiZcbiAgICAhT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgJ2NhbGxlZScpIHx8XG4gICAgZmFsc2U7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG52YXIgX3NsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuZXhwb3J0cy5sb29wQXN5bmMgPSBsb29wQXN5bmM7XG5cbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgc3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBbXS5jb25jYXQoX3NsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc05leHQgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgZG9uZUFyZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9Bc3luY1V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XG5cbnZhciBfd2FybmluZyA9IHJlcXVpcmUoJ3dhcm5pbmcnKTtcblxudmFyIF93YXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3dhcm5pbmcpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG5mdW5jdGlvbiBjcmVhdGVMb2NhdGlvbigpIHtcbiAgdmFyIGxvY2F0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAwIHx8IGFyZ3VtZW50c1swXSA9PT0gdW5kZWZpbmVkID8gJy8nIDogYXJndW1lbnRzWzBdO1xuICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gX0FjdGlvbnMuUE9QIDogYXJndW1lbnRzWzFdO1xuICB2YXIga2V5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAyIHx8IGFyZ3VtZW50c1syXSA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IGFyZ3VtZW50c1syXTtcblxuICB2YXIgX2ZvdXJ0aEFyZyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMyB8fCBhcmd1bWVudHNbM10gPT09IHVuZGVmaW5lZCA/IG51bGwgOiBhcmd1bWVudHNbM107XG5cbiAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gIGlmICh0eXBlb2YgYWN0aW9uID09PSAnb2JqZWN0Jykge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXShmYWxzZSwgJ1RoZSBzdGF0ZSAoMm5kKSBhcmd1bWVudCB0byBjcmVhdGVMb2NhdGlvbiBpcyBkZXByZWNhdGVkOyB1c2UgYSAnICsgJ2xvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgbG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgbG9jYXRpb24sIHsgc3RhdGU6IGFjdGlvbiB9KTtcblxuICAgIGFjdGlvbiA9IGtleSB8fCBfQWN0aW9ucy5QT1A7XG4gICAga2V5ID0gX2ZvdXJ0aEFyZztcbiAgfVxuXG4gIHZhciBwYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lIHx8ICcvJztcbiAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaCB8fCAnJztcbiAgdmFyIGhhc2ggPSBsb2NhdGlvbi5oYXNoIHx8ICcnO1xuICB2YXIgc3RhdGUgPSBsb2NhdGlvbi5zdGF0ZSB8fCBudWxsO1xuXG4gIHJldHVybiB7XG4gICAgcGF0aG5hbWU6IHBhdGhuYW1lLFxuICAgIHNlYXJjaDogc2VhcmNoLFxuICAgIGhhc2g6IGhhc2gsXG4gICAgc3RhdGU6IHN0YXRlLFxuICAgIGFjdGlvbjogYWN0aW9uLFxuICAgIGtleToga2V5XG4gIH07XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUxvY2F0aW9uO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVMb2NhdGlvbi5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2soaG9vaywgbG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gIHZhciByZXN1bHQgPSBob29rKGxvY2F0aW9uLCBjYWxsYmFjayk7XG5cbiAgaWYgKGhvb2subGVuZ3RoIDwgMikge1xuICAgIC8vIEFzc3VtZSB0aGUgaG9vayBydW5zIHN5bmNocm9ub3VzbHkgYW5kIGF1dG9tYXRpY2FsbHlcbiAgICAvLyBjYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSByZXR1cm4gdmFsdWUuXG4gICAgY2FsbGJhY2socmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10ocmVzdWx0ID09PSB1bmRlZmluZWQsICdZb3Ugc2hvdWxkIG5vdCBcInJldHVyblwiIGluIGEgdHJhbnNpdGlvbiBob29rIHdpdGggYSBjYWxsYmFjayBhcmd1bWVudDsgY2FsbCB0aGUgY2FsbGJhY2sgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuICB9XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IHJ1blRyYW5zaXRpb25Ib29rO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9ydW5UcmFuc2l0aW9uSG9vay5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxuZnVuY3Rpb24gZGVwcmVjYXRlKGZuLCBtZXNzYWdlKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnW2hpc3RvcnldICcgKyBtZXNzYWdlKSA6IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuZXhwb3J0c1snZGVmYXVsdCddID0gZGVwcmVjYXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9kZXByZWNhdGUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfcXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeS1zdHJpbmcnKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vayA9IHJlcXVpcmUoJy4vcnVuVHJhbnNpdGlvbkhvb2snKTtcblxudmFyIF9ydW5UcmFuc2l0aW9uSG9vazIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9ydW5UcmFuc2l0aW9uSG9vayk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG52YXIgU0VBUkNIX0JBU0VfS0VZID0gJyRzZWFyY2hCYXNlJztcblxuZnVuY3Rpb24gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSB7XG4gIHJldHVybiBfcXVlcnlTdHJpbmcuc3RyaW5naWZ5KHF1ZXJ5KS5yZXBsYWNlKC8lMjAvZywgJysnKTtcbn1cblxudmFyIGRlZmF1bHRQYXJzZVF1ZXJ5U3RyaW5nID0gX3F1ZXJ5U3RyaW5nLnBhcnNlO1xuXG5mdW5jdGlvbiBpc05lc3RlZE9iamVjdChvYmplY3QpIHtcbiAgZm9yICh2YXIgcCBpbiBvYmplY3QpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcCkgJiYgdHlwZW9mIG9iamVjdFtwXSA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkob2JqZWN0W3BdKSAmJiBvYmplY3RbcF0gIT09IG51bGwpIHJldHVybiB0cnVlO1xuICB9cmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBob3cgdG8gaGFuZGxlIFVSTCBxdWVyaWVzLlxuICovXG5mdW5jdGlvbiB1c2VRdWVyaWVzKGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gICAgdmFyIGhpc3RvcnkgPSBjcmVhdGVIaXN0b3J5KG9wdGlvbnMpO1xuXG4gICAgdmFyIHN0cmluZ2lmeVF1ZXJ5ID0gb3B0aW9ucy5zdHJpbmdpZnlRdWVyeTtcbiAgICB2YXIgcGFyc2VRdWVyeVN0cmluZyA9IG9wdGlvbnMucGFyc2VRdWVyeVN0cmluZztcblxuICAgIGlmICh0eXBlb2Ygc3RyaW5naWZ5UXVlcnkgIT09ICdmdW5jdGlvbicpIHN0cmluZ2lmeVF1ZXJ5ID0gZGVmYXVsdFN0cmluZ2lmeVF1ZXJ5O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJzZVF1ZXJ5U3RyaW5nICE9PSAnZnVuY3Rpb24nKSBwYXJzZVF1ZXJ5U3RyaW5nID0gZGVmYXVsdFBhcnNlUXVlcnlTdHJpbmc7XG5cbiAgICBmdW5jdGlvbiBhZGRRdWVyeShsb2NhdGlvbikge1xuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5ID09IG51bGwpIHtcbiAgICAgICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcblxuICAgICAgICBsb2NhdGlvbi5xdWVyeSA9IHBhcnNlUXVlcnlTdHJpbmcoc2VhcmNoLnN1YnN0cmluZygxKSk7XG4gICAgICAgIGxvY2F0aW9uW1NFQVJDSF9CQVNFX0tFWV0gPSB7IHNlYXJjaDogc2VhcmNoLCBzZWFyY2hCYXNlOiAnJyB9O1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiBJbnN0ZWFkIG9mIGFsbCB0aGUgYm9vay1rZWVwaW5nIGhlcmUsIHRoaXMgc2hvdWxkIGp1c3Qgc3RyaXAgdGhlXG4gICAgICAvLyBzdHJpbmdpZmllZCBxdWVyeSBmcm9tIHRoZSBzZWFyY2guXG5cbiAgICAgIHJldHVybiBsb2NhdGlvbjtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHZhciBfZXh0ZW5kczI7XG5cbiAgICAgIHZhciBzZWFyY2hCYXNlU3BlYyA9IGxvY2F0aW9uW1NFQVJDSF9CQVNFX0tFWV07XG4gICAgICB2YXIgcXVlcnlTdHJpbmcgPSBxdWVyeSA/IHN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5KSA6ICcnO1xuICAgICAgaWYgKCFzZWFyY2hCYXNlU3BlYyAmJiAhcXVlcnlTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgICAgfVxuXG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gX3dhcm5pbmcyWydkZWZhdWx0J10oc3RyaW5naWZ5UXVlcnkgIT09IGRlZmF1bHRTdHJpbmdpZnlRdWVyeSB8fCAhaXNOZXN0ZWRPYmplY3QocXVlcnkpLCAndXNlUXVlcmllcyBkb2VzIG5vdCBzdHJpbmdpZnkgbmVzdGVkIHF1ZXJ5IG9iamVjdHMgYnkgZGVmYXVsdDsgJyArICd1c2UgYSBjdXN0b20gc3RyaW5naWZ5UXVlcnkgZnVuY3Rpb24nKSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKHR5cGVvZiBsb2NhdGlvbiA9PT0gJ3N0cmluZycpIGxvY2F0aW9uID0gX1BhdGhVdGlscy5wYXJzZVBhdGgobG9jYXRpb24pO1xuXG4gICAgICB2YXIgc2VhcmNoQmFzZSA9IHVuZGVmaW5lZDtcbiAgICAgIGlmIChzZWFyY2hCYXNlU3BlYyAmJiBsb2NhdGlvbi5zZWFyY2ggPT09IHNlYXJjaEJhc2VTcGVjLnNlYXJjaCkge1xuICAgICAgICBzZWFyY2hCYXNlID0gc2VhcmNoQmFzZVNwZWMuc2VhcmNoQmFzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNlYXJjaEJhc2UgPSBsb2NhdGlvbi5zZWFyY2ggfHwgJyc7XG4gICAgICB9XG5cbiAgICAgIHZhciBzZWFyY2ggPSBzZWFyY2hCYXNlO1xuICAgICAgaWYgKHF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHNlYXJjaCArPSAoc2VhcmNoID8gJyYnIDogJz8nKSArIHF1ZXJ5U3RyaW5nO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gX2V4dGVuZHMoe30sIGxvY2F0aW9uLCAoX2V4dGVuZHMyID0ge1xuICAgICAgICBzZWFyY2g6IHNlYXJjaFxuICAgICAgfSwgX2V4dGVuZHMyW1NFQVJDSF9CQVNFX0tFWV0gPSB7IHNlYXJjaDogc2VhcmNoLCBzZWFyY2hCYXNlOiBzZWFyY2hCYXNlIH0sIF9leHRlbmRzMikpO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBxdWVyeS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKGhvb2ssIGFkZFF1ZXJ5KGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKGFkZFF1ZXJ5KGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIHF1ZXJ5LWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucHVzaChhcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UoYXBwZW5kUXVlcnkobG9jYXRpb24sIGxvY2F0aW9uLnF1ZXJ5KSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbiwgcXVlcnkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfd2FybmluZzJbJ2RlZmF1bHQnXSghcXVlcnksICd0aGUgcXVlcnkgYXJndW1lbnQgdG8gY3JlYXRlUGF0aCBpcyBkZXByZWNhdGVkOyB1c2UgYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQnKSA6IHVuZGVmaW5lZDtcblxuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChhcHBlbmRRdWVyeShsb2NhdGlvbiwgcXVlcnkgfHwgbG9jYXRpb24ucXVlcnkpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uLCBxdWVyeSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKCFxdWVyeSwgJ3RoZSBxdWVyeSBhcmd1bWVudCB0byBjcmVhdGVIcmVmIGlzIGRlcHJlY2F0ZWQ7IHVzZSBhIGxvY2F0aW9uIGRlc2NyaXB0b3IgaW5zdGVhZCcpIDogdW5kZWZpbmVkO1xuXG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKGFwcGVuZFF1ZXJ5KGxvY2F0aW9uLCBxdWVyeSB8fCBsb2NhdGlvbi5xdWVyeSkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHZhciBmdWxsTG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFthcHBlbmRRdWVyeShsb2NhdGlvbiwgbG9jYXRpb24ucXVlcnkpXS5jb25jYXQoYXJncykpO1xuICAgICAgaWYgKGxvY2F0aW9uLnF1ZXJ5KSB7XG4gICAgICAgIGZ1bGxMb2NhdGlvbi5xdWVyeSA9IGxvY2F0aW9uLnF1ZXJ5O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFkZFF1ZXJ5KGZ1bGxMb2NhdGlvbik7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHB1c2hTdGF0ZShzdGF0ZSwgcGF0aCwgcXVlcnkpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcHVzaChfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoLCB7IHF1ZXJ5OiBxdWVyeSB9KSk7XG4gICAgfVxuXG4gICAgLy8gZGVwcmVjYXRlZFxuICAgIGZ1bmN0aW9uIHJlcGxhY2VTdGF0ZShzdGF0ZSwgcGF0aCwgcXVlcnkpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcmVwbGFjZShfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoLCB7IHF1ZXJ5OiBxdWVyeSB9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbixcblxuICAgICAgcHVzaFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHB1c2hTdGF0ZSwgJ3B1c2hTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcHVzaCBpbnN0ZWFkJyksXG4gICAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VRdWVyaWVzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi91c2VRdWVyaWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xudmFyIHN0cmljdFVyaUVuY29kZSA9IHJlcXVpcmUoJ3N0cmljdC11cmktZW5jb2RlJyk7XG5cbmV4cG9ydHMuZXh0cmFjdCA9IGZ1bmN0aW9uIChzdHIpIHtcblx0cmV0dXJuIHN0ci5zcGxpdCgnPycpWzFdIHx8ICcnO1xufTtcblxuZXhwb3J0cy5wYXJzZSA9IGZ1bmN0aW9uIChzdHIpIHtcblx0aWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0c3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKC9eKFxcP3wjfCYpLywgJycpO1xuXG5cdGlmICghc3RyKSB7XG5cdFx0cmV0dXJuIHt9O1xuXHR9XG5cblx0cmV0dXJuIHN0ci5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbiAocmV0LCBwYXJhbSkge1xuXHRcdHZhciBwYXJ0cyA9IHBhcmFtLnJlcGxhY2UoL1xcKy9nLCAnICcpLnNwbGl0KCc9Jyk7XG5cdFx0Ly8gRmlyZWZveCAocHJlIDQwKSBkZWNvZGVzIGAlM0RgIHRvIGA9YFxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9zaW5kcmVzb3JodXMvcXVlcnktc3RyaW5nL3B1bGwvMzdcblx0XHR2YXIga2V5ID0gcGFydHMuc2hpZnQoKTtcblx0XHR2YXIgdmFsID0gcGFydHMubGVuZ3RoID4gMCA/IHBhcnRzLmpvaW4oJz0nKSA6IHVuZGVmaW5lZDtcblxuXHRcdGtleSA9IGRlY29kZVVSSUNvbXBvbmVudChrZXkpO1xuXG5cdFx0Ly8gbWlzc2luZyBgPWAgc2hvdWxkIGJlIGBudWxsYDpcblx0XHQvLyBodHRwOi8vdzMub3JnL1RSLzIwMTIvV0QtdXJsLTIwMTIwNTI0LyNjb2xsZWN0LXVybC1wYXJhbWV0ZXJzXG5cdFx0dmFsID0gdmFsID09PSB1bmRlZmluZWQgPyBudWxsIDogZGVjb2RlVVJJQ29tcG9uZW50KHZhbCk7XG5cblx0XHRpZiAoIXJldC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRyZXRba2V5XSA9IHZhbDtcblx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmV0W2tleV0pKSB7XG5cdFx0XHRyZXRba2V5XS5wdXNoKHZhbCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldFtrZXldID0gW3JldFtrZXldLCB2YWxdO1xuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sIHt9KTtcbn07XG5cbmV4cG9ydHMuc3RyaW5naWZ5ID0gZnVuY3Rpb24gKG9iaikge1xuXHRyZXR1cm4gb2JqID8gT2JqZWN0LmtleXMob2JqKS5zb3J0KCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcblx0XHR2YXIgdmFsID0gb2JqW2tleV07XG5cblx0XHRpZiAodmFsID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHJldHVybiAnJztcblx0XHR9XG5cblx0XHRpZiAodmFsID09PSBudWxsKSB7XG5cdFx0XHRyZXR1cm4ga2V5O1xuXHRcdH1cblxuXHRcdGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcblx0XHRcdHJldHVybiB2YWwuc2xpY2UoKS5zb3J0KCkubWFwKGZ1bmN0aW9uICh2YWwyKSB7XG5cdFx0XHRcdHJldHVybiBzdHJpY3RVcmlFbmNvZGUoa2V5KSArICc9JyArIHN0cmljdFVyaUVuY29kZSh2YWwyKTtcblx0XHRcdH0pLmpvaW4oJyYnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gc3RyaWN0VXJpRW5jb2RlKGtleSkgKyAnPScgKyBzdHJpY3RVcmlFbmNvZGUodmFsKTtcblx0fSkuZmlsdGVyKGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIHgubGVuZ3RoID4gMDtcblx0fSkuam9pbignJicpIDogJyc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyKSB7XG5cdHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyKS5yZXBsYWNlKC9bIScoKSpdL2csIGZ1bmN0aW9uIChjKSB7XG5cdFx0cmV0dXJuICclJyArIGMuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikudG9VcHBlckNhc2UoKTtcblx0fSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L34vcXVlcnktc3RyaW5nL34vc3RyaWN0LXVyaS1lbmNvZGUvaW5kZXguanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzMiA9IHJlcXVpcmUoJy4vY29tcHV0ZUNoYW5nZWRSb3V0ZXMnKTtcblxudmFyIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jb21wdXRlQ2hhbmdlZFJvdXRlczIpO1xuXG52YXIgX1RyYW5zaXRpb25VdGlscyA9IHJlcXVpcmUoJy4vVHJhbnNpdGlvblV0aWxzJyk7XG5cbnZhciBfaXNBY3RpdmUyID0gcmVxdWlyZSgnLi9pc0FjdGl2ZScpO1xuXG52YXIgX2lzQWN0aXZlMyA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2lzQWN0aXZlMik7XG5cbnZhciBfZ2V0Q29tcG9uZW50cyA9IHJlcXVpcmUoJy4vZ2V0Q29tcG9uZW50cycpO1xuXG52YXIgX2dldENvbXBvbmVudHMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZ2V0Q29tcG9uZW50cyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMgPSByZXF1aXJlKCcuL21hdGNoUm91dGVzJyk7XG5cbnZhciBfbWF0Y2hSb3V0ZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfbWF0Y2hSb3V0ZXMpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBoYXNBbnlQcm9wZXJ0aWVzKG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIHRydWU7XG4gIH1yZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKGhpc3RvcnksIHJvdXRlcykge1xuICB2YXIgc3RhdGUgPSB7fTtcblxuICAvLyBTaWduYXR1cmUgc2hvdWxkIGJlIChsb2NhdGlvbiwgaW5kZXhPbmx5KSwgYnV0IG5lZWRzIHRvIHN1cHBvcnQgKHBhdGgsXG4gIC8vIHF1ZXJ5LCBpbmRleE9ubHkpXG4gIGZ1bmN0aW9uIGlzQWN0aXZlKGxvY2F0aW9uKSB7XG4gICAgdmFyIGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5ID0gYXJndW1lbnRzLmxlbmd0aCA8PSAxIHx8IGFyZ3VtZW50c1sxXSA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBhcmd1bWVudHNbMV07XG4gICAgdmFyIGRlcHJlY2F0ZWRJbmRleE9ubHkgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDIgfHwgYXJndW1lbnRzWzJdID09PSB1bmRlZmluZWQgPyBudWxsIDogYXJndW1lbnRzWzJdO1xuXG4gICAgdmFyIGluZGV4T25seSA9IHZvaWQgMDtcbiAgICBpZiAoaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgJiYgaW5kZXhPbmx5T3JEZXByZWNhdGVkUXVlcnkgIT09IHRydWUgfHwgZGVwcmVjYXRlZEluZGV4T25seSAhPT0gbnVsbCkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgaXNBY3RpdmUocGF0aG5hbWUsIHF1ZXJ5LCBpbmRleE9ubHkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgaXNBY3RpdmUobG9jYXRpb24sIGluZGV4T25seSlgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIGxvY2F0aW9uID0geyBwYXRobmFtZTogbG9jYXRpb24sIHF1ZXJ5OiBpbmRleE9ubHlPckRlcHJlY2F0ZWRRdWVyeSB9O1xuICAgICAgaW5kZXhPbmx5ID0gZGVwcmVjYXRlZEluZGV4T25seSB8fCBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgbG9jYXRpb24gPSBoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKTtcbiAgICAgIGluZGV4T25seSA9IGluZGV4T25seU9yRGVwcmVjYXRlZFF1ZXJ5O1xuICAgIH1cblxuICAgIHJldHVybiAoMCwgX2lzQWN0aXZlMy5kZWZhdWx0KShsb2NhdGlvbiwgaW5kZXhPbmx5LCBzdGF0ZS5sb2NhdGlvbiwgc3RhdGUucm91dGVzLCBzdGF0ZS5wYXJhbXMpO1xuICB9XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gbWF0Y2gobG9jYXRpb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKHBhcnRpYWxOZXh0U3RhdGUgJiYgcGFydGlhbE5leHRTdGF0ZS5sb2NhdGlvbiA9PT0gbG9jYXRpb24pIHtcbiAgICAgIC8vIENvbnRpbnVlIGZyb20gd2hlcmUgd2UgbGVmdCBvZmYuXG4gICAgICBmaW5pc2hNYXRjaChwYXJ0aWFsTmV4dFN0YXRlLCBjYWxsYmFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgICgwLCBfbWF0Y2hSb3V0ZXMyLmRlZmF1bHQpKHJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbmV4dFN0YXRlKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIGlmIChuZXh0U3RhdGUpIHtcbiAgICAgICAgICBmaW5pc2hNYXRjaChfZXh0ZW5kcyh7fSwgbmV4dFN0YXRlLCB7IGxvY2F0aW9uOiBsb2NhdGlvbiB9KSwgY2FsbGJhY2spO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaE1hdGNoKG5leHRTdGF0ZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgX2NvbXB1dGVDaGFuZ2VkUm91dGVzID0gKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIG5leHRTdGF0ZSk7XG5cbiAgICB2YXIgbGVhdmVSb3V0ZXMgPSBfY29tcHV0ZUNoYW5nZWRSb3V0ZXMubGVhdmVSb3V0ZXM7XG4gICAgdmFyIGNoYW5nZVJvdXRlcyA9IF9jb21wdXRlQ2hhbmdlZFJvdXRlcy5jaGFuZ2VSb3V0ZXM7XG4gICAgdmFyIGVudGVyUm91dGVzID0gX2NvbXB1dGVDaGFuZ2VkUm91dGVzLmVudGVyUm91dGVzO1xuXG5cbiAgICAoMCwgX1RyYW5zaXRpb25VdGlscy5ydW5MZWF2ZUhvb2tzKShsZWF2ZVJvdXRlcywgc3RhdGUpO1xuXG4gICAgLy8gVGVhciBkb3duIGNvbmZpcm1hdGlvbiBob29rcyBmb3IgbGVmdCByb3V0ZXNcbiAgICBsZWF2ZVJvdXRlcy5maWx0ZXIoZnVuY3Rpb24gKHJvdXRlKSB7XG4gICAgICByZXR1cm4gZW50ZXJSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgPT09IC0xO1xuICAgIH0pLmZvckVhY2gocmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZSk7XG5cbiAgICAvLyBjaGFuZ2UgYW5kIGVudGVyIGhvb2tzIGFyZSBydW4gaW4gc2VyaWVzXG4gICAgKDAsIF9UcmFuc2l0aW9uVXRpbHMucnVuQ2hhbmdlSG9va3MpKGNoYW5nZVJvdXRlcywgc3RhdGUsIG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCByZWRpcmVjdEluZm8pIHtcbiAgICAgIGlmIChlcnJvciB8fCByZWRpcmVjdEluZm8pIHJldHVybiBoYW5kbGVFcnJvck9yUmVkaXJlY3QoZXJyb3IsIHJlZGlyZWN0SW5mbyk7XG5cbiAgICAgICgwLCBfVHJhbnNpdGlvblV0aWxzLnJ1bkVudGVySG9va3MpKGVudGVyUm91dGVzLCBuZXh0U3RhdGUsIGZpbmlzaEVudGVySG9va3MpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gZmluaXNoRW50ZXJIb29rcyhlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IgfHwgcmVkaXJlY3RJbmZvKSByZXR1cm4gaGFuZGxlRXJyb3JPclJlZGlyZWN0KGVycm9yLCByZWRpcmVjdEluZm8pO1xuXG4gICAgICAvLyBUT0RPOiBGZXRjaCBjb21wb25lbnRzIGFmdGVyIHN0YXRlIGlzIHVwZGF0ZWQuXG4gICAgICAoMCwgX2dldENvbXBvbmVudHMyLmRlZmF1bHQpKG5leHRTdGF0ZSwgZnVuY3Rpb24gKGVycm9yLCBjb21wb25lbnRzKSB7XG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUT0RPOiBNYWtlIG1hdGNoIGEgcHVyZSBmdW5jdGlvbiBhbmQgaGF2ZSBzb21lIG90aGVyIEFQSVxuICAgICAgICAgIC8vIGZvciBcIm1hdGNoIGFuZCB1cGRhdGUgc3RhdGVcIi5cbiAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsLCBzdGF0ZSA9IF9leHRlbmRzKHt9LCBuZXh0U3RhdGUsIHsgY29tcG9uZW50czogY29tcG9uZW50cyB9KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhhbmRsZUVycm9yT3JSZWRpcmVjdChlcnJvciwgcmVkaXJlY3RJbmZvKSB7XG4gICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yKTtlbHNlIGNhbGxiYWNrKG51bGwsIHJlZGlyZWN0SW5mbyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIFJvdXRlR3VpZCA9IDE7XG5cbiAgZnVuY3Rpb24gZ2V0Um91dGVJRChyb3V0ZSkge1xuICAgIHZhciBjcmVhdGUgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDEgfHwgYXJndW1lbnRzWzFdID09PSB1bmRlZmluZWQgPyB0cnVlIDogYXJndW1lbnRzWzFdO1xuXG4gICAgcmV0dXJuIHJvdXRlLl9faWRfXyB8fCBjcmVhdGUgJiYgKHJvdXRlLl9faWRfXyA9IFJvdXRlR3VpZCsrKTtcbiAgfVxuXG4gIHZhciBSb3V0ZUhvb2tzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmdW5jdGlvbiBnZXRSb3V0ZUhvb2tzRm9yUm91dGVzKHJvdXRlcykge1xuICAgIHJldHVybiByb3V0ZXMucmVkdWNlKGZ1bmN0aW9uIChob29rcywgcm91dGUpIHtcbiAgICAgIGhvb2tzLnB1c2guYXBwbHkoaG9va3MsIFJvdXRlSG9va3NbZ2V0Um91dGVJRChyb3V0ZSldKTtcbiAgICAgIHJldHVybiBob29rcztcbiAgICB9LCBbXSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cmFuc2l0aW9uSG9vayhsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAoMCwgX21hdGNoUm91dGVzMi5kZWZhdWx0KShyb3V0ZXMsIGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIG5leHRTdGF0ZSkge1xuICAgICAgaWYgKG5leHRTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIC8vIFRPRE86IFdlIGRpZG4ndCBhY3R1YWxseSBtYXRjaCBhbnl0aGluZywgYnV0IGhhbmdcbiAgICAgICAgLy8gb250byBlcnJvci9uZXh0U3RhdGUgc28gd2UgZG9uJ3QgaGF2ZSB0byBtYXRjaFJvdXRlc1xuICAgICAgICAvLyBhZ2FpbiBpbiB0aGUgbGlzdGVuIGNhbGxiYWNrLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIENhY2hlIHNvbWUgc3RhdGUgaGVyZSBzbyB3ZSBkb24ndCBoYXZlIHRvXG4gICAgICAvLyBtYXRjaFJvdXRlcygpIGFnYWluIGluIHRoZSBsaXN0ZW4gY2FsbGJhY2suXG4gICAgICBwYXJ0aWFsTmV4dFN0YXRlID0gX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwgeyBsb2NhdGlvbjogbG9jYXRpb24gfSk7XG5cbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoKDAsIF9jb21wdXRlQ2hhbmdlZFJvdXRlczMuZGVmYXVsdCkoc3RhdGUsIHBhcnRpYWxOZXh0U3RhdGUpLmxlYXZlUm91dGVzKTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHZvaWQgMDtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBob29rcy5sZW5ndGg7IHJlc3VsdCA9PSBudWxsICYmIGkgPCBsZW47ICsraSkge1xuICAgICAgICAvLyBQYXNzaW5nIHRoZSBsb2NhdGlvbiBhcmcgaGVyZSBpbmRpY2F0ZXMgdG9cbiAgICAgICAgLy8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGEgdHJhbnNpdGlvbiBob29rLlxuICAgICAgICByZXN1bHQgPSBob29rc1tpXShsb2NhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dDogdW50ZXN0YWJsZSB3aXRoIEthcm1hICovXG4gIGZ1bmN0aW9uIGJlZm9yZVVubG9hZEhvb2soKSB7XG4gICAgLy8gU3luY2hyb25vdXNseSBjaGVjayB0byBzZWUgaWYgYW55IHJvdXRlIGhvb2tzIHdhbnRcbiAgICAvLyB0byBwcmV2ZW50IHRoZSBjdXJyZW50IHdpbmRvdy90YWIgZnJvbSBjbG9zaW5nLlxuICAgIGlmIChzdGF0ZS5yb3V0ZXMpIHtcbiAgICAgIHZhciBob29rcyA9IGdldFJvdXRlSG9va3NGb3JSb3V0ZXMoc3RhdGUucm91dGVzKTtcblxuICAgICAgdmFyIG1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gaG9va3MubGVuZ3RoOyB0eXBlb2YgbWVzc2FnZSAhPT0gJ3N0cmluZycgJiYgaSA8IGxlbjsgKytpKSB7XG4gICAgICAgIC8vIFBhc3Npbmcgbm8gYXJncyBpbmRpY2F0ZXMgdG8gdGhlIHVzZXIgdGhhdCB0aGlzIGlzIGFcbiAgICAgICAgLy8gYmVmb3JldW5sb2FkIGhvb2suIFdlIGRvbid0IGtub3cgdGhlIG5leHQgbG9jYXRpb24uXG4gICAgICAgIG1lc3NhZ2UgPSBob29rc1tpXSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9XG4gIH1cblxuICB2YXIgdW5saXN0ZW5CZWZvcmUgPSB2b2lkIDAsXG4gICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IHZvaWQgMDtcblxuICBmdW5jdGlvbiByZW1vdmVMaXN0ZW5CZWZvcmVIb29rc0ZvclJvdXRlKHJvdXRlKSB7XG4gICAgdmFyIHJvdXRlSUQgPSBnZXRSb3V0ZUlEKHJvdXRlLCBmYWxzZSk7XG4gICAgaWYgKCFyb3V0ZUlEKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZGVsZXRlIFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcykpIHtcbiAgICAgIC8vIHRlYXJkb3duIHRyYW5zaXRpb24gJiBiZWZvcmV1bmxvYWQgaG9va3NcbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZSkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh1bmxpc3RlbkJlZm9yZVVubG9hZCkge1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCgpO1xuICAgICAgICB1bmxpc3RlbkJlZm9yZVVubG9hZCA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyB0aGUgZ2l2ZW4gaG9vayBmdW5jdGlvbiB0byBydW4gYmVmb3JlIGxlYXZpbmcgdGhlIGdpdmVuIHJvdXRlLlxuICAgKlxuICAgKiBEdXJpbmcgYSBub3JtYWwgdHJhbnNpdGlvbiwgdGhlIGhvb2sgZnVuY3Rpb24gcmVjZWl2ZXMgdGhlIG5leHQgbG9jYXRpb25cbiAgICogYXMgaXRzIG9ubHkgYXJndW1lbnQgYW5kIGNhbiByZXR1cm4gZWl0aGVyIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykgdG8gc2hvdyB0aGUgdXNlcixcbiAgICogdG8gbWFrZSBzdXJlIHRoZXkgd2FudCB0byBsZWF2ZSB0aGUgcGFnZTsgb3IgYGZhbHNlYCwgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICogQW55IG90aGVyIHJldHVybiB2YWx1ZSB3aWxsIGhhdmUgbm8gZWZmZWN0LlxuICAgKlxuICAgKiBEdXJpbmcgdGhlIGJlZm9yZXVubG9hZCBldmVudCAoaW4gYnJvd3NlcnMpIHRoZSBob29rIHJlY2VpdmVzIG5vIGFyZ3VtZW50cy5cbiAgICogSW4gdGhpcyBjYXNlIGl0IG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudCB0aGUgdHJhbnNpdGlvbi5cbiAgICpcbiAgICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgbWF5IGJlIHVzZWQgdG8gdW5iaW5kIHRoZSBsaXN0ZW5lci5cbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgaG9vaykge1xuICAgIC8vIFRPRE86IFdhcm4gaWYgdGhleSByZWdpc3RlciBmb3IgYSByb3V0ZSB0aGF0IGlzbid0IGN1cnJlbnRseVxuICAgIC8vIGFjdGl2ZS4gVGhleSdyZSBwcm9iYWJseSBkb2luZyBzb21ldGhpbmcgd3JvbmcsIGxpa2UgcmUtY3JlYXRpbmdcbiAgICAvLyByb3V0ZSBvYmplY3RzIG9uIGV2ZXJ5IGxvY2F0aW9uIGNoYW5nZS5cbiAgICB2YXIgcm91dGVJRCA9IGdldFJvdXRlSUQocm91dGUpO1xuICAgIHZhciBob29rcyA9IFJvdXRlSG9va3Nbcm91dGVJRF07XG5cbiAgICBpZiAoIWhvb2tzKSB7XG4gICAgICB2YXIgdGhlcmVXZXJlTm9Sb3V0ZUhvb2tzID0gIWhhc0FueVByb3BlcnRpZXMoUm91dGVIb29rcyk7XG5cbiAgICAgIFJvdXRlSG9va3Nbcm91dGVJRF0gPSBbaG9va107XG5cbiAgICAgIGlmICh0aGVyZVdlcmVOb1JvdXRlSG9va3MpIHtcbiAgICAgICAgLy8gc2V0dXAgdHJhbnNpdGlvbiAmIGJlZm9yZXVubG9hZCBob29rc1xuICAgICAgICB1bmxpc3RlbkJlZm9yZSA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKHRyYW5zaXRpb25Ib29rKTtcblxuICAgICAgICBpZiAoaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQpIHVubGlzdGVuQmVmb3JlVW5sb2FkID0gaGlzdG9yeS5saXN0ZW5CZWZvcmVVbmxvYWQoYmVmb3JlVW5sb2FkSG9vayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChob29rcy5pbmRleE9mKGhvb2spID09PSAtMSkge1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2FkZGluZyBtdWx0aXBsZSBsZWF2ZSBob29rcyBmb3IgdGhlIHNhbWUgcm91dGUgaXMgZGVwcmVjYXRlZDsgbWFuYWdlIG11bHRpcGxlIGNvbmZpcm1hdGlvbnMgaW4geW91ciBvd24gY29kZSBpbnN0ZWFkJykgOiB2b2lkIDA7XG5cbiAgICAgICAgaG9va3MucHVzaChob29rKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGhvb2tzID0gUm91dGVIb29rc1tyb3V0ZUlEXTtcblxuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIHZhciBuZXdIb29rcyA9IGhvb2tzLmZpbHRlcihmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiBpdGVtICE9PSBob29rO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobmV3SG9va3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgcmVtb3ZlTGlzdGVuQmVmb3JlSG9va3NGb3JSb3V0ZShyb3V0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgUm91dGVIb29rc1tyb3V0ZUlEXSA9IG5ld0hvb2tzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGlzIHRoZSBBUEkgZm9yIHN0YXRlZnVsIGVudmlyb25tZW50cy4gQXMgdGhlIGxvY2F0aW9uXG4gICAqIGNoYW5nZXMsIHdlIHVwZGF0ZSBzdGF0ZSBhbmQgY2FsbCB0aGUgbGlzdGVuZXIuIFdlIGNhbiBhbHNvXG4gICAqIGdyYWNlZnVsbHkgaGFuZGxlIGVycm9ycyBhbmQgcmVkaXJlY3RzLlxuICAgKi9cbiAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgLy8gVE9ETzogT25seSB1c2UgYSBzaW5nbGUgaGlzdG9yeSBsaXN0ZW5lci4gT3RoZXJ3aXNlIHdlJ2xsXG4gICAgLy8gZW5kIHVwIHdpdGggbXVsdGlwbGUgY29uY3VycmVudCBjYWxscyB0byBtYXRjaC5cbiAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoc3RhdGUubG9jYXRpb24gPT09IGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKG51bGwsIHN0YXRlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoKGxvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSBpZiAocmVkaXJlY3RMb2NhdGlvbikge1xuICAgICAgICAgICAgaGlzdG9yeS5yZXBsYWNlKHJlZGlyZWN0TG9jYXRpb24pO1xuICAgICAgICAgIH0gZWxzZSBpZiAobmV4dFN0YXRlKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihudWxsLCBuZXh0U3RhdGUpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ0xvY2F0aW9uIFwiJXNcIiBkaWQgbm90IG1hdGNoIGFueSByb3V0ZXMnLCBsb2NhdGlvbi5wYXRobmFtZSArIGxvY2F0aW9uLnNlYXJjaCArIGxvY2F0aW9uLmhhc2gpIDogdm9pZCAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGlzQWN0aXZlOiBpc0FjdGl2ZSxcbiAgICBtYXRjaDogbWF0Y2gsXG4gICAgbGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlOiBsaXN0ZW5CZWZvcmVMZWF2aW5nUm91dGUsXG4gICAgbGlzdGVuOiBsaXN0ZW5cbiAgfTtcbn1cblxuLy9leHBvcnQgZGVmYXVsdCB1c2VSb3V0ZXNcblxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX1BhdHRlcm5VdGlscyA9IHJlcXVpcmUoJy4vUGF0dGVyblV0aWxzJyk7XG5cbmZ1bmN0aW9uIHJvdXRlUGFyYW1zQ2hhbmdlZChyb3V0ZSwgcHJldlN0YXRlLCBuZXh0U3RhdGUpIHtcbiAgaWYgKCFyb3V0ZS5wYXRoKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIHBhcmFtTmFtZXMgPSAoMCwgX1BhdHRlcm5VdGlscy5nZXRQYXJhbU5hbWVzKShyb3V0ZS5wYXRoKTtcblxuICByZXR1cm4gcGFyYW1OYW1lcy5zb21lKGZ1bmN0aW9uIChwYXJhbU5hbWUpIHtcbiAgICByZXR1cm4gcHJldlN0YXRlLnBhcmFtc1twYXJhbU5hbWVdICE9PSBuZXh0U3RhdGUucGFyYW1zW3BhcmFtTmFtZV07XG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IG9mIHsgbGVhdmVSb3V0ZXMsIGNoYW5nZVJvdXRlcywgZW50ZXJSb3V0ZXMgfSBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgY2hhbmdlIGZyb20gcHJldlN0YXRlIHRvIG5leHRTdGF0ZS4gV2UgbGVhdmUgcm91dGVzIGlmIGVpdGhlclxuICogMSkgdGhleSBhcmUgbm90IGluIHRoZSBuZXh0IHN0YXRlIG9yIDIpIHRoZXkgYXJlIGluIHRoZSBuZXh0IHN0YXRlXG4gKiBidXQgdGhlaXIgcGFyYW1zIGhhdmUgY2hhbmdlZCAoaS5lLiAvdXNlcnMvMTIzID0+IC91c2Vycy80NTYpLlxuICpcbiAqIGxlYXZlUm91dGVzIGFyZSBvcmRlcmVkIHN0YXJ0aW5nIGF0IHRoZSBsZWFmIHJvdXRlIG9mIHRoZSB0cmVlXG4gKiB3ZSdyZSBsZWF2aW5nIHVwIHRvIHRoZSBjb21tb24gcGFyZW50IHJvdXRlLiBlbnRlclJvdXRlcyBhcmUgb3JkZXJlZFxuICogZnJvbSB0aGUgdG9wIG9mIHRoZSB0cmVlIHdlJ3JlIGVudGVyaW5nIGRvd24gdG8gdGhlIGxlYWYgcm91dGUuXG4gKlxuICogY2hhbmdlUm91dGVzIGFyZSBhbnkgcm91dGVzIHRoYXQgZGlkbid0IGxlYXZlIG9yIGVudGVyIGR1cmluZ1xuICogdGhlIHRyYW5zaXRpb24uXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVDaGFuZ2VkUm91dGVzKHByZXZTdGF0ZSwgbmV4dFN0YXRlKSB7XG4gIHZhciBwcmV2Um91dGVzID0gcHJldlN0YXRlICYmIHByZXZTdGF0ZS5yb3V0ZXM7XG4gIHZhciBuZXh0Um91dGVzID0gbmV4dFN0YXRlLnJvdXRlcztcblxuICB2YXIgbGVhdmVSb3V0ZXMgPSB2b2lkIDAsXG4gICAgICBjaGFuZ2VSb3V0ZXMgPSB2b2lkIDAsXG4gICAgICBlbnRlclJvdXRlcyA9IHZvaWQgMDtcbiAgaWYgKHByZXZSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhcmVudElzTGVhdmluZyA9IGZhbHNlO1xuICAgICAgbGVhdmVSb3V0ZXMgPSBwcmV2Um91dGVzLmZpbHRlcihmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgaWYgKHBhcmVudElzTGVhdmluZykge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBpc0xlYXZpbmcgPSBuZXh0Um91dGVzLmluZGV4T2Yocm91dGUpID09PSAtMSB8fCByb3V0ZVBhcmFtc0NoYW5nZWQocm91dGUsIHByZXZTdGF0ZSwgbmV4dFN0YXRlKTtcbiAgICAgICAgICBpZiAoaXNMZWF2aW5nKSBwYXJlbnRJc0xlYXZpbmcgPSB0cnVlO1xuICAgICAgICAgIHJldHVybiBpc0xlYXZpbmc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICAvLyBvbkxlYXZlIGhvb2tzIHN0YXJ0IGF0IHRoZSBsZWFmIHJvdXRlLlxuICAgICAgbGVhdmVSb3V0ZXMucmV2ZXJzZSgpO1xuXG4gICAgICBlbnRlclJvdXRlcyA9IFtdO1xuICAgICAgY2hhbmdlUm91dGVzID0gW107XG5cbiAgICAgIG5leHRSb3V0ZXMuZm9yRWFjaChmdW5jdGlvbiAocm91dGUpIHtcbiAgICAgICAgdmFyIGlzTmV3ID0gcHJldlJvdXRlcy5pbmRleE9mKHJvdXRlKSA9PT0gLTE7XG4gICAgICAgIHZhciBwYXJhbXNDaGFuZ2VkID0gbGVhdmVSb3V0ZXMuaW5kZXhPZihyb3V0ZSkgIT09IC0xO1xuXG4gICAgICAgIGlmIChpc05ldyB8fCBwYXJhbXNDaGFuZ2VkKSBlbnRlclJvdXRlcy5wdXNoKHJvdXRlKTtlbHNlIGNoYW5nZVJvdXRlcy5wdXNoKHJvdXRlKTtcbiAgICAgIH0pO1xuICAgIH0pKCk7XG4gIH0gZWxzZSB7XG4gICAgbGVhdmVSb3V0ZXMgPSBbXTtcbiAgICBjaGFuZ2VSb3V0ZXMgPSBbXTtcbiAgICBlbnRlclJvdXRlcyA9IG5leHRSb3V0ZXM7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGxlYXZlUm91dGVzOiBsZWF2ZVJvdXRlcyxcbiAgICBjaGFuZ2VSb3V0ZXM6IGNoYW5nZVJvdXRlcyxcbiAgICBlbnRlclJvdXRlczogZW50ZXJSb3V0ZXNcbiAgfTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gY29tcHV0ZUNoYW5nZWRSb3V0ZXM7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvY29tcHV0ZUNoYW5nZWRSb3V0ZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLnJ1bkVudGVySG9va3MgPSBydW5FbnRlckhvb2tzO1xuZXhwb3J0cy5ydW5DaGFuZ2VIb29rcyA9IHJ1bkNoYW5nZUhvb2tzO1xuZXhwb3J0cy5ydW5MZWF2ZUhvb2tzID0gcnVuTGVhdmVIb29rcztcblxudmFyIF9Bc3luY1V0aWxzID0gcmVxdWlyZSgnLi9Bc3luY1V0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zaXRpb25Ib29rKGhvb2ssIHJvdXRlLCBhc3luY0FyaXR5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgaG9vay5hcHBseShyb3V0ZSwgYXJncyk7XG5cbiAgICBpZiAoaG9vay5sZW5ndGggPCBhc3luY0FyaXR5KSB7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAvLyBBc3N1bWUgaG9vayBleGVjdXRlcyBzeW5jaHJvbm91c2x5IGFuZFxuICAgICAgLy8gYXV0b21hdGljYWxseSBjYWxsIHRoZSBjYWxsYmFjay5cbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRFbnRlckhvb2tzKHJvdXRlcykge1xuICByZXR1cm4gcm91dGVzLnJlZHVjZShmdW5jdGlvbiAoaG9va3MsIHJvdXRlKSB7XG4gICAgaWYgKHJvdXRlLm9uRW50ZXIpIGhvb2tzLnB1c2goY3JlYXRlVHJhbnNpdGlvbkhvb2socm91dGUub25FbnRlciwgcm91dGUsIDMpKTtcblxuICAgIHJldHVybiBob29rcztcbiAgfSwgW10pO1xufVxuXG5mdW5jdGlvbiBnZXRDaGFuZ2VIb29rcyhyb3V0ZXMpIHtcbiAgcmV0dXJuIHJvdXRlcy5yZWR1Y2UoZnVuY3Rpb24gKGhvb2tzLCByb3V0ZSkge1xuICAgIGlmIChyb3V0ZS5vbkNoYW5nZSkgaG9va3MucHVzaChjcmVhdGVUcmFuc2l0aW9uSG9vayhyb3V0ZS5vbkNoYW5nZSwgcm91dGUsIDQpKTtcbiAgICByZXR1cm4gaG9va3M7XG4gIH0sIFtdKTtcbn1cblxuZnVuY3Rpb24gcnVuVHJhbnNpdGlvbkhvb2tzKGxlbmd0aCwgaXRlciwgY2FsbGJhY2spIHtcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBjYWxsYmFjaygpO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHZhciByZWRpcmVjdEluZm8gPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIHJlcGxhY2UobG9jYXRpb24sIGRlcHJlY2F0ZWRQYXRobmFtZSwgZGVwcmVjYXRlZFF1ZXJ5KSB7XG4gICAgaWYgKGRlcHJlY2F0ZWRQYXRobmFtZSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdgcmVwbGFjZVN0YXRlKHN0YXRlLCBwYXRobmFtZSwgcXVlcnkpIGlzIGRlcHJlY2F0ZWQ7IHVzZSBgcmVwbGFjZShsb2NhdGlvbilgIHdpdGggYSBsb2NhdGlvbiBkZXNjcmlwdG9yIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1pc0FjdGl2ZWRlcHJlY2F0ZWQnKSA6IHZvaWQgMDtcbiAgICAgIHJlZGlyZWN0SW5mbyA9IHtcbiAgICAgICAgcGF0aG5hbWU6IGRlcHJlY2F0ZWRQYXRobmFtZSxcbiAgICAgICAgcXVlcnk6IGRlcHJlY2F0ZWRRdWVyeSxcbiAgICAgICAgc3RhdGU6IGxvY2F0aW9uXG4gICAgICB9O1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgcmVkaXJlY3RJbmZvID0gbG9jYXRpb247XG4gIH1cblxuICAoMCwgX0FzeW5jVXRpbHMubG9vcEFzeW5jKShsZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgbmV4dCwgZG9uZSkge1xuICAgIGl0ZXIoaW5kZXgsIHJlcGxhY2UsIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIHx8IHJlZGlyZWN0SW5mbykge1xuICAgICAgICBkb25lKGVycm9yLCByZWRpcmVjdEluZm8pOyAvLyBObyBuZWVkIHRvIGNvbnRpbnVlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmV4dCgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25FbnRlciBob29rcyBpbiB0aGUgZ2l2ZW4gYXJyYXkgb2Ygcm91dGVzIGluIG9yZGVyXG4gKiB3aXRoIG9uRW50ZXIobmV4dFN0YXRlLCByZXBsYWNlLCBjYWxsYmFjaykgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgcmVkaXJlY3RJbmZvKSB3aGVuIGZpbmlzaGVkLiBUaGUgZmlyc3QgaG9va1xuICogdG8gdXNlIHJlcGxhY2Ugc2hvcnQtY2lyY3VpdHMgdGhlIGxvb3AuXG4gKlxuICogSWYgYSBob29rIG5lZWRzIHRvIHJ1biBhc3luY2hyb25vdXNseSwgaXQgbWF5IHVzZSB0aGUgY2FsbGJhY2tcbiAqIGZ1bmN0aW9uLiBIb3dldmVyLCBkb2luZyBzbyB3aWxsIGNhdXNlIHRoZSB0cmFuc2l0aW9uIHRvIHBhdXNlLFxuICogd2hpY2ggY291bGQgbGVhZCB0byBhIG5vbi1yZXNwb25zaXZlIFVJIGlmIHRoZSBob29rIGlzIHNsb3cuXG4gKi9cbmZ1bmN0aW9uIHJ1bkVudGVySG9va3Mocm91dGVzLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldEVudGVySG9va3Mocm91dGVzKTtcbiAgcmV0dXJuIHJ1blRyYW5zaXRpb25Ib29rcyhob29rcy5sZW5ndGgsIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZSwgbmV4dCkge1xuICAgIGhvb2tzW2luZGV4XShuZXh0U3RhdGUsIHJlcGxhY2UsIG5leHQpO1xuICB9LCBjYWxsYmFjayk7XG59XG5cbi8qKlxuICogUnVucyBhbGwgb25DaGFuZ2UgaG9va3MgaW4gdGhlIGdpdmVuIGFycmF5IG9mIHJvdXRlcyBpbiBvcmRlclxuICogd2l0aCBvbkNoYW5nZShwcmV2U3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgY2FsbGJhY2spIGFuZCBjYWxsc1xuICogY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0SW5mbykgd2hlbiBmaW5pc2hlZC4gVGhlIGZpcnN0IGhvb2tcbiAqIHRvIHVzZSByZXBsYWNlIHNob3J0LWNpcmN1aXRzIHRoZSBsb29wLlxuICpcbiAqIElmIGEgaG9vayBuZWVkcyB0byBydW4gYXN5bmNocm9ub3VzbHksIGl0IG1heSB1c2UgdGhlIGNhbGxiYWNrXG4gKiBmdW5jdGlvbi4gSG93ZXZlciwgZG9pbmcgc28gd2lsbCBjYXVzZSB0aGUgdHJhbnNpdGlvbiB0byBwYXVzZSxcbiAqIHdoaWNoIGNvdWxkIGxlYWQgdG8gYSBub24tcmVzcG9uc2l2ZSBVSSBpZiB0aGUgaG9vayBpcyBzbG93LlxuICovXG5mdW5jdGlvbiBydW5DaGFuZ2VIb29rcyhyb3V0ZXMsIHN0YXRlLCBuZXh0U3RhdGUsIGNhbGxiYWNrKSB7XG4gIHZhciBob29rcyA9IGdldENoYW5nZUhvb2tzKHJvdXRlcyk7XG4gIHJldHVybiBydW5UcmFuc2l0aW9uSG9va3MoaG9va3MubGVuZ3RoLCBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2UsIG5leHQpIHtcbiAgICBob29rc1tpbmRleF0oc3RhdGUsIG5leHRTdGF0ZSwgcmVwbGFjZSwgbmV4dCk7XG4gIH0sIGNhbGxiYWNrKTtcbn1cblxuLyoqXG4gKiBSdW5zIGFsbCBvbkxlYXZlIGhvb2tzIGluIHRoZSBnaXZlbiBhcnJheSBvZiByb3V0ZXMgaW4gb3JkZXIuXG4gKi9cbmZ1bmN0aW9uIHJ1bkxlYXZlSG9va3Mocm91dGVzLCBwcmV2U3RhdGUpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHJvdXRlcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChyb3V0ZXNbaV0ub25MZWF2ZSkgcm91dGVzW2ldLm9uTGVhdmUuY2FsbChyb3V0ZXNbaV0sIHByZXZTdGF0ZSk7XG4gIH1cbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvVHJhbnNpdGlvblV0aWxzLmpzIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmxvb3BBc3luYyA9IGxvb3BBc3luYztcbmV4cG9ydHMubWFwQXN5bmMgPSBtYXBBc3luYztcbmZ1bmN0aW9uIGxvb3BBc3luYyh0dXJucywgd29yaywgY2FsbGJhY2spIHtcbiAgdmFyIGN1cnJlbnRUdXJuID0gMCxcbiAgICAgIGlzRG9uZSA9IGZhbHNlO1xuICB2YXIgc3luYyA9IGZhbHNlLFxuICAgICAgaGFzTmV4dCA9IGZhbHNlLFxuICAgICAgZG9uZUFyZ3MgPSB2b2lkIDA7XG5cbiAgZnVuY3Rpb24gZG9uZSgpIHtcbiAgICBpc0RvbmUgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgZG9uZUFyZ3MgPSBbXS5jb25jYXQoQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc05leHQgPSB0cnVlO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICAvLyBJdGVyYXRlIGluc3RlYWQgb2YgcmVjdXJzaW5nIGlmIHBvc3NpYmxlLlxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHN5bmMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKCFpc0RvbmUgJiYgY3VycmVudFR1cm4gPCB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBoYXNOZXh0ID0gZmFsc2U7XG4gICAgICB3b3JrLmNhbGwodGhpcywgY3VycmVudFR1cm4rKywgbmV4dCwgZG9uZSk7XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuXG4gICAgaWYgKGlzRG9uZSkge1xuICAgICAgLy8gVGhpcyBtZWFucyB0aGUgbG9vcCBmaW5pc2hlZCBzeW5jaHJvbm91c2x5LlxuICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgZG9uZUFyZ3MpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChjdXJyZW50VHVybiA+PSB0dXJucyAmJiBoYXNOZXh0KSB7XG4gICAgICBpc0RvbmUgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICBuZXh0KCk7XG59XG5cbmZ1bmN0aW9uIG1hcEFzeW5jKGFycmF5LCB3b3JrLCBjYWxsYmFjaykge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICB2YXIgdmFsdWVzID0gW107XG5cbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHZhbHVlcyk7XG5cbiAgdmFyIGlzRG9uZSA9IGZhbHNlLFxuICAgICAgZG9uZUNvdW50ID0gMDtcblxuICBmdW5jdGlvbiBkb25lKGluZGV4LCBlcnJvciwgdmFsdWUpIHtcbiAgICBpZiAoaXNEb25lKSByZXR1cm47XG5cbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGlzRG9uZSA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcblxuICAgICAgaXNEb25lID0gKytkb25lQ291bnQgPT09IGxlbmd0aDtcblxuICAgICAgaWYgKGlzRG9uZSkgY2FsbGJhY2sobnVsbCwgdmFsdWVzKTtcbiAgICB9XG4gIH1cblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgIHdvcmsoaXRlbSwgaW5kZXgsIGZ1bmN0aW9uIChlcnJvciwgdmFsdWUpIHtcbiAgICAgIGRvbmUoaW5kZXgsIGVycm9yLCB2YWx1ZSk7XG4gICAgfSk7XG4gIH0pO1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Bc3luY1V0aWxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gaXNBY3RpdmU7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgaWYgKGEgPT0gYikgcmV0dXJuIHRydWU7XG5cbiAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGIpICYmIGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJiBhLmV2ZXJ5KGZ1bmN0aW9uIChpdGVtLCBpbmRleCkge1xuICAgICAgcmV0dXJuIGRlZXBFcXVhbChpdGVtLCBiW2luZGV4XSk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoKHR5cGVvZiBhID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihhKSkgPT09ICdvYmplY3QnKSB7XG4gICAgZm9yICh2YXIgcCBpbiBhKSB7XG4gICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhLCBwKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoYltwXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmICghZGVlcEVxdWFsKGFbcF0sIGJbcF0pKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBTdHJpbmcoYSkgPT09IFN0cmluZyhiKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGN1cnJlbnQgcGF0aG5hbWUgbWF0Y2hlcyB0aGUgc3VwcGxpZWQgb25lLCBuZXQgb2ZcbiAqIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNsYXNoIG5vcm1hbGl6YXRpb24uIFRoaXMgaXMgc3VmZmljaWVudCBmb3IgYW5cbiAqIGluZGV4T25seSByb3V0ZSBtYXRjaC5cbiAqL1xuZnVuY3Rpb24gcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50UGF0aG5hbWUpIHtcbiAgLy8gTm9ybWFsaXplIGxlYWRpbmcgc2xhc2ggZm9yIGNvbnNpc3RlbmN5LiBMZWFkaW5nIHNsYXNoIG9uIHBhdGhuYW1lIGhhc1xuICAvLyBhbHJlYWR5IGJlZW4gbm9ybWFsaXplZCBpbiBpc0FjdGl2ZS4gU2VlIGNhdmVhdCB0aGVyZS5cbiAgaWYgKGN1cnJlbnRQYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSA9ICcvJyArIGN1cnJlbnRQYXRobmFtZTtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgZW5kIG9mIGJvdGggcGF0aCBuYW1lcyB0b28uIE1heWJlIGAvZm9vL2Agc2hvdWxkbid0IHNob3dcbiAgLy8gYC9mb29gIGFzIGFjdGl2ZSwgYnV0IGluIHRoaXMgY2FzZSwgd2Ugd291bGQgYWxyZWFkeSBoYXZlIGZhaWxlZCB0aGVcbiAgLy8gbWF0Y2guXG4gIGlmIChwYXRobmFtZS5jaGFyQXQocGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIHBhdGhuYW1lICs9ICcvJztcbiAgfVxuICBpZiAoY3VycmVudFBhdGhuYW1lLmNoYXJBdChjdXJyZW50UGF0aG5hbWUubGVuZ3RoIC0gMSkgIT09ICcvJykge1xuICAgIGN1cnJlbnRQYXRobmFtZSArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gY3VycmVudFBhdGhuYW1lID09PSBwYXRobmFtZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIHBhdGhuYW1lIG1hdGNoZXMgdGhlIGFjdGl2ZSByb3V0ZXMgYW5kIHBhcmFtcy5cbiAqL1xuZnVuY3Rpb24gcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHJlbWFpbmluZ1BhdGhuYW1lID0gcGF0aG5hbWUsXG4gICAgICBwYXJhbU5hbWVzID0gW10sXG4gICAgICBwYXJhbVZhbHVlcyA9IFtdO1xuXG4gIC8vIGZvci4uLm9mIHdvdWxkIHdvcmsgaGVyZSBidXQgaXQncyBwcm9iYWJseSBzbG93ZXIgcG9zdC10cmFuc3BpbGF0aW9uLlxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gcm91dGVzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgdmFyIHJvdXRlID0gcm91dGVzW2ldO1xuICAgIHZhciBwYXR0ZXJuID0gcm91dGUucGF0aCB8fCAnJztcblxuICAgIGlmIChwYXR0ZXJuLmNoYXJBdCgwKSA9PT0gJy8nKSB7XG4gICAgICByZW1haW5pbmdQYXRobmFtZSA9IHBhdGhuYW1lO1xuICAgICAgcGFyYW1OYW1lcyA9IFtdO1xuICAgICAgcGFyYW1WYWx1ZXMgPSBbXTtcbiAgICB9XG5cbiAgICBpZiAocmVtYWluaW5nUGF0aG5hbWUgIT09IG51bGwgJiYgcGF0dGVybikge1xuICAgICAgdmFyIG1hdGNoZWQgPSAoMCwgX1BhdHRlcm5VdGlscy5tYXRjaFBhdHRlcm4pKHBhdHRlcm4sIHJlbWFpbmluZ1BhdGhuYW1lKTtcbiAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgIHJlbWFpbmluZ1BhdGhuYW1lID0gbWF0Y2hlZC5yZW1haW5pbmdQYXRobmFtZTtcbiAgICAgICAgcGFyYW1OYW1lcyA9IFtdLmNvbmNhdChwYXJhbU5hbWVzLCBtYXRjaGVkLnBhcmFtTmFtZXMpO1xuICAgICAgICBwYXJhbVZhbHVlcyA9IFtdLmNvbmNhdChwYXJhbVZhbHVlcywgbWF0Y2hlZC5wYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgICAgLy8gV2UgaGF2ZSBhbiBleGFjdCBtYXRjaCBvbiB0aGUgcm91dGUuIEp1c3QgY2hlY2sgdGhhdCBhbGwgdGhlIHBhcmFtc1xuICAgICAgICAvLyBtYXRjaC5cbiAgICAgICAgLy8gRklYTUU6IFRoaXMgZG9lc24ndCB3b3JrIG9uIHJlcGVhdGVkIHBhcmFtcy5cbiAgICAgICAgcmV0dXJuIHBhcmFtTmFtZXMuZXZlcnkoZnVuY3Rpb24gKHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gU3RyaW5nKHBhcmFtVmFsdWVzW2luZGV4XSkgPT09IFN0cmluZyhwYXJhbXNbcGFyYW1OYW1lXSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYWxsIGtleS92YWx1ZSBwYWlycyBpbiB0aGUgZ2l2ZW4gcXVlcnkgYXJlXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBxdWVyeUlzQWN0aXZlKHF1ZXJ5LCBhY3RpdmVRdWVyeSkge1xuICBpZiAoYWN0aXZlUXVlcnkgPT0gbnVsbCkgcmV0dXJuIHF1ZXJ5ID09IG51bGw7XG5cbiAgaWYgKHF1ZXJ5ID09IG51bGwpIHJldHVybiB0cnVlO1xuXG4gIHJldHVybiBkZWVwRXF1YWwocXVlcnksIGFjdGl2ZVF1ZXJ5KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSA8TGluaz4gdG8gdGhlIGdpdmVuIHBhdGhuYW1lL3F1ZXJ5IGNvbWJpbmF0aW9uIGlzXG4gKiBjdXJyZW50bHkgYWN0aXZlLlxuICovXG5mdW5jdGlvbiBpc0FjdGl2ZShfcmVmLCBpbmRleE9ubHksIGN1cnJlbnRMb2NhdGlvbiwgcm91dGVzLCBwYXJhbXMpIHtcbiAgdmFyIHBhdGhuYW1lID0gX3JlZi5wYXRobmFtZTtcbiAgdmFyIHF1ZXJ5ID0gX3JlZi5xdWVyeTtcblxuICBpZiAoY3VycmVudExvY2F0aW9uID09IG51bGwpIHJldHVybiBmYWxzZTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIGEgYml0IHVnbHkuIEl0IGtlZXBzIGFyb3VuZCBzdXBwb3J0IGZvciB0cmVhdGluZyBwYXRobmFtZXNcbiAgLy8gd2l0aG91dCBwcmVjZWRpbmcgc2xhc2hlcyBhcyBhYnNvbHV0ZSBwYXRocywgYnV0IHBvc3NpYmx5IGFsc28gd29ya3NcbiAgLy8gYXJvdW5kIHRoZSBzYW1lIHF1aXJrcyB3aXRoIGJhc2VuYW1lcyBhcyBpbiBtYXRjaFJvdXRlcy5cbiAgaWYgKHBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfVxuXG4gIGlmICghcGF0aElzQWN0aXZlKHBhdGhuYW1lLCBjdXJyZW50TG9jYXRpb24ucGF0aG5hbWUpKSB7XG4gICAgLy8gVGhlIHBhdGggY2hlY2sgaXMgbmVjZXNzYXJ5IGFuZCBzdWZmaWNpZW50IGZvciBpbmRleE9ubHksIGJ1dCBvdGhlcndpc2VcbiAgICAvLyB3ZSBzdGlsbCBuZWVkIHRvIGNoZWNrIHRoZSByb3V0ZXMuXG4gICAgaWYgKGluZGV4T25seSB8fCAhcm91dGVJc0FjdGl2ZShwYXRobmFtZSwgcm91dGVzLCBwYXJhbXMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHF1ZXJ5SXNBY3RpdmUocXVlcnksIGN1cnJlbnRMb2NhdGlvbi5xdWVyeSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvaXNBY3RpdmUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbWFrZVN0YXRlV2l0aExvY2F0aW9uJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VTdGF0ZVdpdGhMb2NhdGlvbik7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudHNGb3JSb3V0ZShuZXh0U3RhdGUsIHJvdXRlLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuY29tcG9uZW50IHx8IHJvdXRlLmNvbXBvbmVudHMpIHtcbiAgICBjYWxsYmFjayhudWxsLCByb3V0ZS5jb21wb25lbnQgfHwgcm91dGUuY29tcG9uZW50cyk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGdldENvbXBvbmVudCA9IHJvdXRlLmdldENvbXBvbmVudCB8fCByb3V0ZS5nZXRDb21wb25lbnRzO1xuICBpZiAoIWdldENvbXBvbmVudCkge1xuICAgIGNhbGxiYWNrKCk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGxvY2F0aW9uID0gbmV4dFN0YXRlLmxvY2F0aW9uO1xuXG4gIHZhciBuZXh0U3RhdGVXaXRoTG9jYXRpb24gPSAoMCwgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbjIuZGVmYXVsdCkobmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgZ2V0Q29tcG9uZW50LmNhbGwocm91dGUsIG5leHRTdGF0ZVdpdGhMb2NhdGlvbiwgY2FsbGJhY2spO1xufVxuXG4vKipcbiAqIEFzeW5jaHJvbm91c2x5IGZldGNoZXMgYWxsIGNvbXBvbmVudHMgbmVlZGVkIGZvciB0aGUgZ2l2ZW4gcm91dGVyXG4gKiBzdGF0ZSBhbmQgY2FsbHMgY2FsbGJhY2soZXJyb3IsIGNvbXBvbmVudHMpIHdoZW4gZmluaXNoZWQuXG4gKlxuICogTm90ZTogVGhpcyBvcGVyYXRpb24gbWF5IGZpbmlzaCBzeW5jaHJvbm91c2x5IGlmIG5vIHJvdXRlcyBoYXZlIGFuXG4gKiBhc3luY2hyb25vdXMgZ2V0Q29tcG9uZW50cyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIGdldENvbXBvbmVudHMobmV4dFN0YXRlLCBjYWxsYmFjaykge1xuICAoMCwgX0FzeW5jVXRpbHMubWFwQXN5bmMpKG5leHRTdGF0ZS5yb3V0ZXMsIGZ1bmN0aW9uIChyb3V0ZSwgaW5kZXgsIGNhbGxiYWNrKSB7XG4gICAgZ2V0Q29tcG9uZW50c0ZvclJvdXRlKG5leHRTdGF0ZSwgcm91dGUsIGNhbGxiYWNrKTtcbiAgfSwgY2FsbGJhY2spO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRDb21wb25lbnRzO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL2dldENvbXBvbmVudHMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IG1ha2VTdGF0ZVdpdGhMb2NhdGlvbjtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzID0gcmVxdWlyZSgnLi9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIG1ha2VTdGF0ZVdpdGhMb2NhdGlvbihzdGF0ZSwgbG9jYXRpb24pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMuY2FuVXNlTWVtYnJhbmUpIHtcbiAgICB2YXIgc3RhdGVXaXRoTG9jYXRpb24gPSBfZXh0ZW5kcyh7fSwgc3RhdGUpO1xuXG4gICAgLy8gSSBkb24ndCB1c2UgZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyBoZXJlIGJlY2F1c2UgSSB3YW50IHRvIGtlZXAgdGhlXG4gICAgLy8gc2FtZSBjb2RlIHBhdGggYmV0d2VlbiBkZXZlbG9wbWVudCBhbmQgcHJvZHVjdGlvbiwgaW4gdGhhdCB3ZSBqdXN0XG4gICAgLy8gYXNzaWduIGV4dHJhIHByb3BlcnRpZXMgdG8gdGhlIGNvcHkgb2YgdGhlIHN0YXRlIG9iamVjdCBpbiBib3RoIGNhc2VzLlxuXG4gICAgdmFyIF9sb29wID0gZnVuY3Rpb24gX2xvb3AocHJvcCkge1xuICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobG9jYXRpb24sIHByb3ApKSB7XG4gICAgICAgIHJldHVybiAnY29udGludWUnO1xuICAgICAgfVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoc3RhdGVXaXRoTG9jYXRpb24sIHByb3AsIHtcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoZmFsc2UsICdBY2Nlc3NpbmcgbG9jYXRpb24gcHJvcGVydGllcyBkaXJlY3RseSBmcm9tIHRoZSBmaXJzdCBhcmd1bWVudCB0byBgZ2V0Q29tcG9uZW50YCwgYGdldENvbXBvbmVudHNgLCBgZ2V0Q2hpbGRSb3V0ZXNgLCBhbmQgYGdldEluZGV4Um91dGVgIGlzIGRlcHJlY2F0ZWQuIFRoYXQgYXJndW1lbnQgaXMgbm93IHRoZSByb3V0ZXIgc3RhdGUgKGBuZXh0U3RhdGVgIG9yIGBwYXJ0aWFsTmV4dFN0YXRlYCkgcmF0aGVyIHRoYW4gdGhlIGxvY2F0aW9uLiBUbyBhY2Nlc3MgdGhlIGxvY2F0aW9uLCB1c2UgYG5leHRTdGF0ZS5sb2NhdGlvbmAgb3IgYHBhcnRpYWxOZXh0U3RhdGUubG9jYXRpb25gLicpIDogdm9pZCAwO1xuICAgICAgICAgIHJldHVybiBsb2NhdGlvbltwcm9wXTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGZvciAodmFyIHByb3AgaW4gbG9jYXRpb24pIHtcbiAgICAgIHZhciBfcmV0ID0gX2xvb3AocHJvcCk7XG5cbiAgICAgIGlmIChfcmV0ID09PSAnY29udGludWUnKSBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdGVXaXRoTG9jYXRpb247XG4gIH1cblxuICByZXR1cm4gX2V4dGVuZHMoe30sIHN0YXRlLCBsb2NhdGlvbik7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvbWFrZVN0YXRlV2l0aExvY2F0aW9uLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2hSb3V0ZXM7XG5cbnZhciBfQXN5bmNVdGlscyA9IHJlcXVpcmUoJy4vQXN5bmNVdGlscycpO1xuXG52YXIgX21ha2VTdGF0ZVdpdGhMb2NhdGlvbiA9IHJlcXVpcmUoJy4vbWFrZVN0YXRlV2l0aExvY2F0aW9uJyk7XG5cbnZhciBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX21ha2VTdGF0ZVdpdGhMb2NhdGlvbik7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGdldENoaWxkUm91dGVzKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGNhbGxiYWNrKSB7XG4gIGlmIChyb3V0ZS5jaGlsZFJvdXRlcykge1xuICAgIHJldHVybiBbbnVsbCwgcm91dGUuY2hpbGRSb3V0ZXNdO1xuICB9XG4gIGlmICghcm91dGUuZ2V0Q2hpbGRSb3V0ZXMpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICB2YXIgc3luYyA9IHRydWUsXG4gICAgICByZXN1bHQgPSB2b2lkIDA7XG5cbiAgdmFyIHBhcnRpYWxOZXh0U3RhdGUgPSB7XG4gICAgbG9jYXRpb246IGxvY2F0aW9uLFxuICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICB9O1xuXG4gIHZhciBwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uID0gKDAsIF9tYWtlU3RhdGVXaXRoTG9jYXRpb24yLmRlZmF1bHQpKHBhcnRpYWxOZXh0U3RhdGUsIGxvY2F0aW9uKTtcblxuICByb3V0ZS5nZXRDaGlsZFJvdXRlcyhwYXJ0aWFsTmV4dFN0YXRlV2l0aExvY2F0aW9uLCBmdW5jdGlvbiAoZXJyb3IsIGNoaWxkUm91dGVzKSB7XG4gICAgY2hpbGRSb3V0ZXMgPSAhZXJyb3IgJiYgKDAsIF9Sb3V0ZVV0aWxzLmNyZWF0ZVJvdXRlcykoY2hpbGRSb3V0ZXMpO1xuICAgIGlmIChzeW5jKSB7XG4gICAgICByZXN1bHQgPSBbZXJyb3IsIGNoaWxkUm91dGVzXTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhlcnJvciwgY2hpbGRSb3V0ZXMpO1xuICB9KTtcblxuICBzeW5jID0gZmFsc2U7XG4gIHJldHVybiByZXN1bHQ7IC8vIE1pZ2h0IGJlIHVuZGVmaW5lZC5cbn1cblxuZnVuY3Rpb24gZ2V0SW5kZXhSb3V0ZShyb3V0ZSwgbG9jYXRpb24sIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICBpZiAocm91dGUuaW5kZXhSb3V0ZSkge1xuICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlLmluZGV4Um91dGUpO1xuICB9IGVsc2UgaWYgKHJvdXRlLmdldEluZGV4Um91dGUpIHtcbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZSA9IHtcbiAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgIHBhcmFtczogY3JlYXRlUGFyYW1zKHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzKVxuICAgIH07XG5cbiAgICB2YXIgcGFydGlhbE5leHRTdGF0ZVdpdGhMb2NhdGlvbiA9ICgwLCBfbWFrZVN0YXRlV2l0aExvY2F0aW9uMi5kZWZhdWx0KShwYXJ0aWFsTmV4dFN0YXRlLCBsb2NhdGlvbik7XG5cbiAgICByb3V0ZS5nZXRJbmRleFJvdXRlKHBhcnRpYWxOZXh0U3RhdGVXaXRoTG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgY2FsbGJhY2soZXJyb3IsICFlcnJvciAmJiAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShpbmRleFJvdXRlKVswXSk7XG4gICAgfSk7XG4gIH0gZWxzZSBpZiAocm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIHBhdGhsZXNzID0gcm91dGUuY2hpbGRSb3V0ZXMuZmlsdGVyKGZ1bmN0aW9uIChjaGlsZFJvdXRlKSB7XG4gICAgICAgIHJldHVybiAhY2hpbGRSb3V0ZS5wYXRoO1xuICAgICAgfSk7XG5cbiAgICAgICgwLCBfQXN5bmNVdGlscy5sb29wQXN5bmMpKHBhdGhsZXNzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgICAgIGdldEluZGV4Um91dGUocGF0aGxlc3NbaW5kZXhdLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvciB8fCBpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICB2YXIgcm91dGVzID0gW3BhdGhsZXNzW2luZGV4XV0uY29uY2F0KEFycmF5LmlzQXJyYXkoaW5kZXhSb3V0ZSkgPyBpbmRleFJvdXRlIDogW2luZGV4Um91dGVdKTtcbiAgICAgICAgICAgIGRvbmUoZXJyb3IsIHJvdXRlcyk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSwgZnVuY3Rpb24gKGVyciwgcm91dGVzKSB7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIHJvdXRlcyk7XG4gICAgICB9KTtcbiAgICB9KSgpO1xuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzaWduUGFyYW1zKHBhcmFtcywgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMpIHtcbiAgcmV0dXJuIHBhcmFtTmFtZXMucmVkdWNlKGZ1bmN0aW9uIChwYXJhbXMsIHBhcmFtTmFtZSwgaW5kZXgpIHtcbiAgICB2YXIgcGFyYW1WYWx1ZSA9IHBhcmFtVmFsdWVzICYmIHBhcmFtVmFsdWVzW2luZGV4XTtcblxuICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtc1twYXJhbU5hbWVdKSkge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0ucHVzaChwYXJhbVZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtTmFtZSBpbiBwYXJhbXMpIHtcbiAgICAgIHBhcmFtc1twYXJhbU5hbWVdID0gW3BhcmFtc1twYXJhbU5hbWVdLCBwYXJhbVZhbHVlXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1zW3BhcmFtTmFtZV0gPSBwYXJhbVZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH0sIHBhcmFtcyk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcykge1xuICByZXR1cm4gYXNzaWduUGFyYW1zKHt9LCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoUm91dGVEZWVwKHJvdXRlLCBsb2NhdGlvbiwgcmVtYWluaW5nUGF0aG5hbWUsIHBhcmFtTmFtZXMsIHBhcmFtVmFsdWVzLCBjYWxsYmFjaykge1xuICB2YXIgcGF0dGVybiA9IHJvdXRlLnBhdGggfHwgJyc7XG5cbiAgaWYgKHBhdHRlcm4uY2hhckF0KDApID09PSAnLycpIHtcbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICAgIHBhcmFtTmFtZXMgPSBbXTtcbiAgICBwYXJhbVZhbHVlcyA9IFtdO1xuICB9XG5cbiAgLy8gT25seSB0cnkgdG8gbWF0Y2ggdGhlIHBhdGggaWYgdGhlIHJvdXRlIGFjdHVhbGx5IGhhcyBhIHBhdHRlcm4sIGFuZCBpZlxuICAvLyB3ZSdyZSBub3QganVzdCBzZWFyY2hpbmcgZm9yIHBvdGVudGlhbCBuZXN0ZWQgYWJzb2x1dGUgcGF0aHMuXG4gIGlmIChyZW1haW5pbmdQYXRobmFtZSAhPT0gbnVsbCAmJiBwYXR0ZXJuKSB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBtYXRjaGVkID0gKDAsIF9QYXR0ZXJuVXRpbHMubWF0Y2hQYXR0ZXJuKShwYXR0ZXJuLCByZW1haW5pbmdQYXRobmFtZSk7XG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICByZW1haW5pbmdQYXRobmFtZSA9IG1hdGNoZWQucmVtYWluaW5nUGF0aG5hbWU7XG4gICAgICAgIHBhcmFtTmFtZXMgPSBbXS5jb25jYXQocGFyYW1OYW1lcywgbWF0Y2hlZC5wYXJhbU5hbWVzKTtcbiAgICAgICAgcGFyYW1WYWx1ZXMgPSBbXS5jb25jYXQocGFyYW1WYWx1ZXMsIG1hdGNoZWQucGFyYW1WYWx1ZXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVtYWluaW5nUGF0aG5hbWUgPSBudWxsO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfVxuXG4gICAgLy8gQnkgYXNzdW1wdGlvbiwgcGF0dGVybiBpcyBub24tZW1wdHkgaGVyZSwgd2hpY2ggaXMgdGhlIHByZXJlcXVpc2l0ZSBmb3JcbiAgICAvLyBhY3R1YWxseSB0ZXJtaW5hdGluZyBhIG1hdGNoLlxuICAgIGlmIChyZW1haW5pbmdQYXRobmFtZSA9PT0gJycpIHtcbiAgICAgIHZhciBfcmV0MiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0ge1xuICAgICAgICAgIHJvdXRlczogW3JvdXRlXSxcbiAgICAgICAgICBwYXJhbXM6IGNyZWF0ZVBhcmFtcyhwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcylcbiAgICAgICAgfTtcblxuICAgICAgICBnZXRJbmRleFJvdXRlKHJvdXRlLCBsb2NhdGlvbiwgcGFyYW1OYW1lcywgcGFyYW1WYWx1ZXMsIGZ1bmN0aW9uIChlcnJvciwgaW5kZXhSb3V0ZSkge1xuICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShpbmRleFJvdXRlKSkge1xuICAgICAgICAgICAgICB2YXIgX21hdGNoJHJvdXRlcztcblxuICAgICAgICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShpbmRleFJvdXRlLmV2ZXJ5KGZ1bmN0aW9uIChyb3V0ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhcm91dGUucGF0aDtcbiAgICAgICAgICAgICAgfSksICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIChfbWF0Y2gkcm91dGVzID0gbWF0Y2gucm91dGVzKS5wdXNoLmFwcGx5KF9tYXRjaCRyb3V0ZXMsIGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpbmRleFJvdXRlKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKCFpbmRleFJvdXRlLnBhdGgsICdJbmRleCByb3V0ZXMgc2hvdWxkIG5vdCBoYXZlIHBhdGhzJykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIG1hdGNoLnJvdXRlcy5wdXNoKGluZGV4Um91dGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBtYXRjaCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHY6IHZvaWQgMFxuICAgICAgICB9O1xuICAgICAgfSgpO1xuXG4gICAgICBpZiAoKHR5cGVvZiBfcmV0MiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YoX3JldDIpKSA9PT0gXCJvYmplY3RcIikgcmV0dXJuIF9yZXQyLnY7XG4gICAgfVxuICB9XG5cbiAgaWYgKHJlbWFpbmluZ1BhdGhuYW1lICE9IG51bGwgfHwgcm91dGUuY2hpbGRSb3V0ZXMpIHtcbiAgICAvLyBFaXRoZXIgYSkgdGhpcyByb3V0ZSBtYXRjaGVkIGF0IGxlYXN0IHNvbWUgb2YgdGhlIHBhdGggb3IgYilcbiAgICAvLyB3ZSBkb24ndCBoYXZlIHRvIGxvYWQgdGhpcyByb3V0ZSdzIGNoaWxkcmVuIGFzeW5jaHJvbm91c2x5LiBJblxuICAgIC8vIGVpdGhlciBjYXNlIGNvbnRpbnVlIGNoZWNraW5nIGZvciBtYXRjaGVzIGluIHRoZSBzdWJ0cmVlLlxuICAgIHZhciBvbkNoaWxkUm91dGVzID0gZnVuY3Rpb24gb25DaGlsZFJvdXRlcyhlcnJvciwgY2hpbGRSb3V0ZXMpIHtcbiAgICAgIGlmIChlcnJvcikge1xuICAgICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkUm91dGVzKSB7XG4gICAgICAgIC8vIENoZWNrIHRoZSBjaGlsZCByb3V0ZXMgdG8gc2VlIGlmIGFueSBvZiB0aGVtIG1hdGNoLlxuICAgICAgICBtYXRjaFJvdXRlcyhjaGlsZFJvdXRlcywgbG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgbWF0Y2gpIHtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAvLyBBIGNoaWxkIHJvdXRlIG1hdGNoZWQhIEF1Z21lbnQgdGhlIG1hdGNoIGFuZCBwYXNzIGl0IHVwIHRoZSBzdGFjay5cbiAgICAgICAgICAgIG1hdGNoLnJvdXRlcy51bnNoaWZ0KHJvdXRlKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1hdGNoKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0Q2hpbGRSb3V0ZXMocm91dGUsIGxvY2F0aW9uLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgb25DaGlsZFJvdXRlcyk7XG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgb25DaGlsZFJvdXRlcy5hcHBseSh1bmRlZmluZWQsIHJlc3VsdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNhbGxiYWNrKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBtYXRjaGVzIHRoZSBnaXZlbiBsb2NhdGlvbiB0byBhIHNldCBvZiByb3V0ZXMgYW5kIGNhbGxzXG4gKiBjYWxsYmFjayhlcnJvciwgc3RhdGUpIHdoZW4gZmluaXNoZWQuIFRoZSBzdGF0ZSBvYmplY3Qgd2lsbCBoYXZlIHRoZVxuICogZm9sbG93aW5nIHByb3BlcnRpZXM6XG4gKlxuICogLSByb3V0ZXMgICAgICAgQW4gYXJyYXkgb2Ygcm91dGVzIHRoYXQgbWF0Y2hlZCwgaW4gaGllcmFyY2hpY2FsIG9yZGVyXG4gKiAtIHBhcmFtcyAgICAgICBBbiBvYmplY3Qgb2YgVVJMIHBhcmFtZXRlcnNcbiAqXG4gKiBOb3RlOiBUaGlzIG9wZXJhdGlvbiBtYXkgZmluaXNoIHN5bmNocm9ub3VzbHkgaWYgbm8gcm91dGVzIGhhdmUgYW5cbiAqIGFzeW5jaHJvbm91cyBnZXRDaGlsZFJvdXRlcyBtZXRob2QuXG4gKi9cbmZ1bmN0aW9uIG1hdGNoUm91dGVzKHJvdXRlcywgbG9jYXRpb24sIGNhbGxiYWNrLCByZW1haW5pbmdQYXRobmFtZSkge1xuICB2YXIgcGFyYW1OYW1lcyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gNCB8fCBhcmd1bWVudHNbNF0gPT09IHVuZGVmaW5lZCA/IFtdIDogYXJndW1lbnRzWzRdO1xuICB2YXIgcGFyYW1WYWx1ZXMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDUgfHwgYXJndW1lbnRzWzVdID09PSB1bmRlZmluZWQgPyBbXSA6IGFyZ3VtZW50c1s1XTtcblxuICBpZiAocmVtYWluaW5nUGF0aG5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFRPRE86IFRoaXMgaXMgYSBsaXR0bGUgYml0IHVnbHksIGJ1dCBpdCB3b3JrcyBhcm91bmQgYSBxdWlyayBpbiBoaXN0b3J5XG4gICAgLy8gdGhhdCBzdHJpcHMgdGhlIGxlYWRpbmcgc2xhc2ggZnJvbSBwYXRobmFtZXMgd2hlbiB1c2luZyBiYXNlbmFtZXMgd2l0aFxuICAgIC8vIHRyYWlsaW5nIHNsYXNoZXMuXG4gICAgaWYgKGxvY2F0aW9uLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nKSB7XG4gICAgICBsb2NhdGlvbiA9IF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogJy8nICsgbG9jYXRpb24ucGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZW1haW5pbmdQYXRobmFtZSA9IGxvY2F0aW9uLnBhdGhuYW1lO1xuICB9XG5cbiAgKDAsIF9Bc3luY1V0aWxzLmxvb3BBc3luYykocm91dGVzLmxlbmd0aCwgZnVuY3Rpb24gKGluZGV4LCBuZXh0LCBkb25lKSB7XG4gICAgbWF0Y2hSb3V0ZURlZXAocm91dGVzW2luZGV4XSwgbG9jYXRpb24sIHJlbWFpbmluZ1BhdGhuYW1lLCBwYXJhbU5hbWVzLCBwYXJhbVZhbHVlcywgZnVuY3Rpb24gKGVycm9yLCBtYXRjaCkge1xuICAgICAgaWYgKGVycm9yIHx8IG1hdGNoKSB7XG4gICAgICAgIGRvbmUoZXJyb3IsIG1hdGNoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSwgY2FsbGJhY2spO1xufVxubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL21hdGNoUm91dGVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSBcInN5bWJvbFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajsgfTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMnKTtcblxudmFyIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMpO1xuXG52YXIgX2dldFJvdXRlUGFyYW1zID0gcmVxdWlyZSgnLi9nZXRSb3V0ZVBhcmFtcycpO1xuXG52YXIgX2dldFJvdXRlUGFyYW1zMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2dldFJvdXRlUGFyYW1zKTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBhcnJheSA9IF9SZWFjdCRQcm9wVHlwZXMuYXJyYXk7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvYmplY3QgPSBfUmVhY3QkUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBBIDxSb3V0ZXJDb250ZXh0PiByZW5kZXJzIHRoZSBjb21wb25lbnQgdHJlZSBmb3IgYSBnaXZlbiByb3V0ZXIgc3RhdGVcbiAqIGFuZCBzZXRzIHRoZSBoaXN0b3J5IG9iamVjdCBhbmQgdGhlIGN1cnJlbnQgbG9jYXRpb24gaW4gY29udGV4dC5cbiAqL1xuXG52YXIgUm91dGVyQ29udGV4dCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUm91dGVyQ29udGV4dCcsXG5cblxuICBwcm9wVHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgcm91dGVyOiBvYmplY3QuaXNSZXF1aXJlZCxcbiAgICBsb2NhdGlvbjogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgcm91dGVzOiBhcnJheS5pc1JlcXVpcmVkLFxuICAgIHBhcmFtczogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgY29tcG9uZW50czogYXJyYXkuaXNSZXF1aXJlZCxcbiAgICBjcmVhdGVFbGVtZW50OiBmdW5jLmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uIGdldERlZmF1bHRQcm9wcygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY3JlYXRlRWxlbWVudDogX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUVsZW1lbnRcbiAgICB9O1xuICB9LFxuXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICBoaXN0b3J5OiBvYmplY3QsXG4gICAgbG9jYXRpb246IG9iamVjdC5pc1JlcXVpcmVkLFxuICAgIHJvdXRlcjogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICB2YXIgX3Byb3BzID0gdGhpcy5wcm9wcztcbiAgICB2YXIgcm91dGVyID0gX3Byb3BzLnJvdXRlcjtcbiAgICB2YXIgaGlzdG9yeSA9IF9wcm9wcy5oaXN0b3J5O1xuICAgIHZhciBsb2NhdGlvbiA9IF9wcm9wcy5sb2NhdGlvbjtcblxuICAgIGlmICghcm91dGVyKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2A8Um91dGVyQ29udGV4dD5gIGV4cGVjdHMgYSBgcm91dGVyYCByYXRoZXIgdGhhbiBhIGBoaXN0b3J5YCcpIDogdm9pZCAwO1xuXG4gICAgICByb3V0ZXIgPSBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgICAgICBzZXRSb3V0ZUxlYXZlSG9vazogaGlzdG9yeS5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGVcbiAgICAgIH0pO1xuICAgICAgZGVsZXRlIHJvdXRlci5saXN0ZW5CZWZvcmVMZWF2aW5nUm91dGU7XG4gICAgfVxuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGxvY2F0aW9uID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShsb2NhdGlvbiwgJ2Bjb250ZXh0LmxvY2F0aW9uYCBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGEgcm91dGUgY29tcG9uZW50XFwncyBgcHJvcHMubG9jYXRpb25gIGluc3RlYWQuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1hY2Nlc3Npbmdsb2NhdGlvbicpO1xuICAgIH1cblxuICAgIHJldHVybiB7IGhpc3Rvcnk6IGhpc3RvcnksIGxvY2F0aW9uOiBsb2NhdGlvbiwgcm91dGVyOiByb3V0ZXIgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudDogZnVuY3Rpb24gY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKSB7XG4gICAgcmV0dXJuIGNvbXBvbmVudCA9PSBudWxsID8gbnVsbCA6IHRoaXMucHJvcHMuY3JlYXRlRWxlbWVudChjb21wb25lbnQsIHByb3BzKTtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBfcHJvcHMyID0gdGhpcy5wcm9wcztcbiAgICB2YXIgaGlzdG9yeSA9IF9wcm9wczIuaGlzdG9yeTtcbiAgICB2YXIgbG9jYXRpb24gPSBfcHJvcHMyLmxvY2F0aW9uO1xuICAgIHZhciByb3V0ZXMgPSBfcHJvcHMyLnJvdXRlcztcbiAgICB2YXIgcGFyYW1zID0gX3Byb3BzMi5wYXJhbXM7XG4gICAgdmFyIGNvbXBvbmVudHMgPSBfcHJvcHMyLmNvbXBvbmVudHM7XG5cbiAgICB2YXIgZWxlbWVudCA9IG51bGw7XG5cbiAgICBpZiAoY29tcG9uZW50cykge1xuICAgICAgZWxlbWVudCA9IGNvbXBvbmVudHMucmVkdWNlUmlnaHQoZnVuY3Rpb24gKGVsZW1lbnQsIGNvbXBvbmVudHMsIGluZGV4KSB7XG4gICAgICAgIGlmIChjb21wb25lbnRzID09IG51bGwpIHJldHVybiBlbGVtZW50OyAvLyBEb24ndCBjcmVhdGUgbmV3IGNoaWxkcmVuOyB1c2UgdGhlIGdyYW5kY2hpbGRyZW4uXG5cbiAgICAgICAgdmFyIHJvdXRlID0gcm91dGVzW2luZGV4XTtcbiAgICAgICAgdmFyIHJvdXRlUGFyYW1zID0gKDAsIF9nZXRSb3V0ZVBhcmFtczIuZGVmYXVsdCkocm91dGUsIHBhcmFtcyk7XG4gICAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgICBoaXN0b3J5OiBoaXN0b3J5LFxuICAgICAgICAgIGxvY2F0aW9uOiBsb2NhdGlvbixcbiAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICAgICAgICByb3V0ZTogcm91dGUsXG4gICAgICAgICAgcm91dGVQYXJhbXM6IHJvdXRlUGFyYW1zLFxuICAgICAgICAgIHJvdXRlczogcm91dGVzXG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKCgwLCBfUm91dGVVdGlscy5pc1JlYWN0Q2hpbGRyZW4pKGVsZW1lbnQpKSB7XG4gICAgICAgICAgcHJvcHMuY2hpbGRyZW4gPSBlbGVtZW50O1xuICAgICAgICB9IGVsc2UgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGVsZW1lbnQpIHtcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZWxlbWVudCwgcHJvcCkpIHByb3BzW3Byb3BdID0gZWxlbWVudFtwcm9wXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKHR5cGVvZiBjb21wb25lbnRzID09PSAndW5kZWZpbmVkJyA/ICd1bmRlZmluZWQnIDogX3R5cGVvZihjb21wb25lbnRzKSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgdmFyIGVsZW1lbnRzID0ge307XG5cbiAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChjb21wb25lbnRzLCBrZXkpKSB7XG4gICAgICAgICAgICAgIC8vIFBhc3MgdGhyb3VnaCB0aGUga2V5IGFzIGEgcHJvcCB0byBjcmVhdGVFbGVtZW50IHRvIGFsbG93XG4gICAgICAgICAgICAgIC8vIGN1c3RvbSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9ucyB0byBrbm93IHdoaWNoIG5hbWVkIGNvbXBvbmVudFxuICAgICAgICAgICAgICAvLyB0aGV5J3JlIHJlbmRlcmluZywgZm9yIGUuZy4gbWF0Y2hpbmcgdXAgdG8gZmV0Y2hlZCBkYXRhLlxuICAgICAgICAgICAgICBlbGVtZW50c1trZXldID0gX3RoaXMuY3JlYXRlRWxlbWVudChjb21wb25lbnRzW2tleV0sIF9leHRlbmRzKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSB9LCBwcm9wcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBfdGhpcy5jcmVhdGVFbGVtZW50KGNvbXBvbmVudHMsIHByb3BzKTtcbiAgICAgIH0sIGVsZW1lbnQpO1xuICAgIH1cblxuICAgICEoZWxlbWVudCA9PT0gbnVsbCB8fCBlbGVtZW50ID09PSBmYWxzZSB8fCBfcmVhY3QyLmRlZmF1bHQuaXNWYWxpZEVsZW1lbnQoZWxlbWVudCkpID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSByb290IHJvdXRlIG11c3QgcmVuZGVyIGEgc2luZ2xlIGVsZW1lbnQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICByZXR1cm4gZWxlbWVudDtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlckNvbnRleHQ7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvUm91dGVyQ29udGV4dC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9QYXR0ZXJuVXRpbHMgPSByZXF1aXJlKCcuL1BhdHRlcm5VdGlscycpO1xuXG4vKipcbiAqIEV4dHJhY3RzIGFuIG9iamVjdCBvZiBwYXJhbXMgdGhlIGdpdmVuIHJvdXRlIGNhcmVzIGFib3V0IGZyb21cbiAqIHRoZSBnaXZlbiBwYXJhbXMgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBnZXRSb3V0ZVBhcmFtcyhyb3V0ZSwgcGFyYW1zKSB7XG4gIHZhciByb3V0ZVBhcmFtcyA9IHt9O1xuXG4gIGlmICghcm91dGUucGF0aCkgcmV0dXJuIHJvdXRlUGFyYW1zO1xuXG4gICgwLCBfUGF0dGVyblV0aWxzLmdldFBhcmFtTmFtZXMpKHJvdXRlLnBhdGgpLmZvckVhY2goZnVuY3Rpb24gKHApIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHBhcmFtcywgcCkpIHtcbiAgICAgIHJvdXRlUGFyYW1zW3BdID0gcGFyYW1zW3BdO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHJvdXRlUGFyYW1zO1xufVxuXG5leHBvcnRzLmRlZmF1bHQgPSBnZXRSb3V0ZVBhcmFtcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9nZXRSb3V0ZVBhcmFtcy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZXhwb3J0cy5jcmVhdGVSb3V0ZXJPYmplY3QgPSBjcmVhdGVSb3V0ZXJPYmplY3Q7XG5leHBvcnRzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5ID0gY3JlYXRlUm91dGluZ0hpc3Rvcnk7XG5cbnZhciBfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyA9IHJlcXVpcmUoJy4vZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcycpO1xuXG52YXIgX2RlcHJlY2F0ZU9iamVjdFByb3BlcnRpZXMyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfZGVwcmVjYXRlT2JqZWN0UHJvcGVydGllcyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIGNyZWF0ZVJvdXRlck9iamVjdChoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcikge1xuICByZXR1cm4gX2V4dGVuZHMoe30sIGhpc3RvcnksIHtcbiAgICBzZXRSb3V0ZUxlYXZlSG9vazogdHJhbnNpdGlvbk1hbmFnZXIubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlLFxuICAgIGlzQWN0aXZlOiB0cmFuc2l0aW9uTWFuYWdlci5pc0FjdGl2ZVxuICB9KTtcbn1cblxuLy8gZGVwcmVjYXRlZFxuZnVuY3Rpb24gY3JlYXRlUm91dGluZ0hpc3RvcnkoaGlzdG9yeSwgdHJhbnNpdGlvbk1hbmFnZXIpIHtcbiAgaGlzdG9yeSA9IF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBoaXN0b3J5ID0gKDAsIF9kZXByZWNhdGVPYmplY3RQcm9wZXJ0aWVzMi5kZWZhdWx0KShoaXN0b3J5LCAnYHByb3BzLmhpc3RvcnlgIGFuZCBgY29udGV4dC5oaXN0b3J5YCBhcmUgZGVwcmVjYXRlZC4gUGxlYXNlIHVzZSBgY29udGV4dC5yb3V0ZXJgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItY29udGV4dGNoYW5nZXMnKTtcbiAgfVxuXG4gIHJldHVybiBoaXN0b3J5O1xufVxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZXJVdGlscy5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1Byb3BUeXBlcyA9IHJlcXVpcmUoJy4vUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhvYmosIGtleXMpIHsgdmFyIHRhcmdldCA9IHt9OyBmb3IgKHZhciBpIGluIG9iaikgeyBpZiAoa2V5cy5pbmRleE9mKGkpID49IDApIGNvbnRpbnVlOyBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGkpKSBjb250aW51ZTsgdGFyZ2V0W2ldID0gb2JqW2ldOyB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIGJvb2wgPSBfUmVhY3QkUHJvcFR5cGVzLmJvb2w7XG52YXIgb2JqZWN0ID0gX1JlYWN0JFByb3BUeXBlcy5vYmplY3Q7XG52YXIgc3RyaW5nID0gX1JlYWN0JFByb3BUeXBlcy5zdHJpbmc7XG52YXIgZnVuYyA9IF9SZWFjdCRQcm9wVHlwZXMuZnVuYztcbnZhciBvbmVPZlR5cGUgPSBfUmVhY3QkUHJvcFR5cGVzLm9uZU9mVHlwZTtcblxuXG5mdW5jdGlvbiBpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSB7XG4gIHJldHVybiBldmVudC5idXR0b24gPT09IDA7XG59XG5cbmZ1bmN0aW9uIGlzTW9kaWZpZWRFdmVudChldmVudCkge1xuICByZXR1cm4gISEoZXZlbnQubWV0YUtleSB8fCBldmVudC5hbHRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5zaGlmdEtleSk7XG59XG5cbi8vIFRPRE86IERlLWR1cGxpY2F0ZSBhZ2FpbnN0IGhhc0FueVByb3BlcnRpZXMgaW4gY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIuXG5mdW5jdGlvbiBpc0VtcHR5T2JqZWN0KG9iamVjdCkge1xuICBmb3IgKHZhciBwIGluIG9iamVjdCkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwKSkgcmV0dXJuIGZhbHNlO1xuICB9cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uRGVzY3JpcHRvcih0bywgX3JlZikge1xuICB2YXIgcXVlcnkgPSBfcmVmLnF1ZXJ5O1xuICB2YXIgaGFzaCA9IF9yZWYuaGFzaDtcbiAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcblxuICBpZiAocXVlcnkgfHwgaGFzaCB8fCBzdGF0ZSkge1xuICAgIHJldHVybiB7IHBhdGhuYW1lOiB0bywgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfTtcbiAgfVxuXG4gIHJldHVybiB0bztcbn1cblxuLyoqXG4gKiBBIDxMaW5rPiBpcyB1c2VkIHRvIGNyZWF0ZSBhbiA8YT4gZWxlbWVudCB0aGF0IGxpbmtzIHRvIGEgcm91dGUuXG4gKiBXaGVuIHRoYXQgcm91dGUgaXMgYWN0aXZlLCB0aGUgbGluayBnZXRzIHRoZSB2YWx1ZSBvZiBpdHNcbiAqIGFjdGl2ZUNsYXNzTmFtZSBwcm9wLlxuICpcbiAqIEZvciBleGFtcGxlLCBhc3N1bWluZyB5b3UgaGF2ZSB0aGUgZm9sbG93aW5nIHJvdXRlOlxuICpcbiAqICAgPFJvdXRlIHBhdGg9XCIvcG9zdHMvOnBvc3RJRFwiIGNvbXBvbmVudD17UG9zdH0gLz5cbiAqXG4gKiBZb3UgY291bGQgdXNlIHRoZSBmb2xsb3dpbmcgY29tcG9uZW50IHRvIGxpbmsgdG8gdGhhdCByb3V0ZTpcbiAqXG4gKiAgIDxMaW5rIHRvPXtgL3Bvc3RzLyR7cG9zdC5pZH1gfSAvPlxuICpcbiAqIExpbmtzIG1heSBwYXNzIGFsb25nIGxvY2F0aW9uIHN0YXRlIGFuZC9vciBxdWVyeSBzdHJpbmcgcGFyYW1ldGVyc1xuICogaW4gdGhlIHN0YXRlL3F1ZXJ5IHByb3BzLCByZXNwZWN0aXZlbHkuXG4gKlxuICogICA8TGluayAuLi4gcXVlcnk9e3sgc2hvdzogdHJ1ZSB9fSBzdGF0ZT17eyB0aGU6ICdzdGF0ZScgfX0gLz5cbiAqL1xudmFyIExpbmsgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICBkaXNwbGF5TmFtZTogJ0xpbmsnLFxuXG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlXG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IG9uZU9mVHlwZShbc3RyaW5nLCBvYmplY3RdKSxcbiAgICBxdWVyeTogb2JqZWN0LFxuICAgIGhhc2g6IHN0cmluZyxcbiAgICBzdGF0ZTogb2JqZWN0LFxuICAgIGFjdGl2ZVN0eWxlOiBvYmplY3QsXG4gICAgYWN0aXZlQ2xhc3NOYW1lOiBzdHJpbmcsXG4gICAgb25seUFjdGl2ZU9uSW5kZXg6IGJvb2wuaXNSZXF1aXJlZCxcbiAgICBvbkNsaWNrOiBmdW5jLFxuICAgIHRhcmdldDogc3RyaW5nXG4gIH0sXG5cbiAgZ2V0RGVmYXVsdFByb3BzOiBmdW5jdGlvbiBnZXREZWZhdWx0UHJvcHMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG9ubHlBY3RpdmVPbkluZGV4OiBmYWxzZSxcbiAgICAgIHN0eWxlOiB7fVxuICAgIH07XG4gIH0sXG4gIGhhbmRsZUNsaWNrOiBmdW5jdGlvbiBoYW5kbGVDbGljayhldmVudCkge1xuICAgIGlmICh0aGlzLnByb3BzLm9uQ2xpY2spIHRoaXMucHJvcHMub25DbGljayhldmVudCk7XG5cbiAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkgcmV0dXJuO1xuXG4gICAgIXRoaXMuY29udGV4dC5yb3V0ZXIgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPExpbms+cyByZW5kZXJlZCBvdXRzaWRlIG9mIGEgcm91dGVyIGNvbnRleHQgY2Fubm90IG5hdmlnYXRlLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIGlmIChpc01vZGlmaWVkRXZlbnQoZXZlbnQpIHx8ICFpc0xlZnRDbGlja0V2ZW50KGV2ZW50KSkgcmV0dXJuO1xuXG4gICAgLy8gSWYgdGFyZ2V0IHByb3AgaXMgc2V0IChlLmcuIHRvIFwiX2JsYW5rXCIpLCBsZXQgYnJvd3NlciBoYW5kbGUgbGluay5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWY6IHVudGVzdGFibGUgd2l0aCBLYXJtYSAqL1xuICAgIGlmICh0aGlzLnByb3BzLnRhcmdldCkgcmV0dXJuO1xuXG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgIHZhciBfcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgIHZhciB0byA9IF9wcm9wcy50bztcbiAgICB2YXIgcXVlcnkgPSBfcHJvcHMucXVlcnk7XG4gICAgdmFyIGhhc2ggPSBfcHJvcHMuaGFzaDtcbiAgICB2YXIgc3RhdGUgPSBfcHJvcHMuc3RhdGU7XG5cbiAgICB2YXIgbG9jYXRpb24gPSBjcmVhdGVMb2NhdGlvbkRlc2NyaXB0b3IodG8sIHsgcXVlcnk6IHF1ZXJ5LCBoYXNoOiBoYXNoLCBzdGF0ZTogc3RhdGUgfSk7XG5cbiAgICB0aGlzLmNvbnRleHQucm91dGVyLnB1c2gobG9jYXRpb24pO1xuICB9LFxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICB2YXIgX3Byb3BzMiA9IHRoaXMucHJvcHM7XG4gICAgdmFyIHRvID0gX3Byb3BzMi50bztcbiAgICB2YXIgcXVlcnkgPSBfcHJvcHMyLnF1ZXJ5O1xuICAgIHZhciBoYXNoID0gX3Byb3BzMi5oYXNoO1xuICAgIHZhciBzdGF0ZSA9IF9wcm9wczIuc3RhdGU7XG4gICAgdmFyIGFjdGl2ZUNsYXNzTmFtZSA9IF9wcm9wczIuYWN0aXZlQ2xhc3NOYW1lO1xuICAgIHZhciBhY3RpdmVTdHlsZSA9IF9wcm9wczIuYWN0aXZlU3R5bGU7XG4gICAgdmFyIG9ubHlBY3RpdmVPbkluZGV4ID0gX3Byb3BzMi5vbmx5QWN0aXZlT25JbmRleDtcblxuICAgIHZhciBwcm9wcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhfcHJvcHMyLCBbJ3RvJywgJ3F1ZXJ5JywgJ2hhc2gnLCAnc3RhdGUnLCAnYWN0aXZlQ2xhc3NOYW1lJywgJ2FjdGl2ZVN0eWxlJywgJ29ubHlBY3RpdmVPbkluZGV4J10pO1xuXG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfcm91dGVyV2FybmluZzIuZGVmYXVsdCkoIShxdWVyeSB8fCBoYXNoIHx8IHN0YXRlKSwgJ3RoZSBgcXVlcnlgLCBgaGFzaGAsIGFuZCBgc3RhdGVgIHByb3BzIG9uIGA8TGluaz5gIGFyZSBkZXByZWNhdGVkLCB1c2UgYDxMaW5rIHRvPXt7IHBhdGhuYW1lLCBxdWVyeSwgaGFzaCwgc3RhdGUgfX0vPi4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLWlzQWN0aXZlZGVwcmVjYXRlZCcpIDogdm9pZCAwO1xuXG4gICAgLy8gSWdub3JlIGlmIHJlbmRlcmVkIG91dHNpZGUgdGhlIGNvbnRleHQgb2Ygcm91dGVyLCBzaW1wbGlmaWVzIHVuaXQgdGVzdGluZy5cbiAgICB2YXIgcm91dGVyID0gdGhpcy5jb250ZXh0LnJvdXRlcjtcblxuXG4gICAgaWYgKHJvdXRlcikge1xuICAgICAgLy8gSWYgdXNlciBkb2VzIG5vdCBzcGVjaWZ5IGEgYHRvYCBwcm9wLCByZXR1cm4gYW4gZW1wdHkgYW5jaG9yIHRhZy5cbiAgICAgIGlmICh0byA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudCgnYScsIHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGxvY2F0aW9uID0gY3JlYXRlTG9jYXRpb25EZXNjcmlwdG9yKHRvLCB7IHF1ZXJ5OiBxdWVyeSwgaGFzaDogaGFzaCwgc3RhdGU6IHN0YXRlIH0pO1xuICAgICAgcHJvcHMuaHJlZiA9IHJvdXRlci5jcmVhdGVIcmVmKGxvY2F0aW9uKTtcblxuICAgICAgaWYgKGFjdGl2ZUNsYXNzTmFtZSB8fCBhY3RpdmVTdHlsZSAhPSBudWxsICYmICFpc0VtcHR5T2JqZWN0KGFjdGl2ZVN0eWxlKSkge1xuICAgICAgICBpZiAocm91dGVyLmlzQWN0aXZlKGxvY2F0aW9uLCBvbmx5QWN0aXZlT25JbmRleCkpIHtcbiAgICAgICAgICBpZiAoYWN0aXZlQ2xhc3NOYW1lKSB7XG4gICAgICAgICAgICBpZiAocHJvcHMuY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICAgIHByb3BzLmNsYXNzTmFtZSArPSAnICcgKyBhY3RpdmVDbGFzc05hbWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcm9wcy5jbGFzc05hbWUgPSBhY3RpdmVDbGFzc05hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGl2ZVN0eWxlKSBwcm9wcy5zdHlsZSA9IF9leHRlbmRzKHt9LCBwcm9wcy5zdHlsZSwgYWN0aXZlU3R5bGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KCdhJywgX2V4dGVuZHMoe30sIHByb3BzLCB7IG9uQ2xpY2s6IHRoaXMuaGFuZGxlQ2xpY2sgfSkpO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gTGluaztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9MaW5rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfTGluayA9IHJlcXVpcmUoJy4vTGluaycpO1xuXG52YXIgX0xpbmsyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfTGluayk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbi8qKlxuICogQW4gPEluZGV4TGluaz4gaXMgdXNlZCB0byBsaW5rIHRvIGFuIDxJbmRleFJvdXRlPi5cbiAqL1xudmFyIEluZGV4TGluayA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhMaW5rJyxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9MaW5rMi5kZWZhdWx0LCBfZXh0ZW5kcyh7fSwgdGhpcy5wcm9wcywgeyBvbmx5QWN0aXZlT25JbmRleDogdHJ1ZSB9KSk7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleExpbms7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvSW5kZXhMaW5rLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG5leHBvcnRzLmRlZmF1bHQgPSB3aXRoUm91dGVyO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaG9pc3ROb25SZWFjdFN0YXRpY3MgPSByZXF1aXJlKCdob2lzdC1ub24tcmVhY3Qtc3RhdGljcycpO1xuXG52YXIgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2hvaXN0Tm9uUmVhY3RTdGF0aWNzKTtcblxudmFyIF9Qcm9wVHlwZXMgPSByZXF1aXJlKCcuL1Byb3BUeXBlcycpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiBnZXREaXNwbGF5TmFtZShXcmFwcGVkQ29tcG9uZW50KSB7XG4gIHJldHVybiBXcmFwcGVkQ29tcG9uZW50LmRpc3BsYXlOYW1lIHx8IFdyYXBwZWRDb21wb25lbnQubmFtZSB8fCAnQ29tcG9uZW50Jztcbn1cblxuZnVuY3Rpb24gd2l0aFJvdXRlcihXcmFwcGVkQ29tcG9uZW50LCBvcHRpb25zKSB7XG4gIHZhciB3aXRoUmVmID0gb3B0aW9ucyAmJiBvcHRpb25zLndpdGhSZWY7XG5cbiAgdmFyIFdpdGhSb3V0ZXIgPSBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlQ2xhc3Moe1xuICAgIGRpc3BsYXlOYW1lOiAnV2l0aFJvdXRlcicsXG5cbiAgICBjb250ZXh0VHlwZXM6IHsgcm91dGVyOiBfUHJvcFR5cGVzLnJvdXRlclNoYXBlIH0sXG4gICAgcHJvcFR5cGVzOiB7IHJvdXRlcjogX1Byb3BUeXBlcy5yb3V0ZXJTaGFwZSB9LFxuXG4gICAgZ2V0V3JhcHBlZEluc3RhbmNlOiBmdW5jdGlvbiBnZXRXcmFwcGVkSW5zdGFuY2UoKSB7XG4gICAgICAhd2l0aFJlZiA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdUbyBhY2Nlc3MgdGhlIHdyYXBwZWQgaW5zdGFuY2UsIHlvdSBuZWVkIHRvIHNwZWNpZnkgJyArICdgeyB3aXRoUmVmOiB0cnVlIH1gIGFzIHRoZSBzZWNvbmQgYXJndW1lbnQgb2YgdGhlIHdpdGhSb3V0ZXIoKSBjYWxsLicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgICAgcmV0dXJuIHRoaXMud3JhcHBlZEluc3RhbmNlO1xuICAgIH0sXG4gICAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcm91dGVyID0gdGhpcy5wcm9wcy5yb3V0ZXIgfHwgdGhpcy5jb250ZXh0LnJvdXRlcjtcbiAgICAgIHZhciBwcm9wcyA9IF9leHRlbmRzKHt9LCB0aGlzLnByb3BzLCB7IHJvdXRlcjogcm91dGVyIH0pO1xuXG4gICAgICBpZiAod2l0aFJlZikge1xuICAgICAgICBwcm9wcy5yZWYgPSBmdW5jdGlvbiAoYykge1xuICAgICAgICAgIF90aGlzLndyYXBwZWRJbnN0YW5jZSA9IGM7XG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChXcmFwcGVkQ29tcG9uZW50LCBwcm9wcyk7XG4gICAgfVxuICB9KTtcblxuICBXaXRoUm91dGVyLmRpc3BsYXlOYW1lID0gJ3dpdGhSb3V0ZXIoJyArIGdldERpc3BsYXlOYW1lKFdyYXBwZWRDb21wb25lbnQpICsgJyknO1xuICBXaXRoUm91dGVyLldyYXBwZWRDb21wb25lbnQgPSBXcmFwcGVkQ29tcG9uZW50O1xuXG4gIHJldHVybiAoMCwgX2hvaXN0Tm9uUmVhY3RTdGF0aWNzMi5kZWZhdWx0KShXaXRoUm91dGVyLCBXcmFwcGVkQ29tcG9uZW50KTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi93aXRoUm91dGVyLmpzIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNSwgWWFob28hIEluYy5cbiAqIENvcHlyaWdodHMgbGljZW5zZWQgdW5kZXIgdGhlIE5ldyBCU0QgTGljZW5zZS4gU2VlIHRoZSBhY2NvbXBhbnlpbmcgTElDRU5TRSBmaWxlIGZvciB0ZXJtcy5cbiAqL1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUkVBQ1RfU1RBVElDUyA9IHtcbiAgICBjaGlsZENvbnRleHRUeXBlczogdHJ1ZSxcbiAgICBjb250ZXh0VHlwZXM6IHRydWUsXG4gICAgZGVmYXVsdFByb3BzOiB0cnVlLFxuICAgIGRpc3BsYXlOYW1lOiB0cnVlLFxuICAgIGdldERlZmF1bHRQcm9wczogdHJ1ZSxcbiAgICBtaXhpbnM6IHRydWUsXG4gICAgcHJvcFR5cGVzOiB0cnVlLFxuICAgIHR5cGU6IHRydWVcbn07XG5cbnZhciBLTk9XTl9TVEFUSUNTID0ge1xuICAgIG5hbWU6IHRydWUsXG4gICAgbGVuZ3RoOiB0cnVlLFxuICAgIHByb3RvdHlwZTogdHJ1ZSxcbiAgICBjYWxsZXI6IHRydWUsXG4gICAgYXJndW1lbnRzOiB0cnVlLFxuICAgIGFyaXR5OiB0cnVlXG59O1xuXG52YXIgaXNHZXRPd25Qcm9wZXJ0eVN5bWJvbHNBdmFpbGFibGUgPSB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gJ2Z1bmN0aW9uJztcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBob2lzdE5vblJlYWN0U3RhdGljcyh0YXJnZXRDb21wb25lbnQsIHNvdXJjZUNvbXBvbmVudCwgY3VzdG9tU3RhdGljcykge1xuICAgIGlmICh0eXBlb2Ygc291cmNlQ29tcG9uZW50ICE9PSAnc3RyaW5nJykgeyAvLyBkb24ndCBob2lzdCBvdmVyIHN0cmluZyAoaHRtbCkgY29tcG9uZW50c1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHNvdXJjZUNvbXBvbmVudCk7XG5cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgaWYgKGlzR2V0T3duUHJvcGVydHlTeW1ib2xzQXZhaWxhYmxlKSB7XG4gICAgICAgICAgICBrZXlzID0ga2V5cy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzb3VyY2VDb21wb25lbnQpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgaWYgKCFSRUFDVF9TVEFUSUNTW2tleXNbaV1dICYmICFLTk9XTl9TVEFUSUNTW2tleXNbaV1dICYmICghY3VzdG9tU3RhdGljcyB8fCAhY3VzdG9tU3RhdGljc1trZXlzW2ldXSkpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXRDb21wb25lbnRba2V5c1tpXV0gPSBzb3VyY2VDb21wb25lbnRba2V5c1tpXV07XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRDb21wb25lbnQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9ob2lzdC1ub24tcmVhY3Qtc3RhdGljcy9pbmRleC5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBfcmVhY3QyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcmVhY3QpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX1JlZGlyZWN0ID0gcmVxdWlyZSgnLi9SZWRpcmVjdCcpO1xuXG52YXIgX1JlZGlyZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX1JlZGlyZWN0KTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEFuIDxJbmRleFJlZGlyZWN0PiBpcyB1c2VkIHRvIHJlZGlyZWN0IGZyb20gYW4gaW5kZXhSb3V0ZS5cbiAqL1xuXG52YXIgSW5kZXhSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnSW5kZXhSZWRpcmVjdCcsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBmdW5jdGlvbiBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQoZWxlbWVudCwgcGFyZW50Um91dGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlOiBzYW5pdHkgY2hlY2sgKi9cbiAgICAgIGlmIChwYXJlbnRSb3V0ZSkge1xuICAgICAgICBwYXJlbnRSb3V0ZS5pbmRleFJvdXRlID0gX1JlZGlyZWN0Mi5kZWZhdWx0LmNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4UmVkaXJlY3Q+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJlZGlyZWN0PiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleFJlZGlyZWN0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4UmVkaXJlY3QuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfUGF0dGVyblV0aWxzID0gcmVxdWlyZSgnLi9QYXR0ZXJuVXRpbHMnKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIF9SZWFjdCRQcm9wVHlwZXMgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzO1xudmFyIHN0cmluZyA9IF9SZWFjdCRQcm9wVHlwZXMuc3RyaW5nO1xudmFyIG9iamVjdCA9IF9SZWFjdCRQcm9wVHlwZXMub2JqZWN0O1xuXG4vKipcbiAqIEEgPFJlZGlyZWN0PiBpcyB1c2VkIHRvIGRlY2xhcmUgYW5vdGhlciBVUkwgcGF0aCBhIGNsaWVudCBzaG91bGRcbiAqIGJlIHNlbnQgdG8gd2hlbiB0aGV5IHJlcXVlc3QgYSBnaXZlbiBVUkwuXG4gKlxuICogUmVkaXJlY3RzIGFyZSBwbGFjZWQgYWxvbmdzaWRlIHJvdXRlcyBpbiB0aGUgcm91dGUgY29uZmlndXJhdGlvblxuICogYW5kIGFyZSB0cmF2ZXJzZWQgaW4gdGhlIHNhbWUgbWFubmVyLlxuICovXG5cbnZhciBSZWRpcmVjdCA9IF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVDbGFzcyh7XG4gIGRpc3BsYXlOYW1lOiAnUmVkaXJlY3QnLFxuXG5cbiAgc3RhdGljczoge1xuICAgIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudDogZnVuY3Rpb24gY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgIHZhciByb3V0ZSA9ICgwLCBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQpKGVsZW1lbnQpO1xuXG4gICAgICBpZiAocm91dGUuZnJvbSkgcm91dGUucGF0aCA9IHJvdXRlLmZyb207XG5cbiAgICAgIHJvdXRlLm9uRW50ZXIgPSBmdW5jdGlvbiAobmV4dFN0YXRlLCByZXBsYWNlKSB7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IG5leHRTdGF0ZS5sb2NhdGlvbjtcbiAgICAgICAgdmFyIHBhcmFtcyA9IG5leHRTdGF0ZS5wYXJhbXM7XG5cblxuICAgICAgICB2YXIgcGF0aG5hbWUgPSB2b2lkIDA7XG4gICAgICAgIGlmIChyb3V0ZS50by5jaGFyQXQoMCkgPT09ICcvJykge1xuICAgICAgICAgIHBhdGhuYW1lID0gKDAsIF9QYXR0ZXJuVXRpbHMuZm9ybWF0UGF0dGVybikocm91dGUudG8sIHBhcmFtcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoIXJvdXRlLnRvKSB7XG4gICAgICAgICAgcGF0aG5hbWUgPSBsb2NhdGlvbi5wYXRobmFtZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgcm91dGVJbmRleCA9IG5leHRTdGF0ZS5yb3V0ZXMuaW5kZXhPZihyb3V0ZSk7XG4gICAgICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSBSZWRpcmVjdC5nZXRSb3V0ZVBhdHRlcm4obmV4dFN0YXRlLnJvdXRlcywgcm91dGVJbmRleCAtIDEpO1xuICAgICAgICAgIHZhciBwYXR0ZXJuID0gcGFyZW50UGF0dGVybi5yZXBsYWNlKC9cXC8qJC8sICcvJykgKyByb3V0ZS50bztcbiAgICAgICAgICBwYXRobmFtZSA9ICgwLCBfUGF0dGVyblV0aWxzLmZvcm1hdFBhdHRlcm4pKHBhdHRlcm4sIHBhcmFtcyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXBsYWNlKHtcbiAgICAgICAgICBwYXRobmFtZTogcGF0aG5hbWUsXG4gICAgICAgICAgcXVlcnk6IHJvdXRlLnF1ZXJ5IHx8IGxvY2F0aW9uLnF1ZXJ5LFxuICAgICAgICAgIHN0YXRlOiByb3V0ZS5zdGF0ZSB8fCBsb2NhdGlvbi5zdGF0ZVxuICAgICAgICB9KTtcbiAgICAgIH07XG5cbiAgICAgIHJldHVybiByb3V0ZTtcbiAgICB9LFxuICAgIGdldFJvdXRlUGF0dGVybjogZnVuY3Rpb24gZ2V0Um91dGVQYXR0ZXJuKHJvdXRlcywgcm91dGVJbmRleCkge1xuICAgICAgdmFyIHBhcmVudFBhdHRlcm4gPSAnJztcblxuICAgICAgZm9yICh2YXIgaSA9IHJvdXRlSW5kZXg7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHZhciByb3V0ZSA9IHJvdXRlc1tpXTtcbiAgICAgICAgdmFyIHBhdHRlcm4gPSByb3V0ZS5wYXRoIHx8ICcnO1xuXG4gICAgICAgIHBhcmVudFBhdHRlcm4gPSBwYXR0ZXJuLnJlcGxhY2UoL1xcLyokLywgJy8nKSArIHBhcmVudFBhdHRlcm47XG5cbiAgICAgICAgaWYgKHBhdHRlcm4uaW5kZXhPZignLycpID09PSAwKSBicmVhaztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuICcvJyArIHBhcmVudFBhdHRlcm47XG4gICAgfVxuICB9LFxuXG4gIHByb3BUeXBlczoge1xuICAgIHBhdGg6IHN0cmluZyxcbiAgICBmcm9tOiBzdHJpbmcsIC8vIEFsaWFzIGZvciBwYXRoXG4gICAgdG86IHN0cmluZy5pc1JlcXVpcmVkLFxuICAgIHF1ZXJ5OiBvYmplY3QsXG4gICAgc3RhdGU6IG9iamVjdCxcbiAgICBvbkVudGVyOiBfSW50ZXJuYWxQcm9wVHlwZXMuZmFsc3ksXG4gICAgY2hpbGRyZW46IF9JbnRlcm5hbFByb3BUeXBlcy5mYWxzeVxuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxSZWRpcmVjdD4gZWxlbWVudHMgYXJlIGZvciByb3V0ZXIgY29uZmlndXJhdGlvbiBvbmx5IGFuZCBzaG91bGQgbm90IGJlIHJlbmRlcmVkJykgOiAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UpIDogdm9pZCAwO1xuICB9XG59KTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gUmVkaXJlY3Q7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvUmVkaXJlY3QuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBmdW5jID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEFuIDxJbmRleFJvdXRlPiBpcyB1c2VkIHRvIHNwZWNpZnkgaXRzIHBhcmVudCdzIDxSb3V0ZSBpbmRleFJvdXRlPiBpblxuICogYSBKU1ggcm91dGUgY29uZmlnLlxuICovXG5cbnZhciBJbmRleFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdJbmRleFJvdXRlJyxcblxuXG4gIHN0YXRpY3M6IHtcbiAgICBjcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnQ6IGZ1bmN0aW9uIGNyZWF0ZVJvdXRlRnJvbVJlYWN0RWxlbWVudChlbGVtZW50LCBwYXJlbnRSb3V0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2U6IHNhbml0eSBjaGVjayAqL1xuICAgICAgaWYgKHBhcmVudFJvdXRlKSB7XG4gICAgICAgIHBhcmVudFJvdXRlLmluZGV4Um91dGUgPSAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50KShlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnQW4gPEluZGV4Um91dGU+IGRvZXMgbm90IG1ha2Ugc2Vuc2UgYXQgdGhlIHJvb3Qgb2YgeW91ciByb3V0ZSBjb25maWcnKSA6IHZvaWQgMDtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcGF0aDogX0ludGVybmFsUHJvcFR5cGVzLmZhbHN5LFxuICAgIGNvbXBvbmVudDogX0ludGVybmFsUHJvcFR5cGVzLmNvbXBvbmVudCxcbiAgICBjb21wb25lbnRzOiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50cyxcbiAgICBnZXRDb21wb25lbnQ6IGZ1bmMsXG4gICAgZ2V0Q29tcG9uZW50czogZnVuY1xuICB9LFxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzYW5pdHkgY2hlY2sgKi9cbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgIWZhbHNlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJzxJbmRleFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBJbmRleFJvdXRlO1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL0luZGV4Um91dGUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9pbnZhcmlhbnQgPSByZXF1aXJlKCdpbnZhcmlhbnQnKTtcblxudmFyIF9pbnZhcmlhbnQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfaW52YXJpYW50KTtcblxudmFyIF9Sb3V0ZVV0aWxzID0gcmVxdWlyZSgnLi9Sb3V0ZVV0aWxzJyk7XG5cbnZhciBfSW50ZXJuYWxQcm9wVHlwZXMgPSByZXF1aXJlKCcuL0ludGVybmFsUHJvcFR5cGVzJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBfUmVhY3QkUHJvcFR5cGVzID0gX3JlYWN0Mi5kZWZhdWx0LlByb3BUeXBlcztcbnZhciBzdHJpbmcgPSBfUmVhY3QkUHJvcFR5cGVzLnN0cmluZztcbnZhciBmdW5jID0gX1JlYWN0JFByb3BUeXBlcy5mdW5jO1xuXG4vKipcbiAqIEEgPFJvdXRlPiBpcyB1c2VkIHRvIGRlY2xhcmUgd2hpY2ggY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgdG8gdGhlXG4gKiBwYWdlIHdoZW4gdGhlIFVSTCBtYXRjaGVzIGEgZ2l2ZW4gcGF0dGVybi5cbiAqXG4gKiBSb3V0ZXMgYXJlIGFycmFuZ2VkIGluIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlLiBXaGVuIGEgbmV3IFVSTCBpc1xuICogcmVxdWVzdGVkLCB0aGUgdHJlZSBpcyBzZWFyY2hlZCBkZXB0aC1maXJzdCB0byBmaW5kIGEgcm91dGUgd2hvc2VcbiAqIHBhdGggbWF0Y2hlcyB0aGUgVVJMLiAgV2hlbiBvbmUgaXMgZm91bmQsIGFsbCByb3V0ZXMgaW4gdGhlIHRyZWVcbiAqIHRoYXQgbGVhZCB0byBpdCBhcmUgY29uc2lkZXJlZCBcImFjdGl2ZVwiIGFuZCB0aGVpciBjb21wb25lbnRzIGFyZVxuICogcmVuZGVyZWQgaW50byB0aGUgRE9NLCBuZXN0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgaW4gdGhlIHRyZWUuXG4gKi9cblxudmFyIFJvdXRlID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0ZScsXG5cblxuICBzdGF0aWNzOiB7XG4gICAgY3JlYXRlUm91dGVGcm9tUmVhY3RFbGVtZW50OiBfUm91dGVVdGlscy5jcmVhdGVSb3V0ZUZyb21SZWFjdEVsZW1lbnRcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgY29tcG9uZW50OiBfSW50ZXJuYWxQcm9wVHlwZXMuY29tcG9uZW50LFxuICAgIGNvbXBvbmVudHM6IF9JbnRlcm5hbFByb3BUeXBlcy5jb21wb25lbnRzLFxuICAgIGdldENvbXBvbmVudDogZnVuYyxcbiAgICBnZXRDb21wb25lbnRzOiBmdW5jXG4gIH0sXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNhbml0eSBjaGVjayAqL1xuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlcigpIHtcbiAgICAhZmFsc2UgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnPFJvdXRlPiBlbGVtZW50cyBhcmUgZm9yIHJvdXRlciBjb25maWd1cmF0aW9uIG9ubHkgYW5kIHNob3VsZCBub3QgYmUgcmVuZGVyZWQnKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG4gIH1cbn0pO1xuXG5leHBvcnRzLmRlZmF1bHQgPSBSb3V0ZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxudmFyIF9JbnRlcm5hbFByb3BUeXBlcyA9IHJlcXVpcmUoJy4vSW50ZXJuYWxQcm9wVHlwZXMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuLyoqXG4gKiBBIG1peGluIHRoYXQgYWRkcyB0aGUgXCJoaXN0b3J5XCIgaW5zdGFuY2UgdmFyaWFibGUgdG8gY29tcG9uZW50cy5cbiAqL1xudmFyIEhpc3RvcnkgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogX0ludGVybmFsUHJvcFR5cGVzLmhpc3RvcnlcbiAgfSxcblxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgSGlzdG9yeWAgbWl4aW4gaXMgZGVwcmVjYXRlZCwgcGxlYXNlIGFjY2VzcyBgY29udGV4dC5yb3V0ZXJgIHdpdGggeW91ciBvd24gYGNvbnRleHRUeXBlc2AuIGh0dHA6Ly90aW55LmNjL3JvdXRlci1oaXN0b3J5bWl4aW4nKSA6IHZvaWQgMDtcbiAgICB0aGlzLmhpc3RvcnkgPSB0aGlzLmNvbnRleHQuaGlzdG9yeTtcbiAgfVxufTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gSGlzdG9yeTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9IaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgTGlmZWN5Y2xlIG1peGluIGFkZHMgdGhlIHJvdXRlcldpbGxMZWF2ZSBsaWZlY3ljbGUgbWV0aG9kIHRvIGFcbiAqIGNvbXBvbmVudCB0aGF0IG1heSBiZSB1c2VkIHRvIGNhbmNlbCBhIHRyYW5zaXRpb24gb3IgcHJvbXB0IHRoZSB1c2VyXG4gKiBmb3IgY29uZmlybWF0aW9uLlxuICpcbiAqIE9uIHN0YW5kYXJkIHRyYW5zaXRpb25zLCByb3V0ZXJXaWxsTGVhdmUgcmVjZWl2ZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZVxuICogbG9jYXRpb24gd2UncmUgdHJhbnNpdGlvbmluZyB0by4gVG8gY2FuY2VsIHRoZSB0cmFuc2l0aW9uLCByZXR1cm4gZmFsc2UuXG4gKiBUbyBwcm9tcHQgdGhlIHVzZXIgZm9yIGNvbmZpcm1hdGlvbiwgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgKHN0cmluZykuXG4gKlxuICogRHVyaW5nIHRoZSBiZWZvcmV1bmxvYWQgZXZlbnQgKGFzc3VtaW5nIHlvdSdyZSB1c2luZyB0aGUgdXNlQmVmb3JlVW5sb2FkXG4gKiBoaXN0b3J5IGVuaGFuY2VyKSwgcm91dGVyV2lsbExlYXZlIGRvZXMgbm90IHJlY2VpdmUgYSBsb2NhdGlvbiBvYmplY3RcbiAqIGJlY2F1c2UgaXQgaXNuJ3QgcG9zc2libGUgZm9yIHVzIHRvIGtub3cgdGhlIGxvY2F0aW9uIHdlJ3JlIHRyYW5zaXRpb25pbmdcbiAqIHRvLiBJbiB0aGlzIGNhc2Ugcm91dGVyV2lsbExlYXZlIG11c3QgcmV0dXJuIGEgcHJvbXB0IG1lc3NhZ2UgdG8gcHJldmVudFxuICogdGhlIHVzZXIgZnJvbSBjbG9zaW5nIHRoZSB3aW5kb3cvdGFiLlxuICovXG5cbnZhciBMaWZlY3ljbGUgPSB7XG5cbiAgY29udGV4dFR5cGVzOiB7XG4gICAgaGlzdG9yeTogb2JqZWN0LmlzUmVxdWlyZWQsXG4gICAgLy8gTmVzdGVkIGNoaWxkcmVuIHJlY2VpdmUgdGhlIHJvdXRlIGFzIGNvbnRleHQsIGVpdGhlclxuICAgIC8vIHNldCBieSB0aGUgcm91dGUgY29tcG9uZW50IHVzaW5nIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW5cbiAgICAvLyBvciBieSBzb21lIG90aGVyIGFuY2VzdG9yLlxuICAgIHJvdXRlOiBvYmplY3RcbiAgfSxcblxuICBwcm9wVHlwZXM6IHtcbiAgICAvLyBSb3V0ZSBjb21wb25lbnRzIHJlY2VpdmUgdGhlIHJvdXRlIG9iamVjdCBhcyBhIHByb3AuXG4gICAgcm91dGU6IG9iamVjdFxuICB9LFxuXG4gIGNvbXBvbmVudERpZE1vdW50OiBmdW5jdGlvbiBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ3RoZSBgTGlmZWN5Y2xlYCBtaXhpbiBpcyBkZXByZWNhdGVkLCBwbGVhc2UgdXNlIGBjb250ZXh0LnJvdXRlci5zZXRSb3V0ZUxlYXZlSG9vayhyb3V0ZSwgaG9vaylgLiBodHRwOi8vdGlueS5jYy9yb3V0ZXItbGlmZWN5Y2xlbWl4aW4nKSA6IHZvaWQgMDtcbiAgICAhdGhpcy5yb3V0ZXJXaWxsTGVhdmUgPyBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlLCAnVGhlIExpZmVjeWNsZSBtaXhpbiByZXF1aXJlcyB5b3UgdG8gZGVmaW5lIGEgcm91dGVyV2lsbExlYXZlIG1ldGhvZCcpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICAgIHZhciByb3V0ZSA9IHRoaXMucHJvcHMucm91dGUgfHwgdGhpcy5jb250ZXh0LnJvdXRlO1xuXG4gICAgIXJvdXRlID8gcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBMaWZlY3ljbGUgbWl4aW4gbXVzdCBiZSB1c2VkIG9uIGVpdGhlciBhKSBhIDxSb3V0ZSBjb21wb25lbnQ+IG9yICcgKyAnYikgYSBkZXNjZW5kYW50IG9mIGEgPFJvdXRlIGNvbXBvbmVudD4gdGhhdCB1c2VzIHRoZSBSb3V0ZUNvbnRleHQgbWl4aW4nKSA6ICgwLCBfaW52YXJpYW50Mi5kZWZhdWx0KShmYWxzZSkgOiB2b2lkIDA7XG5cbiAgICB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSA9IHRoaXMuY29udGV4dC5oaXN0b3J5Lmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgdGhpcy5yb3V0ZXJXaWxsTGVhdmUpO1xuICB9LFxuICBjb21wb25lbnRXaWxsVW5tb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbFVubW91bnQoKSB7XG4gICAgaWYgKHRoaXMuX3VubGlzdGVuQmVmb3JlTGVhdmluZ1JvdXRlKSB0aGlzLl91bmxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZSgpO1xuICB9XG59O1xuXG5leHBvcnRzLmRlZmF1bHQgPSBMaWZlY3ljbGU7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvTGlmZWN5Y2xlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX3JvdXRlcldhcm5pbmcgPSByZXF1aXJlKCcuL3JvdXRlcldhcm5pbmcnKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JvdXRlcldhcm5pbmcpO1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbnZhciBvYmplY3QgPSBfcmVhY3QyLmRlZmF1bHQuUHJvcFR5cGVzLm9iamVjdDtcblxuLyoqXG4gKiBUaGUgUm91dGVDb250ZXh0IG1peGluIHByb3ZpZGVzIGEgY29udmVuaWVudCB3YXkgZm9yIHJvdXRlXG4gKiBjb21wb25lbnRzIHRvIHNldCB0aGUgcm91dGUgaW4gY29udGV4dC4gVGhpcyBpcyBuZWVkZWQgZm9yXG4gKiByb3V0ZXMgdGhhdCByZW5kZXIgZWxlbWVudHMgdGhhdCB3YW50IHRvIHVzZSB0aGUgTGlmZWN5Y2xlXG4gKiBtaXhpbiB0byBwcmV2ZW50IHRyYW5zaXRpb25zLlxuICovXG5cbnZhciBSb3V0ZUNvbnRleHQgPSB7XG5cbiAgcHJvcFR5cGVzOiB7XG4gICAgcm91dGU6IG9iamVjdC5pc1JlcXVpcmVkXG4gIH0sXG5cbiAgY2hpbGRDb250ZXh0VHlwZXM6IHtcbiAgICByb3V0ZTogb2JqZWN0LmlzUmVxdWlyZWRcbiAgfSxcblxuICBnZXRDaGlsZENvbnRleHQ6IGZ1bmN0aW9uIGdldENoaWxkQ29udGV4dCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcm91dGU6IHRoaXMucHJvcHMucm91dGVcbiAgICB9O1xuICB9LFxuICBjb21wb25lbnRXaWxsTW91bnQ6IGZ1bmN0aW9uIGNvbXBvbmVudFdpbGxNb3VudCgpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ1RoZSBgUm91dGVDb250ZXh0YCBtaXhpbiBpcyBkZXByZWNhdGVkLiBZb3UgY2FuIHByb3ZpZGUgYHRoaXMucHJvcHMucm91dGVgIG9uIGNvbnRleHQgd2l0aCB5b3VyIG93biBgY29udGV4dFR5cGVzYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLXJvdXRlY29udGV4dG1peGluJykgOiB2b2lkIDA7XG4gIH1cbn07XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRlQ29udGV4dDtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9Sb3V0ZUNvbnRleHQuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbnZhciBfdXNlUXVlcmllcyA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZVF1ZXJpZXMnKTtcblxudmFyIF91c2VRdWVyaWVzMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3VzZVF1ZXJpZXMpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyID0gcmVxdWlyZSgnLi9jcmVhdGVUcmFuc2l0aW9uTWFuYWdlcicpO1xuXG52YXIgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyKTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY3JlYXRlSGlzdG9yeSBmdW5jdGlvbiB0aGF0IG1heSBiZSB1c2VkIHRvIGNyZWF0ZVxuICogaGlzdG9yeSBvYmplY3RzIHRoYXQga25vdyBhYm91dCByb3V0aW5nLlxuICpcbiAqIEVuaGFuY2VzIGhpc3Rvcnkgb2JqZWN0cyB3aXRoIHRoZSBmb2xsb3dpbmcgbWV0aG9kczpcbiAqXG4gKiAtIGxpc3RlbigoZXJyb3IsIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGxpc3RlbkJlZm9yZUxlYXZpbmdSb3V0ZShyb3V0ZSwgKG5leHRMb2NhdGlvbikgPT4ge30pXG4gKiAtIG1hdGNoKGxvY2F0aW9uLCAoZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24sIG5leHRTdGF0ZSkgPT4ge30pXG4gKiAtIGlzQWN0aXZlKHBhdGhuYW1lLCBxdWVyeSwgaW5kZXhPbmx5PWZhbHNlKVxuICovXG5mdW5jdGlvbiB1c2VSb3V0ZXMoY3JlYXRlSGlzdG9yeSkge1xuICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShmYWxzZSwgJ2B1c2VSb3V0ZXNgIGlzIGRlcHJlY2F0ZWQuIFBsZWFzZSB1c2UgYGNyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyYCBpbnN0ZWFkLicpIDogdm9pZCAwO1xuXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9yZWYgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciByb3V0ZXMgPSBfcmVmLnJvdXRlcztcblxuICAgIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsncm91dGVzJ10pO1xuXG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKG9wdGlvbnMpO1xuICAgIHZhciB0cmFuc2l0aW9uTWFuYWdlciA9ICgwLCBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyLmRlZmF1bHQpKGhpc3RvcnksIHJvdXRlcyk7XG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIH07XG59XG5cbmV4cG9ydHMuZGVmYXVsdCA9IHVzZVJvdXRlcztcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXMuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfcmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG52YXIgX3JlYWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3JlYWN0KTtcblxudmFyIF9Sb3V0ZXJDb250ZXh0ID0gcmVxdWlyZSgnLi9Sb3V0ZXJDb250ZXh0Jyk7XG5cbnZhciBfUm91dGVyQ29udGV4dDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9Sb3V0ZXJDb250ZXh0KTtcblxudmFyIF9yb3V0ZXJXYXJuaW5nID0gcmVxdWlyZSgnLi9yb3V0ZXJXYXJuaW5nJyk7XG5cbnZhciBfcm91dGVyV2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yb3V0ZXJXYXJuaW5nKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIFJvdXRpbmdDb250ZXh0ID0gX3JlYWN0Mi5kZWZhdWx0LmNyZWF0ZUNsYXNzKHtcbiAgZGlzcGxheU5hbWU6ICdSb3V0aW5nQ29udGV4dCcsXG4gIGNvbXBvbmVudFdpbGxNb3VudDogZnVuY3Rpb24gY29tcG9uZW50V2lsbE1vdW50KCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX3JvdXRlcldhcm5pbmcyLmRlZmF1bHQpKGZhbHNlLCAnYFJvdXRpbmdDb250ZXh0YCBoYXMgYmVlbiByZW5hbWVkIHRvIGBSb3V0ZXJDb250ZXh0YC4gUGxlYXNlIHVzZSBgaW1wb3J0IHsgUm91dGVyQ29udGV4dCB9IGZyb20gXFwncmVhY3Qtcm91dGVyXFwnYC4gaHR0cDovL3RpbnkuY2Mvcm91dGVyLXJvdXRlcmNvbnRleHQnKSA6IHZvaWQgMDtcbiAgfSxcbiAgcmVuZGVyOiBmdW5jdGlvbiByZW5kZXIoKSB7XG4gICAgcmV0dXJuIF9yZWFjdDIuZGVmYXVsdC5jcmVhdGVFbGVtZW50KF9Sb3V0ZXJDb250ZXh0Mi5kZWZhdWx0LCB0aGlzLnByb3BzKTtcbiAgfVxufSk7XG5cbmV4cG9ydHMuZGVmYXVsdCA9IFJvdXRpbmdDb250ZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvbGliL1JvdXRpbmdDb250ZXh0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9BY3Rpb25zJyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlTWVtb3J5SGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlTWVtb3J5SGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyJyk7XG5cbnZhciBfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlVHJhbnNpdGlvbk1hbmFnZXIpO1xuXG52YXIgX1JvdXRlVXRpbHMgPSByZXF1aXJlKCcuL1JvdXRlVXRpbHMnKTtcblxudmFyIF9Sb3V0ZXJVdGlscyA9IHJlcXVpcmUoJy4vUm91dGVyVXRpbHMnKTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwga2V5cykgeyB2YXIgdGFyZ2V0ID0ge307IGZvciAodmFyIGkgaW4gb2JqKSB7IGlmIChrZXlzLmluZGV4T2YoaSkgPj0gMCkgY29udGludWU7IGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaSkpIGNvbnRpbnVlOyB0YXJnZXRbaV0gPSBvYmpbaV07IH0gcmV0dXJuIHRhcmdldDsgfVxuXG4vKipcbiAqIEEgaGlnaC1sZXZlbCBBUEkgdG8gYmUgdXNlZCBmb3Igc2VydmVyLXNpZGUgcmVuZGVyaW5nLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gbWF0Y2hlcyBhIGxvY2F0aW9uIHRvIGEgc2V0IG9mIHJvdXRlcyBhbmQgY2FsbHNcbiAqIGNhbGxiYWNrKGVycm9yLCByZWRpcmVjdExvY2F0aW9uLCByZW5kZXJQcm9wcykgd2hlbiBmaW5pc2hlZC5cbiAqXG4gKiBOb3RlOiBZb3UgcHJvYmFibHkgZG9uJ3Qgd2FudCB0byB1c2UgdGhpcyBpbiBhIGJyb3dzZXIgdW5sZXNzIHlvdSdyZSB1c2luZ1xuICogc2VydmVyLXNpZGUgcmVuZGVyaW5nIHdpdGggYXN5bmMgcm91dGVzLlxuICovXG5mdW5jdGlvbiBtYXRjaChfcmVmLCBjYWxsYmFjaykge1xuICB2YXIgaGlzdG9yeSA9IF9yZWYuaGlzdG9yeTtcbiAgdmFyIHJvdXRlcyA9IF9yZWYucm91dGVzO1xuICB2YXIgbG9jYXRpb24gPSBfcmVmLmxvY2F0aW9uO1xuXG4gIHZhciBvcHRpb25zID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9yZWYsIFsnaGlzdG9yeScsICdyb3V0ZXMnLCAnbG9jYXRpb24nXSk7XG5cbiAgIShoaXN0b3J5IHx8IGxvY2F0aW9uKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyAoMCwgX2ludmFyaWFudDIuZGVmYXVsdCkoZmFsc2UsICdtYXRjaCBuZWVkcyBhIGhpc3Rvcnkgb3IgYSBsb2NhdGlvbicpIDogKDAsIF9pbnZhcmlhbnQyLmRlZmF1bHQpKGZhbHNlKSA6IHZvaWQgMDtcblxuICBoaXN0b3J5ID0gaGlzdG9yeSA/IGhpc3RvcnkgOiAoMCwgX2NyZWF0ZU1lbW9yeUhpc3RvcnkyLmRlZmF1bHQpKG9wdGlvbnMpO1xuICB2YXIgdHJhbnNpdGlvbk1hbmFnZXIgPSAoMCwgX2NyZWF0ZVRyYW5zaXRpb25NYW5hZ2VyMi5kZWZhdWx0KShoaXN0b3J5LCAoMCwgX1JvdXRlVXRpbHMuY3JlYXRlUm91dGVzKShyb3V0ZXMpKTtcblxuICB2YXIgdW5saXN0ZW4gPSB2b2lkIDA7XG5cbiAgaWYgKGxvY2F0aW9uKSB7XG4gICAgLy8gQWxsb3cgbWF0Y2goeyBsb2NhdGlvbjogJy90aGUvcGF0aCcsIC4uLiB9KVxuICAgIGxvY2F0aW9uID0gaGlzdG9yeS5jcmVhdGVMb2NhdGlvbihsb2NhdGlvbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gUGljayB1cCB0aGUgbG9jYXRpb24gZnJvbSB0aGUgaGlzdG9yeSB2aWEgc3luY2hyb25vdXMgaGlzdG9yeS5saXN0ZW5cbiAgICAvLyBjYWxsIGlmIG5lZWRlZC5cbiAgICB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGZ1bmN0aW9uIChoaXN0b3J5TG9jYXRpb24pIHtcbiAgICAgIGxvY2F0aW9uID0gaGlzdG9yeUxvY2F0aW9uO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHJvdXRlciA9ICgwLCBfUm91dGVyVXRpbHMuY3JlYXRlUm91dGVyT2JqZWN0KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG4gIGhpc3RvcnkgPSAoMCwgX1JvdXRlclV0aWxzLmNyZWF0ZVJvdXRpbmdIaXN0b3J5KShoaXN0b3J5LCB0cmFuc2l0aW9uTWFuYWdlcik7XG5cbiAgdHJhbnNpdGlvbk1hbmFnZXIubWF0Y2gobG9jYXRpb24sIGZ1bmN0aW9uIChlcnJvciwgcmVkaXJlY3RMb2NhdGlvbiwgbmV4dFN0YXRlKSB7XG4gICAgY2FsbGJhY2soZXJyb3IsIHJlZGlyZWN0TG9jYXRpb24gJiYgcm91dGVyLmNyZWF0ZUxvY2F0aW9uKHJlZGlyZWN0TG9jYXRpb24sIF9BY3Rpb25zLlJFUExBQ0UpLCBuZXh0U3RhdGUgJiYgX2V4dGVuZHMoe30sIG5leHRTdGF0ZSwge1xuICAgICAgaGlzdG9yeTogaGlzdG9yeSxcbiAgICAgIHJvdXRlcjogcm91dGVyLFxuICAgICAgbWF0Y2hDb250ZXh0OiB7IGhpc3Rvcnk6IGhpc3RvcnksIHRyYW5zaXRpb25NYW5hZ2VyOiB0cmFuc2l0aW9uTWFuYWdlciwgcm91dGVyOiByb3V0ZXIgfVxuICAgIH0pKTtcblxuICAgIC8vIERlZmVyIHJlbW92aW5nIHRoZSBsaXN0ZW5lciB0byBoZXJlIHRvIHByZXZlbnQgRE9NIGhpc3RvcmllcyBmcm9tIGhhdmluZ1xuICAgIC8vIHRvIHVud2luZCBET00gZXZlbnQgbGlzdGVuZXJzIHVubmVjZXNzYXJpbHksIGluIGNhc2UgY2FsbGJhY2sgcmVuZGVycyBhXG4gICAgLy8gPFJvdXRlcj4gYW5kIGF0dGFjaGVzIGFub3RoZXIgaGlzdG9yeSBsaXN0ZW5lci5cbiAgICBpZiAodW5saXN0ZW4pIHtcbiAgICAgIHVubGlzdGVuKCk7XG4gICAgfVxuICB9KTtcbn1cblxuZXhwb3J0cy5kZWZhdWx0ID0gbWF0Y2g7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvbWF0Y2guanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSBjcmVhdGVNZW1vcnlIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG52YXIgX2NyZWF0ZU1lbW9yeUhpc3RvcnkgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi9jcmVhdGVNZW1vcnlIaXN0b3J5Jyk7XG5cbnZhciBfY3JlYXRlTWVtb3J5SGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVNZW1vcnlIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxuZnVuY3Rpb24gY3JlYXRlTWVtb3J5SGlzdG9yeShvcHRpb25zKSB7XG4gIC8vIHNpZ25hdHVyZXMgYW5kIHR5cGUgY2hlY2tpbmcgZGlmZmVyIGJldHdlZW4gYHVzZVJvdXRlc2AgYW5kXG4gIC8vIGBjcmVhdGVNZW1vcnlIaXN0b3J5YCwgaGF2ZSB0byBjcmVhdGUgYG1lbW9yeUhpc3RvcnlgIGZpcnN0IGJlY2F1c2VcbiAgLy8gYHVzZVF1ZXJpZXNgIGRvZXNuJ3QgdW5kZXJzdGFuZCB0aGUgc2lnbmF0dXJlXG4gIHZhciBtZW1vcnlIaXN0b3J5ID0gKDAsIF9jcmVhdGVNZW1vcnlIaXN0b3J5Mi5kZWZhdWx0KShvcHRpb25zKTtcbiAgdmFyIGNyZWF0ZUhpc3RvcnkgPSBmdW5jdGlvbiBjcmVhdGVIaXN0b3J5KCkge1xuICAgIHJldHVybiBtZW1vcnlIaXN0b3J5O1xuICB9O1xuICB2YXIgaGlzdG9yeSA9ICgwLCBfdXNlUXVlcmllczIuZGVmYXVsdCkoKDAsIF91c2VCYXNlbmFtZTIuZGVmYXVsdCkoY3JlYXRlSGlzdG9yeSkpKG9wdGlvbnMpO1xuICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvY3JlYXRlTWVtb3J5SGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX3dhcm5pbmcgPSByZXF1aXJlKCd3YXJuaW5nJyk7XG5cbnZhciBfd2FybmluZzIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF93YXJuaW5nKTtcblxudmFyIF9FeGVjdXRpb25FbnZpcm9ubWVudCA9IHJlcXVpcmUoJy4vRXhlY3V0aW9uRW52aXJvbm1lbnQnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rID0gcmVxdWlyZSgnLi9ydW5UcmFuc2l0aW9uSG9vaycpO1xuXG52YXIgX3J1blRyYW5zaXRpb25Ib29rMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3J1blRyYW5zaXRpb25Ib29rKTtcblxudmFyIF9kZXByZWNhdGUgPSByZXF1aXJlKCcuL2RlcHJlY2F0ZScpO1xuXG52YXIgX2RlcHJlY2F0ZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kZXByZWNhdGUpO1xuXG5mdW5jdGlvbiB1c2VCYXNlbmFtZShjcmVhdGVIaXN0b3J5KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAgIHZhciBoaXN0b3J5ID0gY3JlYXRlSGlzdG9yeShvcHRpb25zKTtcblxuICAgIHZhciBiYXNlbmFtZSA9IG9wdGlvbnMuYmFzZW5hbWU7XG5cbiAgICB2YXIgY2hlY2tlZEJhc2VIcmVmID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBjaGVja0Jhc2VIcmVmKCkge1xuICAgICAgaWYgKGNoZWNrZWRCYXNlSHJlZikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEF1dG9tYXRpY2FsbHkgdXNlIHRoZSB2YWx1ZSBvZiA8YmFzZSBocmVmPiBpbiBIVE1MXG4gICAgICAvLyBkb2N1bWVudHMgYXMgYmFzZW5hbWUgaWYgaXQncyBub3QgZXhwbGljaXRseSBnaXZlbi5cbiAgICAgIGlmIChiYXNlbmFtZSA9PSBudWxsICYmIF9FeGVjdXRpb25FbnZpcm9ubWVudC5jYW5Vc2VET00pIHtcbiAgICAgICAgdmFyIGJhc2UgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYmFzZScpWzBdO1xuICAgICAgICB2YXIgYmFzZUhyZWYgPSBiYXNlICYmIGJhc2UuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAgICAgaWYgKGJhc2VIcmVmICE9IG51bGwpIHtcbiAgICAgICAgICBiYXNlbmFtZSA9IGJhc2VIcmVmO1xuXG4gICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQXV0b21hdGljYWxseSBzZXR0aW5nIGJhc2VuYW1lIHVzaW5nIDxiYXNlIGhyZWY+IGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgJyArICdiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuIFRoZSBzZW1hbnRpY3Mgb2YgPGJhc2UgaHJlZj4gYXJlICcgKyAnc3VidGx5IGRpZmZlcmVudCBmcm9tIGJhc2VuYW1lLiBQbGVhc2UgcGFzcyB0aGUgYmFzZW5hbWUgZXhwbGljaXRseSBpbiAnICsgJ3RoZSBvcHRpb25zIHRvIGNyZWF0ZUhpc3RvcnknKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjaGVja2VkQmFzZUhyZWYgPSB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSB7XG4gICAgICBjaGVja0Jhc2VIcmVmKCk7XG5cbiAgICAgIGlmIChiYXNlbmFtZSAmJiBsb2NhdGlvbi5iYXNlbmFtZSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZS5pbmRleE9mKGJhc2VuYW1lKSA9PT0gMCkge1xuICAgICAgICAgIGxvY2F0aW9uLnBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWUuc3Vic3RyaW5nKGJhc2VuYW1lLmxlbmd0aCk7XG4gICAgICAgICAgbG9jYXRpb24uYmFzZW5hbWUgPSBiYXNlbmFtZTtcblxuICAgICAgICAgIGlmIChsb2NhdGlvbi5wYXRobmFtZSA9PT0gJycpIGxvY2F0aW9uLnBhdGhuYW1lID0gJy8nO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxvY2F0aW9uLmJhc2VuYW1lID0gJyc7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIGxvY2F0aW9uO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikge1xuICAgICAgY2hlY2tCYXNlSHJlZigpO1xuXG4gICAgICBpZiAoIWJhc2VuYW1lKSByZXR1cm4gbG9jYXRpb247XG5cbiAgICAgIGlmICh0eXBlb2YgbG9jYXRpb24gPT09ICdzdHJpbmcnKSBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKGxvY2F0aW9uKTtcblxuICAgICAgdmFyIHBuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgICB2YXIgbm9ybWFsaXplZEJhc2VuYW1lID0gYmFzZW5hbWUuc2xpY2UoLTEpID09PSAnLycgPyBiYXNlbmFtZSA6IGJhc2VuYW1lICsgJy8nO1xuICAgICAgdmFyIG5vcm1hbGl6ZWRQYXRobmFtZSA9IHBuYW1lLmNoYXJBdCgwKSA9PT0gJy8nID8gcG5hbWUuc2xpY2UoMSkgOiBwbmFtZTtcbiAgICAgIHZhciBwYXRobmFtZSA9IG5vcm1hbGl6ZWRCYXNlbmFtZSArIG5vcm1hbGl6ZWRQYXRobmFtZTtcblxuICAgICAgcmV0dXJuIF9leHRlbmRzKHt9LCBsb2NhdGlvbiwge1xuICAgICAgICBwYXRobmFtZTogcGF0aG5hbWVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlIGFsbCByZWFkIG1ldGhvZHMgd2l0aCBiYXNlbmFtZS1hd2FyZSB2ZXJzaW9ucy5cbiAgICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUoaG9vaykge1xuICAgICAgcmV0dXJuIGhpc3RvcnkubGlzdGVuQmVmb3JlKGZ1bmN0aW9uIChsb2NhdGlvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgX3J1blRyYW5zaXRpb25Ib29rMlsnZGVmYXVsdCddKGhvb2ssIGFkZEJhc2VuYW1lKGxvY2F0aW9uKSwgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGlzdGVuKGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5saXN0ZW4oZnVuY3Rpb24gKGxvY2F0aW9uKSB7XG4gICAgICAgIGxpc3RlbmVyKGFkZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBPdmVycmlkZSBhbGwgd3JpdGUgbWV0aG9kcyB3aXRoIGJhc2VuYW1lLWF3YXJlIHZlcnNpb25zLlxuICAgIGZ1bmN0aW9uIHB1c2gobG9jYXRpb24pIHtcbiAgICAgIGhpc3RvcnkucHVzaChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlKGxvY2F0aW9uKSB7XG4gICAgICBoaXN0b3J5LnJlcGxhY2UocHJlcGVuZEJhc2VuYW1lKGxvY2F0aW9uKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlUGF0aChsb2NhdGlvbikge1xuICAgICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlUGF0aChwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVIcmVmKGxvY2F0aW9uKSB7XG4gICAgICByZXR1cm4gaGlzdG9yeS5jcmVhdGVIcmVmKHByZXBlbmRCYXNlbmFtZShsb2NhdGlvbikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUxvY2F0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IEFycmF5KF9sZW4gPiAxID8gX2xlbiAtIDEgOiAwKSwgX2tleSA9IDE7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBhZGRCYXNlbmFtZShoaXN0b3J5LmNyZWF0ZUxvY2F0aW9uLmFwcGx5KGhpc3RvcnksIFtwcmVwZW5kQmFzZW5hbWUobG9jYXRpb24pXS5jb25jYXQoYXJncykpKTtcbiAgICB9XG5cbiAgICAvLyBkZXByZWNhdGVkXG4gICAgZnVuY3Rpb24gcHVzaFN0YXRlKHN0YXRlLCBwYXRoKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT09ICdzdHJpbmcnKSBwYXRoID0gX1BhdGhVdGlscy5wYXJzZVBhdGgocGF0aCk7XG5cbiAgICAgIHB1c2goX2V4dGVuZHMoeyBzdGF0ZTogc3RhdGUgfSwgcGF0aCkpO1xuICAgIH1cblxuICAgIC8vIGRlcHJlY2F0ZWRcbiAgICBmdW5jdGlvbiByZXBsYWNlU3RhdGUoc3RhdGUsIHBhdGgpIHtcbiAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHBhdGggPSBfUGF0aFV0aWxzLnBhcnNlUGF0aChwYXRoKTtcblxuICAgICAgcmVwbGFjZShfZXh0ZW5kcyh7IHN0YXRlOiBzdGF0ZSB9LCBwYXRoKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIF9leHRlbmRzKHt9LCBoaXN0b3J5LCB7XG4gICAgICBsaXN0ZW5CZWZvcmU6IGxpc3RlbkJlZm9yZSxcbiAgICAgIGxpc3RlbjogbGlzdGVuLFxuICAgICAgcHVzaDogcHVzaCxcbiAgICAgIHJlcGxhY2U6IHJlcGxhY2UsXG4gICAgICBjcmVhdGVQYXRoOiBjcmVhdGVQYXRoLFxuICAgICAgY3JlYXRlSHJlZjogY3JlYXRlSHJlZixcbiAgICAgIGNyZWF0ZUxvY2F0aW9uOiBjcmVhdGVMb2NhdGlvbixcblxuICAgICAgcHVzaFN0YXRlOiBfZGVwcmVjYXRlMlsnZGVmYXVsdCddKHB1c2hTdGF0ZSwgJ3B1c2hTdGF0ZSBpcyBkZXByZWNhdGVkOyB1c2UgcHVzaCBpbnN0ZWFkJyksXG4gICAgICByZXBsYWNlU3RhdGU6IF9kZXByZWNhdGUyWydkZWZhdWx0J10ocmVwbGFjZVN0YXRlLCAncmVwbGFjZVN0YXRlIGlzIGRlcHJlY2F0ZWQ7IHVzZSByZXBsYWNlIGluc3RlYWQnKVxuICAgIH0pO1xuICB9O1xufVxuXG5leHBvcnRzWydkZWZhdWx0J10gPSB1c2VCYXNlbmFtZTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL34vaGlzdG9yeS9saWIvdXNlQmFzZW5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5cbnZhciBfZXh0ZW5kcyA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldOyBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7IGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7IHRhcmdldFtrZXldID0gc291cmNlW2tleV07IH0gfSB9IHJldHVybiB0YXJnZXQ7IH07XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cblxudmFyIF93YXJuaW5nID0gcmVxdWlyZSgnd2FybmluZycpO1xuXG52YXIgX3dhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfd2FybmluZyk7XG5cbnZhciBfaW52YXJpYW50ID0gcmVxdWlyZSgnaW52YXJpYW50Jyk7XG5cbnZhciBfaW52YXJpYW50MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2ludmFyaWFudCk7XG5cbnZhciBfUGF0aFV0aWxzID0gcmVxdWlyZSgnLi9QYXRoVXRpbHMnKTtcblxudmFyIF9BY3Rpb25zID0gcmVxdWlyZSgnLi9BY3Rpb25zJyk7XG5cbnZhciBfY3JlYXRlSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlSGlzdG9yeSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlU3RvcmFnZShlbnRyaWVzKSB7XG4gIHJldHVybiBlbnRyaWVzLmZpbHRlcihmdW5jdGlvbiAoZW50cnkpIHtcbiAgICByZXR1cm4gZW50cnkuc3RhdGU7XG4gIH0pLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZW50cnkpIHtcbiAgICBtZW1vW2VudHJ5LmtleV0gPSBlbnRyeS5zdGF0ZTtcbiAgICByZXR1cm4gbWVtbztcbiAgfSwge30pO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNZW1vcnlIaXN0b3J5KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPD0gMCB8fCBhcmd1bWVudHNbMF0gPT09IHVuZGVmaW5lZCA/IHt9IDogYXJndW1lbnRzWzBdO1xuXG4gIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMpKSB7XG4gICAgb3B0aW9ucyA9IHsgZW50cmllczogb3B0aW9ucyB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnc3RyaW5nJykge1xuICAgIG9wdGlvbnMgPSB7IGVudHJpZXM6IFtvcHRpb25zXSB9O1xuICB9XG5cbiAgdmFyIGhpc3RvcnkgPSBfY3JlYXRlSGlzdG9yeTJbJ2RlZmF1bHQnXShfZXh0ZW5kcyh7fSwgb3B0aW9ucywge1xuICAgIGdldEN1cnJlbnRMb2NhdGlvbjogZ2V0Q3VycmVudExvY2F0aW9uLFxuICAgIGZpbmlzaFRyYW5zaXRpb246IGZpbmlzaFRyYW5zaXRpb24sXG4gICAgc2F2ZVN0YXRlOiBzYXZlU3RhdGUsXG4gICAgZ286IGdvXG4gIH0pKTtcblxuICB2YXIgX29wdGlvbnMgPSBvcHRpb25zO1xuICB2YXIgZW50cmllcyA9IF9vcHRpb25zLmVudHJpZXM7XG4gIHZhciBjdXJyZW50ID0gX29wdGlvbnMuY3VycmVudDtcblxuICBpZiAodHlwZW9mIGVudHJpZXMgPT09ICdzdHJpbmcnKSB7XG4gICAgZW50cmllcyA9IFtlbnRyaWVzXTtcbiAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgIGVudHJpZXMgPSBbJy8nXTtcbiAgfVxuXG4gIGVudHJpZXMgPSBlbnRyaWVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcbiAgICB2YXIga2V5ID0gaGlzdG9yeS5jcmVhdGVLZXkoKTtcblxuICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSByZXR1cm4geyBwYXRobmFtZTogZW50cnksIGtleToga2V5IH07XG5cbiAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnb2JqZWN0JyAmJiBlbnRyeSkgcmV0dXJuIF9leHRlbmRzKHt9LCBlbnRyeSwgeyBrZXk6IGtleSB9KTtcblxuICAgICFmYWxzZSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnVW5hYmxlIHRvIGNyZWF0ZSBoaXN0b3J5IGVudHJ5IGZyb20gJXMnLCBlbnRyeSkgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcbiAgfSk7XG5cbiAgaWYgKGN1cnJlbnQgPT0gbnVsbCkge1xuICAgIGN1cnJlbnQgPSBlbnRyaWVzLmxlbmd0aCAtIDE7XG4gIH0gZWxzZSB7XG4gICAgIShjdXJyZW50ID49IDAgJiYgY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQ3VycmVudCBpbmRleCBtdXN0IGJlID49IDAgYW5kIDwgJXMsIHdhcyAlcycsIGVudHJpZXMubGVuZ3RoLCBjdXJyZW50KSA6IF9pbnZhcmlhbnQyWydkZWZhdWx0J10oZmFsc2UpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgdmFyIHN0b3JhZ2UgPSBjcmVhdGVTdGF0ZVN0b3JhZ2UoZW50cmllcyk7XG5cbiAgZnVuY3Rpb24gc2F2ZVN0YXRlKGtleSwgc3RhdGUpIHtcbiAgICBzdG9yYWdlW2tleV0gPSBzdGF0ZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWRTdGF0ZShrZXkpIHtcbiAgICByZXR1cm4gc3RvcmFnZVtrZXldO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKCkge1xuICAgIHZhciBlbnRyeSA9IGVudHJpZXNbY3VycmVudF07XG4gICAgdmFyIGJhc2VuYW1lID0gZW50cnkuYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gZW50cnkucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGVudHJ5LnNlYXJjaDtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgKHNlYXJjaCB8fCAnJyk7XG5cbiAgICB2YXIga2V5ID0gdW5kZWZpbmVkLFxuICAgICAgICBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoZW50cnkua2V5KSB7XG4gICAgICBrZXkgPSBlbnRyeS5rZXk7XG4gICAgICBzdGF0ZSA9IHJlYWRTdGF0ZShrZXkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBoaXN0b3J5LmNyZWF0ZUtleSgpO1xuICAgICAgc3RhdGUgPSBudWxsO1xuICAgICAgZW50cnkua2V5ID0ga2V5O1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gY2FuR28obikge1xuICAgIHZhciBpbmRleCA9IGN1cnJlbnQgKyBuO1xuICAgIHJldHVybiBpbmRleCA+PSAwICYmIGluZGV4IDwgZW50cmllcy5sZW5ndGg7XG4gIH1cblxuICBmdW5jdGlvbiBnbyhuKSB7XG4gICAgaWYgKG4pIHtcbiAgICAgIGlmICghY2FuR28obikpIHtcbiAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyA/IF93YXJuaW5nMlsnZGVmYXVsdCddKGZhbHNlLCAnQ2Fubm90IGdvKCVzKSB0aGVyZSBpcyBub3QgZW5vdWdoIGhpc3RvcnknLCBuKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjdXJyZW50ICs9IG47XG5cbiAgICAgIHZhciBjdXJyZW50TG9jYXRpb24gPSBnZXRDdXJyZW50TG9jYXRpb24oKTtcblxuICAgICAgLy8gY2hhbmdlIGFjdGlvbiB0byBQT1BcbiAgICAgIGhpc3RvcnkudHJhbnNpdGlvblRvKF9leHRlbmRzKHt9LCBjdXJyZW50TG9jYXRpb24sIHsgYWN0aW9uOiBfQWN0aW9ucy5QT1AgfSkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGZpbmlzaFRyYW5zaXRpb24obG9jYXRpb24pIHtcbiAgICBzd2l0Y2ggKGxvY2F0aW9uLmFjdGlvbikge1xuICAgICAgY2FzZSBfQWN0aW9ucy5QVVNIOlxuICAgICAgICBjdXJyZW50ICs9IDE7XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIG5vdCBvbiB0aGUgdG9wIG9mIHN0YWNrXG4gICAgICAgIC8vIHJlbW92ZSByZXN0IGFuZCBwdXNoIG5ld1xuICAgICAgICBpZiAoY3VycmVudCA8IGVudHJpZXMubGVuZ3RoKSBlbnRyaWVzLnNwbGljZShjdXJyZW50KTtcblxuICAgICAgICBlbnRyaWVzLnB1c2gobG9jYXRpb24pO1xuICAgICAgICBzYXZlU3RhdGUobG9jYXRpb24ua2V5LCBsb2NhdGlvbi5zdGF0ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfQWN0aW9ucy5SRVBMQUNFOlxuICAgICAgICBlbnRyaWVzW2N1cnJlbnRdID0gbG9jYXRpb247XG4gICAgICAgIHNhdmVTdGF0ZShsb2NhdGlvbi5rZXksIGxvY2F0aW9uLnN0YXRlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGhpc3Rvcnk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZU1lbW9yeUhpc3Rvcnk7XG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9+L2hpc3RvcnkvbGliL2NyZWF0ZU1lbW9yeUhpc3RvcnkuanMiLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XG5leHBvcnRzLmRlZmF1bHQgPSB1c2VSb3V0ZXJIaXN0b3J5O1xuXG52YXIgX3VzZVF1ZXJpZXMgPSByZXF1aXJlKCdoaXN0b3J5L2xpYi91c2VRdWVyaWVzJyk7XG5cbnZhciBfdXNlUXVlcmllczIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VRdWVyaWVzKTtcblxudmFyIF91c2VCYXNlbmFtZSA9IHJlcXVpcmUoJ2hpc3RvcnkvbGliL3VzZUJhc2VuYW1lJyk7XG5cbnZhciBfdXNlQmFzZW5hbWUyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfdXNlQmFzZW5hbWUpO1xuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyBkZWZhdWx0OiBvYmogfTsgfVxuXG5mdW5jdGlvbiB1c2VSb3V0ZXJIaXN0b3J5KGNyZWF0ZUhpc3RvcnkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdmFyIGhpc3RvcnkgPSAoMCwgX3VzZVF1ZXJpZXMyLmRlZmF1bHQpKCgwLCBfdXNlQmFzZW5hbWUyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKShvcHRpb25zKTtcbiAgICBoaXN0b3J5Ll9fdjJfY29tcGF0aWJsZV9fID0gdHJ1ZTtcbiAgICByZXR1cm4gaGlzdG9yeTtcbiAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi91c2VSb3V0ZXJIaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTsgZm9yICh2YXIga2V5IGluIHNvdXJjZSkgeyBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkgeyB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldOyB9IH0gfSByZXR1cm4gdGFyZ2V0OyB9O1xuXG52YXIgX3JlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcblxudmFyIF9yZWFjdDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9yZWFjdCk7XG5cbnZhciBfUm91dGVyQ29udGV4dCA9IHJlcXVpcmUoJy4vUm91dGVyQ29udGV4dCcpO1xuXG52YXIgX1JvdXRlckNvbnRleHQyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfUm91dGVyQ29udGV4dCk7XG5cbnZhciBfcm91dGVyV2FybmluZyA9IHJlcXVpcmUoJy4vcm91dGVyV2FybmluZycpO1xuXG52YXIgX3JvdXRlcldhcm5pbmcyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfcm91dGVyV2FybmluZyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIG1pZGRsZXdhcmVzID0gQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgbWlkZGxld2FyZXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIG1pZGRsZXdhcmVzLmZvckVhY2goZnVuY3Rpb24gKG1pZGRsZXdhcmUsIGluZGV4KSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gKDAsIF9yb3V0ZXJXYXJuaW5nMi5kZWZhdWx0KShtaWRkbGV3YXJlLnJlbmRlclJvdXRlckNvbnRleHQgfHwgbWlkZGxld2FyZS5yZW5kZXJSb3V0ZUNvbXBvbmVudCwgJ1RoZSBtaWRkbGV3YXJlIHNwZWNpZmllZCBhdCBpbmRleCAnICsgaW5kZXggKyAnIGRvZXMgbm90IGFwcGVhciB0byBiZSAnICsgJ2EgdmFsaWQgUmVhY3QgUm91dGVyIG1pZGRsZXdhcmUuJykgOiB2b2lkIDA7XG4gICAgfSk7XG4gIH1cblxuICB2YXIgd2l0aENvbnRleHQgPSBtaWRkbGV3YXJlcy5tYXAoZnVuY3Rpb24gKG1pZGRsZXdhcmUpIHtcbiAgICByZXR1cm4gbWlkZGxld2FyZS5yZW5kZXJSb3V0ZXJDb250ZXh0O1xuICB9KS5maWx0ZXIoQm9vbGVhbik7XG4gIHZhciB3aXRoQ29tcG9uZW50ID0gbWlkZGxld2FyZXMubWFwKGZ1bmN0aW9uIChtaWRkbGV3YXJlKSB7XG4gICAgcmV0dXJuIG1pZGRsZXdhcmUucmVuZGVyUm91dGVDb21wb25lbnQ7XG4gIH0pLmZpbHRlcihCb29sZWFuKTtcblxuICB2YXIgbWFrZUNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiBtYWtlQ3JlYXRlRWxlbWVudCgpIHtcbiAgICB2YXIgYmFzZUNyZWF0ZUVsZW1lbnQgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyBfcmVhY3QuY3JlYXRlRWxlbWVudCA6IGFyZ3VtZW50c1swXTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKENvbXBvbmVudCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiB3aXRoQ29tcG9uZW50LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVDb21wb25lbnQpIHtcbiAgICAgICAgcmV0dXJuIHJlbmRlclJvdXRlQ29tcG9uZW50KHByZXZpb3VzLCBwcm9wcyk7XG4gICAgICB9LCBiYXNlQ3JlYXRlRWxlbWVudChDb21wb25lbnQsIHByb3BzKSk7XG4gICAgfTtcbiAgfTtcblxuICByZXR1cm4gZnVuY3Rpb24gKHJlbmRlclByb3BzKSB7XG4gICAgcmV0dXJuIHdpdGhDb250ZXh0LnJlZHVjZVJpZ2h0KGZ1bmN0aW9uIChwcmV2aW91cywgcmVuZGVyUm91dGVyQ29udGV4dCkge1xuICAgICAgcmV0dXJuIHJlbmRlclJvdXRlckNvbnRleHQocHJldmlvdXMsIHJlbmRlclByb3BzKTtcbiAgICB9LCBfcmVhY3QyLmRlZmF1bHQuY3JlYXRlRWxlbWVudChfUm91dGVyQ29udGV4dDIuZGVmYXVsdCwgX2V4dGVuZHMoe30sIHJlbmRlclByb3BzLCB7XG4gICAgICBjcmVhdGVFbGVtZW50OiBtYWtlQ3JlYXRlRWxlbWVudChyZW5kZXJQcm9wcy5jcmVhdGVFbGVtZW50KVxuICAgIH0pKSk7XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHNbJ2RlZmF1bHQnXTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L3JlYWN0LXJvdXRlci9saWIvYXBwbHlSb3V0ZXJNaWRkbGV3YXJlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUJyb3dzZXJIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlQnJvd3Nlckhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVCcm93c2VySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVCcm93c2VySGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUJyb3dzZXJIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9icm93c2VySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxudmFyIF9leHRlbmRzID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV07IGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHsgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHsgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTsgfSB9IH0gcmV0dXJuIHRhcmdldDsgfTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxuXG52YXIgX2ludmFyaWFudCA9IHJlcXVpcmUoJ2ludmFyaWFudCcpO1xuXG52YXIgX2ludmFyaWFudDIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9pbnZhcmlhbnQpO1xuXG52YXIgX0FjdGlvbnMgPSByZXF1aXJlKCcuL0FjdGlvbnMnKTtcblxudmFyIF9QYXRoVXRpbHMgPSByZXF1aXJlKCcuL1BhdGhVdGlscycpO1xuXG52YXIgX0V4ZWN1dGlvbkVudmlyb25tZW50ID0gcmVxdWlyZSgnLi9FeGVjdXRpb25FbnZpcm9ubWVudCcpO1xuXG52YXIgX0RPTVV0aWxzID0gcmVxdWlyZSgnLi9ET01VdGlscycpO1xuXG52YXIgX0RPTVN0YXRlU3RvcmFnZSA9IHJlcXVpcmUoJy4vRE9NU3RhdGVTdG9yYWdlJyk7XG5cbnZhciBfY3JlYXRlRE9NSGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlRE9NSGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZURPTUhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlRE9NSGlzdG9yeSk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbmQgcmV0dXJucyBhIGhpc3Rvcnkgb2JqZWN0IHRoYXQgdXNlcyBIVE1MNSdzIGhpc3RvcnkgQVBJXG4gKiAocHVzaFN0YXRlLCByZXBsYWNlU3RhdGUsIGFuZCB0aGUgcG9wc3RhdGUgZXZlbnQpIHRvIG1hbmFnZSBoaXN0b3J5LlxuICogVGhpcyBpcyB0aGUgcmVjb21tZW5kZWQgbWV0aG9kIG9mIG1hbmFnaW5nIGhpc3RvcnkgaW4gYnJvd3NlcnMgYmVjYXVzZVxuICogaXQgcHJvdmlkZXMgdGhlIGNsZWFuZXN0IFVSTHMuXG4gKlxuICogTm90ZTogSW4gYnJvd3NlcnMgdGhhdCBkbyBub3Qgc3VwcG9ydCB0aGUgSFRNTDUgaGlzdG9yeSBBUEkgZnVsbFxuICogcGFnZSByZWxvYWRzIHdpbGwgYmUgdXNlZCB0byBwcmVzZXJ2ZSBVUkxzLlxuICovXG5mdW5jdGlvbiBjcmVhdGVCcm93c2VySGlzdG9yeSgpIHtcbiAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoIDw9IDAgfHwgYXJndW1lbnRzWzBdID09PSB1bmRlZmluZWQgPyB7fSA6IGFyZ3VtZW50c1swXTtcblxuICAhX0V4ZWN1dGlvbkVudmlyb25tZW50LmNhblVzZURPTSA/IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlLCAnQnJvd3NlciBoaXN0b3J5IG5lZWRzIGEgRE9NJykgOiBfaW52YXJpYW50MlsnZGVmYXVsdCddKGZhbHNlKSA6IHVuZGVmaW5lZDtcblxuICB2YXIgZm9yY2VSZWZyZXNoID0gb3B0aW9ucy5mb3JjZVJlZnJlc2g7XG5cbiAgdmFyIGlzU3VwcG9ydGVkID0gX0RPTVV0aWxzLnN1cHBvcnRzSGlzdG9yeSgpO1xuICB2YXIgdXNlUmVmcmVzaCA9ICFpc1N1cHBvcnRlZCB8fCBmb3JjZVJlZnJlc2g7XG5cbiAgZnVuY3Rpb24gZ2V0Q3VycmVudExvY2F0aW9uKGhpc3RvcnlTdGF0ZSkge1xuICAgIHRyeSB7XG4gICAgICBoaXN0b3J5U3RhdGUgPSBoaXN0b3J5U3RhdGUgfHwgd2luZG93Lmhpc3Rvcnkuc3RhdGUgfHwge307XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGlzdG9yeVN0YXRlID0ge307XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBfRE9NVXRpbHMuZ2V0V2luZG93UGF0aCgpO1xuICAgIHZhciBfaGlzdG9yeVN0YXRlID0gaGlzdG9yeVN0YXRlO1xuICAgIHZhciBrZXkgPSBfaGlzdG9yeVN0YXRlLmtleTtcblxuICAgIHZhciBzdGF0ZSA9IHVuZGVmaW5lZDtcbiAgICBpZiAoa2V5KSB7XG4gICAgICBzdGF0ZSA9IF9ET01TdGF0ZVN0b3JhZ2UucmVhZFN0YXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlID0gbnVsbDtcbiAgICAgIGtleSA9IGhpc3RvcnkuY3JlYXRlS2V5KCk7XG5cbiAgICAgIGlmIChpc1N1cHBvcnRlZCkgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKF9leHRlbmRzKHt9LCBoaXN0b3J5U3RhdGUsIHsga2V5OiBrZXkgfSksIG51bGwpO1xuICAgIH1cblxuICAgIHZhciBsb2NhdGlvbiA9IF9QYXRoVXRpbHMucGFyc2VQYXRoKHBhdGgpO1xuXG4gICAgcmV0dXJuIGhpc3RvcnkuY3JlYXRlTG9jYXRpb24oX2V4dGVuZHMoe30sIGxvY2F0aW9uLCB7IHN0YXRlOiBzdGF0ZSB9KSwgdW5kZWZpbmVkLCBrZXkpO1xuICB9XG5cbiAgZnVuY3Rpb24gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKF9yZWYpIHtcbiAgICB2YXIgdHJhbnNpdGlvblRvID0gX3JlZi50cmFuc2l0aW9uVG87XG5cbiAgICBmdW5jdGlvbiBwb3BTdGF0ZUxpc3RlbmVyKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQuc3RhdGUgPT09IHVuZGVmaW5lZCkgcmV0dXJuOyAvLyBJZ25vcmUgZXh0cmFuZW91cyBwb3BzdGF0ZSBldmVudHMgaW4gV2ViS2l0LlxuXG4gICAgICB0cmFuc2l0aW9uVG8oZ2V0Q3VycmVudExvY2F0aW9uKGV2ZW50LnN0YXRlKSk7XG4gICAgfVxuXG4gICAgX0RPTVV0aWxzLmFkZEV2ZW50TGlzdGVuZXIod2luZG93LCAncG9wc3RhdGUnLCBwb3BTdGF0ZUxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBfRE9NVXRpbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcih3aW5kb3csICdwb3BzdGF0ZScsIHBvcFN0YXRlTGlzdGVuZXIpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBmaW5pc2hUcmFuc2l0aW9uKGxvY2F0aW9uKSB7XG4gICAgdmFyIGJhc2VuYW1lID0gbG9jYXRpb24uYmFzZW5hbWU7XG4gICAgdmFyIHBhdGhuYW1lID0gbG9jYXRpb24ucGF0aG5hbWU7XG4gICAgdmFyIHNlYXJjaCA9IGxvY2F0aW9uLnNlYXJjaDtcbiAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2g7XG4gICAgdmFyIHN0YXRlID0gbG9jYXRpb24uc3RhdGU7XG4gICAgdmFyIGFjdGlvbiA9IGxvY2F0aW9uLmFjdGlvbjtcbiAgICB2YXIga2V5ID0gbG9jYXRpb24ua2V5O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUE9QKSByZXR1cm47IC8vIE5vdGhpbmcgdG8gZG8uXG5cbiAgICBfRE9NU3RhdGVTdG9yYWdlLnNhdmVTdGF0ZShrZXksIHN0YXRlKTtcblxuICAgIHZhciBwYXRoID0gKGJhc2VuYW1lIHx8ICcnKSArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbiAgICB2YXIgaGlzdG9yeVN0YXRlID0ge1xuICAgICAga2V5OiBrZXlcbiAgICB9O1xuXG4gICAgaWYgKGFjdGlvbiA9PT0gX0FjdGlvbnMuUFVTSCkge1xuICAgICAgaWYgKHVzZVJlZnJlc2gpIHtcbiAgICAgICAgd2luZG93LmxvY2F0aW9uLmhyZWYgPSBwYXRoO1xuICAgICAgICByZXR1cm4gZmFsc2U7IC8vIFByZXZlbnQgbG9jYXRpb24gdXBkYXRlLlxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoaGlzdG9yeVN0YXRlLCBudWxsLCBwYXRoKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBSRVBMQUNFXG4gICAgICBpZiAodXNlUmVmcmVzaCkge1xuICAgICAgICB3aW5kb3cubG9jYXRpb24ucmVwbGFjZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlOyAvLyBQcmV2ZW50IGxvY2F0aW9uIHVwZGF0ZS5cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgd2luZG93Lmhpc3RvcnkucmVwbGFjZVN0YXRlKGhpc3RvcnlTdGF0ZSwgbnVsbCwgcGF0aCk7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICB2YXIgaGlzdG9yeSA9IF9jcmVhdGVET01IaXN0b3J5MlsnZGVmYXVsdCddKF9leHRlbmRzKHt9LCBvcHRpb25zLCB7XG4gICAgZ2V0Q3VycmVudExvY2F0aW9uOiBnZXRDdXJyZW50TG9jYXRpb24sXG4gICAgZmluaXNoVHJhbnNpdGlvbjogZmluaXNoVHJhbnNpdGlvbixcbiAgICBzYXZlU3RhdGU6IF9ET01TdGF0ZVN0b3JhZ2Uuc2F2ZVN0YXRlXG4gIH0pKTtcblxuICB2YXIgbGlzdGVuZXJDb3VudCA9IDAsXG4gICAgICBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHVuZGVmaW5lZDtcblxuICBmdW5jdGlvbiBsaXN0ZW5CZWZvcmUobGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuQmVmb3JlKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBsaXN0ZW4obGlzdGVuZXIpIHtcbiAgICBpZiAoKytsaXN0ZW5lckNvdW50ID09PSAxKSBzdG9wUG9wU3RhdGVMaXN0ZW5lciA9IHN0YXJ0UG9wU3RhdGVMaXN0ZW5lcihoaXN0b3J5KTtcblxuICAgIHZhciB1bmxpc3RlbiA9IGhpc3RvcnkubGlzdGVuKGxpc3RlbmVyKTtcblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB1bmxpc3RlbigpO1xuXG4gICAgICBpZiAoLS1saXN0ZW5lckNvdW50ID09PSAwKSBzdG9wUG9wU3RhdGVMaXN0ZW5lcigpO1xuICAgIH07XG4gIH1cblxuICAvLyBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGlmICgrK2xpc3RlbmVyQ291bnQgPT09IDEpIHN0b3BQb3BTdGF0ZUxpc3RlbmVyID0gc3RhcnRQb3BTdGF0ZUxpc3RlbmVyKGhpc3RvcnkpO1xuXG4gICAgaGlzdG9yeS5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuICB9XG5cbiAgLy8gZGVwcmVjYXRlZFxuICBmdW5jdGlvbiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2soaG9vaykge1xuICAgIGhpc3RvcnkudW5yZWdpc3RlclRyYW5zaXRpb25Ib29rKGhvb2spO1xuXG4gICAgaWYgKC0tbGlzdGVuZXJDb3VudCA9PT0gMCkgc3RvcFBvcFN0YXRlTGlzdGVuZXIoKTtcbiAgfVxuXG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgaGlzdG9yeSwge1xuICAgIGxpc3RlbkJlZm9yZTogbGlzdGVuQmVmb3JlLFxuICAgIGxpc3RlbjogbGlzdGVuLFxuICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2s6IHJlZ2lzdGVyVHJhbnNpdGlvbkhvb2ssXG4gICAgdW5yZWdpc3RlclRyYW5zaXRpb25Ib29rOiB1bnJlZ2lzdGVyVHJhbnNpdGlvbkhvb2tcbiAgfSk7XG59XG5cbmV4cG9ydHNbJ2RlZmF1bHQnXSA9IGNyZWF0ZUJyb3dzZXJIaXN0b3J5O1xubW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzWydkZWZhdWx0J107XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vfi9yZWFjdC1yb3V0ZXIvfi9oaXN0b3J5L2xpYi9jcmVhdGVCcm93c2VySGlzdG9yeS5qcyIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcblxuZXhwb3J0cy5kZWZhdWx0ID0gZnVuY3Rpb24gKGNyZWF0ZUhpc3RvcnkpIHtcbiAgdmFyIGhpc3RvcnkgPSB2b2lkIDA7XG4gIGlmIChjYW5Vc2VET00pIGhpc3RvcnkgPSAoMCwgX3VzZVJvdXRlckhpc3RvcnkyLmRlZmF1bHQpKGNyZWF0ZUhpc3RvcnkpKCk7XG4gIHJldHVybiBoaXN0b3J5O1xufTtcblxudmFyIF91c2VSb3V0ZXJIaXN0b3J5ID0gcmVxdWlyZSgnLi91c2VSb3V0ZXJIaXN0b3J5Jyk7XG5cbnZhciBfdXNlUm91dGVySGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF91c2VSb3V0ZXJIaXN0b3J5KTtcblxuZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgZGVmYXVsdDogb2JqIH07IH1cblxudmFyIGNhblVzZURPTSA9ICEhKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5kb2N1bWVudCAmJiB3aW5kb3cuZG9jdW1lbnQuY3JlYXRlRWxlbWVudCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9jcmVhdGVSb3V0ZXJIaXN0b3J5LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xuXG52YXIgX2NyZWF0ZUhhc2hIaXN0b3J5ID0gcmVxdWlyZSgnaGlzdG9yeS9saWIvY3JlYXRlSGFzaEhpc3RvcnknKTtcblxudmFyIF9jcmVhdGVIYXNoSGlzdG9yeTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jcmVhdGVIYXNoSGlzdG9yeSk7XG5cbnZhciBfY3JlYXRlUm91dGVySGlzdG9yeSA9IHJlcXVpcmUoJy4vY3JlYXRlUm91dGVySGlzdG9yeScpO1xuXG52YXIgX2NyZWF0ZVJvdXRlckhpc3RvcnkyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfY3JlYXRlUm91dGVySGlzdG9yeSk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7IGRlZmF1bHQ6IG9iaiB9OyB9XG5cbmV4cG9ydHMuZGVmYXVsdCA9ICgwLCBfY3JlYXRlUm91dGVySGlzdG9yeTIuZGVmYXVsdCkoX2NyZWF0ZUhhc2hIaXN0b3J5Mi5kZWZhdWx0KTtcbm1vZHVsZS5leHBvcnRzID0gZXhwb3J0c1snZGVmYXVsdCddO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL34vcmVhY3Qtcm91dGVyL2xpYi9oYXNoSGlzdG9yeS5qcyIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG4vL2tvbXBvbmVudGVcclxudmFyIE5hdmlnYXRpb24gPSByZXF1aXJlKCdOYXZpZ2F0aW9uJyk7XHJcblxyXG52YXIgTWFpbiA9IChwcm9wcykgPT4ge1xyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2PlxyXG4gICAgICAgIDxOYXZpZ2F0aW9uIC8+XHJcbiAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJyb3dcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJjb2x1bW4gc21hbGwtY2VudGVyZWQgbWVkaXVtLTYgbGFyZ2UtNFwiPlxyXG4gICAgICAgICAgICAgICAge3Byb3BzLmNoaWxkcmVufVxyXG4gICAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICA8L2Rpdj5cclxuICAgIDwvZGl2PlxyXG4gICk7XHJcbn07XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE1haW47XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL01haW4uanN4IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxudmFyIHtMaW5rLCBJbmRleExpbmt9ID0gcmVxdWlyZSgncmVhY3Qtcm91dGVyJyk7XHJcblxyXG52YXIgTmF2aWdhdGlvbiA9ICgpID0+IHtcclxuICAgIHJldHVybihcclxuICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRvcC1iYXJcIj5cclxuICAgICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0b3AtYmFyLWxlZnRcIj5cclxuICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICAgIDxsaSBjbGFzc05hbWU9XCJtZW51LXRleHRcIj5SZWFjdCAtIFRpbWVyQXBwPC9saT5cclxuICAgICAgICAgICAgICAgICAgICAgIDxsaT5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICA8SW5kZXhMaW5rIHRvPVwiL1wiIGFjdGl2ZUNsYXNzTmFtZT1cImFjdGl2ZS1saW5rXCI+VGltZXI8L0luZGV4TGluaz5cclxuICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICA8bGk+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgPEluZGV4TGluayB0bz1cIi9jb3VudGRvd25cIiBhY3RpdmVDbGFzc05hbWU9XCJhY3RpdmUtbGlua1wiPk9kYnJvamF2YW5qZTwvSW5kZXhMaW5rPlxyXG4gICAgICAgICAgICAgICAgICAgICAgPC9saT5cclxuICAgICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwidG9wLWJhci1yaWdodFwiPlxyXG4gICAgICAgICAgICAgICAgPHVsIGNsYXNzTmFtZT1cIm1lbnVcIj5cclxuICAgICAgICAgICAgICAgICAgICA8bGkgY2xhc3NOYW1lPVwibWVudS10ZXh0XCI+XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIE5hcHJldmxqZW5vIG9kOiA8YSBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL2JsZXZhamFjXCIgdGFyZ2V0PVwiX2JsYW5rXCI+Qm9yaXMgTGV2YWphYzwvYT5cclxuICAgICAgICAgICAgICAgICAgICA8L2xpPlxyXG4gICAgICAgICAgICAgICAgPC91bD5cclxuICAgICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgPC9kaXY+XHJcbiAgICApO1xyXG5cclxufTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IE5hdmlnYXRpb247XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL05hdmlnYXRpb24uanN4IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBUaW1lciA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4oXHJcblxyXG4gICAgICAgICAgICA8cD50aW1lci5qc3g8L3A+XHJcblxyXG4gICAgICAgICk7XHJcbiAgICB9XHJcbn0pO1xyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBUaW1lcjtcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vYXBwL2NvbXBvbmVudHMvVGltZXIuanN4IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBDbG9jayA9IHJlcXVpcmUoJ0Nsb2NrJyk7XHJcbnZhciBDb3VudGRvd25Gb3JtID0gcmVxdWlyZSgnQ291bnRkb3duRm9ybScpO1xyXG52YXIgQ29udHJvbHMgPSByZXF1aXJlKCdDb250cm9scycpO1xyXG5cclxudmFyIENvdW50ZG93biA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIGdldEluaXRpYWxTdGF0ZTogZnVuY3Rpb24oKXtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjb3VudDogMCxcclxuICAgICAgICAgICAgY291bnRkb3duU3RhdHVzOiAnc3RvcHBlZCdcclxuICAgICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBjb21wb25lbnREaWRVcGRhdGU6IGZ1bmN0aW9uKHByZXZQcm9wcywgcHJldlN0YXRlKXtcclxuICAgICAgICBpZih0aGlzLnN0YXRlLmNvdW50ZG93blN0YXR1cyAhPT0gcHJldlN0YXRlLmNvdW50ZG93blN0YXR1cyl7XHJcbiAgICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuY291bnRkb3duU3RhdHVzKSB7XHJcbiAgICAgICAgICAgICAgY2FzZSAnc3RhcnRlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFRpbWVyKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgY2FzZSAnc3RvcHBlZCc6XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0ZSh7Y291bnQ6IDB9KTtcclxuICAgICAgICAgICAgICBjYXNlICdwYXVzZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy50aW1lcilcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbWVyID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHN0YXJ0VGltZXI6IGZ1bmN0aW9uKCl7XHJcbiAgICAgICAgdGhpcy50aW1lciA9IHNldEludGVydmFsKCgpID0+IHtcclxuICAgICAgICAgICAgdmFyIG5ld0NvdW50ID0gdGhpcy5zdGF0ZS5jb3VudCAtIDE7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgY291bnQ6IG5ld0NvdW50ID49IDAgPyBuZXdDb3VudCA6IDBcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSwgMTAwMCk7XHJcbiAgICB9LFxyXG4gICAgaGFuZGxlU2V0Q291bnRkb3duOiBmdW5jdGlvbihzZWNvbmRzKXtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgY291bnQ6IHNlY29uZHMsXHJcbiAgICAgICAgICAgIGNvdW50ZG93blN0YXR1czogJ3N0YXJ0ZWQnXHJcbiAgICAgICAgfSk7XHJcbiAgICB9LFxyXG4gICAgaGFuZGxlU3RhdHVzQ2hhbmdlOiBmdW5jdGlvbihuZXdTdGF0dXMpe1xyXG4gICAgICB0aGlzLnNldFN0YXRlKHtjb3VudGRvd25TdGF0dXM6IG5ld1N0YXR1c30pO1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIge2NvdW50LCBjb3VudGRvd25TdGF0dXN9ID0gdGhpcy5zdGF0ZTtcclxuICAgICAgICB2YXIgcmVuZGVyQ29udHJvbEFyZWEgPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmKGNvdW50ZG93blN0YXR1cyAhPT0gJ3N0b3BwZWQnKXtcclxuICAgICAgICAgICAgICByZXR1cm4gIDxDb250cm9scyBjb3VudGRvd25TdGF0dXM9e2NvdW50ZG93blN0YXR1c30gb25TdGF0dXNDaGFuZ2U9e3RoaXMuaGFuZGxlU3RhdHVzQ2hhbmdlfS8+XHJcbiAgICAgICAgICAgIH1lbHNle1xyXG4gICAgICAgICAgICAgIHJldHVybiAgPENvdW50ZG93bkZvcm0gb25TZXRDb3VudGRvd249e3RoaXMuaGFuZGxlU2V0Q291bnRkb3dufSAvPlxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuXHJcbiAgICAgICAgcmV0dXJuKFxyXG4gICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICA8Q2xvY2sgdG90YWxTZWNvbmRzID0ge2NvdW50fS8+XHJcbiAgICAgICAgICAgICAge3JlbmRlckNvbnRyb2xBcmVhKCl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ291bnRkb3duO1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9hcHAvY29tcG9uZW50cy9Db3VudGRvd24uanN4IiwidmFyIFJlYWN0ID0gcmVxdWlyZSgncmVhY3QnKTtcclxuXHJcbnZhciBDbG9jayA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICBnZXREZWZhdWx0UHJvcHM6IGZ1bmN0aW9uKCl7XHJcbiAgICAgIHRvdGFsU2Vjb25kczogMFxyXG4gIH0sXHJcbiAgcHJvcFR5cGVzOiB7XHJcbiAgICAgIHRvdGFsU2Vjb25kczogUmVhY3QuUHJvcFR5cGVzLm51bWJlclxyXG4gIH0sXHJcbiAgZm9ybWF0U2Vjb25kczogZnVuY3Rpb24gKHRvdGFsU2Vjb25kcykge1xyXG4gICAgdmFyIHNlY29uZHMgPSB0b3RhbFNlY29uZHMgJSA2MDtcclxuICAgIHZhciBtaW51dGVzID0gTWF0aC5mbG9vcih0b3RhbFNlY29uZHMgLyA2MCk7XHJcblxyXG4gICAgaWYgKHNlY29uZHMgPCAxMCkge1xyXG4gICAgICBzZWNvbmRzID0gJzAnICsgc2Vjb25kcztcclxuICAgIH1cclxuXHJcbiAgICBpZiAobWludXRlcyA8IDEwKSB7XHJcbiAgICAgIG1pbnV0ZXMgPSAnMCcgKyBtaW51dGVzO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBtaW51dGVzICsgJzonICsgc2Vjb25kcztcclxuICB9LFxyXG4gIHJlbmRlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHt0b3RhbFNlY29uZHN9ID0gdGhpcy5wcm9wcztcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICA8ZGl2IGNsYXNzTmFtZT1cImNsb2NrXCI+XHJcbiAgICAgICAgICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiY2xvY2stdGV4dFwiPlxyXG4gICAgICAgICAgICAgICAgICB7dGhpcy5mb3JtYXRTZWNvbmRzKHRvdGFsU2Vjb25kcyl9XHJcbiAgICAgICAgICAgICAgPC9zcGFuPlxyXG4gICAgICA8L2Rpdj5cclxuICAgICk7XHJcbiAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ2xvY2s7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL0Nsb2NrLmpzeCIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgQ291bnRkb3duRm9ybSA9IFJlYWN0LmNyZWF0ZUNsYXNzKHtcclxuICAgIG9uU3VibWl0OiBmdW5jdGlvbihlKXtcclxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XHJcblxyXG4gICAgICAgIHZhciBzdHJTZWNvbmRzID0gdGhpcy5yZWZzLnNlY29uZHMudmFsdWU7XHJcblxyXG4gICAgICAgIGlmKCBzdHJTZWNvbmRzLm1hdGNoKC9eWzAtOV0qJC8pICl7ICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRoaXMucmVmcy5zZWNvbmRzLnZhbHVlID0gJyc7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25TZXRDb3VudGRvd24ocGFyc2VJbnQoc3RyU2Vjb25kcywgMTApKTtcclxuICAgICAgICB9O1xyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcclxuICAgICAgcmV0dXJuKFxyXG4gICAgICAgICAgPGRpdj5cclxuICAgICAgICAgICAgICA8Zm9ybSByZWY9XCJmb3JtXCIgb25TdWJtaXQ9e3RoaXMub25TdWJtaXR9IGNsYXNzTmFtZT1cImNvdW50ZG93bi1mb3JtXCI+XHJcbiAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIHJlZj1cInNlY29uZHNcIiBwbGFjZWhvbGRlcj1cIlVuZXNpdGUgdnJpamVtZSB1IHNla3VuZGFtYVwiLz5cclxuICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzc05hbWU9XCJidXR0b24gZXhwYW5kZWRcIj5TdGFydDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgIDwvZm9ybT5cclxuICAgICAgICAgIDwvZGl2PlxyXG4gICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IENvdW50ZG93bkZvcm07XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL0NvdW50ZG93bkZvcm0uanN4IiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL2ZvdW5kYXRpb24ubWluLmNzc1wiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi8uLi8uLi9zdHlsZS1sb2FkZXIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIHt9KTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi8uLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzIS4vZm91bmRhdGlvbi5taW4uY3NzXCIsIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9mb3VuZGF0aW9uLm1pbi5jc3NcIik7XG5cdFx0XHRpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcblx0XHRcdHVwZGF0ZShuZXdDb250ZW50KTtcblx0XHR9KTtcblx0fVxuXHQvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vfi9zdHlsZS1sb2FkZXIhLi9+L2Nzcy1sb2FkZXIhLi9+L2ZvdW5kYXRpb24tc2l0ZXMvZGlzdC9mb3VuZGF0aW9uLm1pbi5jc3Ncbi8vIG1vZHVsZSBpZCA9IDIzNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi8uLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSgpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcIlVURi04XFxcIjtcXG4vKiEgbm9ybWFsaXplLmNzcyB2My4wLjMgfCBNSVQgTGljZW5zZSB8IGdpdGh1Yi5jb20vbmVjb2xhcy9ub3JtYWxpemUuY3NzICovaHRtbHtmb250LWZhbWlseTpzYW5zLXNlcmlmOy1tcy10ZXh0LXNpemUtYWRqdXN0OjEwMCU7LXdlYmtpdC10ZXh0LXNpemUtYWRqdXN0OjEwMCV9Ym9keXttYXJnaW46MH1hcnRpY2xlLGFzaWRlLGRldGFpbHMsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGhlYWRlcixoZ3JvdXAsbWFpbixtZW51LG5hdixzZWN0aW9uLHN1bW1hcnl7ZGlzcGxheTpibG9ja31hdWRpbyxjYW52YXMscHJvZ3Jlc3MsdmlkZW97ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246YmFzZWxpbmV9YXVkaW86bm90KFtjb250cm9sc10pe2Rpc3BsYXk6bm9uZTtoZWlnaHQ6MH1baGlkZGVuXSx0ZW1wbGF0ZXtkaXNwbGF5Om5vbmV9YXtiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fWE6YWN0aXZlLGE6aG92ZXJ7b3V0bGluZTowfWFiYnJbdGl0bGVde2JvcmRlci1ib3R0b206MXB4IGRvdHRlZH1iLHN0cm9uZ3tmb250LXdlaWdodDo3MDB9ZGZue2ZvbnQtc3R5bGU6aXRhbGljfWgxe2ZvbnQtc2l6ZToyZW07bWFyZ2luOi42N2VtIDB9bWFya3tiYWNrZ3JvdW5kOiNmZjA7Y29sb3I6IzAwMH1zbWFsbHtmb250LXNpemU6ODAlfXN1YixzdXB7Zm9udC1zaXplOjc1JTtsaW5lLWhlaWdodDowO3Bvc2l0aW9uOnJlbGF0aXZlO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfXN1cHt0b3A6LS41ZW19c3Vie2JvdHRvbTotLjI1ZW19aW1ne2JvcmRlcjowfXN2Zzpub3QoOnJvb3Qpe292ZXJmbG93OmhpZGRlbn1maWd1cmV7bWFyZ2luOjFlbSA0MHB4fWhye2JveC1zaXppbmc6Y29udGVudC1ib3g7aGVpZ2h0OjB9cHJle292ZXJmbG93OmF1dG99Y29kZSxrYmQscHJlLHNhbXB7Zm9udC1mYW1pbHk6bW9ub3NwYWNlLG1vbm9zcGFjZTtmb250LXNpemU6MWVtfWJ1dHRvbixpbnB1dCxvcHRncm91cCxzZWxlY3QsdGV4dGFyZWF7Y29sb3I6aW5oZXJpdDtmb250OmluaGVyaXQ7bWFyZ2luOjB9YnV0dG9ue292ZXJmbG93OnZpc2libGV9YnV0dG9uLHNlbGVjdHt0ZXh0LXRyYW5zZm9ybTpub25lfWJ1dHRvbixodG1sIGlucHV0W3R5cGU9YnV0dG9uXSxpbnB1dFt0eXBlPXJlc2V0XSxpbnB1dFt0eXBlPXN1Ym1pdF17LXdlYmtpdC1hcHBlYXJhbmNlOmJ1dHRvbjtjdXJzb3I6cG9pbnRlcn1idXR0b25bZGlzYWJsZWRdLGh0bWwgaW5wdXRbZGlzYWJsZWRde2N1cnNvcjpub3QtYWxsb3dlZH1idXR0b246Oi1tb3otZm9jdXMtaW5uZXIsaW5wdXQ6Oi1tb3otZm9jdXMtaW5uZXJ7Ym9yZGVyOjA7cGFkZGluZzowfWlucHV0e2xpbmUtaGVpZ2h0Om5vcm1hbH1pbnB1dFt0eXBlPWNoZWNrYm94XSxpbnB1dFt0eXBlPXJhZGlvXXtib3gtc2l6aW5nOmJvcmRlci1ib3g7cGFkZGluZzowfWlucHV0W3R5cGU9bnVtYmVyXTo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixpbnB1dFt0eXBlPW51bWJlcl06Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b257aGVpZ2h0OmF1dG99aW5wdXRbdHlwZT1zZWFyY2hdey13ZWJraXQtYXBwZWFyYW5jZTp0ZXh0ZmllbGQ7Ym94LXNpemluZzpjb250ZW50LWJveH1pbnB1dFt0eXBlPXNlYXJjaF06Oi13ZWJraXQtc2VhcmNoLWNhbmNlbC1idXR0b24saW5wdXRbdHlwZT1zZWFyY2hdOjotd2Via2l0LXNlYXJjaC1kZWNvcmF0aW9uey13ZWJraXQtYXBwZWFyYW5jZTpub25lfWxlZ2VuZHtib3JkZXI6MDtwYWRkaW5nOjB9dGV4dGFyZWF7b3ZlcmZsb3c6YXV0b31vcHRncm91cHtmb250LXdlaWdodDo3MDB9dGFibGV7Ym9yZGVyLWNvbGxhcHNlOmNvbGxhcHNlO2JvcmRlci1zcGFjaW5nOjB9dGQsdGh7cGFkZGluZzowfS5mb3VuZGF0aW9uLW1xe2ZvbnQtZmFtaWx5OlxcXCJzbWFsbD0wZW0mbWVkaXVtPTQwZW0mbGFyZ2U9NjRlbSZ4bGFyZ2U9NzVlbSZ4eGxhcmdlPTkwZW1cXFwifWh0bWx7Zm9udC1zaXplOjEwMCU7Ym94LXNpemluZzpib3JkZXItYm94fSosOmFmdGVyLDpiZWZvcmV7Ym94LXNpemluZzppbmhlcml0fWJvZHl7cGFkZGluZzowO21hcmdpbjowO2ZvbnQtZmFtaWx5OkhlbHZldGljYSBOZXVlLEhlbHZldGljYSxSb2JvdG8sQXJpYWwsc2Fucy1zZXJpZjtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS41O2NvbG9yOiMwYTBhMGE7YmFja2dyb3VuZDojZmVmZWZlOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlfWltZ3ttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6YXV0bzstbXMtaW50ZXJwb2xhdGlvbi1tb2RlOmJpY3ViaWM7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlfXRleHRhcmVhe2hlaWdodDphdXRvO21pbi1oZWlnaHQ6NTBweDtib3JkZXItcmFkaXVzOjB9c2VsZWN0e3dpZHRoOjEwMCU7Ym9yZGVyLXJhZGl1czowfSNtYXBfY2FudmFzIGVtYmVkLCNtYXBfY2FudmFzIGltZywjbWFwX2NhbnZhcyBvYmplY3QsLm1hcF9jYW52YXMgZW1iZWQsLm1hcF9jYW52YXMgaW1nLC5tYXBfY2FudmFzIG9iamVjdCwubXFhLWRpc3BsYXkgZW1iZWQsLm1xYS1kaXNwbGF5IGltZywubXFhLWRpc3BsYXkgb2JqZWN0e21heC13aWR0aDpub25lIWltcG9ydGFudH1idXR0b257LXdlYmtpdC1hcHBlYXJhbmNlOm5vbmU7LW1vei1hcHBlYXJhbmNlOm5vbmU7YmFja2dyb3VuZDp0cmFuc3BhcmVudDtwYWRkaW5nOjA7Ym9yZGVyOjA7Ym9yZGVyLXJhZGl1czowO2xpbmUtaGVpZ2h0OjF9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSBidXR0b257b3V0bGluZTowfS5pcy12aXNpYmxle2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5pcy1oaWRkZW57ZGlzcGxheTpub25lIWltcG9ydGFudH0ucm93e21heC13aWR0aDo3NXJlbTttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5yb3c6YWZ0ZXIsLnJvdzpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0ucm93OmFmdGVye2NsZWFyOmJvdGh9LnJvdy5jb2xsYXBzZT4uY29sdW1uLC5yb3cuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5yb3cgLnJvd3ttYXJnaW4tbGVmdDotLjYyNXJlbTttYXJnaW4tcmlnaHQ6LS42MjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucm93IC5yb3d7bWFyZ2luLWxlZnQ6LS45Mzc1cmVtO21hcmdpbi1yaWdodDotLjkzNzVyZW19fS5yb3cgLnJvdy5jb2xsYXBzZXttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5yb3cuZXhwYW5kZWR7bWF4LXdpZHRoOm5vbmV9LnJvdy5leHBhbmRlZCAucm93e21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LmNvbHVtbiwuY29sdW1uc3t3aWR0aDoxMDAlO2Zsb2F0OmxlZnQ7cGFkZGluZy1sZWZ0Oi42MjVyZW07cGFkZGluZy1yaWdodDouNjI1cmVtfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LmNvbHVtbiwuY29sdW1uc3twYWRkaW5nLWxlZnQ6LjkzNzVyZW07cGFkZGluZy1yaWdodDouOTM3NXJlbX19LmNvbHVtbjpsYXN0LWNoaWxkOm5vdCg6Zmlyc3QtY2hpbGQpLC5jb2x1bW5zOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7ZmxvYXQ6cmlnaHR9LmNvbHVtbi5lbmQ6bGFzdC1jaGlsZDpsYXN0LWNoaWxkLC5lbmQuY29sdW1uczpsYXN0LWNoaWxkOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uY29sdW1uLnJvdy5yb3csLnJvdy5yb3cuY29sdW1uc3tmbG9hdDpub25lfS5yb3cgLmNvbHVtbi5yb3cucm93LC5yb3cgLnJvdy5yb3cuY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjA7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0uc21hbGwtMXt3aWR0aDo4LjMzMzMzJX0uc21hbGwtcHVzaC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6OC4zMzMzMyV9LnNtYWxsLXB1bGwtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04LjMzMzMzJX0uc21hbGwtb2Zmc2V0LTB7bWFyZ2luLWxlZnQ6MH0uc21hbGwtMnt3aWR0aDoxNi42NjY2NyV9LnNtYWxsLXB1c2gtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjE2LjY2NjY3JX0uc21hbGwtcHVsbC0ye3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTE2LjY2NjY3JX0uc21hbGwtb2Zmc2V0LTF7bWFyZ2luLWxlZnQ6OC4zMzMzMyV9LnNtYWxsLTN7d2lkdGg6MjUlfS5zbWFsbC1wdXNoLTN7cG9zaXRpb246cmVsYXRpdmU7bGVmdDoyNSV9LnNtYWxsLXB1bGwtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0yNSV9LnNtYWxsLW9mZnNldC0ye21hcmdpbi1sZWZ0OjE2LjY2NjY3JX0uc21hbGwtNHt3aWR0aDozMy4zMzMzMyV9LnNtYWxsLXB1c2gtNHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjMzLjMzMzMzJX0uc21hbGwtcHVsbC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTMzLjMzMzMzJX0uc21hbGwtb2Zmc2V0LTN7bWFyZ2luLWxlZnQ6MjUlfS5zbWFsbC01e3dpZHRoOjQxLjY2NjY3JX0uc21hbGwtcHVzaC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NDEuNjY2NjclfS5zbWFsbC1wdWxsLTV7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNDEuNjY2NjclfS5zbWFsbC1vZmZzZXQtNHttYXJnaW4tbGVmdDozMy4zMzMzMyV9LnNtYWxsLTZ7d2lkdGg6NTAlfS5zbWFsbC1wdXNoLTZ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo1MCV9LnNtYWxsLXB1bGwtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi01MCV9LnNtYWxsLW9mZnNldC01e21hcmdpbi1sZWZ0OjQxLjY2NjY3JX0uc21hbGwtN3t3aWR0aDo1OC4zMzMzMyV9LnNtYWxsLXB1c2gtN3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjU4LjMzMzMzJX0uc21hbGwtcHVsbC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTU4LjMzMzMzJX0uc21hbGwtb2Zmc2V0LTZ7bWFyZ2luLWxlZnQ6NTAlfS5zbWFsbC04e3dpZHRoOjY2LjY2NjY3JX0uc21hbGwtcHVzaC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NjYuNjY2NjclfS5zbWFsbC1wdWxsLTh7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNjYuNjY2NjclfS5zbWFsbC1vZmZzZXQtN3ttYXJnaW4tbGVmdDo1OC4zMzMzMyV9LnNtYWxsLTl7d2lkdGg6NzUlfS5zbWFsbC1wdXNoLTl7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo3NSV9LnNtYWxsLXB1bGwtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi03NSV9LnNtYWxsLW9mZnNldC04e21hcmdpbi1sZWZ0OjY2LjY2NjY3JX0uc21hbGwtMTB7d2lkdGg6ODMuMzMzMzMlfS5zbWFsbC1wdXNoLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6ODMuMzMzMzMlfS5zbWFsbC1wdWxsLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTgzLjMzMzMzJX0uc21hbGwtb2Zmc2V0LTl7bWFyZ2luLWxlZnQ6NzUlfS5zbWFsbC0xMXt3aWR0aDo5MS42NjY2NyV9LnNtYWxsLXB1c2gtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo5MS42NjY2NyV9LnNtYWxsLXB1bGwtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotOTEuNjY2NjclfS5zbWFsbC1vZmZzZXQtMTB7bWFyZ2luLWxlZnQ6ODMuMzMzMzMlfS5zbWFsbC0xMnt3aWR0aDoxMDAlfS5zbWFsbC1vZmZzZXQtMTF7bWFyZ2luLWxlZnQ6OTEuNjY2NjclfS5zbWFsbC11cC0xPi5jb2x1bW4sLnNtYWxsLXVwLTE+LmNvbHVtbnN7d2lkdGg6MTAwJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksLnNtYWxsLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtMT4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTE+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC0yPi5jb2x1bW4sLnNtYWxsLXVwLTI+LmNvbHVtbnN7d2lkdGg6NTAlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTI+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgybisxKSwuc21hbGwtdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgybisxKXtjbGVhcjpib3RofS5zbWFsbC11cC0yPi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtMj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTM+LmNvbHVtbiwuc21hbGwtdXAtMz4uY29sdW1uc3t3aWR0aDozMy4zMzMzMyU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtMz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtMz4uY29sdW1uOm50aC1vZi10eXBlKDNuKzEpLC5zbWFsbC11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDNuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTM+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC0zPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtND4uY29sdW1uLC5zbWFsbC11cC00Pi5jb2x1bW5ze3dpZHRoOjI1JTtmbG9hdDpsZWZ0fS5zbWFsbC11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksLnNtYWxsLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNG4rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtND4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTQ+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC01Pi5jb2x1bW4sLnNtYWxsLXVwLTU+LmNvbHVtbnN7d2lkdGg6MjAlO2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLnNtYWxsLXVwLTU+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LnNtYWxsLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSg1bisxKSwuc21hbGwtdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSg1bisxKXtjbGVhcjpib3RofS5zbWFsbC11cC01Pi5jb2x1bW46bGFzdC1jaGlsZCwuc21hbGwtdXAtNT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LnNtYWxsLXVwLTY+LmNvbHVtbiwuc21hbGwtdXAtNj4uY29sdW1uc3t3aWR0aDoxNi42NjY2NyU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtNj4uY29sdW1uOm50aC1vZi10eXBlKDZuKzEpLC5zbWFsbC11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDZuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTY+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC02Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtNz4uY29sdW1uLC5zbWFsbC11cC03Pi5jb2x1bW5ze3dpZHRoOjE0LjI4NTcxJTtmbG9hdDpsZWZ0fS5zbWFsbC11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5zbWFsbC11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5zbWFsbC11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksLnNtYWxsLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoN24rMSl7Y2xlYXI6Ym90aH0uc21hbGwtdXAtNz4uY29sdW1uOmxhc3QtY2hpbGQsLnNtYWxsLXVwLTc+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5zbWFsbC11cC04Pi5jb2x1bW4sLnNtYWxsLXVwLTg+LmNvbHVtbnN7d2lkdGg6MTIuNSU7ZmxvYXQ6bGVmdH0uc21hbGwtdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwuc21hbGwtdXAtOD4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0uc21hbGwtdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDhuKzEpLC5zbWFsbC11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpe2NsZWFyOmJvdGh9LnNtYWxsLXVwLTg+LmNvbHVtbjpsYXN0LWNoaWxkLC5zbWFsbC11cC04Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0uc21hbGwtY29sbGFwc2U+LmNvbHVtbiwuc21hbGwtY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0OjA7cGFkZGluZy1yaWdodDowfS5leHBhbmRlZC5yb3cgLnNtYWxsLWNvbGxhcHNlLnJvdywuc21hbGwtY29sbGFwc2UgLnJvd3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5zbWFsbC11bmNvbGxhcHNlPi5jb2x1bW4sLnNtYWxsLXVuY29sbGFwc2U+LmNvbHVtbnN7cGFkZGluZy1sZWZ0Oi42MjVyZW07cGFkZGluZy1yaWdodDouNjI1cmVtfS5zbWFsbC1jZW50ZXJlZHttYXJnaW4tbGVmdDphdXRvO21hcmdpbi1yaWdodDphdXRvfS5zbWFsbC1jZW50ZXJlZCwuc21hbGwtY2VudGVyZWQ6bGFzdC1jaGlsZDpub3QoOmZpcnN0LWNoaWxkKXtmbG9hdDpub25lO2NsZWFyOmJvdGh9LnNtYWxsLXB1bGwtMCwuc21hbGwtcHVzaC0wLC5zbWFsbC11bmNlbnRlcmVke3Bvc2l0aW9uOnN0YXRpYzttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowO2Zsb2F0OmxlZnR9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsubWVkaXVtLTF7d2lkdGg6OC4zMzMzMyV9Lm1lZGl1bS1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0ubWVkaXVtLXB1bGwtMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi04LjMzMzMzJX0ubWVkaXVtLW9mZnNldC0we21hcmdpbi1sZWZ0OjB9Lm1lZGl1bS0ye3dpZHRoOjE2LjY2NjY3JX0ubWVkaXVtLXB1c2gtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjE2LjY2NjY3JX0ubWVkaXVtLXB1bGwtMntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi0xNi42NjY2NyV9Lm1lZGl1bS1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0ubWVkaXVtLTN7d2lkdGg6MjUlfS5tZWRpdW0tcHVzaC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MjUlfS5tZWRpdW0tcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0ubWVkaXVtLW9mZnNldC0ye21hcmdpbi1sZWZ0OjE2LjY2NjY3JX0ubWVkaXVtLTR7d2lkdGg6MzMuMzMzMzMlfS5tZWRpdW0tcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5tZWRpdW0tcHVsbC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTMzLjMzMzMzJX0ubWVkaXVtLW9mZnNldC0ze21hcmdpbi1sZWZ0OjI1JX0ubWVkaXVtLTV7d2lkdGg6NDEuNjY2NjclfS5tZWRpdW0tcHVzaC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NDEuNjY2NjclfS5tZWRpdW0tcHVsbC01e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTQxLjY2NjY3JX0ubWVkaXVtLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0ubWVkaXVtLTZ7d2lkdGg6NTAlfS5tZWRpdW0tcHVzaC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTAlfS5tZWRpdW0tcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0ubWVkaXVtLW9mZnNldC01e21hcmdpbi1sZWZ0OjQxLjY2NjY3JX0ubWVkaXVtLTd7d2lkdGg6NTguMzMzMzMlfS5tZWRpdW0tcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5tZWRpdW0tcHVsbC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTU4LjMzMzMzJX0ubWVkaXVtLW9mZnNldC02e21hcmdpbi1sZWZ0OjUwJX0ubWVkaXVtLTh7d2lkdGg6NjYuNjY2NjclfS5tZWRpdW0tcHVzaC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NjYuNjY2NjclfS5tZWRpdW0tcHVsbC04e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTY2LjY2NjY3JX0ubWVkaXVtLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0ubWVkaXVtLTl7d2lkdGg6NzUlfS5tZWRpdW0tcHVzaC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NzUlfS5tZWRpdW0tcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0ubWVkaXVtLW9mZnNldC04e21hcmdpbi1sZWZ0OjY2LjY2NjY3JX0ubWVkaXVtLTEwe3dpZHRoOjgzLjMzMzMzJX0ubWVkaXVtLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9Lm1lZGl1bS1wdWxsLTEwe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTgzLjMzMzMzJX0ubWVkaXVtLW9mZnNldC05e21hcmdpbi1sZWZ0Ojc1JX0ubWVkaXVtLTExe3dpZHRoOjkxLjY2NjY3JX0ubWVkaXVtLXB1c2gtMTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo5MS42NjY2NyV9Lm1lZGl1bS1wdWxsLTExe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTkxLjY2NjY3JX0ubWVkaXVtLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9Lm1lZGl1bS0xMnt3aWR0aDoxMDAlfS5tZWRpdW0tb2Zmc2V0LTExe21hcmdpbi1sZWZ0OjkxLjY2NjY3JX0ubWVkaXVtLXVwLTE+LmNvbHVtbiwubWVkaXVtLXVwLTE+LmNvbHVtbnN7d2lkdGg6MTAwJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC0xPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4rMSksLm1lZGl1bS11cC0xPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTE+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtMj4uY29sdW1uLC5tZWRpdW0tdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTI+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5tZWRpdW0tdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgybisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtMj4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTM+LmNvbHVtbiwubWVkaXVtLXVwLTM+LmNvbHVtbnN7d2lkdGg6MzMuMzMzMzMlO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtMz4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTM+LmNvbHVtbjpudGgtb2YtdHlwZSgzbisxKSwubWVkaXVtLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTM+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtMz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC00Pi5jb2x1bW4sLm1lZGl1bS11cC00Pi5jb2x1bW5ze3dpZHRoOjI1JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtND4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC00Pi5jb2x1bW46bnRoLW9mLXR5cGUoNG4rMSksLm1lZGl1bS11cC00Pi5jb2x1bW5zOm50aC1vZi10eXBlKDRuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTQ+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNT4uY29sdW1uLC5tZWRpdW0tdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTU+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLm1lZGl1bS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5tZWRpdW0tdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5tZWRpdW0tdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSg1bisxKXtjbGVhcjpib3RofS5tZWRpdW0tdXAtNT4uY29sdW1uOmxhc3QtY2hpbGQsLm1lZGl1bS11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubWVkaXVtLXVwLTY+LmNvbHVtbiwubWVkaXVtLXVwLTY+LmNvbHVtbnN7d2lkdGg6MTYuNjY2NjclO2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5tZWRpdW0tdXAtNj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubWVkaXVtLXVwLTY+LmNvbHVtbjpudGgtb2YtdHlwZSg2bisxKSwubWVkaXVtLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0ubWVkaXVtLXVwLTY+LmNvbHVtbjpsYXN0LWNoaWxkLC5tZWRpdW0tdXAtNj4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9Lm1lZGl1bS11cC03Pi5jb2x1bW4sLm1lZGl1bS11cC03Pi5jb2x1bW5ze3dpZHRoOjE0LjI4NTcxJTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtNz4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC03Pi5jb2x1bW46bnRoLW9mLXR5cGUoN24rMSksLm1lZGl1bS11cC03Pi5jb2x1bW5zOm50aC1vZi10eXBlKDduKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTc+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtOD4uY29sdW1uLC5tZWRpdW0tdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5tZWRpdW0tdXAtOD4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubWVkaXVtLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9Lm1lZGl1bS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLm1lZGl1bS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDhuKzEpe2NsZWFyOmJvdGh9Lm1lZGl1bS11cC04Pi5jb2x1bW46bGFzdC1jaGlsZCwubWVkaXVtLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5tZWRpdW0tY29sbGFwc2U+LmNvbHVtbiwubWVkaXVtLWNvbGxhcHNlPi5jb2x1bW5ze3BhZGRpbmctbGVmdDowO3BhZGRpbmctcmlnaHQ6MH0uZXhwYW5kZWQucm93IC5tZWRpdW0tY29sbGFwc2Uucm93LC5tZWRpdW0tY29sbGFwc2UgLnJvd3ttYXJnaW4tbGVmdDowO21hcmdpbi1yaWdodDowfS5tZWRpdW0tdW5jb2xsYXBzZT4uY29sdW1uLC5tZWRpdW0tdW5jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6LjkzNzVyZW07cGFkZGluZy1yaWdodDouOTM3NXJlbX0ubWVkaXVtLWNlbnRlcmVke21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99Lm1lZGl1bS1jZW50ZXJlZCwubWVkaXVtLWNlbnRlcmVkOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7ZmxvYXQ6bm9uZTtjbGVhcjpib3RofS5tZWRpdW0tcHVsbC0wLC5tZWRpdW0tcHVzaC0wLC5tZWRpdW0tdW5jZW50ZXJlZHtwb3NpdGlvbjpzdGF0aWM7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtmbG9hdDpsZWZ0fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5sYXJnZS0xe3dpZHRoOjguMzMzMzMlfS5sYXJnZS1wdXNoLTF7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4LjMzMzMzJX0ubGFyZ2UtcHVsbC0xe3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTguMzMzMzMlfS5sYXJnZS1vZmZzZXQtMHttYXJnaW4tbGVmdDowfS5sYXJnZS0ye3dpZHRoOjE2LjY2NjY3JX0ubGFyZ2UtcHVzaC0ye3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MTYuNjY2NjclfS5sYXJnZS1wdWxsLTJ7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMTYuNjY2NjclfS5sYXJnZS1vZmZzZXQtMXttYXJnaW4tbGVmdDo4LjMzMzMzJX0ubGFyZ2UtM3t3aWR0aDoyNSV9LmxhcmdlLXB1c2gtM3twb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjI1JX0ubGFyZ2UtcHVsbC0ze3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTI1JX0ubGFyZ2Utb2Zmc2V0LTJ7bWFyZ2luLWxlZnQ6MTYuNjY2NjclfS5sYXJnZS00e3dpZHRoOjMzLjMzMzMzJX0ubGFyZ2UtcHVzaC00e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6MzMuMzMzMzMlfS5sYXJnZS1wdWxsLTR7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotMzMuMzMzMzMlfS5sYXJnZS1vZmZzZXQtM3ttYXJnaW4tbGVmdDoyNSV9LmxhcmdlLTV7d2lkdGg6NDEuNjY2NjclfS5sYXJnZS1wdXNoLTV7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo0MS42NjY2NyV9LmxhcmdlLXB1bGwtNXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi00MS42NjY2NyV9LmxhcmdlLW9mZnNldC00e21hcmdpbi1sZWZ0OjMzLjMzMzMzJX0ubGFyZ2UtNnt3aWR0aDo1MCV9LmxhcmdlLXB1c2gtNntwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjUwJX0ubGFyZ2UtcHVsbC02e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTUwJX0ubGFyZ2Utb2Zmc2V0LTV7bWFyZ2luLWxlZnQ6NDEuNjY2NjclfS5sYXJnZS03e3dpZHRoOjU4LjMzMzMzJX0ubGFyZ2UtcHVzaC03e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6NTguMzMzMzMlfS5sYXJnZS1wdWxsLTd7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotNTguMzMzMzMlfS5sYXJnZS1vZmZzZXQtNnttYXJnaW4tbGVmdDo1MCV9LmxhcmdlLTh7d2lkdGg6NjYuNjY2NjclfS5sYXJnZS1wdXNoLTh7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo2Ni42NjY2NyV9LmxhcmdlLXB1bGwtOHtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi02Ni42NjY2NyV9LmxhcmdlLW9mZnNldC03e21hcmdpbi1sZWZ0OjU4LjMzMzMzJX0ubGFyZ2UtOXt3aWR0aDo3NSV9LmxhcmdlLXB1c2gtOXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Ojc1JX0ubGFyZ2UtcHVsbC05e3Bvc2l0aW9uOnJlbGF0aXZlO2xlZnQ6LTc1JX0ubGFyZ2Utb2Zmc2V0LTh7bWFyZ2luLWxlZnQ6NjYuNjY2NjclfS5sYXJnZS0xMHt3aWR0aDo4My4zMzMzMyV9LmxhcmdlLXB1c2gtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDo4My4zMzMzMyV9LmxhcmdlLXB1bGwtMTB7cG9zaXRpb246cmVsYXRpdmU7bGVmdDotODMuMzMzMzMlfS5sYXJnZS1vZmZzZXQtOXttYXJnaW4tbGVmdDo3NSV9LmxhcmdlLTExe3dpZHRoOjkxLjY2NjY3JX0ubGFyZ2UtcHVzaC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0OjkxLjY2NjY3JX0ubGFyZ2UtcHVsbC0xMXtwb3NpdGlvbjpyZWxhdGl2ZTtsZWZ0Oi05MS42NjY2NyV9LmxhcmdlLW9mZnNldC0xMHttYXJnaW4tbGVmdDo4My4zMzMzMyV9LmxhcmdlLTEye3dpZHRoOjEwMCV9LmxhcmdlLW9mZnNldC0xMXttYXJnaW4tbGVmdDo5MS42NjY2NyV9LmxhcmdlLXVwLTE+LmNvbHVtbiwubGFyZ2UtdXAtMT4uY29sdW1uc3t3aWR0aDoxMDAlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTE+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTE+LmNvbHVtbjpudGgtb2YtdHlwZSgxbisxKSwubGFyZ2UtdXAtMT4uY29sdW1uczpudGgtb2YtdHlwZSgxbisxKXtjbGVhcjpib3RofS5sYXJnZS11cC0xPi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtMT4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTI+LmNvbHVtbiwubGFyZ2UtdXAtMj4uY29sdW1uc3t3aWR0aDo1MCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtMj4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtMj4uY29sdW1uOm50aC1vZi10eXBlKDJuKzEpLC5sYXJnZS11cC0yPi5jb2x1bW5zOm50aC1vZi10eXBlKDJuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTI+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC0yPi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtMz4uY29sdW1uLC5sYXJnZS11cC0zPi5jb2x1bW5ze3dpZHRoOjMzLjMzMzMzJTtmbG9hdDpsZWZ0fS5sYXJnZS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC0zPi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC0zPi5jb2x1bW46bnRoLW9mLXR5cGUoM24rMSksLmxhcmdlLXVwLTM+LmNvbHVtbnM6bnRoLW9mLXR5cGUoM24rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtMz4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTM+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC00Pi5jb2x1bW4sLmxhcmdlLXVwLTQ+LmNvbHVtbnN7d2lkdGg6MjUlO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTQ+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTQ+LmNvbHVtbjpudGgtb2YtdHlwZSg0bisxKSwubGFyZ2UtdXAtND4uY29sdW1uczpudGgtb2YtdHlwZSg0bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC00Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtND4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTU+LmNvbHVtbiwubGFyZ2UtdXAtNT4uY29sdW1uc3t3aWR0aDoyMCU7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDFuKSwubGFyZ2UtdXAtNT4uY29sdW1uczpudGgtb2YtdHlwZSgxbil7Y2xlYXI6bm9uZX0ubGFyZ2UtdXAtNT4uY29sdW1uOm50aC1vZi10eXBlKDVuKzEpLC5sYXJnZS11cC01Pi5jb2x1bW5zOm50aC1vZi10eXBlKDVuKzEpe2NsZWFyOmJvdGh9LmxhcmdlLXVwLTU+LmNvbHVtbjpsYXN0LWNoaWxkLC5sYXJnZS11cC01Pi5jb2x1bW5zOmxhc3QtY2hpbGR7ZmxvYXQ6bGVmdH0ubGFyZ2UtdXAtNj4uY29sdW1uLC5sYXJnZS11cC02Pi5jb2x1bW5ze3dpZHRoOjE2LjY2NjY3JTtmbG9hdDpsZWZ0fS5sYXJnZS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC02Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC02Pi5jb2x1bW46bnRoLW9mLXR5cGUoNm4rMSksLmxhcmdlLXVwLTY+LmNvbHVtbnM6bnRoLW9mLXR5cGUoNm4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtNj4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTY+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS11cC03Pi5jb2x1bW4sLmxhcmdlLXVwLTc+LmNvbHVtbnN7d2lkdGg6MTQuMjg1NzElO2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSgxbiksLmxhcmdlLXVwLTc+LmNvbHVtbnM6bnRoLW9mLXR5cGUoMW4pe2NsZWFyOm5vbmV9LmxhcmdlLXVwLTc+LmNvbHVtbjpudGgtb2YtdHlwZSg3bisxKSwubGFyZ2UtdXAtNz4uY29sdW1uczpudGgtb2YtdHlwZSg3bisxKXtjbGVhcjpib3RofS5sYXJnZS11cC03Pi5jb2x1bW46bGFzdC1jaGlsZCwubGFyZ2UtdXAtNz4uY29sdW1uczpsYXN0LWNoaWxke2Zsb2F0OmxlZnR9LmxhcmdlLXVwLTg+LmNvbHVtbiwubGFyZ2UtdXAtOD4uY29sdW1uc3t3aWR0aDoxMi41JTtmbG9hdDpsZWZ0fS5sYXJnZS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoMW4pLC5sYXJnZS11cC04Pi5jb2x1bW5zOm50aC1vZi10eXBlKDFuKXtjbGVhcjpub25lfS5sYXJnZS11cC04Pi5jb2x1bW46bnRoLW9mLXR5cGUoOG4rMSksLmxhcmdlLXVwLTg+LmNvbHVtbnM6bnRoLW9mLXR5cGUoOG4rMSl7Y2xlYXI6Ym90aH0ubGFyZ2UtdXAtOD4uY29sdW1uOmxhc3QtY2hpbGQsLmxhcmdlLXVwLTg+LmNvbHVtbnM6bGFzdC1jaGlsZHtmbG9hdDpsZWZ0fS5sYXJnZS1jb2xsYXBzZT4uY29sdW1uLC5sYXJnZS1jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6MDtwYWRkaW5nLXJpZ2h0OjB9LmV4cGFuZGVkLnJvdyAubGFyZ2UtY29sbGFwc2Uucm93LC5sYXJnZS1jb2xsYXBzZSAucm93e21hcmdpbi1sZWZ0OjA7bWFyZ2luLXJpZ2h0OjB9LmxhcmdlLXVuY29sbGFwc2U+LmNvbHVtbiwubGFyZ2UtdW5jb2xsYXBzZT4uY29sdW1uc3twYWRkaW5nLWxlZnQ6LjkzNzVyZW07cGFkZGluZy1yaWdodDouOTM3NXJlbX0ubGFyZ2UtY2VudGVyZWR7bWFyZ2luLWxlZnQ6YXV0bzttYXJnaW4tcmlnaHQ6YXV0b30ubGFyZ2UtY2VudGVyZWQsLmxhcmdlLWNlbnRlcmVkOmxhc3QtY2hpbGQ6bm90KDpmaXJzdC1jaGlsZCl7ZmxvYXQ6bm9uZTtjbGVhcjpib3RofS5sYXJnZS1wdWxsLTAsLmxhcmdlLXB1c2gtMCwubGFyZ2UtdW5jZW50ZXJlZHtwb3NpdGlvbjpzdGF0aWM7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MDtmbG9hdDpsZWZ0fX1ibG9ja3F1b3RlLGRkLGRpdixkbCxkdCxmb3JtLGgxLGgyLGgzLGg0LGg1LGg2LGxpLG9sLHAscHJlLHRkLHRoLHVse21hcmdpbjowO3BhZGRpbmc6MH1we2ZvbnQtc2l6ZTppbmhlcml0O2xpbmUtaGVpZ2h0OjEuNjttYXJnaW4tYm90dG9tOjFyZW07dGV4dC1yZW5kZXJpbmc6b3B0aW1pemVMZWdpYmlsaXR5fWVtLGl7Zm9udC1zdHlsZTppdGFsaWN9YixlbSxpLHN0cm9uZ3tsaW5lLWhlaWdodDppbmhlcml0fWIsc3Ryb25ne2ZvbnQtd2VpZ2h0OjcwMH1zbWFsbHtmb250LXNpemU6ODAlO2xpbmUtaGVpZ2h0OmluaGVyaXR9aDEsaDIsaDMsaDQsaDUsaDZ7Zm9udC1mYW1pbHk6SGVsdmV0aWNhIE5ldWUsSGVsdmV0aWNhLFJvYm90byxBcmlhbCxzYW5zLXNlcmlmO2ZvbnQtd2VpZ2h0OjQwMDtmb250LXN0eWxlOm5vcm1hbDtjb2xvcjppbmhlcml0O3RleHQtcmVuZGVyaW5nOm9wdGltaXplTGVnaWJpbGl0eTttYXJnaW4tdG9wOjA7bWFyZ2luLWJvdHRvbTouNXJlbTtsaW5lLWhlaWdodDoxLjR9aDEgc21hbGwsaDIgc21hbGwsaDMgc21hbGwsaDQgc21hbGwsaDUgc21hbGwsaDYgc21hbGx7Y29sb3I6I2NhY2FjYTtsaW5lLWhlaWdodDowfWgxe2ZvbnQtc2l6ZToxLjVyZW19aDJ7Zm9udC1zaXplOjEuMjVyZW19aDN7Zm9udC1zaXplOjEuMTg3NXJlbX1oNHtmb250LXNpemU6MS4xMjVyZW19aDV7Zm9udC1zaXplOjEuMDYyNXJlbX1oNntmb250LXNpemU6MXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pe2gxe2ZvbnQtc2l6ZTozcmVtfWgye2ZvbnQtc2l6ZToyLjVyZW19aDN7Zm9udC1zaXplOjEuOTM3NXJlbX1oNHtmb250LXNpemU6MS41NjI1cmVtfWg1e2ZvbnQtc2l6ZToxLjI1cmVtfWg2e2ZvbnQtc2l6ZToxcmVtfX1he2NvbG9yOiMyMTk5ZTg7dGV4dC1kZWNvcmF0aW9uOm5vbmU7bGluZS1oZWlnaHQ6aW5oZXJpdDtjdXJzb3I6cG9pbnRlcn1hOmZvY3VzLGE6aG92ZXJ7Y29sb3I6IzE1ODVjZn1hIGltZ3tib3JkZXI6MH1ocnttYXgtd2lkdGg6NzVyZW07aGVpZ2h0OjA7Ym9yZGVyLXJpZ2h0OjA7Ym9yZGVyLXRvcDowO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNjYWNhY2E7Ym9yZGVyLWxlZnQ6MDttYXJnaW46MS4yNXJlbSBhdXRvO2NsZWFyOmJvdGh9ZGwsb2wsdWx7bGluZS1oZWlnaHQ6MS42O21hcmdpbi1ib3R0b206MXJlbTtsaXN0LXN0eWxlLXBvc2l0aW9uOm91dHNpZGV9bGl7Zm9udC1zaXplOmluaGVyaXR9dWx7bGlzdC1zdHlsZS10eXBlOmRpc2N9b2wsdWx7bWFyZ2luLWxlZnQ6MS4yNXJlbX1vbCBvbCxvbCB1bCx1bCBvbCx1bCB1bHttYXJnaW4tbGVmdDoxLjI1cmVtO21hcmdpbi1ib3R0b206MH1kbHttYXJnaW4tYm90dG9tOjFyZW19ZGwgZHR7bWFyZ2luLWJvdHRvbTouM3JlbTtmb250LXdlaWdodDo3MDB9YmxvY2txdW90ZXttYXJnaW46MCAwIDFyZW07cGFkZGluZzouNTYyNXJlbSAxLjI1cmVtIDAgMS4xODc1cmVtO2JvcmRlci1sZWZ0OjFweCBzb2xpZCAjY2FjYWNhfWJsb2NrcXVvdGUsYmxvY2txdW90ZSBwe2xpbmUtaGVpZ2h0OjEuNjtjb2xvcjojOGE4YThhfWNpdGV7ZGlzcGxheTpibG9jaztmb250LXNpemU6LjgxMjVyZW07Y29sb3I6IzhhOGE4YX1jaXRlOmJlZm9yZXtjb250ZW50OidcXFxcMjAxNCAgICAnfWFiYnJ7Y29sb3I6IzBhMGEwYTtjdXJzb3I6aGVscDtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQgIzBhMGEwYX1jb2Rle2ZvbnQtd2VpZ2h0OjQwMDtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2E7cGFkZGluZzouMTI1cmVtIC4zMTI1cmVtIC4wNjI1cmVtfWNvZGUsa2Jke2ZvbnQtZmFtaWx5OkNvbnNvbGFzLExpYmVyYXRpb24gTW9ubyxDb3VyaWVyLG1vbm9zcGFjZTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNn1rYmR7cGFkZGluZzouMTI1cmVtIC4yNXJlbSAwO21hcmdpbjowfS5zdWJoZWFkZXJ7bWFyZ2luLXRvcDouMnJlbTttYXJnaW4tYm90dG9tOi41cmVtO2ZvbnQtd2VpZ2h0OjQwMDtsaW5lLWhlaWdodDoxLjQ7Y29sb3I6IzhhOGE4YX0ubGVhZHtmb250LXNpemU6MTI1JTtsaW5lLWhlaWdodDoxLjZ9LnN0YXR7Zm9udC1zaXplOjIuNXJlbTtsaW5lLWhlaWdodDoxfXArLnN0YXR7bWFyZ2luLXRvcDotMXJlbX0ubm8tYnVsbGV0e21hcmdpbi1sZWZ0OjA7bGlzdC1zdHlsZTpub25lfS50ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS50ZXh0LXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9LnRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS50ZXh0LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7Lm1lZGl1bS10ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS5tZWRpdW0tdGV4dC1yaWdodHt0ZXh0LWFsaWduOnJpZ2h0fS5tZWRpdW0tdGV4dC1jZW50ZXJ7dGV4dC1hbGlnbjpjZW50ZXJ9Lm1lZGl1bS10ZXh0LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5sYXJnZS10ZXh0LWxlZnR7dGV4dC1hbGlnbjpsZWZ0fS5sYXJnZS10ZXh0LXJpZ2h0e3RleHQtYWxpZ246cmlnaHR9LmxhcmdlLXRleHQtY2VudGVye3RleHQtYWxpZ246Y2VudGVyfS5sYXJnZS10ZXh0LWp1c3RpZnl7dGV4dC1hbGlnbjpqdXN0aWZ5fX0uc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTpub25lIWltcG9ydGFudH1AbWVkaWEgcHJpbnR7KntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50IWltcG9ydGFudDtjb2xvcjojMDAwIWltcG9ydGFudDtib3gtc2hhZG93Om5vbmUhaW1wb3J0YW50O3RleHQtc2hhZG93Om5vbmUhaW1wb3J0YW50fS5zaG93LWZvci1wcmludHtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH0uaGlkZS1mb3ItcHJpbnR7ZGlzcGxheTpub25lIWltcG9ydGFudH10YWJsZS5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlIWltcG9ydGFudH10aGVhZC5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlLWhlYWRlci1ncm91cCFpbXBvcnRhbnR9dGJvZHkuc2hvdy1mb3ItcHJpbnR7ZGlzcGxheTp0YWJsZS1yb3ctZ3JvdXAhaW1wb3J0YW50fXRyLnNob3ctZm9yLXByaW50e2Rpc3BsYXk6dGFibGUtcm93IWltcG9ydGFudH10ZC5zaG93LWZvci1wcmludCx0aC5zaG93LWZvci1wcmludHtkaXNwbGF5OnRhYmxlLWNlbGwhaW1wb3J0YW50fWEsYTp2aXNpdGVke3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9YVtocmVmXTphZnRlcntjb250ZW50OlxcXCIgKFxcXCIgYXR0cihocmVmKSBcXFwiKVxcXCJ9LmlyIGE6YWZ0ZXIsYVtocmVmXj0nIyddOmFmdGVyLGFbaHJlZl49J2phdmFzY3JpcHQ6J106YWZ0ZXJ7Y29udGVudDonJ31hYmJyW3RpdGxlXTphZnRlcntjb250ZW50OlxcXCIgKFxcXCIgYXR0cih0aXRsZSkgXFxcIilcXFwifWJsb2NrcXVvdGUscHJle2JvcmRlcjoxcHggc29saWQgIzhhOGE4YTtwYWdlLWJyZWFrLWluc2lkZTphdm9pZH10aGVhZHtkaXNwbGF5OnRhYmxlLWhlYWRlci1ncm91cH1pbWcsdHJ7cGFnZS1icmVhay1pbnNpZGU6YXZvaWR9aW1ne21heC13aWR0aDoxMDAlIWltcG9ydGFudH1AcGFnZXttYXJnaW46LjVjbX1oMixoMyxwe29ycGhhbnM6Mzt3aWRvd3M6M31oMixoM3twYWdlLWJyZWFrLWFmdGVyOmF2b2lkfX1bdHlwZT1jb2xvcl0sW3R5cGU9ZGF0ZV0sW3R5cGU9ZGF0ZXRpbWUtbG9jYWxdLFt0eXBlPWRhdGV0aW1lXSxbdHlwZT1lbWFpbF0sW3R5cGU9bW9udGhdLFt0eXBlPW51bWJlcl0sW3R5cGU9cGFzc3dvcmRdLFt0eXBlPXNlYXJjaF0sW3R5cGU9dGVsXSxbdHlwZT10ZXh0XSxbdHlwZT10aW1lXSxbdHlwZT11cmxdLFt0eXBlPXdlZWtdLHRleHRhcmVhe2Rpc3BsYXk6YmxvY2s7Ym94LXNpemluZzpib3JkZXItYm94O3dpZHRoOjEwMCU7aGVpZ2h0OjIuNDM3NXJlbTtwYWRkaW5nOi41cmVtO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTttYXJnaW46MCAwIDFyZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtmb250LXNpemU6MXJlbTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3gtc2hhZG93Omluc2V0IDAgMXB4IDJweCBoc2xhKDAsMCUsNCUsLjEpO2JvcmRlci1yYWRpdXM6MDstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC1ib3gtc2hhZG93IC41cyxib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmJveC1zaGFkb3cgLjVzLGJvcmRlci1jb2xvciAuMjVzIGVhc2UtaW4tb3V0Oy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lfVt0eXBlPWNvbG9yXTpmb2N1cyxbdHlwZT1kYXRlXTpmb2N1cyxbdHlwZT1kYXRldGltZS1sb2NhbF06Zm9jdXMsW3R5cGU9ZGF0ZXRpbWVdOmZvY3VzLFt0eXBlPWVtYWlsXTpmb2N1cyxbdHlwZT1tb250aF06Zm9jdXMsW3R5cGU9bnVtYmVyXTpmb2N1cyxbdHlwZT1wYXNzd29yZF06Zm9jdXMsW3R5cGU9c2VhcmNoXTpmb2N1cyxbdHlwZT10ZWxdOmZvY3VzLFt0eXBlPXRleHRdOmZvY3VzLFt0eXBlPXRpbWVdOmZvY3VzLFt0eXBlPXVybF06Zm9jdXMsW3R5cGU9d2Vla106Zm9jdXMsdGV4dGFyZWE6Zm9jdXN7Ym9yZGVyOjFweCBzb2xpZCAjOGE4YThhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtvdXRsaW5lOm5vbmU7Ym94LXNoYWRvdzowIDAgNXB4ICNjYWNhY2E7LXdlYmtpdC10cmFuc2l0aW9uOi13ZWJraXQtYm94LXNoYWRvdyAuNXMsYm9yZGVyLWNvbG9yIC4yNXMgZWFzZS1pbi1vdXQ7dHJhbnNpdGlvbjpib3gtc2hhZG93IC41cyxib3JkZXItY29sb3IgLjI1cyBlYXNlLWluLW91dH10ZXh0YXJlYXttYXgtd2lkdGg6MTAwJX10ZXh0YXJlYVtyb3dzXXtoZWlnaHQ6YXV0b31pbnB1dDo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcix0ZXh0YXJlYTo6LXdlYmtpdC1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojY2FjYWNhfWlucHV0OjotbW96LXBsYWNlaG9sZGVyLHRleHRhcmVhOjotbW96LXBsYWNlaG9sZGVye2NvbG9yOiNjYWNhY2F9aW5wdXQ6LW1zLWlucHV0LXBsYWNlaG9sZGVyLHRleHRhcmVhOi1tcy1pbnB1dC1wbGFjZWhvbGRlcntjb2xvcjojY2FjYWNhfWlucHV0OjpwbGFjZWhvbGRlcix0ZXh0YXJlYTo6cGxhY2Vob2xkZXJ7Y29sb3I6I2NhY2FjYX1pbnB1dDpkaXNhYmxlZCxpbnB1dFtyZWFkb25seV0sdGV4dGFyZWE6ZGlzYWJsZWQsdGV4dGFyZWFbcmVhZG9ubHlde2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNjtjdXJzb3I6bm90LWFsbG93ZWR9W3R5cGU9YnV0dG9uXSxbdHlwZT1zdWJtaXRde2JvcmRlci1yYWRpdXM6MDstd2Via2l0LWFwcGVhcmFuY2U6bm9uZTstbW96LWFwcGVhcmFuY2U6bm9uZX1pbnB1dFt0eXBlPXNlYXJjaF17Ym94LXNpemluZzpib3JkZXItYm94fVt0eXBlPWNoZWNrYm94XSxbdHlwZT1maWxlXSxbdHlwZT1yYWRpb117bWFyZ2luOjAgMCAxcmVtfVt0eXBlPWNoZWNrYm94XStsYWJlbCxbdHlwZT1yYWRpb10rbGFiZWx7ZGlzcGxheTppbmxpbmUtYmxvY2s7bWFyZ2luLWxlZnQ6LjVyZW07bWFyZ2luLXJpZ2h0OjFyZW07bWFyZ2luLWJvdHRvbTowO3ZlcnRpY2FsLWFsaWduOmJhc2VsaW5lfVt0eXBlPWNoZWNrYm94XStsYWJlbFtmb3JdLFt0eXBlPXJhZGlvXStsYWJlbFtmb3Jde2N1cnNvcjpwb2ludGVyfWxhYmVsPlt0eXBlPWNoZWNrYm94XSxsYWJlbD5bdHlwZT1yYWRpb117bWFyZ2luLXJpZ2h0Oi41cmVtfVt0eXBlPWZpbGVde3dpZHRoOjEwMCV9bGFiZWx7ZGlzcGxheTpibG9jazttYXJnaW46MDtmb250LXNpemU6Ljg3NXJlbTtmb250LXdlaWdodDo0MDA7bGluZS1oZWlnaHQ6MS44O2NvbG9yOiMwYTBhMGF9bGFiZWwubWlkZGxle21hcmdpbjowIDAgMXJlbTtwYWRkaW5nOi41NjI1cmVtIDB9LmhlbHAtdGV4dHttYXJnaW4tdG9wOi0uNXJlbTtmb250LXNpemU6LjgxMjVyZW07Zm9udC1zdHlsZTppdGFsaWM7Y29sb3I6IzBhMGEwYX0uaW5wdXQtZ3JvdXB7ZGlzcGxheTp0YWJsZTt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MXJlbX0uaW5wdXQtZ3JvdXA+OmZpcnN0LWNoaWxkLC5pbnB1dC1ncm91cD46bGFzdC1jaGlsZD4qe2JvcmRlci1yYWRpdXM6MCAwIDAgMH0uaW5wdXQtZ3JvdXAtYnV0dG9uLC5pbnB1dC1ncm91cC1maWVsZCwuaW5wdXQtZ3JvdXAtbGFiZWx7bWFyZ2luOjA7d2hpdGUtc3BhY2U6bm93cmFwO2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjptaWRkbGV9LmlucHV0LWdyb3VwLWxhYmVse3RleHQtYWxpZ246Y2VudGVyO3BhZGRpbmc6MCAxcmVtO2JhY2tncm91bmQ6I2U2ZTZlNjtjb2xvcjojMGEwYTBhO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTt3aGl0ZS1zcGFjZTpub3dyYXA7d2lkdGg6MSU7aGVpZ2h0OjEwMCV9LmlucHV0LWdyb3VwLWxhYmVsOmZpcnN0LWNoaWxke2JvcmRlci1yaWdodDowfS5pbnB1dC1ncm91cC1sYWJlbDpsYXN0LWNoaWxke2JvcmRlci1sZWZ0OjB9LmlucHV0LWdyb3VwLWZpZWxke2JvcmRlci1yYWRpdXM6MDtoZWlnaHQ6Mi41cmVtfS5pbnB1dC1ncm91cC1idXR0b257cGFkZGluZy10b3A6MDtwYWRkaW5nLWJvdHRvbTowO3RleHQtYWxpZ246Y2VudGVyO2hlaWdodDoxMDAlO3dpZHRoOjElfS5pbnB1dC1ncm91cC1idXR0b24gYSwuaW5wdXQtZ3JvdXAtYnV0dG9uIGJ1dHRvbiwuaW5wdXQtZ3JvdXAtYnV0dG9uIGlucHV0e21hcmdpbjowfS5pbnB1dC1ncm91cCAuaW5wdXQtZ3JvdXAtYnV0dG9ue2Rpc3BsYXk6dGFibGUtY2VsbH1maWVsZHNldHtib3JkZXI6MDtwYWRkaW5nOjA7bWFyZ2luOjB9bGVnZW5ke21hcmdpbi1ib3R0b206LjVyZW07bWF4LXdpZHRoOjEwMCV9LmZpZWxkc2V0e2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTtwYWRkaW5nOjEuMjVyZW07bWFyZ2luOjEuMTI1cmVtIDB9LmZpZWxkc2V0IGxlZ2VuZHtiYWNrZ3JvdW5kOiNmZWZlZmU7cGFkZGluZzowIC4xODc1cmVtO21hcmdpbjowO21hcmdpbi1sZWZ0Oi0uMTg3NXJlbX1zZWxlY3R7aGVpZ2h0OjIuNDM3NXJlbTtwYWRkaW5nOi41cmVtO2JvcmRlcjoxcHggc29saWQgI2NhY2FjYTttYXJnaW46MCAwIDFyZW07Zm9udC1zaXplOjFyZW07Zm9udC1mYW1pbHk6aW5oZXJpdDtsaW5lLWhlaWdodDpub3JtYWw7Y29sb3I6IzBhMGEwYTtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Ym9yZGVyLXJhZGl1czowOy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy1tb3otYXBwZWFyYW5jZTpub25lO2JhY2tncm91bmQtaW1hZ2U6dXJsKFxcXCJkYXRhOmltYWdlL3N2Zyt4bWw7dXRmOCw8c3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycgdmVyc2lvbj0nMS4xJyB3aWR0aD0nMzInIGhlaWdodD0nMjQnIHZpZXdCb3g9JzAgMCAzMiAyNCc+PHBvbHlnb24gcG9pbnRzPScwLDAgMzIsMCAxNiwyNCcgc3R5bGU9J2ZpbGw6IHJnYiUyODEzOCwgMTM4LCAxMzglMjknPjwvcG9seWdvbj48L3N2Zz5cXFwiKTtiYWNrZ3JvdW5kLXNpemU6OXB4IDZweDtiYWNrZ3JvdW5kLXBvc2l0aW9uOnJpZ2h0IC0xcmVtIGNlbnRlcjtiYWNrZ3JvdW5kLW9yaWdpbjpjb250ZW50LWJveDtiYWNrZ3JvdW5kLXJlcGVhdDpuby1yZXBlYXQ7cGFkZGluZy1yaWdodDoxLjVyZW19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDowXFxcXDApe3NlbGVjdHtiYWNrZ3JvdW5kLWltYWdlOnVybChcXFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFDQUFBQUFZQ0FZQUFBQ2JVLzgwQUFBQUdYUkZXSFJUYjJaMGQyRnlaUUJCWkc5aVpTQkpiV0ZuWlZKbFlXUjVjY2xsUEFBQUFJcEpSRUZVZU5yRWtja05nREFNQkJmUmtFdDBPYlJCQmRzR1hVRGdtUWZLNFhoSDJtOGN6UUFBeTI3UjN0c3c0UWZlMng4dU9PNm9ZTGI2R2xPb3IzR0Yrc3dVUkFPbVVKK1J3dEVKczlXdlRHRVl4QlhxSTFNUUFaaENmVVFLUnpETVZqK1R3ckFJVjZqdlNVRWtZQXIxTFNrY3lUQmIvVitLWWZYN3hBZXVzcTNzTER0R0gza0VHQUNQV0lmbE5aZmhSUUFBQUFCSlJVNUVya0pnZ2c9PVxcXCIpfX1zZWxlY3Q6ZGlzYWJsZWR7YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpub3QtYWxsb3dlZH1zZWxlY3Q6Oi1tcy1leHBhbmR7ZGlzcGxheTpub25lfXNlbGVjdFttdWx0aXBsZV17aGVpZ2h0OmF1dG87YmFja2dyb3VuZC1pbWFnZTpub25lfS5pcy1pbnZhbGlkLWlucHV0Om5vdCg6Zm9jdXMpe2JhY2tncm91bmQtY29sb3I6cmdiYSgyMzYsODgsNjQsLjEpO2JvcmRlci1jb2xvcjojZWM1ODQwfS5mb3JtLWVycm9yLC5pcy1pbnZhbGlkLWxhYmVse2NvbG9yOiNlYzU4NDB9LmZvcm0tZXJyb3J7ZGlzcGxheTpub25lO21hcmdpbi10b3A6LS41cmVtO21hcmdpbi1ib3R0b206MXJlbTtmb250LXNpemU6Ljc1cmVtO2ZvbnQtd2VpZ2h0OjcwMH0uZm9ybS1lcnJvci5pcy12aXNpYmxle2Rpc3BsYXk6YmxvY2t9LmJ1dHRvbntkaXNwbGF5OmlubGluZS1ibG9jazt0ZXh0LWFsaWduOmNlbnRlcjtsaW5lLWhlaWdodDoxO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtYXBwZWFyYW5jZTpub25lOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kLWNvbG9yIC4yNXMgZWFzZS1vdXQsY29sb3IgLjI1cyBlYXNlLW91dDt0cmFuc2l0aW9uOmJhY2tncm91bmQtY29sb3IgLjI1cyBlYXNlLW91dCxjb2xvciAuMjVzIGVhc2Utb3V0O3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtib3JkZXI6MXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1yYWRpdXM6MDtwYWRkaW5nOi44NWVtIDFlbTttYXJnaW46MCAwIDFyZW07Zm9udC1zaXplOi45cmVtO2JhY2tncm91bmQtY29sb3I6IzIxOTllODtjb2xvcjojZmVmZWZlfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmJ1dHRvbntvdXRsaW5lOjB9LmJ1dHRvbjpmb2N1cywuYnV0dG9uOmhvdmVye2JhY2tncm91bmQtY29sb3I6IzE1ODNjYztjb2xvcjojZmVmZWZlfS5idXR0b24udGlueXtmb250LXNpemU6LjZyZW19LmJ1dHRvbi5zbWFsbHtmb250LXNpemU6Ljc1cmVtfS5idXR0b24ubGFyZ2V7Zm9udC1zaXplOjEuMjVyZW19LmJ1dHRvbi5leHBhbmRlZHtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7bWFyZ2luLWxlZnQ6MDttYXJnaW4tcmlnaHQ6MH0uYnV0dG9uLnByaW1hcnl7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5wcmltYXJ5OmZvY3VzLC5idXR0b24ucHJpbWFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMxNDdjYzA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnNlY29uZGFyeXtiYWNrZ3JvdW5kLWNvbG9yOiM3Nzc7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnNlY29uZGFyeTpmb2N1cywuYnV0dG9uLnNlY29uZGFyeTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiM1ZjVmNWY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLnN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5zdWNjZXNzOmZvY3VzLC5idXR0b24uc3VjY2Vzczpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyMmJiNWI7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLndhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi53YXJuaW5nOmZvY3VzLC5idXR0b24ud2FybmluZzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNjYzhiMDA7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmFsZXJ0e2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24uYWxlcnQ6Zm9jdXMsLmJ1dHRvbi5hbGVydDpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNkYTMxMTY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmhvbGxvd3tib3JkZXI6MXB4IHNvbGlkICMyMTk5ZTg7Y29sb3I6IzIxOTllOH0uYnV0dG9uLmhvbGxvdywuYnV0dG9uLmhvbGxvdzpmb2N1cywuYnV0dG9uLmhvbGxvdzpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOnRyYW5zcGFyZW50fS5idXR0b24uaG9sbG93OmZvY3VzLC5idXR0b24uaG9sbG93OmhvdmVye2JvcmRlci1jb2xvcjojMGM0ZDc4O2NvbG9yOiMwYzRkNzh9LmJ1dHRvbi5ob2xsb3cucHJpbWFyeXtib3JkZXI6MXB4IHNvbGlkICMyMTk5ZTg7Y29sb3I6IzIxOTllOH0uYnV0dG9uLmhvbGxvdy5wcmltYXJ5OmZvY3VzLC5idXR0b24uaG9sbG93LnByaW1hcnk6aG92ZXJ7Ym9yZGVyLWNvbG9yOiMwYzRkNzg7Y29sb3I6IzBjNGQ3OH0uYnV0dG9uLmhvbGxvdy5zZWNvbmRhcnl7Ym9yZGVyOjFweCBzb2xpZCAjNzc3O2NvbG9yOiM3Nzd9LmJ1dHRvbi5ob2xsb3cuc2Vjb25kYXJ5OmZvY3VzLC5idXR0b24uaG9sbG93LnNlY29uZGFyeTpob3Zlcntib3JkZXItY29sb3I6IzNjM2MzYztjb2xvcjojM2MzYzNjfS5idXR0b24uaG9sbG93LnN1Y2Nlc3N7Ym9yZGVyOjFweCBzb2xpZCAjM2FkYjc2O2NvbG9yOiMzYWRiNzZ9LmJ1dHRvbi5ob2xsb3cuc3VjY2Vzczpmb2N1cywuYnV0dG9uLmhvbGxvdy5zdWNjZXNzOmhvdmVye2JvcmRlci1jb2xvcjojMTU3NTM5O2NvbG9yOiMxNTc1Mzl9LmJ1dHRvbi5ob2xsb3cud2FybmluZ3tib3JkZXI6MXB4IHNvbGlkICNmZmFlMDA7Y29sb3I6I2ZmYWUwMH0uYnV0dG9uLmhvbGxvdy53YXJuaW5nOmZvY3VzLC5idXR0b24uaG9sbG93Lndhcm5pbmc6aG92ZXJ7Ym9yZGVyLWNvbG9yOiM4MDU3MDA7Y29sb3I6IzgwNTcwMH0uYnV0dG9uLmhvbGxvdy5hbGVydHtib3JkZXI6MXB4IHNvbGlkICNlYzU4NDA7Y29sb3I6I2VjNTg0MH0uYnV0dG9uLmhvbGxvdy5hbGVydDpmb2N1cywuYnV0dG9uLmhvbGxvdy5hbGVydDpob3Zlcntib3JkZXItY29sb3I6Izg4MWYwZTtjb2xvcjojODgxZjBlfS5idXR0b24uZGlzYWJsZWQsLmJ1dHRvbltkaXNhYmxlZF17b3BhY2l0eTouMjU7Y3Vyc29yOm5vdC1hbGxvd2VkfS5idXR0b24uZGlzYWJsZWQ6Zm9jdXMsLmJ1dHRvbi5kaXNhYmxlZDpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXTpmb2N1cywuYnV0dG9uW2Rpc2FibGVkXTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmRpc2FibGVkLnByaW1hcnksLmJ1dHRvbltkaXNhYmxlZF0ucHJpbWFyeXtvcGFjaXR5Oi4yNTtjdXJzb3I6bm90LWFsbG93ZWR9LmJ1dHRvbi5kaXNhYmxlZC5wcmltYXJ5OmZvY3VzLC5idXR0b24uZGlzYWJsZWQucHJpbWFyeTpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXS5wcmltYXJ5OmZvY3VzLC5idXR0b25bZGlzYWJsZWRdLnByaW1hcnk6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5kaXNhYmxlZC5zZWNvbmRhcnksLmJ1dHRvbltkaXNhYmxlZF0uc2Vjb25kYXJ5e29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uYnV0dG9uLmRpc2FibGVkLnNlY29uZGFyeTpmb2N1cywuYnV0dG9uLmRpc2FibGVkLnNlY29uZGFyeTpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXS5zZWNvbmRhcnk6Zm9jdXMsLmJ1dHRvbltkaXNhYmxlZF0uc2Vjb25kYXJ5OmhvdmVye2JhY2tncm91bmQtY29sb3I6Izc3Nztjb2xvcjojZmVmZWZlfS5idXR0b24uZGlzYWJsZWQuc3VjY2VzcywuYnV0dG9uW2Rpc2FibGVkXS5zdWNjZXNze29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uYnV0dG9uLmRpc2FibGVkLnN1Y2Nlc3M6Zm9jdXMsLmJ1dHRvbi5kaXNhYmxlZC5zdWNjZXNzOmhvdmVyLC5idXR0b25bZGlzYWJsZWRdLnN1Y2Nlc3M6Zm9jdXMsLmJ1dHRvbltkaXNhYmxlZF0uc3VjY2Vzczpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiMzYWRiNzY7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLmRpc2FibGVkLndhcm5pbmcsLmJ1dHRvbltkaXNhYmxlZF0ud2FybmluZ3tvcGFjaXR5Oi4yNTtjdXJzb3I6bm90LWFsbG93ZWR9LmJ1dHRvbi5kaXNhYmxlZC53YXJuaW5nOmZvY3VzLC5idXR0b24uZGlzYWJsZWQud2FybmluZzpob3ZlciwuYnV0dG9uW2Rpc2FibGVkXS53YXJuaW5nOmZvY3VzLC5idXR0b25bZGlzYWJsZWRdLndhcm5pbmc6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi5kaXNhYmxlZC5hbGVydCwuYnV0dG9uW2Rpc2FibGVkXS5hbGVydHtvcGFjaXR5Oi4yNTtjdXJzb3I6bm90LWFsbG93ZWR9LmJ1dHRvbi5kaXNhYmxlZC5hbGVydDpmb2N1cywuYnV0dG9uLmRpc2FibGVkLmFsZXJ0OmhvdmVyLC5idXR0b25bZGlzYWJsZWRdLmFsZXJ0OmZvY3VzLC5idXR0b25bZGlzYWJsZWRdLmFsZXJ0OmhvdmVye2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24uZHJvcGRvd246YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOi40ZW0gaW5zZXQ7Ym9yZGVyLWNvbG9yOiNmZWZlZmUgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXRvcC1zdHlsZTpzb2xpZDtib3JkZXItYm90dG9tLXdpZHRoOjA7cG9zaXRpb246cmVsYXRpdmU7dG9wOi40ZW07ZmxvYXQ6cmlnaHQ7bWFyZ2luLWxlZnQ6MWVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5idXR0b24uYXJyb3ctb25seTphZnRlcnttYXJnaW4tbGVmdDowO2Zsb2F0Om5vbmU7dG9wOi0uMWVtfS5hY2NvcmRpb257bGlzdC1zdHlsZS10eXBlOm5vbmU7YmFja2dyb3VuZDojZmVmZWZlO21hcmdpbi1sZWZ0OjB9LmFjY29yZGlvbi1pdGVtOmZpcnN0LWNoaWxkPjpmaXJzdC1jaGlsZCwuYWNjb3JkaW9uLWl0ZW06bGFzdC1jaGlsZD46bGFzdC1jaGlsZHtib3JkZXItcmFkaXVzOjAgMCAwIDB9LmFjY29yZGlvbi10aXRsZXtkaXNwbGF5OmJsb2NrO3BhZGRpbmc6MS4yNXJlbSAxcmVtO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOi43NXJlbTtjb2xvcjojMjE5OWU4O3Bvc2l0aW9uOnJlbGF0aXZlO2JvcmRlcjoxcHggc29saWQgI2U2ZTZlNjtib3JkZXItYm90dG9tOjB9Omxhc3QtY2hpbGQ6bm90KC5pcy1hY3RpdmUpPi5hY2NvcmRpb24tdGl0bGV7Ym9yZGVyLXJhZGl1czowIDAgMCAwO2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlNmU2ZTZ9LmFjY29yZGlvbi10aXRsZTpmb2N1cywuYWNjb3JkaW9uLXRpdGxlOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2U2ZTZlNn0uYWNjb3JkaW9uLXRpdGxlOmJlZm9yZXtjb250ZW50OicrJztwb3NpdGlvbjphYnNvbHV0ZTtyaWdodDoxcmVtO3RvcDo1MCU7bWFyZ2luLXRvcDotLjVyZW19LmlzLWFjdGl2ZT4uYWNjb3JkaW9uLXRpdGxlOmJlZm9yZXtjb250ZW50OidcXFxcMjAxMyd9LmFjY29yZGlvbi1jb250ZW50e3BhZGRpbmc6MXJlbTtkaXNwbGF5Om5vbmU7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2O2JvcmRlci1ib3R0b206MDtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Y29sb3I6IzBhMGEwYX06bGFzdC1jaGlsZD4uYWNjb3JkaW9uLWNvbnRlbnQ6bGFzdC1jaGlsZHtib3JkZXItYm90dG9tOjFweCBzb2xpZCAjZTZlNmU2fS5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnQ+YXtwb3NpdGlvbjpyZWxhdGl2ZX0uaXMtYWNjb3JkaW9uLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjZweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO21hcmdpbi10b3A6LTRweDtyaWdodDoxcmVtfS5pcy1hY2NvcmRpb24tc3VibWVudS1wYXJlbnRbYXJpYS1leHBhbmRlZD10cnVlXT5hOmFmdGVyey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgNTAlO3RyYW5zZm9ybS1vcmlnaW46NTAlIDUwJTstd2Via2l0LXRyYW5zZm9ybTpzY2FsZVkoLTEpO3RyYW5zZm9ybTpzY2FsZVkoLTEpfS5iYWRnZXtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOi4zZW07bWluLXdpZHRoOjIuMWVtO2ZvbnQtc2l6ZTouNnJlbTt0ZXh0LWFsaWduOmNlbnRlcjtib3JkZXItcmFkaXVzOjUwJTtiYWNrZ3JvdW5kOiMyMTk5ZTg7Y29sb3I6I2ZlZmVmZX0uYmFkZ2Uuc2Vjb25kYXJ5e2JhY2tncm91bmQ6Izc3Nztjb2xvcjojZmVmZWZlfS5iYWRnZS5zdWNjZXNze2JhY2tncm91bmQ6IzNhZGI3Njtjb2xvcjojZmVmZWZlfS5iYWRnZS53YXJuaW5ne2JhY2tncm91bmQ6I2ZmYWUwMDtjb2xvcjojZmVmZWZlfS5iYWRnZS5hbGVydHtiYWNrZ3JvdW5kOiNlYzU4NDA7Y29sb3I6I2ZlZmVmZX0uYnJlYWRjcnVtYnN7bGlzdC1zdHlsZTpub25lO21hcmdpbjowIDAgMXJlbX0uYnJlYWRjcnVtYnM6YWZ0ZXIsLmJyZWFkY3J1bWJzOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlfS5icmVhZGNydW1iczphZnRlcntjbGVhcjpib3RofS5icmVhZGNydW1icyBsaXtmbG9hdDpsZWZ0O2NvbG9yOiMwYTBhMGE7Zm9udC1zaXplOi42ODc1cmVtO2N1cnNvcjpkZWZhdWx0O3RleHQtdHJhbnNmb3JtOnVwcGVyY2FzZX0uYnJlYWRjcnVtYnMgbGk6bm90KDpsYXN0LWNoaWxkKTphZnRlcntjb2xvcjojY2FjYWNhO2NvbnRlbnQ6XFxcIi9cXFwiO21hcmdpbjowIC43NXJlbTtwb3NpdGlvbjpyZWxhdGl2ZTt0b3A6MXB4O29wYWNpdHk6MX0uYnJlYWRjcnVtYnMgYXtjb2xvcjojMjE5OWU4fS5icmVhZGNydW1icyBhOmhvdmVye3RleHQtZGVjb3JhdGlvbjp1bmRlcmxpbmV9LmJyZWFkY3J1bWJzIC5kaXNhYmxlZHtjb2xvcjojY2FjYWNhO2N1cnNvcjpub3QtYWxsb3dlZH0uYnV0dG9uLWdyb3Vwe21hcmdpbi1ib3R0b206MXJlbTtmb250LXNpemU6MH0uYnV0dG9uLWdyb3VwOmFmdGVyLC5idXR0b24tZ3JvdXA6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9LmJ1dHRvbi1ncm91cDphZnRlcntjbGVhcjpib3RofS5idXR0b24tZ3JvdXAgLmJ1dHRvbnttYXJnaW46MDttYXJnaW4tcmlnaHQ6MXB4O21hcmdpbi1ib3R0b206MXB4O2ZvbnQtc2l6ZTouOXJlbX0uYnV0dG9uLWdyb3VwIC5idXR0b246bGFzdC1jaGlsZHttYXJnaW4tcmlnaHQ6MH0uYnV0dG9uLWdyb3VwLnRpbnkgLmJ1dHRvbntmb250LXNpemU6LjZyZW19LmJ1dHRvbi1ncm91cC5zbWFsbCAuYnV0dG9ue2ZvbnQtc2l6ZTouNzVyZW19LmJ1dHRvbi1ncm91cC5sYXJnZSAuYnV0dG9ue2ZvbnQtc2l6ZToxLjI1cmVtfS5idXR0b24tZ3JvdXAuZXhwYW5kZWR7bWFyZ2luLXJpZ2h0Oi0xcHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZDphZnRlciwuYnV0dG9uLWdyb3VwLmV4cGFuZGVkOmJlZm9yZXtkaXNwbGF5Om5vbmV9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoNTAlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgyKX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDIpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMzMuMzMzMzMlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCgzKX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDMpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMjUlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg0KX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDQpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMjAlIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg1KX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDUpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpLC5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KX4uYnV0dG9ue2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOmNhbGMoMTYuNjY2NjclIC0gMXB4KTttYXJnaW4tcmlnaHQ6MXB4fS5idXR0b24tZ3JvdXAuZXhwYW5kZWQgLmJ1dHRvbjpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KTpmaXJzdC1jaGlsZDpudGgtbGFzdC1jaGlsZCg2KX4uYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5leHBhbmRlZCAuYnV0dG9uOmZpcnN0LWNoaWxkOm50aC1sYXN0LWNoaWxkKDYpOmxhc3QtY2hpbGR7bWFyZ2luLXJpZ2h0Oi02cHh9LmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC5wcmltYXJ5IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTQ3Y2MwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zZWNvbmRhcnkgLmJ1dHRvbntiYWNrZ3JvdW5kLWNvbG9yOiM3Nzc7Y29sb3I6I2ZlZmVmZX0uYnV0dG9uLWdyb3VwLnNlY29uZGFyeSAuYnV0dG9uOmZvY3VzLC5idXR0b24tZ3JvdXAuc2Vjb25kYXJ5IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojNWY1ZjVmO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC5zdWNjZXNzIC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMjJiYjViO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b257YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b246Zm9jdXMsLmJ1dHRvbi1ncm91cC53YXJuaW5nIC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojY2M4YjAwO2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5hbGVydCAuYnV0dG9ue2JhY2tncm91bmQtY29sb3I6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5idXR0b24tZ3JvdXAuYWxlcnQgLmJ1dHRvbjpmb2N1cywuYnV0dG9uLWdyb3VwLmFsZXJ0IC5idXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZGEzMTE2O2NvbG9yOiNmZWZlZmV9LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbiwuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b24sLmJ1dHRvbi1ncm91cC5zdGFja2VkIC5idXR0b257d2lkdGg6MTAwJX0uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLW1lZGl1bSAuYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1zbWFsbCAuYnV0dG9uOmxhc3QtY2hpbGQsLmJ1dHRvbi1ncm91cC5zdGFja2VkIC5idXR0b246bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsIC5idXR0b257d2lkdGg6YXV0bzttYXJnaW4tYm90dG9tOjB9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmJ1dHRvbi1ncm91cC5zdGFja2VkLWZvci1tZWRpdW0gLmJ1dHRvbnt3aWR0aDphdXRvO21hcmdpbi1ib3R0b206MH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5idXR0b24tZ3JvdXAuc3RhY2tlZC1mb3Itc21hbGwuZXhwYW5kZWR7ZGlzcGxheTpibG9ja30uYnV0dG9uLWdyb3VwLnN0YWNrZWQtZm9yLXNtYWxsLmV4cGFuZGVkIC5idXR0b257ZGlzcGxheTpibG9jazttYXJnaW4tcmlnaHQ6MH19LmNhbGxvdXR7bWFyZ2luOjAgMCAxcmVtO3BhZGRpbmc6MXJlbTtib3JkZXI6MXB4IHNvbGlkIGhzbGEoMCwwJSw0JSwuMjUpO2JvcmRlci1yYWRpdXM6MDtwb3NpdGlvbjpyZWxhdGl2ZTtjb2xvcjojMGEwYTBhO2JhY2tncm91bmQtY29sb3I6I2ZmZn0uY2FsbG91dD46Zmlyc3QtY2hpbGR7bWFyZ2luLXRvcDowfS5jYWxsb3V0PjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0uY2FsbG91dC5wcmltYXJ5e2JhY2tncm91bmQtY29sb3I6I2RlZjBmY30uY2FsbG91dC5zZWNvbmRhcnl7YmFja2dyb3VuZC1jb2xvcjojZWJlYmVifS5jYWxsb3V0LnN1Y2Nlc3N7YmFja2dyb3VuZC1jb2xvcjojZTFmYWVhfS5jYWxsb3V0Lndhcm5pbmd7YmFja2dyb3VuZC1jb2xvcjojZmZmM2Q5fS5jYWxsb3V0LmFsZXJ0e2JhY2tncm91bmQtY29sb3I6I2ZjZTZlMn0uY2FsbG91dC5zbWFsbHtwYWRkaW5nOi41cmVtfS5jYWxsb3V0Lmxhcmdle3BhZGRpbmc6M3JlbX0uY2xvc2UtYnV0dG9ue3Bvc2l0aW9uOmFic29sdXRlO2NvbG9yOiM4YThhOGE7cmlnaHQ6MXJlbTt0b3A6LjVyZW07Zm9udC1zaXplOjJlbTtsaW5lLWhlaWdodDoxO2N1cnNvcjpwb2ludGVyfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmNsb3NlLWJ1dHRvbntvdXRsaW5lOjB9LmNsb3NlLWJ1dHRvbjpmb2N1cywuY2xvc2UtYnV0dG9uOmhvdmVye2NvbG9yOiMwYTBhMGF9Lm1lbnV7bWFyZ2luOjA7bGlzdC1zdHlsZS10eXBlOm5vbmV9Lm1lbnU+bGl7ZGlzcGxheTp0YWJsZS1jZWxsO3ZlcnRpY2FsLWFsaWduOm1pZGRsZX1bZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5tZW51Pmxpe291dGxpbmU6MH0ubWVudT5saT5he2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouN3JlbSAxcmVtO2xpbmUtaGVpZ2h0OjF9Lm1lbnUgYSwubWVudSBidXR0b24sLm1lbnUgaW5wdXR7bWFyZ2luLWJvdHRvbTowfS5tZW51PmxpPmEgaSwubWVudT5saT5hIGkrc3BhbiwubWVudT5saT5hIGltZywubWVudT5saT5hIGltZytzcGFuLC5tZW51PmxpPmEgc3ZnLC5tZW51PmxpPmEgc3ZnK3NwYW57dmVydGljYWwtYWxpZ246bWlkZGxlfS5tZW51PmxpPmEgaSwubWVudT5saT5hIGltZywubWVudT5saT5hIHN2Z3ttYXJnaW4tcmlnaHQ6LjI1cmVtO2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5tZW51Pmxpe2Rpc3BsYXk6dGFibGUtY2VsbH0ubWVudS52ZXJ0aWNhbD5saXtkaXNwbGF5OmJsb2NrfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7Lm1lbnUubWVkaXVtLWhvcml6b250YWw+bGl7ZGlzcGxheTp0YWJsZS1jZWxsfS5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saXtkaXNwbGF5OmJsb2NrfX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pey5tZW51LmxhcmdlLWhvcml6b250YWw+bGl7ZGlzcGxheTp0YWJsZS1jZWxsfS5tZW51LmxhcmdlLXZlcnRpY2FsPmxpe2Rpc3BsYXk6YmxvY2t9fS5tZW51LnNpbXBsZSBsaXtsaW5lLWhlaWdodDoxO2Rpc3BsYXk6aW5saW5lLWJsb2NrO21hcmdpbi1yaWdodDoxcmVtfS5tZW51LnNpbXBsZSBhe3BhZGRpbmc6MH0ubWVudS5hbGlnbi1yaWdodDphZnRlciwubWVudS5hbGlnbi1yaWdodDpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0ubWVudS5hbGlnbi1yaWdodDphZnRlcntjbGVhcjpib3RofS5tZW51LmFsaWduLXJpZ2h0Pmxpe2Zsb2F0OnJpZ2h0fS5tZW51LmV4cGFuZGVke3dpZHRoOjEwMCU7ZGlzcGxheTp0YWJsZTt0YWJsZS1sYXlvdXQ6Zml4ZWR9Lm1lbnUuZXhwYW5kZWQ+bGk6Zmlyc3QtY2hpbGQ6bGFzdC1jaGlsZHt3aWR0aDoxMDAlfS5tZW51Lmljb24tdG9wPmxpPmF7dGV4dC1hbGlnbjpjZW50ZXJ9Lm1lbnUuaWNvbi10b3A+bGk+YSBpLC5tZW51Lmljb24tdG9wPmxpPmEgaW1nLC5tZW51Lmljb24tdG9wPmxpPmEgc3Zne2Rpc3BsYXk6YmxvY2s7bWFyZ2luOjAgYXV0byAuMjVyZW19Lm1lbnUubmVzdGVke21hcmdpbi1sZWZ0OjFyZW19Lm1lbnUgLmFjdGl2ZT5he2NvbG9yOiNmZWZlZmU7YmFja2dyb3VuZDojMjE5OWU4fS5tZW51LXRleHR7Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOmluaGVyaXQ7bGluZS1oZWlnaHQ6MTtwYWRkaW5nLXRvcDowO3BhZGRpbmctYm90dG9tOjA7cGFkZGluZzouN3JlbSAxcmVtfS5tZW51LWNlbnRlcmVke3RleHQtYWxpZ246Y2VudGVyfS5tZW51LWNlbnRlcmVkPi5tZW51e2Rpc3BsYXk6aW5saW5lLWJsb2NrfS5uby1qcyBbZGF0YS1yZXNwb25zaXZlLW1lbnVdIHVse2Rpc3BsYXk6bm9uZX0ubWVudS1pY29ue3Bvc2l0aW9uOnJlbGF0aXZlO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3ZlcnRpY2FsLWFsaWduOm1pZGRsZTtjdXJzb3I6cG9pbnRlcjt3aWR0aDoyMHB4O2hlaWdodDoxNnB4fS5tZW51LWljb246YWZ0ZXJ7Y29udGVudDonJztwb3NpdGlvbjphYnNvbHV0ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjEwMCU7aGVpZ2h0OjJweDtiYWNrZ3JvdW5kOiNmZWZlZmU7dG9wOjA7bGVmdDowO2JveC1zaGFkb3c6MCA3cHggMCAjZmVmZWZlLDAgMTRweCAwICNmZWZlZmV9Lm1lbnUtaWNvbjpob3ZlcjphZnRlcntiYWNrZ3JvdW5kOiNjYWNhY2E7Ym94LXNoYWRvdzowIDdweCAwICNjYWNhY2EsMCAxNHB4IDAgI2NhY2FjYX0ubWVudS1pY29uLmRhcmt7cG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246bWlkZGxlO2N1cnNvcjpwb2ludGVyO3dpZHRoOjIwcHg7aGVpZ2h0OjE2cHh9Lm1lbnUtaWNvbi5kYXJrOmFmdGVye2NvbnRlbnQ6Jyc7cG9zaXRpb246YWJzb2x1dGU7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO2hlaWdodDoycHg7YmFja2dyb3VuZDojMGEwYTBhO3RvcDowO2xlZnQ6MDtib3gtc2hhZG93OjAgN3B4IDAgIzBhMGEwYSwwIDE0cHggMCAjMGEwYTBhfS5tZW51LWljb24uZGFyazpob3ZlcjphZnRlcntiYWNrZ3JvdW5kOiM4YThhOGE7Ym94LXNoYWRvdzowIDdweCAwICM4YThhOGEsMCAxNHB4IDAgIzhhOGE4YX0uaXMtZHJpbGxkb3due3Bvc2l0aW9uOnJlbGF0aXZlO292ZXJmbG93OmhpZGRlbn0uaXMtZHJpbGxkb3duIGxpe2Rpc3BsYXk6YmxvY2shaW1wb3J0YW50fS5pcy1kcmlsbGRvd24tc3VibWVudXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjEwMCU7ei1pbmRleDotMTt3aWR0aDoxMDAlO2JhY2tncm91bmQ6I2ZlZmVmZTstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjE1cyBsaW5lYXI7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjE1cyBsaW5lYXJ9LmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWFjdGl2ZXt6LWluZGV4OjE7ZGlzcGxheTpibG9jazstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTAwJSl9LmlzLWRyaWxsZG93bi1zdWJtZW51LmlzLWNsb3Npbmd7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgxMDAlKX0uaXMtZHJpbGxkb3duLXN1Ym1lbnUtcGFyZW50PmF7cG9zaXRpb246cmVsYXRpdmV9LmlzLWRyaWxsZG93bi1zdWJtZW51LXBhcmVudD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo2cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjA7cG9zaXRpb246YWJzb2x1dGU7dG9wOjUwJTttYXJnaW4tdG9wOi02cHg7cmlnaHQ6MXJlbX0uanMtZHJpbGxkb3duLWJhY2s+YTpiZWZvcmV7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjZweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgIzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItcmlnaHQtc3R5bGU6c29saWQ7Ym9yZGVyLWxlZnQtd2lkdGg6MDtkaXNwbGF5OmlubGluZS1ibG9jazt2ZXJ0aWNhbC1hbGlnbjptaWRkbGU7bWFyZ2luLXJpZ2h0Oi43NXJlbX0uZHJvcGRvd24tcGFuZXtiYWNrZ3JvdW5kLWNvbG9yOiNmZWZlZmU7Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO2JvcmRlci1yYWRpdXM6MDtkaXNwbGF5OmJsb2NrO2ZvbnQtc2l6ZToxcmVtO3BhZGRpbmc6MXJlbTtwb3NpdGlvbjphYnNvbHV0ZTt2aXNpYmlsaXR5OmhpZGRlbjt3aWR0aDozMDBweDt6LWluZGV4OjEwfS5kcm9wZG93bi1wYW5lLmlzLW9wZW57dmlzaWJpbGl0eTp2aXNpYmxlfS5kcm9wZG93bi1wYW5lLnRpbnl7d2lkdGg6MTAwcHh9LmRyb3Bkb3duLXBhbmUuc21hbGx7d2lkdGg6MjAwcHh9LmRyb3Bkb3duLXBhbmUubGFyZ2V7d2lkdGg6NDAwcHh9LmRyb3Bkb3duLm1lbnU+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudT5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudT5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51PmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLmRyb3Bkb3duLm1lbnUgYXtvdXRsaW5lOjB9Lm5vLWpzIC5kcm9wZG93bi5tZW51IHVse2Rpc3BsYXk6bm9uZX0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saSAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MH0uZHJvcGRvd24ubWVudS52ZXJ0aWNhbD5saS5vcGVucy1sZWZ0Pi5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDoxMDAlfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0Pi5pcy1kcm9wZG93bi1zdWJtZW51e3JpZ2h0OmF1dG87bGVmdDoxMDAlfS5kcm9wZG93bi5tZW51LnZlcnRpY2FsPmxpPmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtbGVmdD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50ICMyMTk5ZTggdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQ7Ym9yZGVyLXJpZ2h0LXN0eWxlOnNvbGlkO2JvcmRlci1sZWZ0LXdpZHRoOjB9LmRyb3Bkb3duLm1lbnUudmVydGljYWw+bGkub3BlbnMtcmlnaHQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMjE5OWU4O2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowfUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LmRyb3Bkb3duLm1lbnUubWVkaXVtLWhvcml6b250YWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MDt0b3A6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0taG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51Lm1lZGl1bS1ob3Jpem9udGFsPmxpLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6IzIxOTllOCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDtyaWdodDo1cHg7bWFyZ2luLXRvcDotMnB4fS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saSAuaXMtZHJvcGRvd24tc3VibWVudXt0b3A6MH0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS5tZWRpdW0tdmVydGljYWw+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjEwMCV9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpPmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmRyb3Bkb3duLm1lbnUubWVkaXVtLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51Lm1lZGl1bS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NjRlbSl7LmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saS5vcGVucy1sZWZ0Pi5pcy1kcm9wZG93bi1zdWJtZW51e2xlZnQ6YXV0bztyaWdodDowO3RvcDoxMDAlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjA7dG9wOjEwMCV9LmRyb3Bkb3duLm1lbnUubGFyZ2UtaG9yaXpvbnRhbD5saS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudD5he3BhZGRpbmctcmlnaHQ6MS41cmVtO3Bvc2l0aW9uOnJlbGF0aXZlfS5kcm9wZG93bi5tZW51LmxhcmdlLWhvcml6b250YWw+bGkuaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjojMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci10b3Atc3R5bGU6c29saWQ7Ym9yZGVyLWJvdHRvbS13aWR0aDowO3JpZ2h0OjVweDttYXJnaW4tdG9wOi0ycHh9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7dG9wOjB9LmRyb3Bkb3duLm1lbnUubGFyZ2UtdmVydGljYWw+bGkub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saS5vcGVucy1yaWdodD4uaXMtZHJvcGRvd24tc3VibWVudXtyaWdodDphdXRvO2xlZnQ6MTAwJX0uZHJvcGRvd24ubWVudS5sYXJnZS12ZXJ0aWNhbD5saT5hOmFmdGVye3JpZ2h0OjE0cHg7bWFyZ2luLXRvcDotM3B4fS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5kcm9wZG93bi5tZW51LmxhcmdlLXZlcnRpY2FsPmxpLm9wZW5zLXJpZ2h0PmE6YWZ0ZXJ7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym9yZGVyOjVweCBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzIxOTllODtib3JkZXItbGVmdC1zdHlsZTpzb2xpZDtib3JkZXItcmlnaHQtd2lkdGg6MH19LmRyb3Bkb3duLm1lbnUuYWxpZ24tcmlnaHQgLmlzLWRyb3Bkb3duLXN1Ym1lbnUuZmlyc3Qtc3Vie3RvcDoxMDAlO2xlZnQ6YXV0bztyaWdodDowfS5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2Fse3dpZHRoOjEwMHB4fS5pcy1kcm9wZG93bi1tZW51LnZlcnRpY2FsLmFsaWduLXJpZ2h0e2Zsb2F0OnJpZ2h0fS5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudHtwb3NpdGlvbjpyZWxhdGl2ZX0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQgYTphZnRlcntwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlO3JpZ2h0OjVweDttYXJnaW4tdG9wOi0ycHh9LmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWlubmVyPi5pcy1kcm9wZG93bi1zdWJtZW51e3RvcDoxMDAlO2xlZnQ6YXV0b30uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtbGVmdD4uaXMtZHJvcGRvd24tc3VibWVudXtsZWZ0OmF1dG87cmlnaHQ6MTAwJX0uaXMtZHJvcGRvd24tc3VibWVudS1wYXJlbnQub3BlbnMtcmlnaHQ+LmlzLWRyb3Bkb3duLXN1Ym1lbnV7cmlnaHQ6YXV0bztsZWZ0OjEwMCV9LmlzLWRyb3Bkb3duLXN1Ym1lbnV7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MTAwJTttaW4td2lkdGg6MjAwcHg7ei1pbmRleDoxO2JhY2tncm91bmQ6I2ZlZmVmZTtib3JkZXI6MXB4IHNvbGlkICNjYWNhY2F9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50PmE6YWZ0ZXJ7cmlnaHQ6MTRweDttYXJnaW4tdG9wOi0zcHh9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnUtcGFyZW50Lm9wZW5zLWxlZnQ+YTphZnRlcntjb250ZW50OicnO2Rpc3BsYXk6YmxvY2s7d2lkdGg6MDtoZWlnaHQ6MDtib3JkZXI6NXB4IGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMjE5OWU4IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowfS5pcy1kcm9wZG93bi1zdWJtZW51IC5pcy1kcm9wZG93bi1zdWJtZW51LXBhcmVudC5vcGVucy1yaWdodD5hOmFmdGVye2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowO2JvcmRlcjo1cHggaW5zZXQ7Ym9yZGVyLWNvbG9yOnRyYW5zcGFyZW50IHRyYW5zcGFyZW50IHRyYW5zcGFyZW50ICMyMTk5ZTg7Ym9yZGVyLWxlZnQtc3R5bGU6c29saWQ7Ym9yZGVyLXJpZ2h0LXdpZHRoOjB9LmlzLWRyb3Bkb3duLXN1Ym1lbnUgLmlzLWRyb3Bkb3duLXN1Ym1lbnV7bWFyZ2luLXRvcDotMXB4fS5pcy1kcm9wZG93bi1zdWJtZW51Pmxpe3dpZHRoOjEwMCV9LmlzLWRyb3Bkb3duLXN1Ym1lbnUuanMtZHJvcGRvd24tYWN0aXZle2Rpc3BsYXk6YmxvY2t9LmZsZXgtdmlkZW97cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0OjA7cGFkZGluZy1ib3R0b206NzUlO21hcmdpbi1ib3R0b206MXJlbTtvdmVyZmxvdzpoaWRkZW59LmZsZXgtdmlkZW8gZW1iZWQsLmZsZXgtdmlkZW8gaWZyYW1lLC5mbGV4LXZpZGVvIG9iamVjdCwuZmxleC12aWRlbyB2aWRlb3twb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjA7d2lkdGg6MTAwJTtoZWlnaHQ6MTAwJX0uZmxleC12aWRlby53aWRlc2NyZWVue3BhZGRpbmctYm90dG9tOjU2LjI1JX0uZmxleC12aWRlby52aW1lb3twYWRkaW5nLXRvcDowfS5sYWJlbHtkaXNwbGF5OmlubGluZS1ibG9jaztwYWRkaW5nOi4zMzMzM3JlbSAuNXJlbTtmb250LXNpemU6LjhyZW07bGluZS1oZWlnaHQ6MTt3aGl0ZS1zcGFjZTpub3dyYXA7Y3Vyc29yOmRlZmF1bHQ7Ym9yZGVyLXJhZGl1czowO2JhY2tncm91bmQ6IzIxOTllODtjb2xvcjojZmVmZWZlfS5sYWJlbC5zZWNvbmRhcnl7YmFja2dyb3VuZDojNzc3O2NvbG9yOiNmZWZlZmV9LmxhYmVsLnN1Y2Nlc3N7YmFja2dyb3VuZDojM2FkYjc2O2NvbG9yOiNmZWZlZmV9LmxhYmVsLndhcm5pbmd7YmFja2dyb3VuZDojZmZhZTAwO2NvbG9yOiNmZWZlZmV9LmxhYmVsLmFsZXJ0e2JhY2tncm91bmQ6I2VjNTg0MDtjb2xvcjojZmVmZWZlfS5tZWRpYS1vYmplY3R7bWFyZ2luLWJvdHRvbToxcmVtO2Rpc3BsYXk6YmxvY2t9Lm1lZGlhLW9iamVjdCBpbWd7bWF4LXdpZHRoOm5vbmV9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5tZWRpYS1vYmplY3Quc3RhY2stZm9yLXNtYWxsIC5tZWRpYS1vYmplY3Qtc2VjdGlvbntwYWRkaW5nOjA7cGFkZGluZy1ib3R0b206MXJlbTtkaXNwbGF5OmJsb2NrfS5tZWRpYS1vYmplY3Quc3RhY2stZm9yLXNtYWxsIC5tZWRpYS1vYmplY3Qtc2VjdGlvbiBpbWd7d2lkdGg6MTAwJX19Lm1lZGlhLW9iamVjdC1zZWN0aW9ue2Rpc3BsYXk6dGFibGUtY2VsbDt2ZXJ0aWNhbC1hbGlnbjp0b3B9Lm1lZGlhLW9iamVjdC1zZWN0aW9uOmZpcnN0LWNoaWxke3BhZGRpbmctcmlnaHQ6MXJlbX0ubWVkaWEtb2JqZWN0LXNlY3Rpb246bGFzdC1jaGlsZDpub3QoOm50aC1jaGlsZCgyKSl7cGFkZGluZy1sZWZ0OjFyZW19Lm1lZGlhLW9iamVjdC1zZWN0aW9uPjpsYXN0LWNoaWxke21hcmdpbi1ib3R0b206MH0ubWVkaWEtb2JqZWN0LXNlY3Rpb24ubWlkZGxle3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0ubWVkaWEtb2JqZWN0LXNlY3Rpb24uYm90dG9te3ZlcnRpY2FsLWFsaWduOmJvdHRvbX1ib2R5LGh0bWx7aGVpZ2h0OjEwMCV9Lm9mZi1jYW52YXMtd3JhcHBlcnt3aWR0aDoxMDAlO292ZXJmbG93LXg6aGlkZGVuO3Bvc2l0aW9uOnJlbGF0aXZlOy13ZWJraXQtYmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47YmFja2ZhY2UtdmlzaWJpbGl0eTpoaWRkZW47LXdlYmtpdC1vdmVyZmxvdy1zY3JvbGxpbmc6YXV0b30ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVye3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjEwMCU7bWluLWhlaWdodDoxMDAlOy13ZWJraXQtdHJhbnNpdGlvbjotd2Via2l0LXRyYW5zZm9ybSAuNXMgZWFzZTt0cmFuc2l0aW9uOnRyYW5zZm9ybSAuNXMgZWFzZX0ub2ZmLWNhbnZhcy13cmFwcGVyLWlubmVyOmFmdGVyLC5vZmYtY2FudmFzLXdyYXBwZXItaW5uZXI6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9Lm9mZi1jYW52YXMtd3JhcHBlci1pbm5lcjphZnRlcntjbGVhcjpib3RofS5vZmYtY2FudmFzLWNvbnRlbnR7bWluLWhlaWdodDoxMDAlO2JhY2tncm91bmQ6I2ZlZmVmZTstd2Via2l0LXRyYW5zaXRpb246LXdlYmtpdC10cmFuc2Zvcm0gLjVzIGVhc2U7dHJhbnNpdGlvbjp0cmFuc2Zvcm0gLjVzIGVhc2U7LXdlYmtpdC1iYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjtiYWNrZmFjZS12aXNpYmlsaXR5OmhpZGRlbjt6LWluZGV4OjE7cGFkZGluZy1ib3R0b206LjFweDtib3gtc2hhZG93OjAgMCAxMHB4IGhzbGEoMCwwJSw0JSwuNSl9LmpzLW9mZi1jYW52YXMtZXhpdHtkaXNwbGF5Om5vbmU7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZDpoc2xhKDAsMCUsMTAwJSwuMjUpO2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdHJhbnNpdGlvbjpiYWNrZ3JvdW5kIC41cyBlYXNlO3RyYW5zaXRpb246YmFja2dyb3VuZCAuNXMgZWFzZX0ub2ZmLWNhbnZhc3twb3NpdGlvbjphYnNvbHV0ZTtiYWNrZ3JvdW5kOiNlNmU2ZTY7ei1pbmRleDotMTttYXgtaGVpZ2h0OjEwMCU7b3ZlcmZsb3cteTphdXRvOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub2ZmLWNhbnZhc3tvdXRsaW5lOjB9Lm9mZi1jYW52YXMucG9zaXRpb24tbGVmdHtsZWZ0Oi0yNTBweDt0b3A6MDt3aWR0aDoyNTBweH0uaXMtb3Blbi1sZWZ0ey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMjUwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDI1MHB4KX0ub2ZmLWNhbnZhcy5wb3NpdGlvbi1yaWdodHtyaWdodDotMjUwcHg7dG9wOjA7d2lkdGg6MjUwcHh9LmlzLW9wZW4tcmlnaHR7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMjUwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC0yNTBweCl9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLW1lZGl1bXtsZWZ0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1sZWZ0LnJldmVhbC1mb3ItbWVkaXVtfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLWxlZnQ6MjUwcHh9LnBvc2l0aW9uLXJpZ2h0LnJldmVhbC1mb3ItbWVkaXVte3JpZ2h0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLW1lZGl1bX4ub2ZmLWNhbnZhcy1jb250ZW50e21hcmdpbi1yaWdodDoyNTBweH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsucG9zaXRpb24tbGVmdC5yZXZlYWwtZm9yLWxhcmdle2xlZnQ6MDt6LWluZGV4OmF1dG87cG9zaXRpb246Zml4ZWR9LnBvc2l0aW9uLWxlZnQucmV2ZWFsLWZvci1sYXJnZX4ub2ZmLWNhbnZhcy1jb250ZW50e21hcmdpbi1sZWZ0OjI1MHB4fS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdle3JpZ2h0OjA7ei1pbmRleDphdXRvO3Bvc2l0aW9uOmZpeGVkfS5wb3NpdGlvbi1yaWdodC5yZXZlYWwtZm9yLWxhcmdlfi5vZmYtY2FudmFzLWNvbnRlbnR7bWFyZ2luLXJpZ2h0OjI1MHB4fX0ub3JiaXQsLm9yYml0LWNvbnRhaW5lcntwb3NpdGlvbjpyZWxhdGl2ZX0ub3JiaXQtY29udGFpbmVye21hcmdpbjowO292ZXJmbG93OmhpZGRlbjtsaXN0LXN0eWxlOm5vbmV9Lm9yYml0LXNsaWRle3dpZHRoOjEwMCU7bWF4LWhlaWdodDoxMDAlfS5vcmJpdC1zbGlkZS5uby1tb3Rpb251aS5pcy1hY3RpdmV7dG9wOjA7bGVmdDowfS5vcmJpdC1maWd1cmV7bWFyZ2luOjB9Lm9yYml0LWltYWdle21hcmdpbjowO3dpZHRoOjEwMCU7bWF4LXdpZHRoOjEwMCV9Lm9yYml0LWNhcHRpb257Ym90dG9tOjA7d2lkdGg6MTAwJTttYXJnaW4tYm90dG9tOjA7YmFja2dyb3VuZC1jb2xvcjpoc2xhKDAsMCUsNCUsLjUpfS5vcmJpdC1jYXB0aW9uLC5vcmJpdC1uZXh0LC5vcmJpdC1wcmV2aW91c3twb3NpdGlvbjphYnNvbHV0ZTtwYWRkaW5nOjFyZW07Y29sb3I6I2ZlZmVmZX0ub3JiaXQtbmV4dCwub3JiaXQtcHJldmlvdXN7dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3otaW5kZXg6MTB9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub3JiaXQtbmV4dCxbZGF0YS13aGF0aW5wdXQ9bW91c2VdIC5vcmJpdC1wcmV2aW91c3tvdXRsaW5lOjB9Lm9yYml0LW5leHQ6YWN0aXZlLC5vcmJpdC1uZXh0OmZvY3VzLC5vcmJpdC1uZXh0OmhvdmVyLC5vcmJpdC1wcmV2aW91czphY3RpdmUsLm9yYml0LXByZXZpb3VzOmZvY3VzLC5vcmJpdC1wcmV2aW91czpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw0JSwuNSl9Lm9yYml0LXByZXZpb3Vze2xlZnQ6MH0ub3JiaXQtbmV4dHtsZWZ0OmF1dG87cmlnaHQ6MH0ub3JiaXQtYnVsbGV0c3twb3NpdGlvbjpyZWxhdGl2ZTttYXJnaW4tdG9wOi44cmVtO21hcmdpbi1ib3R0b206LjhyZW07dGV4dC1hbGlnbjpjZW50ZXJ9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAub3JiaXQtYnVsbGV0c3tvdXRsaW5lOjB9Lm9yYml0LWJ1bGxldHMgYnV0dG9ue3dpZHRoOjEuMnJlbTtoZWlnaHQ6MS4ycmVtO21hcmdpbjouMXJlbTtiYWNrZ3JvdW5kLWNvbG9yOiNjYWNhY2E7Ym9yZGVyLXJhZGl1czo1MCV9Lm9yYml0LWJ1bGxldHMgYnV0dG9uLmlzLWFjdGl2ZSwub3JiaXQtYnVsbGV0cyBidXR0b246aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojOGE4YThhfS5wYWdpbmF0aW9ue21hcmdpbi1sZWZ0OjA7bWFyZ2luLWJvdHRvbToxcmVtfS5wYWdpbmF0aW9uOmFmdGVyLC5wYWdpbmF0aW9uOmJlZm9yZXtjb250ZW50OicgJztkaXNwbGF5OnRhYmxlfS5wYWdpbmF0aW9uOmFmdGVye2NsZWFyOmJvdGh9LnBhZ2luYXRpb24gbGl7Zm9udC1zaXplOi44NzVyZW07bWFyZ2luLXJpZ2h0Oi4wNjI1cmVtO2JvcmRlci1yYWRpdXM6MDtkaXNwbGF5Om5vbmV9LnBhZ2luYXRpb24gbGk6Zmlyc3QtY2hpbGQsLnBhZ2luYXRpb24gbGk6bGFzdC1jaGlsZHtkaXNwbGF5OmlubGluZS1ibG9ja31AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey5wYWdpbmF0aW9uIGxpe2Rpc3BsYXk6aW5saW5lLWJsb2NrfX0ucGFnaW5hdGlvbiBhLC5wYWdpbmF0aW9uIGJ1dHRvbntjb2xvcjojMGEwYTBhO2Rpc3BsYXk6YmxvY2s7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2JvcmRlci1yYWRpdXM6MH0ucGFnaW5hdGlvbiBhOmhvdmVyLC5wYWdpbmF0aW9uIGJ1dHRvbjpob3ZlcntiYWNrZ3JvdW5kOiNlNmU2ZTZ9LnBhZ2luYXRpb24gLmN1cnJlbnR7cGFkZGluZzouMTg3NXJlbSAuNjI1cmVtO2JhY2tncm91bmQ6IzIxOTllODtjb2xvcjojZmVmZWZlO2N1cnNvcjpkZWZhdWx0fS5wYWdpbmF0aW9uIC5kaXNhYmxlZHtwYWRkaW5nOi4xODc1cmVtIC42MjVyZW07Y29sb3I6I2NhY2FjYTtjdXJzb3I6bm90LWFsbG93ZWR9LnBhZ2luYXRpb24gLmRpc2FibGVkOmhvdmVye2JhY2tncm91bmQ6dHJhbnNwYXJlbnR9LnBhZ2luYXRpb24gLmVsbGlwc2lzOmFmdGVye2NvbnRlbnQ6J1xcXFwyMDI2JztwYWRkaW5nOi4xODc1cmVtIC42MjVyZW07Y29sb3I6IzBhMGEwYX0ucGFnaW5hdGlvbi1wcmV2aW91cy5kaXNhYmxlZDpiZWZvcmUsLnBhZ2luYXRpb24tcHJldmlvdXMgYTpiZWZvcmV7Y29udGVudDonXFxcXEFCJztkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tcmlnaHQ6LjVyZW19LnBhZ2luYXRpb24tbmV4dC5kaXNhYmxlZDphZnRlciwucGFnaW5hdGlvbi1uZXh0IGE6YWZ0ZXJ7Y29udGVudDonXFxcXEJCJztkaXNwbGF5OmlubGluZS1ibG9jazttYXJnaW4tbGVmdDouNXJlbX0ucHJvZ3Jlc3N7YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhO2hlaWdodDoxcmVtO21hcmdpbi1ib3R0b206MXJlbTtib3JkZXItcmFkaXVzOjB9LnByb2dyZXNzLnByaW1hcnkgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6IzIxOTllOH0ucHJvZ3Jlc3Muc2Vjb25kYXJ5IC5wcm9ncmVzcy1tZXRlcntiYWNrZ3JvdW5kLWNvbG9yOiM3Nzd9LnByb2dyZXNzLnN1Y2Nlc3MgLnByb2dyZXNzLW1ldGVye2JhY2tncm91bmQtY29sb3I6IzNhZGI3Nn0ucHJvZ3Jlc3Mud2FybmluZyAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZmZhZTAwfS5wcm9ncmVzcy5hbGVydCAucHJvZ3Jlc3MtbWV0ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWM1ODQwfS5wcm9ncmVzcy1tZXRlcntwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjEwMCU7YmFja2dyb3VuZC1jb2xvcjojMjE5OWU4fS5wcm9ncmVzcy1tZXRlci10ZXh0e3RvcDo1MCU7bGVmdDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLC01MCUpO3Bvc2l0aW9uOmFic29sdXRlO21hcmdpbjowO2ZvbnQtc2l6ZTouNzVyZW07Zm9udC13ZWlnaHQ6NzAwO2NvbG9yOiNmZWZlZmU7d2hpdGUtc3BhY2U6bm93cmFwfS5zbGlkZXJ7cG9zaXRpb246cmVsYXRpdmU7aGVpZ2h0Oi41cmVtO21hcmdpbi10b3A6MS4yNXJlbTttYXJnaW4tYm90dG9tOjIuMjVyZW07YmFja2dyb3VuZC1jb2xvcjojZTZlNmU2O2N1cnNvcjpwb2ludGVyOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZTstbXMtdG91Y2gtYWN0aW9uOm5vbmU7dG91Y2gtYWN0aW9uOm5vbmV9LnNsaWRlci1maWxse3Bvc2l0aW9uOmFic29sdXRlO3RvcDowO2xlZnQ6MDtkaXNwbGF5OmlubGluZS1ibG9jazttYXgtd2lkdGg6MTAwJTtoZWlnaHQ6LjVyZW07YmFja2dyb3VuZC1jb2xvcjojY2FjYWNhOy13ZWJraXQtdHJhbnNpdGlvbjphbGwgLjJzIGVhc2UtaW4tb3V0O3RyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dH0uc2xpZGVyLWZpbGwuaXMtZHJhZ2dpbmd7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAwcyBsaW5lYXI7dHJhbnNpdGlvbjphbGwgMHMgbGluZWFyfS5zbGlkZXItaGFuZGxle3RvcDo1MCU7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtNTAlKTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjA7ei1pbmRleDoxO2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOjEuNHJlbTtoZWlnaHQ6MS40cmVtO2JhY2tncm91bmQtY29sb3I6IzIxOTllODstd2Via2l0LXRyYW5zaXRpb246YWxsIC4ycyBlYXNlLWluLW91dDt0cmFuc2l0aW9uOmFsbCAuMnMgZWFzZS1pbi1vdXQ7LW1zLXRvdWNoLWFjdGlvbjptYW5pcHVsYXRpb247dG91Y2gtYWN0aW9uOm1hbmlwdWxhdGlvbjtib3JkZXItcmFkaXVzOjB9W2RhdGEtd2hhdGlucHV0PW1vdXNlXSAuc2xpZGVyLWhhbmRsZXtvdXRsaW5lOjB9LnNsaWRlci1oYW5kbGU6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojMTU4M2NjfS5zbGlkZXItaGFuZGxlLmlzLWRyYWdnaW5ney13ZWJraXQtdHJhbnNpdGlvbjphbGwgMHMgbGluZWFyO3RyYW5zaXRpb246YWxsIDBzIGxpbmVhcn0uc2xpZGVyLmRpc2FibGVkLC5zbGlkZXJbZGlzYWJsZWRde29wYWNpdHk6LjI1O2N1cnNvcjpub3QtYWxsb3dlZH0uc2xpZGVyLnZlcnRpY2Fse2Rpc3BsYXk6aW5saW5lLWJsb2NrO3dpZHRoOi41cmVtO2hlaWdodDoxMi41cmVtO21hcmdpbjowIDEuMjVyZW07LXdlYmtpdC10cmFuc2Zvcm06c2NhbGVZKC0xKTt0cmFuc2Zvcm06c2NhbGVZKC0xKX0uc2xpZGVyLnZlcnRpY2FsIC5zbGlkZXItZmlsbHt0b3A6MDt3aWR0aDouNXJlbTttYXgtaGVpZ2h0OjEwMCV9LnNsaWRlci52ZXJ0aWNhbCAuc2xpZGVyLWhhbmRsZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6MDtsZWZ0OjUwJTt3aWR0aDoxLjRyZW07aGVpZ2h0OjEuNHJlbTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS5zdGlja3ktY29udGFpbmVye3Bvc2l0aW9uOnJlbGF0aXZlfS5zdGlja3l7cG9zaXRpb246YWJzb2x1dGU7ei1pbmRleDowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVooMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVooMCl9LnN0aWNreS5pcy1zdHVja3twb3NpdGlvbjpmaXhlZDt6LWluZGV4OjV9LnN0aWNreS5pcy1zdHVjay5pcy1hdC10b3B7dG9wOjB9LnN0aWNreS5pcy1zdHVjay5pcy1hdC1ib3R0b217Ym90dG9tOjB9LnN0aWNreS5pcy1hbmNob3JlZHtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OmF1dG87cmlnaHQ6YXV0b30uc3RpY2t5LmlzLWFuY2hvcmVkLmlzLWF0LWJvdHRvbXtib3R0b206MH1ib2R5LmlzLXJldmVhbC1vcGVue292ZXJmbG93OmhpZGRlbn1odG1sLmlzLXJldmVhbC1vcGVuLGh0bWwuaXMtcmV2ZWFsLW9wZW4gYm9keXttaW4taGVpZ2h0OjEwMCU7b3ZlcmZsb3c6aGlkZGVuOy13ZWJraXQtdXNlci1zZWxlY3Q6bm9uZTstbW96LXVzZXItc2VsZWN0Om5vbmU7LW1zLXVzZXItc2VsZWN0Om5vbmU7dXNlci1zZWxlY3Q6bm9uZX0ucmV2ZWFsLW92ZXJsYXl7ZGlzcGxheTpub25lO3Bvc2l0aW9uOmZpeGVkO3RvcDowO2JvdHRvbTowO2xlZnQ6MDtyaWdodDowO3otaW5kZXg6MTAwNTtiYWNrZ3JvdW5kLWNvbG9yOmhzbGEoMCwwJSw0JSwuNDUpO292ZXJmbG93LXk6c2Nyb2xsfS5yZXZlYWx7ZGlzcGxheTpub25lO3otaW5kZXg6MTAwNjtwYWRkaW5nOjFyZW07Ym9yZGVyOjFweCBzb2xpZCAjY2FjYWNhO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZTtib3JkZXItcmFkaXVzOjA7cG9zaXRpb246cmVsYXRpdmU7dG9wOjEwMHB4O21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG87b3ZlcmZsb3cteTphdXRvfVtkYXRhLXdoYXRpbnB1dD1tb3VzZV0gLnJldmVhbHtvdXRsaW5lOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFse21pbi1oZWlnaHQ6MH19LnJldmVhbCAuY29sdW1uLC5yZXZlYWwgLmNvbHVtbnN7bWluLXdpZHRoOjB9LnJldmVhbD46bGFzdC1jaGlsZHttYXJnaW4tYm90dG9tOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFse3dpZHRoOjYwMHB4O21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsIC5yZXZlYWx7bGVmdDphdXRvO3JpZ2h0OmF1dG87bWFyZ2luOjAgYXV0b319LnJldmVhbC5jb2xsYXBzZXtwYWRkaW5nOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLnRpbnl7d2lkdGg6MzAlO21heC13aWR0aDo3NXJlbX19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsucmV2ZWFsLnNtYWxse3dpZHRoOjUwJTttYXgtd2lkdGg6NzVyZW19fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnJldmVhbC5sYXJnZXt3aWR0aDo5MCU7bWF4LXdpZHRoOjc1cmVtfX0ucmV2ZWFsLmZ1bGx7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7aGVpZ2h0OjEwMHZoO21pbi1oZWlnaHQ6MTAwdmg7bWF4LXdpZHRoOm5vbmU7bWFyZ2luLWxlZnQ6MDtib3JkZXI6MDtib3JkZXItcmFkaXVzOjB9QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5yZXZlYWx7dG9wOjA7bGVmdDowO3dpZHRoOjEwMCU7aGVpZ2h0OjEwMCU7aGVpZ2h0OjEwMHZoO21pbi1oZWlnaHQ6MTAwdmg7bWF4LXdpZHRoOm5vbmU7bWFyZ2luLWxlZnQ6MDtib3JkZXI6MDtib3JkZXItcmFkaXVzOjB9fS5yZXZlYWwud2l0aG91dC1vdmVybGF5e3Bvc2l0aW9uOmZpeGVkfS5zd2l0Y2h7aGVpZ2h0OjJyZW07bWFyZ2luLWJvdHRvbToxcmVtO291dGxpbmU6MDtwb3NpdGlvbjpyZWxhdGl2ZTstd2Via2l0LXVzZXItc2VsZWN0Om5vbmU7LW1vei11c2VyLXNlbGVjdDpub25lOy1tcy11c2VyLXNlbGVjdDpub25lO3VzZXItc2VsZWN0Om5vbmU7Y29sb3I6I2ZlZmVmZTtmb250LXdlaWdodDo3MDA7Zm9udC1zaXplOi44NzVyZW19LnN3aXRjaC1pbnB1dHtvcGFjaXR5OjA7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luLWJvdHRvbTowfS5zd2l0Y2gtcGFkZGxle2JhY2tncm91bmQ6I2NhY2FjYTtjdXJzb3I6cG9pbnRlcjtkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOnJlbGF0aXZlO3dpZHRoOjRyZW07aGVpZ2h0OjJyZW07LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMjVzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC4yNXMgZWFzZS1vdXQ7Ym9yZGVyLXJhZGl1czowO2NvbG9yOmluaGVyaXQ7Zm9udC13ZWlnaHQ6aW5oZXJpdH1pbnB1dCsuc3dpdGNoLXBhZGRsZXttYXJnaW46MH0uc3dpdGNoLXBhZGRsZTphZnRlcntiYWNrZ3JvdW5kOiNmZWZlZmU7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3Bvc2l0aW9uOmFic29sdXRlO2hlaWdodDoxLjVyZW07bGVmdDouMjVyZW07dG9wOi4yNXJlbTt3aWR0aDoxLjVyZW07LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuMjVzIGVhc2Utb3V0O3RyYW5zaXRpb246YWxsIC4yNXMgZWFzZS1vdXQ7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWigwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWigwKTtib3JkZXItcmFkaXVzOjB9aW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZXtiYWNrZ3JvdW5kOiMyMTk5ZTh9aW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjIuMjVyZW19W2RhdGEtd2hhdGlucHV0PW1vdXNlXSBpbnB1dDpmb2N1c34uc3dpdGNoLXBhZGRsZXtvdXRsaW5lOjB9LnN3aXRjaC1hY3RpdmUsLnN3aXRjaC1pbmFjdGl2ZXtwb3NpdGlvbjphYnNvbHV0ZTt0b3A6NTAlOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTUwJSl9LnN3aXRjaC1hY3RpdmV7bGVmdDo4JTtkaXNwbGF5Om5vbmV9aW5wdXQ6Y2hlY2tlZCtsYWJlbD4uc3dpdGNoLWFjdGl2ZXtkaXNwbGF5OmJsb2NrfS5zd2l0Y2gtaW5hY3RpdmV7cmlnaHQ6MTUlfWlucHV0OmNoZWNrZWQrbGFiZWw+LnN3aXRjaC1pbmFjdGl2ZXtkaXNwbGF5Om5vbmV9LnN3aXRjaC50aW55e2hlaWdodDoxLjVyZW19LnN3aXRjaC50aW55IC5zd2l0Y2gtcGFkZGxle3dpZHRoOjNyZW07aGVpZ2h0OjEuNXJlbTtmb250LXNpemU6LjYyNXJlbX0uc3dpdGNoLnRpbnkgLnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7d2lkdGg6MXJlbTtoZWlnaHQ6MXJlbX0uc3dpdGNoLnRpbnkgaW5wdXQ6Y2hlY2tlZH4uc3dpdGNoLXBhZGRsZTphZnRlcntsZWZ0OjEuNzVyZW19LnN3aXRjaC5zbWFsbHtoZWlnaHQ6MS43NXJlbX0uc3dpdGNoLnNtYWxsIC5zd2l0Y2gtcGFkZGxle3dpZHRoOjMuNXJlbTtoZWlnaHQ6MS43NXJlbTtmb250LXNpemU6Ljc1cmVtfS5zd2l0Y2guc21hbGwgLnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7d2lkdGg6MS4yNXJlbTtoZWlnaHQ6MS4yNXJlbX0uc3dpdGNoLnNtYWxsIGlucHV0OmNoZWNrZWR+LnN3aXRjaC1wYWRkbGU6YWZ0ZXJ7bGVmdDoycmVtfS5zd2l0Y2gubGFyZ2V7aGVpZ2h0OjIuNXJlbX0uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxle3dpZHRoOjVyZW07aGVpZ2h0OjIuNXJlbTtmb250LXNpemU6MXJlbX0uc3dpdGNoLmxhcmdlIC5zd2l0Y2gtcGFkZGxlOmFmdGVye3dpZHRoOjJyZW07aGVpZ2h0OjJyZW19LnN3aXRjaC5sYXJnZSBpbnB1dDpjaGVja2Vkfi5zd2l0Y2gtcGFkZGxlOmFmdGVye2xlZnQ6Mi43NXJlbX10YWJsZXt3aWR0aDoxMDAlO21hcmdpbi1ib3R0b206MXJlbTtib3JkZXItcmFkaXVzOjB9dGFibGUgdGJvZHksdGFibGUgdGZvb3QsdGFibGUgdGhlYWR7Ym9yZGVyOjFweCBzb2xpZCAjZjFmMWYxO2JhY2tncm91bmQtY29sb3I6I2ZlZmVmZX10YWJsZSBjYXB0aW9ue2ZvbnQtd2VpZ2h0OjcwMDtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbX10YWJsZSB0aGVhZHtiYWNrZ3JvdW5kOiNmOGY4Zjg7Y29sb3I6IzBhMGEwYX10YWJsZSB0Zm9vdHtiYWNrZ3JvdW5kOiNmMWYxZjE7Y29sb3I6IzBhMGEwYX10YWJsZSB0Zm9vdCB0cix0YWJsZSB0aGVhZCB0cntiYWNrZ3JvdW5kOnRyYW5zcGFyZW50fXRhYmxlIHRmb290IHRkLHRhYmxlIHRmb290IHRoLHRhYmxlIHRoZWFkIHRkLHRhYmxlIHRoZWFkIHRoe3BhZGRpbmc6LjVyZW0gLjYyNXJlbSAuNjI1cmVtO2ZvbnQtd2VpZ2h0OjcwMDt0ZXh0LWFsaWduOmxlZnR9dGFibGUgdGJvZHkgdHI6bnRoLWNoaWxkKGV2ZW4pe2JhY2tncm91bmQtY29sb3I6I2YxZjFmMX10YWJsZSB0Ym9keSB0ZCx0YWJsZSB0Ym9keSB0aHtwYWRkaW5nOi41cmVtIC42MjVyZW0gLjYyNXJlbX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjYzLjkzNzVlbSl7dGFibGUuc3RhY2sgdGZvb3QsdGFibGUuc3RhY2sgdGhlYWR7ZGlzcGxheTpub25lfXRhYmxlLnN0YWNrIHRkLHRhYmxlLnN0YWNrIHRoLHRhYmxlLnN0YWNrIHRye2Rpc3BsYXk6YmxvY2t9dGFibGUuc3RhY2sgdGR7Ym9yZGVyLXRvcDowfX10YWJsZS5zY3JvbGx7ZGlzcGxheTpibG9jazt3aWR0aDoxMDAlO292ZXJmbG93LXg6YXV0b310YWJsZS5ob3ZlciB0aGVhZCB0cjpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNmM2YzZjN9dGFibGUuaG92ZXIgdGZvb3QgdHI6aG92ZXJ7YmFja2dyb3VuZC1jb2xvcjojZWNlY2VjfXRhYmxlLmhvdmVyIHRib2R5IHRyOmhvdmVye2JhY2tncm91bmQtY29sb3I6I2Y5ZjlmOX10YWJsZS5ob3ZlciB0Ym9keSB0cjpudGgtb2YtdHlwZShldmVuKTpob3ZlcntiYWNrZ3JvdW5kLWNvbG9yOiNlY2VjZWN9LnRhYmxlLXNjcm9sbHtvdmVyZmxvdy14OmF1dG99LnRhYmxlLXNjcm9sbCB0YWJsZXt3aWR0aDphdXRvfS50YWJze21hcmdpbjowO2xpc3Qtc3R5bGUtdHlwZTpub25lO2JhY2tncm91bmQ6I2ZlZmVmZTtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTZ9LnRhYnM6YWZ0ZXIsLnRhYnM6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9LnRhYnM6YWZ0ZXJ7Y2xlYXI6Ym90aH0udGFicy52ZXJ0aWNhbD5saXt3aWR0aDphdXRvO2Zsb2F0Om5vbmU7ZGlzcGxheTpibG9ja30udGFicy5zaW1wbGU+bGk+YXtwYWRkaW5nOjB9LnRhYnMuc2ltcGxlPmxpPmE6aG92ZXJ7YmFja2dyb3VuZDp0cmFuc3BhcmVudH0udGFicy5wcmltYXJ5e2JhY2tncm91bmQ6IzIxOTllOH0udGFicy5wcmltYXJ5PmxpPmF7Y29sb3I6I2ZlZmVmZX0udGFicy5wcmltYXJ5PmxpPmE6Zm9jdXMsLnRhYnMucHJpbWFyeT5saT5hOmhvdmVye2JhY2tncm91bmQ6IzE4OTNlNH0udGFicy10aXRsZXtmbG9hdDpsZWZ0fS50YWJzLXRpdGxlPmF7ZGlzcGxheTpibG9jaztwYWRkaW5nOjEuMjVyZW0gMS41cmVtO2xpbmUtaGVpZ2h0OjE7Zm9udC1zaXplOi43NXJlbX0udGFicy10aXRsZT5hOmhvdmVye2JhY2tncm91bmQ6I2ZlZmVmZX0udGFicy10aXRsZT5hOmZvY3VzLC50YWJzLXRpdGxlPmFbYXJpYS1zZWxlY3RlZD10cnVlXXtiYWNrZ3JvdW5kOiNlNmU2ZTZ9LnRhYnMtY29udGVudHtiYWNrZ3JvdW5kOiNmZWZlZmU7LXdlYmtpdC10cmFuc2l0aW9uOmFsbCAuNXMgZWFzZTt0cmFuc2l0aW9uOmFsbCAuNXMgZWFzZTtib3JkZXI6MXB4IHNvbGlkICNlNmU2ZTY7Ym9yZGVyLXRvcDowfS50YWJzLWNvbnRlbnQudmVydGljYWx7Ym9yZGVyOjFweCBzb2xpZCAjZTZlNmU2O2JvcmRlci1sZWZ0OjB9LnRhYnMtcGFuZWx7ZGlzcGxheTpub25lO3BhZGRpbmc6MXJlbX0udGFicy1wYW5lbC5pcy1hY3RpdmV7ZGlzcGxheTpibG9ja30udGh1bWJuYWlse2JvcmRlcjo0cHggc29saWQgI2ZlZmVmZTtib3gtc2hhZG93OjAgMCAwIDFweCBoc2xhKDAsMCUsNCUsLjIpO2Rpc3BsYXk6aW5saW5lLWJsb2NrO2xpbmUtaGVpZ2h0OjA7bWF4LXdpZHRoOjEwMCU7LXdlYmtpdC10cmFuc2l0aW9uOi13ZWJraXQtYm94LXNoYWRvdyAuMnMgZWFzZS1vdXQ7dHJhbnNpdGlvbjpib3gtc2hhZG93IC4ycyBlYXNlLW91dDtib3JkZXItcmFkaXVzOjA7bWFyZ2luLWJvdHRvbToxcmVtfS50aHVtYm5haWw6Zm9jdXMsLnRodW1ibmFpbDpob3Zlcntib3gtc2hhZG93OjAgMCA2cHggMXB4IHJnYmEoMzMsMTUzLDIzMiwuNSl9LnRpdGxlLWJhcntiYWNrZ3JvdW5kOiMwYTBhMGE7Y29sb3I6I2ZlZmVmZTtwYWRkaW5nOi41cmVtfS50aXRsZS1iYXI6YWZ0ZXIsLnRpdGxlLWJhcjpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0udGl0bGUtYmFyOmFmdGVye2NsZWFyOmJvdGh9LnRpdGxlLWJhciAubWVudS1pY29ue21hcmdpbi1sZWZ0Oi4yNXJlbTttYXJnaW4tcmlnaHQ6LjI1cmVtfS50aXRsZS1iYXItbGVmdHtmbG9hdDpsZWZ0fS50aXRsZS1iYXItcmlnaHR7ZmxvYXQ6cmlnaHQ7dGV4dC1hbGlnbjpyaWdodH0udGl0bGUtYmFyLXRpdGxle3ZlcnRpY2FsLWFsaWduOm1pZGRsZX0uaGFzLXRpcCwudGl0bGUtYmFyLXRpdGxle2ZvbnQtd2VpZ2h0OjcwMDtkaXNwbGF5OmlubGluZS1ibG9ja30uaGFzLXRpcHtib3JkZXItYm90dG9tOjFweCBkb3R0ZWQgIzhhOGE4YTtwb3NpdGlvbjpyZWxhdGl2ZTtjdXJzb3I6aGVscH0udG9vbHRpcHtiYWNrZ3JvdW5kLWNvbG9yOiMwYTBhMGE7Y29sb3I6I2ZlZmVmZTtmb250LXNpemU6ODAlO3BhZGRpbmc6Ljc1cmVtO3Bvc2l0aW9uOmFic29sdXRlO3otaW5kZXg6MTA7dG9wOmNhbGMoMTAwJSArIC42NDk1cmVtKTttYXgtd2lkdGg6MTByZW0haW1wb3J0YW50O2JvcmRlci1yYWRpdXM6MH0udG9vbHRpcDpiZWZvcmV7Ym9yZGVyOi43NXJlbSBpbnNldDtib3JkZXItY29sb3I6dHJhbnNwYXJlbnQgdHJhbnNwYXJlbnQgIzBhMGEwYTtib3JkZXItYm90dG9tLXN0eWxlOnNvbGlkO2JvcmRlci10b3Atd2lkdGg6MDtib3R0b206MTAwJTtwb3NpdGlvbjphYnNvbHV0ZTtsZWZ0OjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKC01MCUpfS50b29sdGlwLnRvcDpiZWZvcmUsLnRvb2x0aXA6YmVmb3Jle2NvbnRlbnQ6Jyc7ZGlzcGxheTpibG9jazt3aWR0aDowO2hlaWdodDowfS50b29sdGlwLnRvcDpiZWZvcmV7Ym9yZGVyOi43NXJlbSBpbnNldDtib3JkZXItY29sb3I6IzBhMGEwYSB0cmFuc3BhcmVudCB0cmFuc3BhcmVudDtib3JkZXItdG9wLXN0eWxlOnNvbGlkO2JvcmRlci1ib3R0b20td2lkdGg6MDt0b3A6MTAwJTtib3R0b206YXV0b30udG9vbHRpcC5sZWZ0OmJlZm9yZXtib3JkZXI6Ljc1cmVtIGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCB0cmFuc3BhcmVudCB0cmFuc3BhcmVudCAjMGEwYTBhO2JvcmRlci1sZWZ0LXN0eWxlOnNvbGlkO2JvcmRlci1yaWdodC13aWR0aDowO2xlZnQ6MTAwJX0udG9vbHRpcC5sZWZ0OmJlZm9yZSwudG9vbHRpcC5yaWdodDpiZWZvcmV7Y29udGVudDonJztkaXNwbGF5OmJsb2NrO3dpZHRoOjA7aGVpZ2h0OjA7Ym90dG9tOmF1dG87dG9wOjUwJTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC01MCUpfS50b29sdGlwLnJpZ2h0OmJlZm9yZXtib3JkZXI6Ljc1cmVtIGluc2V0O2JvcmRlci1jb2xvcjp0cmFuc3BhcmVudCAjMGEwYTBhIHRyYW5zcGFyZW50IHRyYW5zcGFyZW50O2JvcmRlci1yaWdodC1zdHlsZTpzb2xpZDtib3JkZXItbGVmdC13aWR0aDowO2xlZnQ6YXV0bztyaWdodDoxMDAlfS50b3AtYmFye3BhZGRpbmc6LjVyZW19LnRvcC1iYXI6YWZ0ZXIsLnRvcC1iYXI6YmVmb3Jle2NvbnRlbnQ6JyAnO2Rpc3BsYXk6dGFibGV9LnRvcC1iYXI6YWZ0ZXJ7Y2xlYXI6Ym90aH0udG9wLWJhciwudG9wLWJhciB1bHtiYWNrZ3JvdW5kLWNvbG9yOiNlNmU2ZTZ9LnRvcC1iYXIgaW5wdXR7bWF4LXdpZHRoOjIwMHB4O21hcmdpbi1yaWdodDoxcmVtfS50b3AtYmFyIC5pbnB1dC1ncm91cC1maWVsZHt3aWR0aDoxMDAlO21hcmdpbi1yaWdodDowfS50b3AtYmFyIGlucHV0LmJ1dHRvbnt3aWR0aDphdXRvfS50b3AtYmFyIC50b3AtYmFyLWxlZnQsLnRvcC1iYXIgLnRvcC1iYXItcmlnaHR7d2lkdGg6MTAwJX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjQwZW0pey50b3AtYmFyIC50b3AtYmFyLWxlZnQsLnRvcC1iYXIgLnRvcC1iYXItcmlnaHR7d2lkdGg6YXV0b319QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey50b3AtYmFyLnN0YWNrZWQtZm9yLW1lZGl1bSAudG9wLWJhci1sZWZ0LC50b3AtYmFyLnN0YWNrZWQtZm9yLW1lZGl1bSAudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfX1AbWVkaWEgc2NyZWVuIGFuZCAobWF4LXdpZHRoOjc0LjkzNzVlbSl7LnRvcC1iYXIuc3RhY2tlZC1mb3ItbGFyZ2UgLnRvcC1iYXItbGVmdCwudG9wLWJhci5zdGFja2VkLWZvci1sYXJnZSAudG9wLWJhci1yaWdodHt3aWR0aDoxMDAlfX0udG9wLWJhci10aXRsZXtmbG9hdDpsZWZ0O21hcmdpbi1yaWdodDoxcmVtfS50b3AtYmFyLWxlZnR7ZmxvYXQ6bGVmdH0udG9wLWJhci1yaWdodHtmbG9hdDpyaWdodH0uaGlkZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fS5pbnZpc2libGV7dmlzaWJpbGl0eTpoaWRkZW59QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pey5oaWRlLWZvci1zbWFsbC1vbmx5e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MGVtKSxzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSl7LnNob3ctZm9yLXNtYWxsLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo0MGVtKXsuaGlkZS1mb3ItbWVkaXVte2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtYXgtd2lkdGg6MzkuOTM3NWVtKXsuc2hvdy1mb3ItbWVkaXVte2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChtaW4td2lkdGg6NDBlbSkgYW5kIChtYXgtd2lkdGg6NjMuOTM3NWVtKXsuaGlkZS1mb3ItbWVkaXVtLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDozOS45Mzc1ZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuc2hvdy1mb3ItbWVkaXVtLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1pbi13aWR0aDo2NGVtKXsuaGlkZS1mb3ItbGFyZ2V7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pey5zaG93LWZvci1sYXJnZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX1AbWVkaWEgc2NyZWVuIGFuZCAobWluLXdpZHRoOjY0ZW0pIGFuZCAobWF4LXdpZHRoOjc0LjkzNzVlbSl7LmhpZGUtZm9yLWxhcmdlLW9ubHl7ZGlzcGxheTpub25lIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG1heC13aWR0aDo2My45Mzc1ZW0pLHNjcmVlbiBhbmQgKG1pbi13aWR0aDo3NWVtKXsuc2hvdy1mb3ItbGFyZ2Utb25seXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX0uc2hvdy1mb3Itc3IsLnNob3ctb24tZm9jdXN7cG9zaXRpb246YWJzb2x1dGUhaW1wb3J0YW50O3dpZHRoOjFweDtoZWlnaHQ6MXB4O292ZXJmbG93OmhpZGRlbjtjbGlwOnJlY3QoMCwwLDAsMCl9LnNob3ctb24tZm9jdXM6YWN0aXZlLC5zaG93LW9uLWZvY3VzOmZvY3Vze3Bvc2l0aW9uOnN0YXRpYyFpbXBvcnRhbnQ7aGVpZ2h0OmF1dG87d2lkdGg6YXV0bztvdmVyZmxvdzp2aXNpYmxlO2NsaXA6YXV0b30uaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH1AbWVkaWEgc2NyZWVuIGFuZCAob3JpZW50YXRpb246bGFuZHNjYXBlKXsuaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5OmJsb2NrIWltcG9ydGFudH19QG1lZGlhIHNjcmVlbiBhbmQgKG9yaWVudGF0aW9uOnBvcnRyYWl0KXsuaGlkZS1mb3ItcG9ydHJhaXQsLnNob3ctZm9yLWxhbmRzY2FwZXtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fX0uaGlkZS1mb3ItbGFuZHNjYXBlLC5zaG93LWZvci1wb3J0cmFpdHtkaXNwbGF5Om5vbmUhaW1wb3J0YW50fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpsYW5kc2NhcGUpey5oaWRlLWZvci1sYW5kc2NhcGUsLnNob3ctZm9yLXBvcnRyYWl0e2Rpc3BsYXk6bm9uZSFpbXBvcnRhbnR9fUBtZWRpYSBzY3JlZW4gYW5kIChvcmllbnRhdGlvbjpwb3J0cmFpdCl7LmhpZGUtZm9yLWxhbmRzY2FwZSwuc2hvdy1mb3ItcG9ydHJhaXR7ZGlzcGxheTpibG9jayFpbXBvcnRhbnR9fS5mbG9hdC1sZWZ0e2Zsb2F0OmxlZnQhaW1wb3J0YW50fS5mbG9hdC1yaWdodHtmbG9hdDpyaWdodCFpbXBvcnRhbnR9LmZsb2F0LWNlbnRlcntkaXNwbGF5OmJsb2NrO21hcmdpbi1sZWZ0OmF1dG87bWFyZ2luLXJpZ2h0OmF1dG99LmNsZWFyZml4OmFmdGVyLC5jbGVhcmZpeDpiZWZvcmV7Y29udGVudDonICc7ZGlzcGxheTp0YWJsZX0uY2xlYXJmaXg6YWZ0ZXJ7Y2xlYXI6Ym90aH1cIiwgXCJcIl0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vY3NzLWxvYWRlciEuL34vZm91bmRhdGlvbi1zaXRlcy9kaXN0L2ZvdW5kYXRpb24ubWluLmNzc1xuLy8gbW9kdWxlIGlkID0gMjM2XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qXHJcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcclxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXHJcbiovXHJcbi8vIGNzcyBiYXNlIGNvZGUsIGluamVjdGVkIGJ5IHRoZSBjc3MtbG9hZGVyXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oKSB7XHJcblx0dmFyIGxpc3QgPSBbXTtcclxuXHJcblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xyXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBpdGVtID0gdGhpc1tpXTtcclxuXHRcdFx0aWYoaXRlbVsyXSkge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgaXRlbVsxXSArIFwifVwiKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChpdGVtWzFdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdC5qb2luKFwiXCIpO1xyXG5cdH07XHJcblxyXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XHJcblx0bGlzdC5pID0gZnVuY3Rpb24obW9kdWxlcywgbWVkaWFRdWVyeSkge1xyXG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXHJcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcclxuXHRcdHZhciBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzID0ge307XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xyXG5cdFx0XHRpZih0eXBlb2YgaWQgPT09IFwibnVtYmVyXCIpXHJcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xyXG5cdFx0fVxyXG5cdFx0Zm9yKGkgPSAwOyBpIDwgbW9kdWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XHJcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcclxuXHRcdFx0Ly8gdGhpcyBpbXBsZW1lbnRhdGlvbiBpcyBub3QgMTAwJSBwZXJmZWN0IGZvciB3ZWlyZCBtZWRpYSBxdWVyeSBjb21iaW5hdGlvbnNcclxuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cclxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcclxuXHRcdFx0aWYodHlwZW9mIGl0ZW1bMF0gIT09IFwibnVtYmVyXCIgfHwgIWFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcclxuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XHJcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVkaWFRdWVyeSkge1xyXG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsaXN0LnB1c2goaXRlbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cdHJldHVybiBsaXN0O1xyXG59O1xyXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9+L2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwiLypcclxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxyXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcclxuKi9cclxudmFyIHN0eWxlc0luRG9tID0ge30sXHJcblx0bWVtb2l6ZSA9IGZ1bmN0aW9uKGZuKSB7XHJcblx0XHR2YXIgbWVtbztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0XHRcdHJldHVybiBtZW1vO1xyXG5cdFx0fTtcclxuXHR9LFxyXG5cdGlzT2xkSUUgPSBtZW1vaXplKGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIC9tc2llIFs2LTldXFxiLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkpO1xyXG5cdH0pLFxyXG5cdGdldEhlYWRFbGVtZW50ID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07XHJcblx0fSksXHJcblx0c2luZ2xldG9uRWxlbWVudCA9IG51bGwsXHJcblx0c2luZ2xldG9uQ291bnRlciA9IDAsXHJcblx0c3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AgPSBbXTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xyXG5cdGlmKHR5cGVvZiBERUJVRyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBERUJVRykge1xyXG5cdFx0aWYodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XHJcblx0fVxyXG5cclxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHQvLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cclxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiA9PT0gXCJ1bmRlZmluZWRcIikgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XHJcblxyXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIGJvdHRvbSBvZiA8aGVhZD4uXHJcblx0aWYgKHR5cGVvZiBvcHRpb25zLmluc2VydEF0ID09PSBcInVuZGVmaW5lZFwiKSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcclxuXHJcblx0dmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhsaXN0KTtcclxuXHRhZGRTdHlsZXNUb0RvbShzdHlsZXMsIG9wdGlvbnMpO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlKG5ld0xpc3QpIHtcclxuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xyXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XHJcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcclxuXHRcdH1cclxuXHRcdGlmKG5ld0xpc3QpIHtcclxuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0KTtcclxuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcclxuXHRcdH1cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xyXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XHJcblx0XHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKVxyXG5cdFx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oKTtcclxuXHRcdFx0XHRkZWxldGUgc3R5bGVzSW5Eb21bZG9tU3R5bGUuaWRdO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKSB7XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XHJcblx0XHR2YXIgZG9tU3R5bGUgPSBzdHlsZXNJbkRvbVtpdGVtLmlkXTtcclxuXHRcdGlmKGRvbVN0eWxlKSB7XHJcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcclxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Zm9yKDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcclxuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIHBhcnRzID0gW107XHJcblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XHJcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3R5bGVzSW5Eb21baXRlbS5pZF0gPSB7aWQ6IGl0ZW0uaWQsIHJlZnM6IDEsIHBhcnRzOiBwYXJ0c307XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMobGlzdCkge1xyXG5cdHZhciBzdHlsZXMgPSBbXTtcclxuXHR2YXIgbmV3U3R5bGVzID0ge307XHJcblx0Zm9yKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcclxuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcclxuXHRcdHZhciBpZCA9IGl0ZW1bMF07XHJcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcclxuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XHJcblx0XHR2YXIgc291cmNlTWFwID0gaXRlbVszXTtcclxuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcclxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKVxyXG5cdFx0XHRzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xyXG5cdFx0ZWxzZVxyXG5cdFx0XHRuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XHJcblx0fVxyXG5cdHJldHVybiBzdHlsZXM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpIHtcclxuXHR2YXIgaGVhZCA9IGdldEhlYWRFbGVtZW50KCk7XHJcblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3Bbc3R5bGVFbGVtZW50c0luc2VydGVkQXRUb3AubGVuZ3RoIC0gMV07XHJcblx0aWYgKG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwidG9wXCIpIHtcclxuXHRcdGlmKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xyXG5cdFx0XHRoZWFkLmluc2VydEJlZm9yZShzdHlsZUVsZW1lbnQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2UgaWYobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcclxuXHRcdFx0aGVhZC5pbnNlcnRCZWZvcmUoc3R5bGVFbGVtZW50LCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XHJcblx0XHRoZWFkLmFwcGVuZENoaWxkKHN0eWxlRWxlbWVudCk7XHJcblx0fSBlbHNlIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciAnaW5zZXJ0QXQnLiBNdXN0IGJlICd0b3AnIG9yICdib3R0b20nLlwiKTtcclxuXHR9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZUVsZW1lbnQpIHtcclxuXHRzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG5cdHZhciBpZHggPSBzdHlsZUVsZW1lbnRzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlRWxlbWVudCk7XHJcblx0aWYoaWR4ID49IDApIHtcclxuXHRcdHN0eWxlRWxlbWVudHNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInN0eWxlXCIpO1xyXG5cdHN0eWxlRWxlbWVudC50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xyXG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBzdHlsZUVsZW1lbnQpO1xyXG5cdHJldHVybiBzdHlsZUVsZW1lbnQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpIHtcclxuXHR2YXIgbGlua0VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcclxuXHRsaW5rRWxlbWVudC5yZWwgPSBcInN0eWxlc2hlZXRcIjtcclxuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGlua0VsZW1lbnQpO1xyXG5cdHJldHVybiBsaW5rRWxlbWVudDtcclxufVxyXG5cclxuZnVuY3Rpb24gYWRkU3R5bGUob2JqLCBvcHRpb25zKSB7XHJcblx0dmFyIHN0eWxlRWxlbWVudCwgdXBkYXRlLCByZW1vdmU7XHJcblxyXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xyXG5cdFx0dmFyIHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XHJcblx0XHRzdHlsZUVsZW1lbnQgPSBzaW5nbGV0b25FbGVtZW50IHx8IChzaW5nbGV0b25FbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpKTtcclxuXHRcdHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKTtcclxuXHRcdHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpO1xyXG5cdH0gZWxzZSBpZihvYmouc291cmNlTWFwICYmXHJcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBVUkwucmV2b2tlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcclxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCIpIHtcclxuXHRcdHN0eWxlRWxlbWVudCA9IGNyZWF0ZUxpbmtFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHRcdGlmKHN0eWxlRWxlbWVudC5ocmVmKVxyXG5cdFx0XHRcdFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGVFbGVtZW50LmhyZWYpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0c3R5bGVFbGVtZW50ID0gY3JlYXRlU3R5bGVFbGVtZW50KG9wdGlvbnMpO1xyXG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudCk7XHJcblx0XHRyZW1vdmUgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0cmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0dXBkYXRlKG9iaik7XHJcblxyXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZShuZXdPYmopIHtcclxuXHRcdGlmKG5ld09iaikge1xyXG5cdFx0XHRpZihuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApXHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlbW92ZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcbn1cclxuXHJcbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XHJcblx0dmFyIHRleHRTdG9yZSA9IFtdO1xyXG5cclxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xyXG5cdFx0dGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50O1xyXG5cdFx0cmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJyk7XHJcblx0fTtcclxufSkoKTtcclxuXHJcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGVFbGVtZW50LCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcclxuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XHJcblxyXG5cdGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xyXG5cdFx0c3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XHJcblx0XHR2YXIgY2hpbGROb2RlcyA9IHN0eWxlRWxlbWVudC5jaGlsZE5vZGVzO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XHJcblx0XHRcdHN0eWxlRWxlbWVudC5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gYXBwbHlUb1RhZyhzdHlsZUVsZW1lbnQsIG9iaikge1xyXG5cdHZhciBjc3MgPSBvYmouY3NzO1xyXG5cdHZhciBtZWRpYSA9IG9iai5tZWRpYTtcclxuXHJcblx0aWYobWVkaWEpIHtcclxuXHRcdHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcclxuXHR9XHJcblxyXG5cdGlmKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XHJcblx0XHRzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xyXG5cdH0gZWxzZSB7XHJcblx0XHR3aGlsZShzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xyXG5cdFx0XHRzdHlsZUVsZW1lbnQucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpO1xyXG5cdFx0fVxyXG5cdFx0c3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xyXG5cdH1cclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlTGluayhsaW5rRWxlbWVudCwgb2JqKSB7XHJcblx0dmFyIGNzcyA9IG9iai5jc3M7XHJcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XHJcblxyXG5cdGlmKHNvdXJjZU1hcCkge1xyXG5cdFx0Ly8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjY2MDM4NzVcclxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcclxuXHR9XHJcblxyXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xyXG5cclxuXHR2YXIgb2xkU3JjID0gbGlua0VsZW1lbnQuaHJlZjtcclxuXHJcblx0bGlua0VsZW1lbnQuaHJlZiA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XHJcblxyXG5cdGlmKG9sZFNyYylcclxuXHRcdFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcclxufVxyXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL34vc3R5bGUtbG9hZGVyL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGlkID0gMjM4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9hZGRTdHlsZXMuanNcIikoY29udGVudCwge30pO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzIS4vLi4vLi4vbm9kZV9tb2R1bGVzL3Nhc3MtbG9hZGVyL2luZGV4LmpzIS4vYXBwLnNjc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi8uLi8uLi9ub2RlX21vZHVsZXMvc2Fzcy1sb2FkZXIvaW5kZXguanMhLi9hcHAuc2Nzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L3N0eWxlLWxvYWRlciEuL34vY3NzLWxvYWRlciEuL34vc2Fzcy1sb2FkZXIhLi9hcHAvc3R5bGVzL2FwcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAyMzlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKCk7XG4vLyBpbXBvcnRzXG5cblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCIudG9wLWJhciwgLnRvcC1iYXIgdWwge1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzMzMzMzMzsgfVxcblxcbi50b3AtYmFyIC5tZW51LXRleHQge1xcbiAgY29sb3I6IHdoaXRlOyB9XFxuXFxuLnRvcC1iYXIgLm1lbnUgPiAubWVudS10ZXh0ID4gYSB7XFxuICBkaXNwbGF5OiBpbmxpbmU7XFxuICBwYWRkaW5nOiAwOyB9XFxuXFxuLnRvcC1iYXIgLmFjdGl2ZS1saW5rIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkOyB9XFxuXFxuLmNsb2NrIHtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjQjVEMEUyO1xcbiAgYm9yZGVyOiAycHggc29saWQgIzIwOTlFODtcXG4gIGJvcmRlci1yYWRpdXM6IDUwJTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDE0cmVtO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBtYXJnaW46IDRyZW0gYXV0bztcXG4gIHdpZHRoOiAxNHJlbTsgfVxcblxcbi5jbG9jay10ZXh0IHtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIGZvbnQtc2l6ZTogMi4yNXJlbTtcXG4gIGZvbnQtd2VpZ2h0OiAzMDA7IH1cXG5cXG4uY29udHJvbHMge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyOyB9XFxuICAuY29udHJvbHMgLmJ1dHRvbiB7XFxuICAgIHBhZGRpbmc6IC43NXJlbSAzcmVtOyB9XFxuICAuY29udHJvbHMgLmJ1dHRvbjpmaXJzdC1jaGlsZCB7XFxuICAgIG1hcmdpbi1yaWdodDogMS41cmVtOyB9XFxuXCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9+L2Nzcy1sb2FkZXIhLi9+L3Nhc3MtbG9hZGVyIS4vYXBwL3N0eWxlcy9hcHAuc2Nzc1xuLy8gbW9kdWxlIGlkID0gMjQwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsInZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XHJcblxyXG52YXIgQ29udHJvbHMgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XHJcbiAgICBwcm9wVHlwZXM6IHtcclxuICAgICAgY291bnRkb3duU3RhdHVzOiBSZWFjdC5Qcm9wVHlwZXMuc3RyaW5nLmlzUmVxdWlyZWQsXHJcbiAgICAgIG9uU3RhdHVzQ2hhbmdlOiBSZWFjdC5Qcm9wVHlwZXMuZnVuYy5pc1JlcXVpcmVkXHJcbiAgICB9LFxyXG4gICAgb25TdGF0dXNDaGFuZ2U6IGZ1bmN0aW9uKG5ld1N0YXR1cyl7XHJcbiAgICAgICAgcmV0dXJuICgpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vblN0YXR1c0NoYW5nZShuZXdTdGF0dXMpXHJcbiAgICAgICAgfVxyXG4gICAgfSxcclxuICAgIHJlbmRlcjogZnVuY3Rpb24oKXtcclxuICAgICAgICB2YXIge2NvdW50ZG93blN0YXR1c30gPSB0aGlzLnByb3BzO1xyXG4gICAgICAgIHZhciByZW5kZXJTdGFydFN0b3BCdXR0b24gPSAoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmKGNvdW50ZG93blN0YXR1cyA9PT0gJ3N0YXJ0ZWQnKXtcclxuICAgICAgICAgICAgICAgIHJldHVybihcclxuICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3NOYW1lPVwiYnV0dG9uIHNlY29uZGFyeVwiIG9uQ2xpY2s9e3RoaXMub25TdGF0dXNDaGFuZ2UoJ3BhdXNlZCcpfT5QYXV6aXJhajwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfWVsc2UgaWYoY291bnRkb3duU3RhdHVzID09PSAncGF1c2VkJyl7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4oXHJcbiAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ1dHRvbiBwcmltYXJ5XCIgb25DbGljaz17dGhpcy5vblN0YXR1c0NoYW5nZSgnc3RhcnRlZCcpfT5TdGFydDwvYnV0dG9uPlxyXG4gICAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIHJldHVybiAoXHJcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cImNvbnRyb2xzXCI+XHJcbiAgICAgICAgICAgICAgICB7cmVuZGVyU3RhcnRTdG9wQnV0dG9uKCl9XHJcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzTmFtZT1cImJ1dHRvbiBhbGVydCBob2xsb3dcIiBvbkNsaWNrPXt0aGlzLm9uU3RhdHVzQ2hhbmdlKCdzdG9wcGVkJyl9Pk/Eh2lzdGl0PC9idXR0b24+XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICApO1xyXG4gICAgfVxyXG59KTtcclxuXHJcbm1vZHVsZS5leHBvcnRzID0gQ29udHJvbHM7XHJcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL2FwcC9jb21wb25lbnRzL0NvbnRyb2xzLmpzeCJdLCJzb3VyY2VSb290IjoiIn0=